var n1 = Object.defineProperty;
var i1 = (s, e, n) => e in s ? n1(s, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : s[e] = n;
var fe = (s, e, n) => i1(s, typeof e != "symbol" ? e + "" : e, n);
/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function sf(s) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const n of s.split(",")) e[n] = 1;
  return (n) => n in e;
}
const en = {}, Po = [], ss = () => {
}, pg = () => !1, cu = (s) => s.charCodeAt(0) === 111 && s.charCodeAt(1) === 110 && // uppercase letter
(s.charCodeAt(2) > 122 || s.charCodeAt(2) < 97), rf = (s) => s.startsWith("onUpdate:"), Zn = Object.assign, of = (s, e) => {
  const n = s.indexOf(e);
  n > -1 && s.splice(n, 1);
}, s1 = Object.prototype.hasOwnProperty, Xt = (s, e) => s1.call(s, e), xt = Array.isArray, Ro = (s) => yl(s) === "[object Map]", Yo = (s) => yl(s) === "[object Set]", mp = (s) => yl(s) === "[object Date]", Ct = (s) => typeof s == "function", yn = (s) => typeof s == "string", $i = (s) => typeof s == "symbol", tn = (s) => s !== null && typeof s == "object", mg = (s) => (tn(s) || Ct(s)) && Ct(s.then) && Ct(s.catch), vg = Object.prototype.toString, yl = (s) => vg.call(s), r1 = (s) => yl(s).slice(8, -1), gg = (s) => yl(s) === "[object Object]", uu = (s) => yn(s) && s !== "NaN" && s[0] !== "-" && "" + parseInt(s, 10) === s, La = /* @__PURE__ */ sf(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), du = (s) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = s(n));
}, o1 = /-\w/g, Di = du(
  (s) => s.replace(o1, (e) => e.slice(1).toUpperCase())
), a1 = /\B([A-Z])/g, cr = du(
  (s) => s.replace(a1, "-$1").toLowerCase()
), hu = du((s) => s.charAt(0).toUpperCase() + s.slice(1)), $u = du(
  (s) => s ? `on${hu(s)}` : ""
), sr = (s, e) => !Object.is(s, e), Tc = (s, ...e) => {
  for (let n = 0; n < s.length; n++)
    s[n](...e);
}, yg = (s, e, n, i = !1) => {
  Object.defineProperty(s, e, {
    configurable: !0,
    enumerable: !1,
    writable: i,
    value: n
  });
}, fu = (s) => {
  const e = parseFloat(s);
  return isNaN(e) ? s : e;
};
let vp;
const pu = () => vp || (vp = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function yt(s) {
  if (xt(s)) {
    const e = {};
    for (let n = 0; n < s.length; n++) {
      const i = s[n], r = yn(i) ? d1(i) : yt(i);
      if (r)
        for (const o in r)
          e[o] = r[o];
    }
    return e;
  } else if (yn(s) || tn(s))
    return s;
}
const l1 = /;(?![^(]*\))/g, c1 = /:([^]+)/, u1 = /\/\*[^]*?\*\//g;
function d1(s) {
  const e = {};
  return s.replace(u1, "").split(l1).forEach((n) => {
    if (n) {
      const i = n.split(c1);
      i.length > 1 && (e[i[0].trim()] = i[1].trim());
    }
  }), e;
}
function Fe(s) {
  let e = "";
  if (yn(s))
    e = s;
  else if (xt(s))
    for (let n = 0; n < s.length; n++) {
      const i = Fe(s[n]);
      i && (e += i + " ");
    }
  else if (tn(s))
    for (const n in s)
      s[n] && (e += n + " ");
  return e.trim();
}
const h1 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", f1 = /* @__PURE__ */ sf(h1);
function _g(s) {
  return !!s || s === "";
}
function p1(s, e) {
  if (s.length !== e.length) return !1;
  let n = !0;
  for (let i = 0; n && i < s.length; i++)
    n = _l(s[i], e[i]);
  return n;
}
function _l(s, e) {
  if (s === e) return !0;
  let n = mp(s), i = mp(e);
  if (n || i)
    return n && i ? s.getTime() === e.getTime() : !1;
  if (n = $i(s), i = $i(e), n || i)
    return s === e;
  if (n = xt(s), i = xt(e), n || i)
    return n && i ? p1(s, e) : !1;
  if (n = tn(s), i = tn(e), n || i) {
    if (!n || !i)
      return !1;
    const r = Object.keys(s).length, o = Object.keys(e).length;
    if (r !== o)
      return !1;
    for (const a in s) {
      const l = s.hasOwnProperty(a), c = e.hasOwnProperty(a);
      if (l && !c || !l && c || !_l(s[a], e[a]))
        return !1;
    }
  }
  return String(s) === String(e);
}
function af(s, e) {
  return s.findIndex((n) => _l(n, e));
}
const xg = (s) => !!(s && s.__v_isRef === !0), xe = (s) => yn(s) ? s : s == null ? "" : xt(s) || tn(s) && (s.toString === vg || !Ct(s.toString)) ? xg(s) ? xe(s.value) : JSON.stringify(s, bg, 2) : String(s), bg = (s, e) => xg(e) ? bg(s, e.value) : Ro(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (n, [i, r], o) => (n[Wu(i, o) + " =>"] = r, n),
    {}
  )
} : Yo(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((n) => Wu(n))
} : $i(e) ? Wu(e) : tn(e) && !xt(e) && !gg(e) ? String(e) : e, Wu = (s, e = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    $i(s) ? `Symbol(${(n = s.description) != null ? n : e})` : s
  );
};
/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Xn;
class wg {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Xn, !e && Xn && (this.index = (Xn.scopes || (Xn.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].pause();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].resume();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const n = Xn;
      try {
        return Xn = this, e();
      } finally {
        Xn = n;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Xn, Xn = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Xn = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let n, i;
      for (n = 0, i = this.effects.length; n < i; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, i = this.cleanups.length; n < i; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, i = this.scopes.length; n < i; n++)
          this.scopes[n].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const r = this.parent.scopes.pop();
        r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Sg(s) {
  return new wg(s);
}
function Mg() {
  return Xn;
}
function m1(s, e = !1) {
  Xn && Xn.cleanups.push(s);
}
let nn;
const Xu = /* @__PURE__ */ new WeakSet();
class Cg {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Xn && Xn.active && Xn.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Xu.has(this) && (Xu.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Tg(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, gp(this), Ag(this);
    const e = nn, n = Hi;
    nn = this, Hi = !0;
    try {
      return this.fn();
    } finally {
      Pg(this), nn = e, Hi = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        uf(e);
      this.deps = this.depsTail = void 0, gp(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Xu.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    qd(this) && this.run();
  }
  get dirty() {
    return qd(this);
  }
}
let Eg = 0, Fa, Ua;
function Tg(s, e = !1) {
  if (s.flags |= 8, e) {
    s.next = Ua, Ua = s;
    return;
  }
  s.next = Fa, Fa = s;
}
function lf() {
  Eg++;
}
function cf() {
  if (--Eg > 0)
    return;
  if (Ua) {
    let e = Ua;
    for (Ua = void 0; e; ) {
      const n = e.next;
      e.next = void 0, e.flags &= -9, e = n;
    }
  }
  let s;
  for (; Fa; ) {
    let e = Fa;
    for (Fa = void 0; e; ) {
      const n = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (i) {
          s || (s = i);
        }
      e = n;
    }
  }
  if (s) throw s;
}
function Ag(s) {
  for (let e = s.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function Pg(s) {
  let e, n = s.depsTail, i = n;
  for (; i; ) {
    const r = i.prevDep;
    i.version === -1 ? (i === n && (n = r), uf(i), v1(i)) : e = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = r;
  }
  s.deps = e, s.depsTail = n;
}
function qd(s) {
  for (let e = s.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (Rg(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!s._dirty;
}
function Rg(s) {
  if (s.flags & 4 && !(s.flags & 16) || (s.flags &= -17, s.globalVersion === Ja) || (s.globalVersion = Ja, !s.isSSR && s.flags & 128 && (!s.deps && !s._dirty || !qd(s))))
    return;
  s.flags |= 2;
  const e = s.dep, n = nn, i = Hi;
  nn = s, Hi = !0;
  try {
    Ag(s);
    const r = s.fn(s._value);
    (e.version === 0 || sr(r, s._value)) && (s.flags |= 128, s._value = r, e.version++);
  } catch (r) {
    throw e.version++, r;
  } finally {
    nn = n, Hi = i, Pg(s), s.flags &= -3;
  }
}
function uf(s, e = !1) {
  const { dep: n, prevSub: i, nextSub: r } = s;
  if (i && (i.nextSub = r, s.prevSub = void 0), r && (r.prevSub = i, s.nextSub = void 0), n.subs === s && (n.subs = i, !i && n.computed)) {
    n.computed.flags &= -5;
    for (let o = n.computed.deps; o; o = o.nextDep)
      uf(o, !0);
  }
  !e && !--n.sc && n.map && n.map.delete(n.key);
}
function v1(s) {
  const { prevDep: e, nextDep: n } = s;
  e && (e.nextDep = n, s.prevDep = void 0), n && (n.prevDep = e, s.nextDep = void 0);
}
let Hi = !0;
const Dg = [];
function Ds() {
  Dg.push(Hi), Hi = !1;
}
function ks() {
  const s = Dg.pop();
  Hi = s === void 0 ? !0 : s;
}
function gp(s) {
  const { cleanup: e } = s;
  if (s.cleanup = void 0, e) {
    const n = nn;
    nn = void 0;
    try {
      e();
    } finally {
      nn = n;
    }
  }
}
let Ja = 0;
class g1 {
  constructor(e, n) {
    this.sub = e, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class df {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(e) {
    if (!nn || !Hi || nn === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== nn)
      n = this.activeLink = new g1(nn, this), nn.deps ? (n.prevDep = nn.depsTail, nn.depsTail.nextDep = n, nn.depsTail = n) : nn.deps = nn.depsTail = n, kg(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const i = n.nextDep;
      i.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = i), n.prevDep = nn.depsTail, n.nextDep = void 0, nn.depsTail.nextDep = n, nn.depsTail = n, nn.deps === n && (nn.deps = i);
    }
    return n;
  }
  trigger(e) {
    this.version++, Ja++, this.notify(e);
  }
  notify(e) {
    lf();
    try {
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      cf();
    }
  }
}
function kg(s) {
  if (s.dep.sc++, s.sub.flags & 4) {
    const e = s.dep.computed;
    if (e && !s.dep.subs) {
      e.flags |= 20;
      for (let i = e.deps; i; i = i.nextDep)
        kg(i);
    }
    const n = s.dep.subs;
    n !== s && (s.prevSub = n, n && (n.nextSub = s)), s.dep.subs = s;
  }
}
const Gc = /* @__PURE__ */ new WeakMap(), Or = Symbol(
  ""
), Zd = Symbol(
  ""
), Qa = Symbol(
  ""
);
function Yn(s, e, n) {
  if (Hi && nn) {
    let i = Gc.get(s);
    i || Gc.set(s, i = /* @__PURE__ */ new Map());
    let r = i.get(n);
    r || (i.set(n, r = new df()), r.map = i, r.key = n), r.track();
  }
}
function Ms(s, e, n, i, r, o) {
  const a = Gc.get(s);
  if (!a) {
    Ja++;
    return;
  }
  const l = (c) => {
    c && c.trigger();
  };
  if (lf(), e === "clear")
    a.forEach(l);
  else {
    const c = xt(s), u = c && uu(n);
    if (c && n === "length") {
      const d = Number(i);
      a.forEach((h, m) => {
        (m === "length" || m === Qa || !$i(m) && m >= d) && l(h);
      });
    } else
      switch ((n !== void 0 || a.has(void 0)) && l(a.get(n)), u && l(a.get(Qa)), e) {
        case "add":
          c ? u && l(a.get("length")) : (l(a.get(Or)), Ro(s) && l(a.get(Zd)));
          break;
        case "delete":
          c || (l(a.get(Or)), Ro(s) && l(a.get(Zd)));
          break;
        case "set":
          Ro(s) && l(a.get(Or));
          break;
      }
  }
  cf();
}
function y1(s, e) {
  const n = Gc.get(s);
  return n && n.get(e);
}
function Zr(s) {
  const e = Nt(s);
  return e === s ? e : (Yn(e, "iterate", Qa), wi(s) ? e : e.map(Wi));
}
function mu(s) {
  return Yn(s = Nt(s), "iterate", Qa), s;
}
function Qs(s, e) {
  return Is(s) ? Ts(s) ? Fo(Wi(e)) : Fo(e) : Wi(e);
}
const _1 = {
  __proto__: null,
  [Symbol.iterator]() {
    return ju(this, Symbol.iterator, (s) => Qs(this, s));
  },
  concat(...s) {
    return Zr(this).concat(
      ...s.map((e) => xt(e) ? Zr(e) : e)
    );
  },
  entries() {
    return ju(this, "entries", (s) => (s[1] = Qs(this, s[1]), s));
  },
  every(s, e) {
    return us(this, "every", s, e, void 0, arguments);
  },
  filter(s, e) {
    return us(
      this,
      "filter",
      s,
      e,
      (n) => n.map((i) => Qs(this, i)),
      arguments
    );
  },
  find(s, e) {
    return us(
      this,
      "find",
      s,
      e,
      (n) => Qs(this, n),
      arguments
    );
  },
  findIndex(s, e) {
    return us(this, "findIndex", s, e, void 0, arguments);
  },
  findLast(s, e) {
    return us(
      this,
      "findLast",
      s,
      e,
      (n) => Qs(this, n),
      arguments
    );
  },
  findLastIndex(s, e) {
    return us(this, "findLastIndex", s, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(s, e) {
    return us(this, "forEach", s, e, void 0, arguments);
  },
  includes(...s) {
    return Yu(this, "includes", s);
  },
  indexOf(...s) {
    return Yu(this, "indexOf", s);
  },
  join(s) {
    return Zr(this).join(s);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...s) {
    return Yu(this, "lastIndexOf", s);
  },
  map(s, e) {
    return us(this, "map", s, e, void 0, arguments);
  },
  pop() {
    return ca(this, "pop");
  },
  push(...s) {
    return ca(this, "push", s);
  },
  reduce(s, ...e) {
    return yp(this, "reduce", s, e);
  },
  reduceRight(s, ...e) {
    return yp(this, "reduceRight", s, e);
  },
  shift() {
    return ca(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(s, e) {
    return us(this, "some", s, e, void 0, arguments);
  },
  splice(...s) {
    return ca(this, "splice", s);
  },
  toReversed() {
    return Zr(this).toReversed();
  },
  toSorted(s) {
    return Zr(this).toSorted(s);
  },
  toSpliced(...s) {
    return Zr(this).toSpliced(...s);
  },
  unshift(...s) {
    return ca(this, "unshift", s);
  },
  values() {
    return ju(this, "values", (s) => Qs(this, s));
  }
};
function ju(s, e, n) {
  const i = mu(s), r = i[e]();
  return i !== s && !wi(s) && (r._next = r.next, r.next = () => {
    const o = r._next();
    return o.done || (o.value = n(o.value)), o;
  }), r;
}
const x1 = Array.prototype;
function us(s, e, n, i, r, o) {
  const a = mu(s), l = a !== s && !wi(s), c = a[e];
  if (c !== x1[e]) {
    const h = c.apply(s, o);
    return l ? Wi(h) : h;
  }
  let u = n;
  a !== s && (l ? u = function(h, m) {
    return n.call(this, Qs(s, h), m, s);
  } : n.length > 2 && (u = function(h, m) {
    return n.call(this, h, m, s);
  }));
  const d = c.call(a, u, i);
  return l && r ? r(d) : d;
}
function yp(s, e, n, i) {
  const r = mu(s);
  let o = n;
  return r !== s && (wi(s) ? n.length > 3 && (o = function(a, l, c) {
    return n.call(this, a, l, c, s);
  }) : o = function(a, l, c) {
    return n.call(this, a, Qs(s, l), c, s);
  }), r[e](o, ...i);
}
function Yu(s, e, n) {
  const i = Nt(s);
  Yn(i, "iterate", Qa);
  const r = i[e](...n);
  return (r === -1 || r === !1) && vu(n[0]) ? (n[0] = Nt(n[0]), i[e](...n)) : r;
}
function ca(s, e, n = []) {
  Ds(), lf();
  const i = Nt(s)[e].apply(s, n);
  return cf(), ks(), i;
}
const b1 = /* @__PURE__ */ sf("__proto__,__v_isRef,__isVue"), Ig = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((s) => s !== "arguments" && s !== "caller").map((s) => Symbol[s]).filter($i)
);
function w1(s) {
  $i(s) || (s = String(s));
  const e = Nt(this);
  return Yn(e, "has", s), e.hasOwnProperty(s);
}
class Lg {
  constructor(e = !1, n = !1) {
    this._isReadonly = e, this._isShallow = n;
  }
  get(e, n, i) {
    if (n === "__v_skip") return e.__v_skip;
    const r = this._isReadonly, o = this._isShallow;
    if (n === "__v_isReactive")
      return !r;
    if (n === "__v_isReadonly")
      return r;
    if (n === "__v_isShallow")
      return o;
    if (n === "__v_raw")
      return i === (r ? o ? k1 : zg : o ? Og : Ug).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(i) ? e : void 0;
    const a = xt(e);
    if (!r) {
      let c;
      if (a && (c = _1[n]))
        return c;
      if (n === "hasOwnProperty")
        return w1;
    }
    const l = Reflect.get(
      e,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      gn(e) ? e : i
    );
    if (($i(n) ? Ig.has(n) : b1(n)) || (r || Yn(e, "get", n), o))
      return l;
    if (gn(l)) {
      const c = a && uu(n) ? l : l.value;
      return r && tn(c) ? Jd(c) : c;
    }
    return tn(l) ? r ? Jd(l) : Gr(l) : l;
  }
}
class Fg extends Lg {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, n, i, r) {
    let o = e[n];
    const a = xt(e) && uu(n);
    if (!this._isShallow) {
      const u = Is(o);
      if (!wi(i) && !Is(i) && (o = Nt(o), i = Nt(i)), !a && gn(o) && !gn(i))
        return u || (o.value = i), !0;
    }
    const l = a ? Number(n) < e.length : Xt(e, n), c = Reflect.set(
      e,
      n,
      i,
      gn(e) ? e : r
    );
    return e === Nt(r) && (l ? sr(i, o) && Ms(e, "set", n, i) : Ms(e, "add", n, i)), c;
  }
  deleteProperty(e, n) {
    const i = Xt(e, n);
    e[n];
    const r = Reflect.deleteProperty(e, n);
    return r && i && Ms(e, "delete", n, void 0), r;
  }
  has(e, n) {
    const i = Reflect.has(e, n);
    return (!$i(n) || !Ig.has(n)) && Yn(e, "has", n), i;
  }
  ownKeys(e) {
    return Yn(
      e,
      "iterate",
      xt(e) ? "length" : Or
    ), Reflect.ownKeys(e);
  }
}
class S1 extends Lg {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, n) {
    return !0;
  }
  deleteProperty(e, n) {
    return !0;
  }
}
const M1 = /* @__PURE__ */ new Fg(), C1 = /* @__PURE__ */ new S1(), E1 = /* @__PURE__ */ new Fg(!0);
const Kd = (s) => s, Ll = (s) => Reflect.getPrototypeOf(s);
function T1(s, e, n) {
  return function(...i) {
    const r = this.__v_raw, o = Nt(r), a = Ro(o), l = s === "entries" || s === Symbol.iterator && a, c = s === "keys" && a, u = r[s](...i), d = n ? Kd : e ? Fo : Wi;
    return !e && Yn(
      o,
      "iterate",
      c ? Zd : Or
    ), {
      // iterator protocol
      next() {
        const { value: h, done: m } = u.next();
        return m ? { value: h, done: m } : {
          value: l ? [d(h[0]), d(h[1])] : d(h),
          done: m
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Fl(s) {
  return function(...e) {
    return s === "delete" ? !1 : s === "clear" ? void 0 : this;
  };
}
function A1(s, e) {
  const n = {
    get(r) {
      const o = this.__v_raw, a = Nt(o), l = Nt(r);
      s || (sr(r, l) && Yn(a, "get", r), Yn(a, "get", l));
      const { has: c } = Ll(a), u = e ? Kd : s ? Fo : Wi;
      if (c.call(a, r))
        return u(o.get(r));
      if (c.call(a, l))
        return u(o.get(l));
      o !== a && o.get(r);
    },
    get size() {
      const r = this.__v_raw;
      return !s && Yn(Nt(r), "iterate", Or), r.size;
    },
    has(r) {
      const o = this.__v_raw, a = Nt(o), l = Nt(r);
      return s || (sr(r, l) && Yn(a, "has", r), Yn(a, "has", l)), r === l ? o.has(r) : o.has(r) || o.has(l);
    },
    forEach(r, o) {
      const a = this, l = a.__v_raw, c = Nt(l), u = e ? Kd : s ? Fo : Wi;
      return !s && Yn(c, "iterate", Or), l.forEach((d, h) => r.call(o, u(d), u(h), a));
    }
  };
  return Zn(
    n,
    s ? {
      add: Fl("add"),
      set: Fl("set"),
      delete: Fl("delete"),
      clear: Fl("clear")
    } : {
      add(r) {
        !e && !wi(r) && !Is(r) && (r = Nt(r));
        const o = Nt(this);
        return Ll(o).has.call(o, r) || (o.add(r), Ms(o, "add", r, r)), this;
      },
      set(r, o) {
        !e && !wi(o) && !Is(o) && (o = Nt(o));
        const a = Nt(this), { has: l, get: c } = Ll(a);
        let u = l.call(a, r);
        u || (r = Nt(r), u = l.call(a, r));
        const d = c.call(a, r);
        return a.set(r, o), u ? sr(o, d) && Ms(a, "set", r, o) : Ms(a, "add", r, o), this;
      },
      delete(r) {
        const o = Nt(this), { has: a, get: l } = Ll(o);
        let c = a.call(o, r);
        c || (r = Nt(r), c = a.call(o, r)), l && l.call(o, r);
        const u = o.delete(r);
        return c && Ms(o, "delete", r, void 0), u;
      },
      clear() {
        const r = Nt(this), o = r.size !== 0, a = r.clear();
        return o && Ms(
          r,
          "clear",
          void 0,
          void 0
        ), a;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((r) => {
    n[r] = T1(r, s, e);
  }), n;
}
function hf(s, e) {
  const n = A1(s, e);
  return (i, r, o) => r === "__v_isReactive" ? !s : r === "__v_isReadonly" ? s : r === "__v_raw" ? i : Reflect.get(
    Xt(n, r) && r in i ? n : i,
    r,
    o
  );
}
const P1 = {
  get: /* @__PURE__ */ hf(!1, !1)
}, R1 = {
  get: /* @__PURE__ */ hf(!1, !0)
}, D1 = {
  get: /* @__PURE__ */ hf(!0, !1)
};
const Ug = /* @__PURE__ */ new WeakMap(), Og = /* @__PURE__ */ new WeakMap(), zg = /* @__PURE__ */ new WeakMap(), k1 = /* @__PURE__ */ new WeakMap();
function I1(s) {
  switch (s) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function L1(s) {
  return s.__v_skip || !Object.isExtensible(s) ? 0 : I1(r1(s));
}
function Gr(s) {
  return Is(s) ? s : ff(
    s,
    !1,
    M1,
    P1,
    Ug
  );
}
function F1(s) {
  return ff(
    s,
    !1,
    E1,
    R1,
    Og
  );
}
function Jd(s) {
  return ff(
    s,
    !0,
    C1,
    D1,
    zg
  );
}
function ff(s, e, n, i, r) {
  if (!tn(s) || s.__v_raw && !(e && s.__v_isReactive))
    return s;
  const o = L1(s);
  if (o === 0)
    return s;
  const a = r.get(s);
  if (a)
    return a;
  const l = new Proxy(
    s,
    o === 2 ? i : n
  );
  return r.set(s, l), l;
}
function Ts(s) {
  return Is(s) ? Ts(s.__v_raw) : !!(s && s.__v_isReactive);
}
function Is(s) {
  return !!(s && s.__v_isReadonly);
}
function wi(s) {
  return !!(s && s.__v_isShallow);
}
function vu(s) {
  return s ? !!s.__v_raw : !1;
}
function Nt(s) {
  const e = s && s.__v_raw;
  return e ? Nt(e) : s;
}
function Ss(s) {
  return !Xt(s, "__v_skip") && Object.isExtensible(s) && yg(s, "__v_skip", !0), s;
}
const Wi = (s) => tn(s) ? Gr(s) : s, Fo = (s) => tn(s) ? Jd(s) : s;
function gn(s) {
  return s ? s.__v_isRef === !0 : !1;
}
function we(s) {
  return Ng(s, !1);
}
function U1(s) {
  return Ng(s, !0);
}
function Ng(s, e) {
  return gn(s) ? s : new O1(s, e);
}
class O1 {
  constructor(e, n) {
    this.dep = new df(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? e : Nt(e), this._value = n ? e : Wi(e), this.__v_isShallow = n;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(e) {
    const n = this._rawValue, i = this.__v_isShallow || wi(e) || Is(e);
    e = i ? e : Nt(e), sr(e, n) && (this._rawValue = e, this._value = i ? e : Wi(e), this.dep.trigger());
  }
}
function Ve(s) {
  return gn(s) ? s.value : s;
}
const z1 = {
  get: (s, e, n) => e === "__v_raw" ? s : Ve(Reflect.get(s, e, n)),
  set: (s, e, n, i) => {
    const r = s[e];
    return gn(r) && !gn(n) ? (r.value = n, !0) : Reflect.set(s, e, n, i);
  }
};
function Bg(s) {
  return Ts(s) ? s : new Proxy(s, z1);
}
function N1(s) {
  const e = xt(s) ? new Array(s.length) : {};
  for (const n in s)
    e[n] = V1(s, n);
  return e;
}
class B1 {
  constructor(e, n, i) {
    this._object = e, this._key = n, this._defaultValue = i, this.__v_isRef = !0, this._value = void 0, this._raw = Nt(e);
    let r = !0, o = e;
    if (!xt(e) || !uu(String(n)))
      do
        r = !vu(o) || wi(o);
      while (r && (o = o.__v_raw));
    this._shallow = r;
  }
  get value() {
    let e = this._object[this._key];
    return this._shallow && (e = Ve(e)), this._value = e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    if (this._shallow && gn(this._raw[this._key])) {
      const n = this._object[this._key];
      if (gn(n)) {
        n.value = e;
        return;
      }
    }
    this._object[this._key] = e;
  }
  get dep() {
    return y1(this._raw, this._key);
  }
}
function V1(s, e, n) {
  return new B1(s, e, n);
}
class G1 {
  constructor(e, n, i) {
    this.fn = e, this.setter = n, this._value = void 0, this.dep = new df(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Ja - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = i;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    nn !== this)
      return Tg(this, !0), !0;
  }
  get value() {
    const e = this.dep.track();
    return Rg(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter && this.setter(e);
  }
}
function H1(s, e, n = !1) {
  let i, r;
  return Ct(s) ? i = s : (i = s.get, r = s.set), new G1(i, r, n);
}
const Ul = {}, Hc = /* @__PURE__ */ new WeakMap();
let Cr;
function $1(s, e = !1, n = Cr) {
  if (n) {
    let i = Hc.get(n);
    i || Hc.set(n, i = []), i.push(s);
  }
}
function W1(s, e, n = en) {
  const { immediate: i, deep: r, once: o, scheduler: a, augmentJob: l, call: c } = n, u = (b) => r ? b : wi(b) || r === !1 || r === 0 ? Cs(b, 1) : Cs(b);
  let d, h, m, p, v = !1, x = !1;
  if (gn(s) ? (h = () => s.value, v = wi(s)) : Ts(s) ? (h = () => u(s), v = !0) : xt(s) ? (x = !0, v = s.some((b) => Ts(b) || wi(b)), h = () => s.map((b) => {
    if (gn(b))
      return b.value;
    if (Ts(b))
      return u(b);
    if (Ct(b))
      return c ? c(b, 2) : b();
  })) : Ct(s) ? e ? h = c ? () => c(s, 2) : s : h = () => {
    if (m) {
      Ds();
      try {
        m();
      } finally {
        ks();
      }
    }
    const b = Cr;
    Cr = d;
    try {
      return c ? c(s, 3, [p]) : s(p);
    } finally {
      Cr = b;
    }
  } : h = ss, e && r) {
    const b = h, C = r === !0 ? 1 / 0 : r;
    h = () => Cs(b(), C);
  }
  const g = Mg(), _ = () => {
    d.stop(), g && g.active && of(g.effects, d);
  };
  if (o && e) {
    const b = e;
    e = (...C) => {
      b(...C), _();
    };
  }
  let M = x ? new Array(s.length).fill(Ul) : Ul;
  const S = (b) => {
    if (!(!(d.flags & 1) || !d.dirty && !b))
      if (e) {
        const C = d.run();
        if (r || v || (x ? C.some((E, P) => sr(E, M[P])) : sr(C, M))) {
          m && m();
          const E = Cr;
          Cr = d;
          try {
            const P = [
              C,
              // pass undefined as the old value when it's changed for the first time
              M === Ul ? void 0 : x && M[0] === Ul ? [] : M,
              p
            ];
            M = C, c ? c(e, 3, P) : (
              // @ts-expect-error
              e(...P)
            );
          } finally {
            Cr = E;
          }
        }
      } else
        d.run();
  };
  return l && l(S), d = new Cg(h), d.scheduler = a ? () => a(S, !1) : S, p = (b) => $1(b, !1, d), m = d.onStop = () => {
    const b = Hc.get(d);
    if (b) {
      if (c)
        c(b, 4);
      else
        for (const C of b) C();
      Hc.delete(d);
    }
  }, e ? i ? S(!0) : M = d.run() : a ? a(S.bind(null, !0), !0) : d.run(), _.pause = d.pause.bind(d), _.resume = d.resume.bind(d), _.stop = _, _;
}
function Cs(s, e = 1 / 0, n) {
  if (e <= 0 || !tn(s) || s.__v_skip || (n = n || /* @__PURE__ */ new Map(), (n.get(s) || 0) >= e))
    return s;
  if (n.set(s, e), e--, gn(s))
    Cs(s.value, e, n);
  else if (xt(s))
    for (let i = 0; i < s.length; i++)
      Cs(s[i], e, n);
  else if (Yo(s) || Ro(s))
    s.forEach((i) => {
      Cs(i, e, n);
    });
  else if (gg(s)) {
    for (const i in s)
      Cs(s[i], e, n);
    for (const i of Object.getOwnPropertySymbols(s))
      Object.prototype.propertyIsEnumerable.call(s, i) && Cs(s[i], e, n);
  }
  return s;
}
/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function xl(s, e, n, i) {
  try {
    return i ? s(...i) : s();
  } catch (r) {
    gu(r, e, n);
  }
}
function os(s, e, n, i) {
  if (Ct(s)) {
    const r = xl(s, e, n, i);
    return r && mg(r) && r.catch((o) => {
      gu(o, e, n);
    }), r;
  }
  if (xt(s)) {
    const r = [];
    for (let o = 0; o < s.length; o++)
      r.push(os(s[o], e, n, i));
    return r;
  }
}
function gu(s, e, n, i = !0) {
  const r = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: a } = e && e.appContext.config || en;
  if (e) {
    let l = e.parent;
    const c = e.proxy, u = `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; l; ) {
      const d = l.ec;
      if (d) {
        for (let h = 0; h < d.length; h++)
          if (d[h](s, c, u) === !1)
            return;
      }
      l = l.parent;
    }
    if (o) {
      Ds(), xl(o, null, 10, [
        s,
        c,
        u
      ]), ks();
      return;
    }
  }
  X1(s, n, r, i, a);
}
function X1(s, e, n, i = !0, r = !1) {
  if (r)
    throw s;
  console.error(s);
}
const ii = [];
let es = -1;
const Do = [];
let er = null, xo = 0;
const Vg = /* @__PURE__ */ Promise.resolve();
let $c = null;
function Pi(s) {
  const e = $c || Vg;
  return s ? e.then(this ? s.bind(this) : s) : e;
}
function j1(s) {
  let e = es + 1, n = ii.length;
  for (; e < n; ) {
    const i = e + n >>> 1, r = ii[i], o = el(r);
    o < s || o === s && r.flags & 2 ? e = i + 1 : n = i;
  }
  return e;
}
function pf(s) {
  if (!(s.flags & 1)) {
    const e = el(s), n = ii[ii.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(s.flags & 2) && e >= el(n) ? ii.push(s) : ii.splice(j1(e), 0, s), s.flags |= 1, Gg();
  }
}
function Gg() {
  $c || ($c = Vg.then($g));
}
function Y1(s) {
  xt(s) ? Do.push(...s) : er && s.id === -1 ? er.splice(xo + 1, 0, s) : s.flags & 1 || (Do.push(s), s.flags |= 1), Gg();
}
function _p(s, e, n = es + 1) {
  for (; n < ii.length; n++) {
    const i = ii[n];
    if (i && i.flags & 2) {
      if (s && i.id !== s.uid)
        continue;
      ii.splice(n, 1), n--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2);
    }
  }
}
function Hg(s) {
  if (Do.length) {
    const e = [...new Set(Do)].sort(
      (n, i) => el(n) - el(i)
    );
    if (Do.length = 0, er) {
      er.push(...e);
      return;
    }
    for (er = e, xo = 0; xo < er.length; xo++) {
      const n = er[xo];
      n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2;
    }
    er = null, xo = 0;
  }
}
const el = (s) => s.id == null ? s.flags & 2 ? -1 : 1 / 0 : s.id;
function $g(s) {
  try {
    for (es = 0; es < ii.length; es++) {
      const e = ii[es];
      e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), xl(
        e,
        e.i,
        e.i ? 15 : 14
      ), e.flags & 4 || (e.flags &= -2));
    }
  } finally {
    for (; es < ii.length; es++) {
      const e = ii[es];
      e && (e.flags &= -2);
    }
    es = -1, ii.length = 0, Hg(), $c = null, (ii.length || Do.length) && $g();
  }
}
let Fn = null, Wg = null;
function Wc(s) {
  const e = Fn;
  return Fn = s, Wg = s && s.type.__scopeId || null, e;
}
function zi(s, e = Fn, n) {
  if (!e || s._n)
    return s;
  const i = (...r) => {
    i._d && Yc(-1);
    const o = Wc(e);
    let a;
    try {
      a = s(...r);
    } finally {
      Wc(o), i._d && Yc(1);
    }
    return a;
  };
  return i._n = !0, i._c = !0, i._d = !0, i;
}
function st(s, e) {
  if (Fn === null)
    return s;
  const n = wu(Fn), i = s.dirs || (s.dirs = []);
  for (let r = 0; r < e.length; r++) {
    let [o, a, l, c = en] = e[r];
    o && (Ct(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Cs(a), i.push({
      dir: o,
      instance: n,
      value: a,
      oldValue: void 0,
      arg: l,
      modifiers: c
    }));
  }
  return s;
}
function hr(s, e, n, i) {
  const r = s.dirs, o = e && e.dirs;
  for (let a = 0; a < r.length; a++) {
    const l = r[a];
    o && (l.oldValue = o[a].value);
    let c = l.dir[i];
    c && (Ds(), os(c, n, 8, [
      s.el,
      l,
      s,
      e
    ]), ks());
  }
}
const Xg = Symbol("_vte"), q1 = (s) => s.__isTeleport, Oa = (s) => s && (s.disabled || s.disabled === ""), xp = (s) => s && (s.defer || s.defer === ""), bp = (s) => typeof SVGElement < "u" && s instanceof SVGElement, wp = (s) => typeof MathMLElement == "function" && s instanceof MathMLElement, Qd = (s, e) => {
  const n = s && s.to;
  return yn(n) ? e ? e(n) : null : n;
}, jg = {
  name: "Teleport",
  __isTeleport: !0,
  process(s, e, n, i, r, o, a, l, c, u) {
    const {
      mc: d,
      pc: h,
      pbc: m,
      o: { insert: p, querySelector: v, createText: x, createComment: g }
    } = u, _ = Oa(e.props);
    let { shapeFlag: M, children: S, dynamicChildren: b } = e;
    if (s == null) {
      const C = e.el = x(""), E = e.anchor = x("");
      p(C, n, i), p(E, n, i);
      const P = (y, w) => {
        M & 16 && d(
          S,
          y,
          w,
          r,
          o,
          a,
          l,
          c
        );
      }, T = () => {
        const y = e.target = Qd(e.props, v), w = Yg(y, e, x, p);
        y && (a !== "svg" && bp(y) ? a = "svg" : a !== "mathml" && wp(y) && (a = "mathml"), r && r.isCE && (r.ce._teleportTargets || (r.ce._teleportTargets = /* @__PURE__ */ new Set())).add(y), _ || (P(y, w), Ac(e, !1)));
      };
      _ && (P(n, E), Ac(e, !0)), xp(e.props) ? (e.el.__isMounted = !1, ti(() => {
        T(), delete e.el.__isMounted;
      }, o)) : T();
    } else {
      if (xp(e.props) && s.el.__isMounted === !1) {
        ti(() => {
          jg.process(
            s,
            e,
            n,
            i,
            r,
            o,
            a,
            l,
            c,
            u
          );
        }, o);
        return;
      }
      e.el = s.el, e.targetStart = s.targetStart;
      const C = e.anchor = s.anchor, E = e.target = s.target, P = e.targetAnchor = s.targetAnchor, T = Oa(s.props), y = T ? n : E, w = T ? C : P;
      if (a === "svg" || bp(E) ? a = "svg" : (a === "mathml" || wp(E)) && (a = "mathml"), b ? (m(
        s.dynamicChildren,
        b,
        y,
        r,
        o,
        a,
        l
      ), _f(s, e, !0)) : c || h(
        s,
        e,
        y,
        w,
        r,
        o,
        a,
        l,
        !1
      ), _)
        T ? e.props && s.props && e.props.to !== s.props.to && (e.props.to = s.props.to) : Ol(
          e,
          n,
          C,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (s.props && s.props.to)) {
        const D = e.target = Qd(
          e.props,
          v
        );
        D && Ol(
          e,
          D,
          null,
          u,
          0
        );
      } else T && Ol(
        e,
        E,
        P,
        u,
        1
      );
      Ac(e, _);
    }
  },
  remove(s, e, n, { um: i, o: { remove: r } }, o) {
    const {
      shapeFlag: a,
      children: l,
      anchor: c,
      targetStart: u,
      targetAnchor: d,
      target: h,
      props: m
    } = s;
    if (h && (r(u), r(d)), o && r(c), a & 16) {
      const p = o || !Oa(m);
      for (let v = 0; v < l.length; v++) {
        const x = l[v];
        i(
          x,
          e,
          n,
          p,
          !!x.dynamicChildren
        );
      }
    }
  },
  move: Ol,
  hydrate: Z1
};
function Ol(s, e, n, { o: { insert: i }, m: r }, o = 2) {
  o === 0 && i(s.targetAnchor, e, n);
  const { el: a, anchor: l, shapeFlag: c, children: u, props: d } = s, h = o === 2;
  if (h && i(a, e, n), (!h || Oa(d)) && c & 16)
    for (let m = 0; m < u.length; m++)
      r(
        u[m],
        e,
        n,
        2
      );
  h && i(l, e, n);
}
function Z1(s, e, n, i, r, o, {
  o: { nextSibling: a, parentNode: l, querySelector: c, insert: u, createText: d }
}, h) {
  function m(x, g, _, M) {
    g.anchor = h(
      a(x),
      g,
      l(x),
      n,
      i,
      r,
      o
    ), g.targetStart = _, g.targetAnchor = M;
  }
  const p = e.target = Qd(
    e.props,
    c
  ), v = Oa(e.props);
  if (p) {
    const x = p._lpa || p.firstChild;
    if (e.shapeFlag & 16)
      if (v)
        m(
          s,
          e,
          x,
          x && a(x)
        );
      else {
        e.anchor = a(s);
        let g = x;
        for (; g; ) {
          if (g && g.nodeType === 8) {
            if (g.data === "teleport start anchor")
              e.targetStart = g;
            else if (g.data === "teleport anchor") {
              e.targetAnchor = g, p._lpa = e.targetAnchor && a(e.targetAnchor);
              break;
            }
          }
          g = a(g);
        }
        e.targetAnchor || Yg(p, e, d, u), h(
          x && a(x),
          e,
          p,
          n,
          i,
          r,
          o
        );
      }
    Ac(e, v);
  } else v && e.shapeFlag & 16 && m(s, e, s, a(s));
  return e.anchor && a(e.anchor);
}
const Uo = jg;
function Ac(s, e) {
  const n = s.ctx;
  if (n && n.ut) {
    let i, r;
    for (e ? (i = s.el, r = s.anchor) : (i = s.targetStart, r = s.targetAnchor); i && i !== r; )
      i.nodeType === 1 && i.setAttribute("data-v-owner", n.uid), i = i.nextSibling;
    n.ut();
  }
}
function Yg(s, e, n, i) {
  const r = e.targetStart = n(""), o = e.targetAnchor = n("");
  return r[Xg] = o, s && (i(r, s), i(o, s)), o;
}
const K1 = Symbol("_leaveCb");
function mf(s, e) {
  s.shapeFlag & 6 && s.component ? (s.transition = e, mf(s.component.subTree, e)) : s.shapeFlag & 128 ? (s.ssContent.transition = e.clone(s.ssContent), s.ssFallback.transition = e.clone(s.ssFallback)) : s.transition = e;
}
// @__NO_SIDE_EFFECTS__
function Ot(s, e) {
  return Ct(s) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Zn({ name: s.name }, e, { setup: s })
  ) : s;
}
function qg(s) {
  s.ids = [s.ids[0] + s.ids[2]++ + "-", 0, 0];
}
const Xc = /* @__PURE__ */ new WeakMap();
function za(s, e, n, i, r = !1) {
  if (xt(s)) {
    s.forEach(
      (v, x) => za(
        v,
        e && (xt(e) ? e[x] : e),
        n,
        i,
        r
      )
    );
    return;
  }
  if (ko(i) && !r) {
    i.shapeFlag & 512 && i.type.__asyncResolved && i.component.subTree.component && za(s, e, n, i.component.subTree);
    return;
  }
  const o = i.shapeFlag & 4 ? wu(i.component) : i.el, a = r ? null : o, { i: l, r: c } = s, u = e && e.r, d = l.refs === en ? l.refs = {} : l.refs, h = l.setupState, m = Nt(h), p = h === en ? pg : (v) => Xt(m, v);
  if (u != null && u !== c) {
    if (Sp(e), yn(u))
      d[u] = null, p(u) && (h[u] = null);
    else if (gn(u)) {
      u.value = null;
      const v = e;
      v.k && (d[v.k] = null);
    }
  }
  if (Ct(c))
    xl(c, l, 12, [a, d]);
  else {
    const v = yn(c), x = gn(c);
    if (v || x) {
      const g = () => {
        if (s.f) {
          const _ = v ? p(c) ? h[c] : d[c] : c.value;
          if (r)
            xt(_) && of(_, o);
          else if (xt(_))
            _.includes(o) || _.push(o);
          else if (v)
            d[c] = [o], p(c) && (h[c] = d[c]);
          else {
            const M = [o];
            c.value = M, s.k && (d[s.k] = M);
          }
        } else v ? (d[c] = a, p(c) && (h[c] = a)) : x && (c.value = a, s.k && (d[s.k] = a));
      };
      if (a) {
        const _ = () => {
          g(), Xc.delete(s);
        };
        _.id = -1, Xc.set(s, _), ti(_, n);
      } else
        Sp(s), g();
    }
  }
}
function Sp(s) {
  const e = Xc.get(s);
  e && (e.flags |= 8, Xc.delete(s));
}
pu().requestIdleCallback;
pu().cancelIdleCallback;
const ko = (s) => !!s.type.__asyncLoader, Zg = (s) => s.type.__isKeepAlive;
function J1(s, e) {
  Kg(s, "a", e);
}
function Q1(s, e) {
  Kg(s, "da", e);
}
function Kg(s, e, n = qn) {
  const i = s.__wdc || (s.__wdc = () => {
    let r = n;
    for (; r; ) {
      if (r.isDeactivated)
        return;
      r = r.parent;
    }
    return s();
  });
  if (yu(e, i, n), n) {
    let r = n.parent;
    for (; r && r.parent; )
      Zg(r.parent.vnode) && e_(i, e, n, r), r = r.parent;
  }
}
function e_(s, e, n, i) {
  const r = yu(
    e,
    s,
    i,
    !0
    /* prepend */
  );
  Nn(() => {
    of(i[e], r);
  }, n);
}
function yu(s, e, n = qn, i = !1) {
  if (n) {
    const r = n[s] || (n[s] = []), o = e.__weh || (e.__weh = (...a) => {
      Ds();
      const l = bl(n), c = os(e, n, s, a);
      return l(), ks(), c;
    });
    return i ? r.unshift(o) : r.push(o), o;
  }
}
const Fs = (s) => (e, n = qn) => {
  (!il || s === "sp") && yu(s, (...i) => e(...i), n);
}, t_ = Fs("bm"), _n = Fs("m"), n_ = Fs(
  "bu"
), i_ = Fs("u"), vf = Fs(
  "bum"
), Nn = Fs("um"), s_ = Fs(
  "sp"
), r_ = Fs("rtg"), o_ = Fs("rtc");
function a_(s, e = qn) {
  yu("ec", s, e);
}
const l_ = "components", Jg = Symbol.for("v-ndc");
function Qg(s) {
  return yn(s) ? c_(l_, s, !1) || s : s || Jg;
}
function c_(s, e, n = !0, i = !1) {
  const r = Fn || qn;
  if (r) {
    const o = r.type;
    {
      const l = Q_(
        o,
        !1
      );
      if (l && (l === e || l === Di(e) || l === hu(Di(e))))
        return o;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      Mp(r[s] || o[s], e) || // global registration
      Mp(r.appContext[s], e)
    );
    return !a && i ? o : a;
  }
}
function Mp(s, e) {
  return s && (s[e] || s[Di(e)] || s[hu(Di(e))]);
}
function ot(s, e, n, i) {
  let r;
  const o = n, a = xt(s);
  if (a || yn(s)) {
    const l = a && Ts(s);
    let c = !1, u = !1;
    l && (c = !wi(s), u = Is(s), s = mu(s)), r = new Array(s.length);
    for (let d = 0, h = s.length; d < h; d++)
      r[d] = e(
        c ? u ? Fo(Wi(s[d])) : Wi(s[d]) : s[d],
        d,
        void 0,
        o
      );
  } else if (typeof s == "number") {
    r = new Array(s);
    for (let l = 0; l < s; l++)
      r[l] = e(l + 1, l, void 0, o);
  } else if (tn(s))
    if (s[Symbol.iterator])
      r = Array.from(
        s,
        (l, c) => e(l, c, void 0, o)
      );
    else {
      const l = Object.keys(s);
      r = new Array(l.length);
      for (let c = 0, u = l.length; c < u; c++) {
        const d = l[c];
        r[c] = e(s[d], d, c, o);
      }
    }
  else
    r = [];
  return r;
}
function u_(s, e, n = {}, i, r) {
  if (Fn.ce || Fn.parent && ko(Fn.parent) && Fn.parent.ce) {
    const u = Object.keys(n).length > 0;
    return te(), St(
      qe,
      null,
      [ze("slot", n, i)],
      u ? -2 : 64
    );
  }
  let o = s[e];
  o && o._c && (o._d = !1), te();
  const a = o && e0(o(n)), l = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  a && a.key, c = St(
    qe,
    {
      key: (l && !$i(l) ? l : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!a && i ? "_fb" : "")
    },
    a || [],
    a && s._ === 1 ? 64 : -2
  );
  return c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), o && o._c && (o._d = !0), c;
}
function e0(s) {
  return s.some((e) => nl(e) ? !(e.type === Ls || e.type === qe && !e0(e.children)) : !0) ? s : null;
}
const eh = (s) => s ? _0(s) ? wu(s) : eh(s.parent) : null, Na = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Zn(/* @__PURE__ */ Object.create(null), {
    $: (s) => s,
    $el: (s) => s.vnode.el,
    $data: (s) => s.data,
    $props: (s) => s.props,
    $attrs: (s) => s.attrs,
    $slots: (s) => s.slots,
    $refs: (s) => s.refs,
    $parent: (s) => eh(s.parent),
    $root: (s) => eh(s.root),
    $host: (s) => s.ce,
    $emit: (s) => s.emit,
    $options: (s) => n0(s),
    $forceUpdate: (s) => s.f || (s.f = () => {
      pf(s.update);
    }),
    $nextTick: (s) => s.n || (s.n = Pi.bind(s.proxy)),
    $watch: (s) => M_.bind(s)
  })
), qu = (s, e) => s !== en && !s.__isScriptSetup && Xt(s, e), d_ = {
  get({ _: s }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: n, setupState: i, data: r, props: o, accessCache: a, type: l, appContext: c } = s;
    if (e[0] !== "$") {
      const m = a[e];
      if (m !== void 0)
        switch (m) {
          case 1:
            return i[e];
          case 2:
            return r[e];
          case 4:
            return n[e];
          case 3:
            return o[e];
        }
      else {
        if (qu(i, e))
          return a[e] = 1, i[e];
        if (r !== en && Xt(r, e))
          return a[e] = 2, r[e];
        if (Xt(o, e))
          return a[e] = 3, o[e];
        if (n !== en && Xt(n, e))
          return a[e] = 4, n[e];
        th && (a[e] = 0);
      }
    }
    const u = Na[e];
    let d, h;
    if (u)
      return e === "$attrs" && Yn(s.attrs, "get", ""), u(s);
    if (
      // css module (injected by vue-loader)
      (d = l.__cssModules) && (d = d[e])
    )
      return d;
    if (n !== en && Xt(n, e))
      return a[e] = 4, n[e];
    if (
      // global properties
      h = c.config.globalProperties, Xt(h, e)
    )
      return h[e];
  },
  set({ _: s }, e, n) {
    const { data: i, setupState: r, ctx: o } = s;
    return qu(r, e) ? (r[e] = n, !0) : i !== en && Xt(i, e) ? (i[e] = n, !0) : Xt(s.props, e) || e[0] === "$" && e.slice(1) in s ? !1 : (o[e] = n, !0);
  },
  has({
    _: { data: s, setupState: e, accessCache: n, ctx: i, appContext: r, props: o, type: a }
  }, l) {
    let c;
    return !!(n[l] || s !== en && l[0] !== "$" && Xt(s, l) || qu(e, l) || Xt(o, l) || Xt(i, l) || Xt(Na, l) || Xt(r.config.globalProperties, l) || (c = a.__cssModules) && c[l]);
  },
  defineProperty(s, e, n) {
    return n.get != null ? s._.accessCache[e] = 0 : Xt(n, "value") && this.set(s, e, n.value, null), Reflect.defineProperty(s, e, n);
  }
};
function h_() {
  return f_().slots;
}
function f_(s) {
  const e = bu();
  return e.setupContext || (e.setupContext = b0(e));
}
function Cp(s) {
  return xt(s) ? s.reduce(
    (e, n) => (e[n] = null, e),
    {}
  ) : s;
}
let th = !0;
function p_(s) {
  const e = n0(s), n = s.proxy, i = s.ctx;
  th = !1, e.beforeCreate && Ep(e.beforeCreate, s, "bc");
  const {
    // state
    data: r,
    computed: o,
    methods: a,
    watch: l,
    provide: c,
    inject: u,
    // lifecycle
    created: d,
    beforeMount: h,
    mounted: m,
    beforeUpdate: p,
    updated: v,
    activated: x,
    deactivated: g,
    beforeDestroy: _,
    beforeUnmount: M,
    destroyed: S,
    unmounted: b,
    render: C,
    renderTracked: E,
    renderTriggered: P,
    errorCaptured: T,
    serverPrefetch: y,
    // public API
    expose: w,
    inheritAttrs: D,
    // assets
    components: U,
    directives: R,
    filters: O
  } = e;
  if (u && m_(u, i, null), a)
    for (const ue in a) {
      const Q = a[ue];
      Ct(Q) && (i[ue] = Q.bind(n));
    }
  if (r) {
    const ue = r.call(n, n);
    tn(ue) && (s.data = Gr(ue));
  }
  if (th = !0, o)
    for (const ue in o) {
      const Q = o[ue], le = Ct(Q) ? Q.bind(n, n) : Ct(Q.get) ? Q.get.bind(n, n) : ss, re = !Ct(Q) && Ct(Q.set) ? Q.set.bind(n) : ss, j = Ie({
        get: le,
        set: re
      });
      Object.defineProperty(i, ue, {
        enumerable: !0,
        configurable: !0,
        get: () => j.value,
        set: ($) => j.value = $
      });
    }
  if (l)
    for (const ue in l)
      t0(l[ue], i, n, ue);
  if (c) {
    const ue = Ct(c) ? c.call(n) : c;
    Reflect.ownKeys(ue).forEach((Q) => {
      Ks(Q, ue[Q]);
    });
  }
  d && Ep(d, s, "c");
  function G(ue, Q) {
    xt(Q) ? Q.forEach((le) => ue(le.bind(n))) : Q && ue(Q.bind(n));
  }
  if (G(t_, h), G(_n, m), G(n_, p), G(i_, v), G(J1, x), G(Q1, g), G(a_, T), G(o_, E), G(r_, P), G(vf, M), G(Nn, b), G(s_, y), xt(w))
    if (w.length) {
      const ue = s.exposed || (s.exposed = {});
      w.forEach((Q) => {
        Object.defineProperty(ue, Q, {
          get: () => n[Q],
          set: (le) => n[Q] = le,
          enumerable: !0
        });
      });
    } else s.exposed || (s.exposed = {});
  C && s.render === ss && (s.render = C), D != null && (s.inheritAttrs = D), U && (s.components = U), R && (s.directives = R), y && qg(s);
}
function m_(s, e, n = ss) {
  xt(s) && (s = nh(s));
  for (const i in s) {
    const r = s[i];
    let o;
    tn(r) ? "default" in r ? o = Ni(
      r.from || i,
      r.default,
      !0
    ) : o = Ni(r.from || i) : o = Ni(r), gn(o) ? Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (a) => o.value = a
    }) : e[i] = o;
  }
}
function Ep(s, e, n) {
  os(
    xt(s) ? s.map((i) => i.bind(e.proxy)) : s.bind(e.proxy),
    e,
    n
  );
}
function t0(s, e, n, i) {
  let r = i.includes(".") ? r0(n, i) : () => n[i];
  if (yn(s)) {
    const o = e[s];
    Ct(o) && Ft(r, o);
  } else if (Ct(s))
    Ft(r, s.bind(n));
  else if (tn(s))
    if (xt(s))
      s.forEach((o) => t0(o, e, n, i));
    else {
      const o = Ct(s.handler) ? s.handler.bind(n) : e[s.handler];
      Ct(o) && Ft(r, o, s);
    }
}
function n0(s) {
  const e = s.type, { mixins: n, extends: i } = e, {
    mixins: r,
    optionsCache: o,
    config: { optionMergeStrategies: a }
  } = s.appContext, l = o.get(e);
  let c;
  return l ? c = l : !r.length && !n && !i ? c = e : (c = {}, r.length && r.forEach(
    (u) => jc(c, u, a, !0)
  ), jc(c, e, a)), tn(e) && o.set(e, c), c;
}
function jc(s, e, n, i = !1) {
  const { mixins: r, extends: o } = e;
  o && jc(s, o, n, !0), r && r.forEach(
    (a) => jc(s, a, n, !0)
  );
  for (const a in e)
    if (!(i && a === "expose")) {
      const l = v_[a] || n && n[a];
      s[a] = l ? l(s[a], e[a]) : e[a];
    }
  return s;
}
const v_ = {
  data: Tp,
  props: Ap,
  emits: Ap,
  // objects
  methods: Aa,
  computed: Aa,
  // lifecycle
  beforeCreate: Jn,
  created: Jn,
  beforeMount: Jn,
  mounted: Jn,
  beforeUpdate: Jn,
  updated: Jn,
  beforeDestroy: Jn,
  beforeUnmount: Jn,
  destroyed: Jn,
  unmounted: Jn,
  activated: Jn,
  deactivated: Jn,
  errorCaptured: Jn,
  serverPrefetch: Jn,
  // assets
  components: Aa,
  directives: Aa,
  // watch
  watch: y_,
  // provide / inject
  provide: Tp,
  inject: g_
};
function Tp(s, e) {
  return e ? s ? function() {
    return Zn(
      Ct(s) ? s.call(this, this) : s,
      Ct(e) ? e.call(this, this) : e
    );
  } : e : s;
}
function g_(s, e) {
  return Aa(nh(s), nh(e));
}
function nh(s) {
  if (xt(s)) {
    const e = {};
    for (let n = 0; n < s.length; n++)
      e[s[n]] = s[n];
    return e;
  }
  return s;
}
function Jn(s, e) {
  return s ? [...new Set([].concat(s, e))] : e;
}
function Aa(s, e) {
  return s ? Zn(/* @__PURE__ */ Object.create(null), s, e) : e;
}
function Ap(s, e) {
  return s ? xt(s) && xt(e) ? [.../* @__PURE__ */ new Set([...s, ...e])] : Zn(
    /* @__PURE__ */ Object.create(null),
    Cp(s),
    Cp(e ?? {})
  ) : e;
}
function y_(s, e) {
  if (!s) return e;
  if (!e) return s;
  const n = Zn(/* @__PURE__ */ Object.create(null), s);
  for (const i in e)
    n[i] = Jn(s[i], e[i]);
  return n;
}
function i0() {
  return {
    app: null,
    config: {
      isNativeTag: pg,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let __ = 0;
function x_(s, e) {
  return function(i, r = null) {
    Ct(i) || (i = Zn({}, i)), r != null && !tn(r) && (r = null);
    const o = i0(), a = /* @__PURE__ */ new WeakSet(), l = [];
    let c = !1;
    const u = o.app = {
      _uid: __++,
      _component: i,
      _props: r,
      _container: null,
      _context: o,
      _instance: null,
      version: nx,
      get config() {
        return o.config;
      },
      set config(d) {
      },
      use(d, ...h) {
        return a.has(d) || (d && Ct(d.install) ? (a.add(d), d.install(u, ...h)) : Ct(d) && (a.add(d), d(u, ...h))), u;
      },
      mixin(d) {
        return o.mixins.includes(d) || o.mixins.push(d), u;
      },
      component(d, h) {
        return h ? (o.components[d] = h, u) : o.components[d];
      },
      directive(d, h) {
        return h ? (o.directives[d] = h, u) : o.directives[d];
      },
      mount(d, h, m) {
        if (!c) {
          const p = u._ceVNode || ze(i, r);
          return p.appContext = o, m === !0 ? m = "svg" : m === !1 && (m = void 0), s(p, d, m), c = !0, u._container = d, d.__vue_app__ = u, wu(p.component);
        }
      },
      onUnmount(d) {
        l.push(d);
      },
      unmount() {
        c && (os(
          l,
          u._instance,
          16
        ), s(null, u._container), delete u._container.__vue_app__);
      },
      provide(d, h) {
        return o.provides[d] = h, u;
      },
      runWithContext(d) {
        const h = zr;
        zr = u;
        try {
          return d();
        } finally {
          zr = h;
        }
      }
    };
    return u;
  };
}
let zr = null;
function Ks(s, e) {
  if (qn) {
    let n = qn.provides;
    const i = qn.parent && qn.parent.provides;
    i === n && (n = qn.provides = Object.create(i)), n[s] = e;
  }
}
function Ni(s, e, n = !1) {
  const i = bu();
  if (i || zr) {
    let r = zr ? zr._context.provides : i ? i.parent == null || i.ce ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
    if (r && s in r)
      return r[s];
    if (arguments.length > 1)
      return n && Ct(e) ? e.call(i && i.proxy) : e;
  }
}
function b_() {
  return !!(bu() || zr);
}
const w_ = Symbol.for("v-scx"), S_ = () => Ni(w_);
function Ft(s, e, n) {
  return s0(s, e, n);
}
function s0(s, e, n = en) {
  const { immediate: i, deep: r, flush: o, once: a } = n, l = Zn({}, n), c = e && i || !e && o !== "post";
  let u;
  if (il) {
    if (o === "sync") {
      const p = S_();
      u = p.__watcherHandles || (p.__watcherHandles = []);
    } else if (!c) {
      const p = () => {
      };
      return p.stop = ss, p.resume = ss, p.pause = ss, p;
    }
  }
  const d = qn;
  l.call = (p, v, x) => os(p, d, v, x);
  let h = !1;
  o === "post" ? l.scheduler = (p) => {
    ti(p, d && d.suspense);
  } : o !== "sync" && (h = !0, l.scheduler = (p, v) => {
    v ? p() : pf(p);
  }), l.augmentJob = (p) => {
    e && (p.flags |= 4), h && (p.flags |= 2, d && (p.id = d.uid, p.i = d));
  };
  const m = W1(s, e, l);
  return il && (u ? u.push(m) : c && m()), m;
}
function M_(s, e, n) {
  const i = this.proxy, r = yn(s) ? s.includes(".") ? r0(i, s) : () => i[s] : s.bind(i, i);
  let o;
  Ct(e) ? o = e : (o = e.handler, n = e);
  const a = bl(this), l = s0(r, o.bind(i), n);
  return a(), l;
}
function r0(s, e) {
  const n = e.split(".");
  return () => {
    let i = s;
    for (let r = 0; r < n.length && i; r++)
      i = i[n[r]];
    return i;
  };
}
const C_ = (s, e) => e === "modelValue" || e === "model-value" ? s.modelModifiers : s[`${e}Modifiers`] || s[`${Di(e)}Modifiers`] || s[`${cr(e)}Modifiers`];
function E_(s, e, ...n) {
  if (s.isUnmounted) return;
  const i = s.vnode.props || en;
  let r = n;
  const o = e.startsWith("update:"), a = o && C_(i, e.slice(7));
  a && (a.trim && (r = n.map((d) => yn(d) ? d.trim() : d)), a.number && (r = n.map(fu)));
  let l, c = i[l = $u(e)] || // also try camelCase event handler (#2249)
  i[l = $u(Di(e))];
  !c && o && (c = i[l = $u(cr(e))]), c && os(
    c,
    s,
    6,
    r
  );
  const u = i[l + "Once"];
  if (u) {
    if (!s.emitted)
      s.emitted = {};
    else if (s.emitted[l])
      return;
    s.emitted[l] = !0, os(
      u,
      s,
      6,
      r
    );
  }
}
const T_ = /* @__PURE__ */ new WeakMap();
function o0(s, e, n = !1) {
  const i = n ? T_ : e.emitsCache, r = i.get(s);
  if (r !== void 0)
    return r;
  const o = s.emits;
  let a = {}, l = !1;
  if (!Ct(s)) {
    const c = (u) => {
      const d = o0(u, e, !0);
      d && (l = !0, Zn(a, d));
    };
    !n && e.mixins.length && e.mixins.forEach(c), s.extends && c(s.extends), s.mixins && s.mixins.forEach(c);
  }
  return !o && !l ? (tn(s) && i.set(s, null), null) : (xt(o) ? o.forEach((c) => a[c] = null) : Zn(a, o), tn(s) && i.set(s, a), a);
}
function _u(s, e) {
  return !s || !cu(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Xt(s, e[0].toLowerCase() + e.slice(1)) || Xt(s, cr(e)) || Xt(s, e));
}
function Pp(s) {
  const {
    type: e,
    vnode: n,
    proxy: i,
    withProxy: r,
    propsOptions: [o],
    slots: a,
    attrs: l,
    emit: c,
    render: u,
    renderCache: d,
    props: h,
    data: m,
    setupState: p,
    ctx: v,
    inheritAttrs: x
  } = s, g = Wc(s);
  let _, M;
  try {
    if (n.shapeFlag & 4) {
      const b = r || i, C = b;
      _ = ns(
        u.call(
          C,
          b,
          d,
          h,
          p,
          m,
          v
        )
      ), M = l;
    } else {
      const b = e;
      _ = ns(
        b.length > 1 ? b(
          h,
          { attrs: l, slots: a, emit: c }
        ) : b(
          h,
          null
        )
      ), M = e.props ? l : A_(l);
    }
  } catch (b) {
    Ba.length = 0, gu(b, s, 1), _ = ze(Ls);
  }
  let S = _;
  if (M && x !== !1) {
    const b = Object.keys(M), { shapeFlag: C } = S;
    b.length && C & 7 && (o && b.some(rf) && (M = P_(
      M,
      o
    )), S = Oo(S, M, !1, !0));
  }
  return n.dirs && (S = Oo(S, null, !1, !0), S.dirs = S.dirs ? S.dirs.concat(n.dirs) : n.dirs), n.transition && mf(S, n.transition), _ = S, Wc(g), _;
}
const A_ = (s) => {
  let e;
  for (const n in s)
    (n === "class" || n === "style" || cu(n)) && ((e || (e = {}))[n] = s[n]);
  return e;
}, P_ = (s, e) => {
  const n = {};
  for (const i in s)
    (!rf(i) || !(i.slice(9) in e)) && (n[i] = s[i]);
  return n;
};
function R_(s, e, n) {
  const { props: i, children: r, component: o } = s, { props: a, children: l, patchFlag: c } = e, u = o.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (n && c >= 0) {
    if (c & 1024)
      return !0;
    if (c & 16)
      return i ? Rp(i, a, u) : !!a;
    if (c & 8) {
      const d = e.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        const m = d[h];
        if (a[m] !== i[m] && !_u(u, m))
          return !0;
      }
    }
  } else
    return (r || l) && (!l || !l.$stable) ? !0 : i === a ? !1 : i ? a ? Rp(i, a, u) : !0 : !!a;
  return !1;
}
function Rp(s, e, n) {
  const i = Object.keys(e);
  if (i.length !== Object.keys(s).length)
    return !0;
  for (let r = 0; r < i.length; r++) {
    const o = i[r];
    if (e[o] !== s[o] && !_u(n, o))
      return !0;
  }
  return !1;
}
function D_({ vnode: s, parent: e }, n) {
  for (; e; ) {
    const i = e.subTree;
    if (i.suspense && i.suspense.activeBranch === s && (i.el = s.el), i === s)
      (s = e.vnode).el = n, e = e.parent;
    else
      break;
  }
}
const a0 = {}, l0 = () => Object.create(a0), c0 = (s) => Object.getPrototypeOf(s) === a0;
function k_(s, e, n, i = !1) {
  const r = {}, o = l0();
  s.propsDefaults = /* @__PURE__ */ Object.create(null), u0(s, e, r, o);
  for (const a in s.propsOptions[0])
    a in r || (r[a] = void 0);
  n ? s.props = i ? r : F1(r) : s.type.props ? s.props = r : s.props = o, s.attrs = o;
}
function I_(s, e, n, i) {
  const {
    props: r,
    attrs: o,
    vnode: { patchFlag: a }
  } = s, l = Nt(r), [c] = s.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (i || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const d = s.vnode.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        let m = d[h];
        if (_u(s.emitsOptions, m))
          continue;
        const p = e[m];
        if (c)
          if (Xt(o, m))
            p !== o[m] && (o[m] = p, u = !0);
          else {
            const v = Di(m);
            r[v] = ih(
              c,
              l,
              v,
              p,
              s,
              !1
            );
          }
        else
          p !== o[m] && (o[m] = p, u = !0);
      }
    }
  } else {
    u0(s, e, r, o) && (u = !0);
    let d;
    for (const h in l)
      (!e || // for camelCase
      !Xt(e, h) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((d = cr(h)) === h || !Xt(e, d))) && (c ? n && // for camelCase
      (n[h] !== void 0 || // for kebab-case
      n[d] !== void 0) && (r[h] = ih(
        c,
        l,
        h,
        void 0,
        s,
        !0
      )) : delete r[h]);
    if (o !== l)
      for (const h in o)
        (!e || !Xt(e, h)) && (delete o[h], u = !0);
  }
  u && Ms(s.attrs, "set", "");
}
function u0(s, e, n, i) {
  const [r, o] = s.propsOptions;
  let a = !1, l;
  if (e)
    for (let c in e) {
      if (La(c))
        continue;
      const u = e[c];
      let d;
      r && Xt(r, d = Di(c)) ? !o || !o.includes(d) ? n[d] = u : (l || (l = {}))[d] = u : _u(s.emitsOptions, c) || (!(c in i) || u !== i[c]) && (i[c] = u, a = !0);
    }
  if (o) {
    const c = Nt(n), u = l || en;
    for (let d = 0; d < o.length; d++) {
      const h = o[d];
      n[h] = ih(
        r,
        c,
        h,
        u[h],
        s,
        !Xt(u, h)
      );
    }
  }
  return a;
}
function ih(s, e, n, i, r, o) {
  const a = s[n];
  if (a != null) {
    const l = Xt(a, "default");
    if (l && i === void 0) {
      const c = a.default;
      if (a.type !== Function && !a.skipFactory && Ct(c)) {
        const { propsDefaults: u } = r;
        if (n in u)
          i = u[n];
        else {
          const d = bl(r);
          i = u[n] = c.call(
            null,
            e
          ), d();
        }
      } else
        i = c;
      r.ce && r.ce._setProp(n, i);
    }
    a[
      0
      /* shouldCast */
    ] && (o && !l ? i = !1 : a[
      1
      /* shouldCastTrue */
    ] && (i === "" || i === cr(n)) && (i = !0));
  }
  return i;
}
const L_ = /* @__PURE__ */ new WeakMap();
function d0(s, e, n = !1) {
  const i = n ? L_ : e.propsCache, r = i.get(s);
  if (r)
    return r;
  const o = s.props, a = {}, l = [];
  let c = !1;
  if (!Ct(s)) {
    const d = (h) => {
      c = !0;
      const [m, p] = d0(h, e, !0);
      Zn(a, m), p && l.push(...p);
    };
    !n && e.mixins.length && e.mixins.forEach(d), s.extends && d(s.extends), s.mixins && s.mixins.forEach(d);
  }
  if (!o && !c)
    return tn(s) && i.set(s, Po), Po;
  if (xt(o))
    for (let d = 0; d < o.length; d++) {
      const h = Di(o[d]);
      Dp(h) && (a[h] = en);
    }
  else if (o)
    for (const d in o) {
      const h = Di(d);
      if (Dp(h)) {
        const m = o[d], p = a[h] = xt(m) || Ct(m) ? { type: m } : Zn({}, m), v = p.type;
        let x = !1, g = !0;
        if (xt(v))
          for (let _ = 0; _ < v.length; ++_) {
            const M = v[_], S = Ct(M) && M.name;
            if (S === "Boolean") {
              x = !0;
              break;
            } else S === "String" && (g = !1);
          }
        else
          x = Ct(v) && v.name === "Boolean";
        p[
          0
          /* shouldCast */
        ] = x, p[
          1
          /* shouldCastTrue */
        ] = g, (x || Xt(p, "default")) && l.push(h);
      }
    }
  const u = [a, l];
  return tn(s) && i.set(s, u), u;
}
function Dp(s) {
  return s[0] !== "$" && !La(s);
}
const gf = (s) => s === "_" || s === "_ctx" || s === "$stable", yf = (s) => xt(s) ? s.map(ns) : [ns(s)], F_ = (s, e, n) => {
  if (e._n)
    return e;
  const i = zi((...r) => yf(e(...r)), n);
  return i._c = !1, i;
}, h0 = (s, e, n) => {
  const i = s._ctx;
  for (const r in s) {
    if (gf(r)) continue;
    const o = s[r];
    if (Ct(o))
      e[r] = F_(r, o, i);
    else if (o != null) {
      const a = yf(o);
      e[r] = () => a;
    }
  }
}, f0 = (s, e) => {
  const n = yf(e);
  s.slots.default = () => n;
}, p0 = (s, e, n) => {
  for (const i in e)
    (n || !gf(i)) && (s[i] = e[i]);
}, U_ = (s, e, n) => {
  const i = s.slots = l0();
  if (s.vnode.shapeFlag & 32) {
    const r = e._;
    r ? (p0(i, e, n), n && yg(i, "_", r, !0)) : h0(e, i);
  } else e && f0(s, e);
}, O_ = (s, e, n) => {
  const { vnode: i, slots: r } = s;
  let o = !0, a = en;
  if (i.shapeFlag & 32) {
    const l = e._;
    l ? n && l === 1 ? o = !1 : p0(r, e, n) : (o = !e.$stable, h0(e, r)), a = e;
  } else e && (f0(s, e), a = { default: 1 });
  if (o)
    for (const l in r)
      !gf(l) && a[l] == null && delete r[l];
}, ti = G_;
function z_(s) {
  return N_(s);
}
function N_(s, e) {
  const n = pu();
  n.__VUE__ = !0;
  const {
    insert: i,
    remove: r,
    patchProp: o,
    createElement: a,
    createText: l,
    createComment: c,
    setText: u,
    setElementText: d,
    parentNode: h,
    nextSibling: m,
    setScopeId: p = ss,
    insertStaticContent: v
  } = s, x = (L, ee, Z, k = null, ne = null, J = null, B = void 0, X = null, se = !!ee.dynamicChildren) => {
    if (L === ee)
      return;
    L && !ua(L, ee) && (k = V(L), $(L, ne, J, !0), L = null), ee.patchFlag === -2 && (se = !1, ee.dynamicChildren = null);
    const { type: z, ref: N, shapeFlag: K } = ee;
    switch (z) {
      case xu:
        g(L, ee, Z, k);
        break;
      case Ls:
        _(L, ee, Z, k);
        break;
      case Pc:
        L == null && M(ee, Z, k, B);
        break;
      case qe:
        U(
          L,
          ee,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se
        );
        break;
      default:
        K & 1 ? C(
          L,
          ee,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se
        ) : K & 6 ? R(
          L,
          ee,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se
        ) : (K & 64 || K & 128) && z.process(
          L,
          ee,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se,
          I
        );
    }
    N != null && ne ? za(N, L && L.ref, J, ee || L, !ee) : N == null && L && L.ref != null && za(L.ref, null, J, L, !0);
  }, g = (L, ee, Z, k) => {
    if (L == null)
      i(
        ee.el = l(ee.children),
        Z,
        k
      );
    else {
      const ne = ee.el = L.el;
      ee.children !== L.children && u(ne, ee.children);
    }
  }, _ = (L, ee, Z, k) => {
    L == null ? i(
      ee.el = c(ee.children || ""),
      Z,
      k
    ) : ee.el = L.el;
  }, M = (L, ee, Z, k) => {
    [L.el, L.anchor] = v(
      L.children,
      ee,
      Z,
      k,
      L.el,
      L.anchor
    );
  }, S = ({ el: L, anchor: ee }, Z, k) => {
    let ne;
    for (; L && L !== ee; )
      ne = m(L), i(L, Z, k), L = ne;
    i(ee, Z, k);
  }, b = ({ el: L, anchor: ee }) => {
    let Z;
    for (; L && L !== ee; )
      Z = m(L), r(L), L = Z;
    r(ee);
  }, C = (L, ee, Z, k, ne, J, B, X, se) => {
    if (ee.type === "svg" ? B = "svg" : ee.type === "math" && (B = "mathml"), L == null)
      E(
        ee,
        Z,
        k,
        ne,
        J,
        B,
        X,
        se
      );
    else {
      const z = L.el && L.el._isVueCE ? L.el : null;
      try {
        z && z._beginPatch(), y(
          L,
          ee,
          ne,
          J,
          B,
          X,
          se
        );
      } finally {
        z && z._endPatch();
      }
    }
  }, E = (L, ee, Z, k, ne, J, B, X) => {
    let se, z;
    const { props: N, shapeFlag: K, transition: he, dirs: me } = L;
    if (se = L.el = a(
      L.type,
      J,
      N && N.is,
      N
    ), K & 8 ? d(se, L.children) : K & 16 && T(
      L.children,
      se,
      null,
      k,
      ne,
      Zu(L, J),
      B,
      X
    ), me && hr(L, null, k, "created"), P(se, L, L.scopeId, B, k), N) {
      for (const Me in N)
        Me !== "value" && !La(Me) && o(se, Me, null, N[Me], J, k);
      "value" in N && o(se, "value", null, N.value, J), (z = N.onVnodeBeforeMount) && Zi(z, k, L);
    }
    me && hr(L, null, k, "beforeMount");
    const ge = B_(ne, he);
    ge && he.beforeEnter(se), i(se, ee, Z), ((z = N && N.onVnodeMounted) || ge || me) && ti(() => {
      z && Zi(z, k, L), ge && he.enter(se), me && hr(L, null, k, "mounted");
    }, ne);
  }, P = (L, ee, Z, k, ne) => {
    if (Z && p(L, Z), k)
      for (let J = 0; J < k.length; J++)
        p(L, k[J]);
    if (ne) {
      let J = ne.subTree;
      if (ee === J || v0(J.type) && (J.ssContent === ee || J.ssFallback === ee)) {
        const B = ne.vnode;
        P(
          L,
          B,
          B.scopeId,
          B.slotScopeIds,
          ne.parent
        );
      }
    }
  }, T = (L, ee, Z, k, ne, J, B, X, se = 0) => {
    for (let z = se; z < L.length; z++) {
      const N = L[z] = X ? tr(L[z]) : ns(L[z]);
      x(
        null,
        N,
        ee,
        Z,
        k,
        ne,
        J,
        B,
        X
      );
    }
  }, y = (L, ee, Z, k, ne, J, B) => {
    const X = ee.el = L.el;
    let { patchFlag: se, dynamicChildren: z, dirs: N } = ee;
    se |= L.patchFlag & 16;
    const K = L.props || en, he = ee.props || en;
    let me;
    if (Z && fr(Z, !1), (me = he.onVnodeBeforeUpdate) && Zi(me, Z, ee, L), N && hr(ee, L, Z, "beforeUpdate"), Z && fr(Z, !0), (K.innerHTML && he.innerHTML == null || K.textContent && he.textContent == null) && d(X, ""), z ? w(
      L.dynamicChildren,
      z,
      X,
      Z,
      k,
      Zu(ee, ne),
      J
    ) : B || Q(
      L,
      ee,
      X,
      null,
      Z,
      k,
      Zu(ee, ne),
      J,
      !1
    ), se > 0) {
      if (se & 16)
        D(X, K, he, Z, ne);
      else if (se & 2 && K.class !== he.class && o(X, "class", null, he.class, ne), se & 4 && o(X, "style", K.style, he.style, ne), se & 8) {
        const ge = ee.dynamicProps;
        for (let Me = 0; Me < ge.length; Me++) {
          const Te = ge[Me], Ae = K[Te], Xe = he[Te];
          (Xe !== Ae || Te === "value") && o(X, Te, Ae, Xe, ne, Z);
        }
      }
      se & 1 && L.children !== ee.children && d(X, ee.children);
    } else !B && z == null && D(X, K, he, Z, ne);
    ((me = he.onVnodeUpdated) || N) && ti(() => {
      me && Zi(me, Z, ee, L), N && hr(ee, L, Z, "updated");
    }, k);
  }, w = (L, ee, Z, k, ne, J, B) => {
    for (let X = 0; X < ee.length; X++) {
      const se = L[X], z = ee[X], N = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        se.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (se.type === qe || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !ua(se, z) || // - In the case of a component, it could contain anything.
        se.shapeFlag & 198) ? h(se.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          Z
        )
      );
      x(
        se,
        z,
        N,
        null,
        k,
        ne,
        J,
        B,
        !0
      );
    }
  }, D = (L, ee, Z, k, ne) => {
    if (ee !== Z) {
      if (ee !== en)
        for (const J in ee)
          !La(J) && !(J in Z) && o(
            L,
            J,
            ee[J],
            null,
            ne,
            k
          );
      for (const J in Z) {
        if (La(J)) continue;
        const B = Z[J], X = ee[J];
        B !== X && J !== "value" && o(L, J, X, B, ne, k);
      }
      "value" in Z && o(L, "value", ee.value, Z.value, ne);
    }
  }, U = (L, ee, Z, k, ne, J, B, X, se) => {
    const z = ee.el = L ? L.el : l(""), N = ee.anchor = L ? L.anchor : l("");
    let { patchFlag: K, dynamicChildren: he, slotScopeIds: me } = ee;
    me && (X = X ? X.concat(me) : me), L == null ? (i(z, Z, k), i(N, Z, k), T(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      ee.children || [],
      Z,
      N,
      ne,
      J,
      B,
      X,
      se
    )) : K > 0 && K & 64 && he && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    L.dynamicChildren ? (w(
      L.dynamicChildren,
      he,
      Z,
      ne,
      J,
      B,
      X
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (ee.key != null || ne && ee === ne.subTree) && _f(
      L,
      ee,
      !0
      /* shallow */
    )) : Q(
      L,
      ee,
      Z,
      N,
      ne,
      J,
      B,
      X,
      se
    );
  }, R = (L, ee, Z, k, ne, J, B, X, se) => {
    ee.slotScopeIds = X, L == null ? ee.shapeFlag & 512 ? ne.ctx.activate(
      ee,
      Z,
      k,
      B,
      se
    ) : O(
      ee,
      Z,
      k,
      ne,
      J,
      B,
      se
    ) : A(L, ee, se);
  }, O = (L, ee, Z, k, ne, J, B) => {
    const X = L.component = q_(
      L,
      k,
      ne
    );
    if (Zg(L) && (X.ctx.renderer = I), Z_(X, !1, B), X.asyncDep) {
      if (ne && ne.registerDep(X, G, B), !L.el) {
        const se = X.subTree = ze(Ls);
        _(null, se, ee, Z), L.placeholder = se.el;
      }
    } else
      G(
        X,
        L,
        ee,
        Z,
        ne,
        J,
        B
      );
  }, A = (L, ee, Z) => {
    const k = ee.component = L.component;
    if (R_(L, ee, Z))
      if (k.asyncDep && !k.asyncResolved) {
        ue(k, ee, Z);
        return;
      } else
        k.next = ee, k.update();
    else
      ee.el = L.el, k.vnode = ee;
  }, G = (L, ee, Z, k, ne, J, B) => {
    const X = () => {
      if (L.isMounted) {
        let { next: K, bu: he, u: me, parent: ge, vnode: Me } = L;
        {
          const He = m0(L);
          if (He) {
            K && (K.el = Me.el, ue(L, K, B)), He.asyncDep.then(() => {
              L.isUnmounted || X();
            });
            return;
          }
        }
        let Te = K, Ae;
        fr(L, !1), K ? (K.el = Me.el, ue(L, K, B)) : K = Me, he && Tc(he), (Ae = K.props && K.props.onVnodeBeforeUpdate) && Zi(Ae, ge, K, Me), fr(L, !0);
        const Xe = Pp(L), Oe = L.subTree;
        L.subTree = Xe, x(
          Oe,
          Xe,
          // parent may have changed if it's in a teleport
          h(Oe.el),
          // anchor may have changed if it's in a fragment
          V(Oe),
          L,
          ne,
          J
        ), K.el = Xe.el, Te === null && D_(L, Xe.el), me && ti(me, ne), (Ae = K.props && K.props.onVnodeUpdated) && ti(
          () => Zi(Ae, ge, K, Me),
          ne
        );
      } else {
        let K;
        const { el: he, props: me } = ee, { bm: ge, m: Me, parent: Te, root: Ae, type: Xe } = L, Oe = ko(ee);
        fr(L, !1), ge && Tc(ge), !Oe && (K = me && me.onVnodeBeforeMount) && Zi(K, Te, ee), fr(L, !0);
        {
          Ae.ce && // @ts-expect-error _def is private
          Ae.ce._def.shadowRoot !== !1 && Ae.ce._injectChildStyle(Xe);
          const He = L.subTree = Pp(L);
          x(
            null,
            He,
            Z,
            k,
            L,
            ne,
            J
          ), ee.el = He.el;
        }
        if (Me && ti(Me, ne), !Oe && (K = me && me.onVnodeMounted)) {
          const He = ee;
          ti(
            () => Zi(K, Te, He),
            ne
          );
        }
        (ee.shapeFlag & 256 || Te && ko(Te.vnode) && Te.vnode.shapeFlag & 256) && L.a && ti(L.a, ne), L.isMounted = !0, ee = Z = k = null;
      }
    };
    L.scope.on();
    const se = L.effect = new Cg(X);
    L.scope.off();
    const z = L.update = se.run.bind(se), N = L.job = se.runIfDirty.bind(se);
    N.i = L, N.id = L.uid, se.scheduler = () => pf(N), fr(L, !0), z();
  }, ue = (L, ee, Z) => {
    ee.component = L;
    const k = L.vnode.props;
    L.vnode = ee, L.next = null, I_(L, ee.props, k, Z), O_(L, ee.children, Z), Ds(), _p(L), ks();
  }, Q = (L, ee, Z, k, ne, J, B, X, se = !1) => {
    const z = L && L.children, N = L ? L.shapeFlag : 0, K = ee.children, { patchFlag: he, shapeFlag: me } = ee;
    if (he > 0) {
      if (he & 128) {
        re(
          z,
          K,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se
        );
        return;
      } else if (he & 256) {
        le(
          z,
          K,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se
        );
        return;
      }
    }
    me & 8 ? (N & 16 && ce(z, ne, J), K !== z && d(Z, K)) : N & 16 ? me & 16 ? re(
      z,
      K,
      Z,
      k,
      ne,
      J,
      B,
      X,
      se
    ) : ce(z, ne, J, !0) : (N & 8 && d(Z, ""), me & 16 && T(
      K,
      Z,
      k,
      ne,
      J,
      B,
      X,
      se
    ));
  }, le = (L, ee, Z, k, ne, J, B, X, se) => {
    L = L || Po, ee = ee || Po;
    const z = L.length, N = ee.length, K = Math.min(z, N);
    let he;
    for (he = 0; he < K; he++) {
      const me = ee[he] = se ? tr(ee[he]) : ns(ee[he]);
      x(
        L[he],
        me,
        Z,
        null,
        ne,
        J,
        B,
        X,
        se
      );
    }
    z > N ? ce(
      L,
      ne,
      J,
      !0,
      !1,
      K
    ) : T(
      ee,
      Z,
      k,
      ne,
      J,
      B,
      X,
      se,
      K
    );
  }, re = (L, ee, Z, k, ne, J, B, X, se) => {
    let z = 0;
    const N = ee.length;
    let K = L.length - 1, he = N - 1;
    for (; z <= K && z <= he; ) {
      const me = L[z], ge = ee[z] = se ? tr(ee[z]) : ns(ee[z]);
      if (ua(me, ge))
        x(
          me,
          ge,
          Z,
          null,
          ne,
          J,
          B,
          X,
          se
        );
      else
        break;
      z++;
    }
    for (; z <= K && z <= he; ) {
      const me = L[K], ge = ee[he] = se ? tr(ee[he]) : ns(ee[he]);
      if (ua(me, ge))
        x(
          me,
          ge,
          Z,
          null,
          ne,
          J,
          B,
          X,
          se
        );
      else
        break;
      K--, he--;
    }
    if (z > K) {
      if (z <= he) {
        const me = he + 1, ge = me < N ? ee[me].el : k;
        for (; z <= he; )
          x(
            null,
            ee[z] = se ? tr(ee[z]) : ns(ee[z]),
            Z,
            ge,
            ne,
            J,
            B,
            X,
            se
          ), z++;
      }
    } else if (z > he)
      for (; z <= K; )
        $(L[z], ne, J, !0), z++;
    else {
      const me = z, ge = z, Me = /* @__PURE__ */ new Map();
      for (z = ge; z <= he; z++) {
        const Le = ee[z] = se ? tr(ee[z]) : ns(ee[z]);
        Le.key != null && Me.set(Le.key, z);
      }
      let Te, Ae = 0;
      const Xe = he - ge + 1;
      let Oe = !1, He = 0;
      const Ye = new Array(Xe);
      for (z = 0; z < Xe; z++) Ye[z] = 0;
      for (z = me; z <= K; z++) {
        const Le = L[z];
        if (Ae >= Xe) {
          $(Le, ne, J, !0);
          continue;
        }
        let nt;
        if (Le.key != null)
          nt = Me.get(Le.key);
        else
          for (Te = ge; Te <= he; Te++)
            if (Ye[Te - ge] === 0 && ua(Le, ee[Te])) {
              nt = Te;
              break;
            }
        nt === void 0 ? $(Le, ne, J, !0) : (Ye[nt - ge] = z + 1, nt >= He ? He = nt : Oe = !0, x(
          Le,
          ee[nt],
          Z,
          null,
          ne,
          J,
          B,
          X,
          se
        ), Ae++);
      }
      const $e = Oe ? V_(Ye) : Po;
      for (Te = $e.length - 1, z = Xe - 1; z >= 0; z--) {
        const Le = ge + z, nt = ee[Le], Je = ee[Le + 1], bt = Le + 1 < N ? (
          // #13559, fallback to el placeholder for unresolved async component
          Je.el || Je.placeholder
        ) : k;
        Ye[z] === 0 ? x(
          null,
          nt,
          Z,
          bt,
          ne,
          J,
          B,
          X,
          se
        ) : Oe && (Te < 0 || z !== $e[Te] ? j(nt, Z, bt, 2) : Te--);
      }
    }
  }, j = (L, ee, Z, k, ne = null) => {
    const { el: J, type: B, transition: X, children: se, shapeFlag: z } = L;
    if (z & 6) {
      j(L.component.subTree, ee, Z, k);
      return;
    }
    if (z & 128) {
      L.suspense.move(ee, Z, k);
      return;
    }
    if (z & 64) {
      B.move(L, ee, Z, I);
      return;
    }
    if (B === qe) {
      i(J, ee, Z);
      for (let K = 0; K < se.length; K++)
        j(se[K], ee, Z, k);
      i(L.anchor, ee, Z);
      return;
    }
    if (B === Pc) {
      S(L, ee, Z);
      return;
    }
    if (k !== 2 && z & 1 && X)
      if (k === 0)
        X.beforeEnter(J), i(J, ee, Z), ti(() => X.enter(J), ne);
      else {
        const { leave: K, delayLeave: he, afterLeave: me } = X, ge = () => {
          L.ctx.isUnmounted ? r(J) : i(J, ee, Z);
        }, Me = () => {
          J._isLeaving && J[K1](
            !0
            /* cancelled */
          ), K(J, () => {
            ge(), me && me();
          });
        };
        he ? he(J, ge, Me) : Me();
      }
    else
      i(J, ee, Z);
  }, $ = (L, ee, Z, k = !1, ne = !1) => {
    const {
      type: J,
      props: B,
      ref: X,
      children: se,
      dynamicChildren: z,
      shapeFlag: N,
      patchFlag: K,
      dirs: he,
      cacheIndex: me
    } = L;
    if (K === -2 && (ne = !1), X != null && (Ds(), za(X, null, Z, L, !0), ks()), me != null && (ee.renderCache[me] = void 0), N & 256) {
      ee.ctx.deactivate(L);
      return;
    }
    const ge = N & 1 && he, Me = !ko(L);
    let Te;
    if (Me && (Te = B && B.onVnodeBeforeUnmount) && Zi(Te, ee, L), N & 6)
      ie(L.component, Z, k);
    else {
      if (N & 128) {
        L.suspense.unmount(Z, k);
        return;
      }
      ge && hr(L, null, ee, "beforeUnmount"), N & 64 ? L.type.remove(
        L,
        ee,
        Z,
        I,
        k
      ) : z && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !z.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (J !== qe || K > 0 && K & 64) ? ce(
        z,
        ee,
        Z,
        !1,
        !0
      ) : (J === qe && K & 384 || !ne && N & 16) && ce(se, ee, Z), k && q(L);
    }
    (Me && (Te = B && B.onVnodeUnmounted) || ge) && ti(() => {
      Te && Zi(Te, ee, L), ge && hr(L, null, ee, "unmounted");
    }, Z);
  }, q = (L) => {
    const { type: ee, el: Z, anchor: k, transition: ne } = L;
    if (ee === qe) {
      oe(Z, k);
      return;
    }
    if (ee === Pc) {
      b(L);
      return;
    }
    const J = () => {
      r(Z), ne && !ne.persisted && ne.afterLeave && ne.afterLeave();
    };
    if (L.shapeFlag & 1 && ne && !ne.persisted) {
      const { leave: B, delayLeave: X } = ne, se = () => B(Z, J);
      X ? X(L.el, J, se) : se();
    } else
      J();
  }, oe = (L, ee) => {
    let Z;
    for (; L !== ee; )
      Z = m(L), r(L), L = Z;
    r(ee);
  }, ie = (L, ee, Z) => {
    const { bum: k, scope: ne, job: J, subTree: B, um: X, m: se, a: z } = L;
    kp(se), kp(z), k && Tc(k), ne.stop(), J && (J.flags |= 8, $(B, L, ee, Z)), X && ti(X, ee), ti(() => {
      L.isUnmounted = !0;
    }, ee);
  }, ce = (L, ee, Z, k = !1, ne = !1, J = 0) => {
    for (let B = J; B < L.length; B++)
      $(L[B], ee, Z, k, ne);
  }, V = (L) => {
    if (L.shapeFlag & 6)
      return V(L.component.subTree);
    if (L.shapeFlag & 128)
      return L.suspense.next();
    const ee = m(L.anchor || L.el), Z = ee && ee[Xg];
    return Z ? m(Z) : ee;
  };
  let Y = !1;
  const H = (L, ee, Z) => {
    L == null ? ee._vnode && $(ee._vnode, null, null, !0) : x(
      ee._vnode || null,
      L,
      ee,
      null,
      null,
      null,
      Z
    ), ee._vnode = L, Y || (Y = !0, _p(), Hg(), Y = !1);
  }, I = {
    p: x,
    um: $,
    m: j,
    r: q,
    mt: O,
    mc: T,
    pc: Q,
    pbc: w,
    n: V,
    o: s
  };
  return {
    render: H,
    hydrate: void 0,
    createApp: x_(H)
  };
}
function Zu({ type: s, props: e }, n) {
  return n === "svg" && s === "foreignObject" || n === "mathml" && s === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n;
}
function fr({ effect: s, job: e }, n) {
  n ? (s.flags |= 32, e.flags |= 4) : (s.flags &= -33, e.flags &= -5);
}
function B_(s, e) {
  return (!s || s && !s.pendingBranch) && e && !e.persisted;
}
function _f(s, e, n = !1) {
  const i = s.children, r = e.children;
  if (xt(i) && xt(r))
    for (let o = 0; o < i.length; o++) {
      const a = i[o];
      let l = r[o];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = r[o] = tr(r[o]), l.el = a.el), !n && l.patchFlag !== -2 && _f(a, l)), l.type === xu && // avoid cached text nodes retaining detached dom nodes
      l.patchFlag !== -1 && (l.el = a.el), l.type === Ls && !l.el && (l.el = a.el);
    }
}
function V_(s) {
  const e = s.slice(), n = [0];
  let i, r, o, a, l;
  const c = s.length;
  for (i = 0; i < c; i++) {
    const u = s[i];
    if (u !== 0) {
      if (r = n[n.length - 1], s[r] < u) {
        e[i] = r, n.push(i);
        continue;
      }
      for (o = 0, a = n.length - 1; o < a; )
        l = o + a >> 1, s[n[l]] < u ? o = l + 1 : a = l;
      u < s[n[o]] && (o > 0 && (e[i] = n[o - 1]), n[o] = i);
    }
  }
  for (o = n.length, a = n[o - 1]; o-- > 0; )
    n[o] = a, a = e[a];
  return n;
}
function m0(s) {
  const e = s.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : m0(e);
}
function kp(s) {
  if (s)
    for (let e = 0; e < s.length; e++)
      s[e].flags |= 8;
}
const v0 = (s) => s.__isSuspense;
function G_(s, e) {
  e && e.pendingBranch ? xt(s) ? e.effects.push(...s) : e.effects.push(s) : Y1(s);
}
const qe = Symbol.for("v-fgt"), xu = Symbol.for("v-txt"), Ls = Symbol.for("v-cmt"), Pc = Symbol.for("v-stc"), Ba = [];
let bi = null;
function te(s = !1) {
  Ba.push(bi = s ? null : []);
}
function H_() {
  Ba.pop(), bi = Ba[Ba.length - 1] || null;
}
let tl = 1;
function Yc(s, e = !1) {
  tl += s, s < 0 && bi && e && (bi.hasOnce = !0);
}
function g0(s) {
  return s.dynamicChildren = tl > 0 ? bi || Po : null, H_(), tl > 0 && bi && bi.push(s), s;
}
function ae(s, e, n, i, r, o) {
  return g0(
    f(
      s,
      e,
      n,
      i,
      r,
      o,
      !0
    )
  );
}
function St(s, e, n, i, r) {
  return g0(
    ze(
      s,
      e,
      n,
      i,
      r,
      !0
    )
  );
}
function nl(s) {
  return s ? s.__v_isVNode === !0 : !1;
}
function ua(s, e) {
  return s.type === e.type && s.key === e.key;
}
const y0 = ({ key: s }) => s ?? null, Rc = ({
  ref: s,
  ref_key: e,
  ref_for: n
}) => (typeof s == "number" && (s = "" + s), s != null ? yn(s) || gn(s) || Ct(s) ? { i: Fn, r: s, k: e, f: !!n } : s : null);
function f(s, e = null, n = null, i = 0, r = null, o = s === qe ? 0 : 1, a = !1, l = !1) {
  const c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: s,
    props: e,
    key: e && y0(e),
    ref: e && Rc(e),
    scopeId: Wg,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: i,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
    ctx: Fn
  };
  return l ? (xf(c, n), o & 128 && s.normalize(c)) : n && (c.shapeFlag |= yn(n) ? 8 : 16), tl > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  bi && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (c.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  c.patchFlag !== 32 && bi.push(c), c;
}
const ze = $_;
function $_(s, e = null, n = null, i = 0, r = null, o = !1) {
  if ((!s || s === Jg) && (s = Ls), nl(s)) {
    const l = Oo(
      s,
      e,
      !0
      /* mergeRef: true */
    );
    return n && xf(l, n), tl > 0 && !o && bi && (l.shapeFlag & 6 ? bi[bi.indexOf(s)] = l : bi.push(l)), l.patchFlag = -2, l;
  }
  if (ex(s) && (s = s.__vccOpts), e) {
    e = W_(e);
    let { class: l, style: c } = e;
    l && !yn(l) && (e.class = Fe(l)), tn(c) && (vu(c) && !xt(c) && (c = Zn({}, c)), e.style = yt(c));
  }
  const a = yn(s) ? 1 : v0(s) ? 128 : q1(s) ? 64 : tn(s) ? 4 : Ct(s) ? 2 : 0;
  return f(
    s,
    e,
    n,
    i,
    r,
    a,
    o,
    !0
  );
}
function W_(s) {
  return s ? vu(s) || c0(s) ? Zn({}, s) : s : null;
}
function Oo(s, e, n = !1, i = !1) {
  const { props: r, ref: o, patchFlag: a, children: l, transition: c } = s, u = e ? X_(r || {}, e) : r, d = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: s.type,
    props: u,
    key: u && y0(u),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && o ? xt(o) ? o.concat(Rc(e)) : [o, Rc(e)] : Rc(e)
    ) : o,
    scopeId: s.scopeId,
    slotScopeIds: s.slotScopeIds,
    children: l,
    target: s.target,
    targetStart: s.targetStart,
    targetAnchor: s.targetAnchor,
    staticCount: s.staticCount,
    shapeFlag: s.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && s.type !== qe ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: s.dynamicProps,
    dynamicChildren: s.dynamicChildren,
    appContext: s.appContext,
    dirs: s.dirs,
    transition: c,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: s.component,
    suspense: s.suspense,
    ssContent: s.ssContent && Oo(s.ssContent),
    ssFallback: s.ssFallback && Oo(s.ssFallback),
    placeholder: s.placeholder,
    el: s.el,
    anchor: s.anchor,
    ctx: s.ctx,
    ce: s.ce
  };
  return c && i && mf(
    d,
    c.clone(d)
  ), d;
}
function ct(s = " ", e = 0) {
  return ze(xu, null, s, e);
}
function as(s, e) {
  const n = ze(Pc, null, s);
  return n.staticCount = e, n;
}
function Pe(s = "", e = !1) {
  return e ? (te(), St(Ls, null, s)) : ze(Ls, null, s);
}
function ns(s) {
  return s == null || typeof s == "boolean" ? ze(Ls) : xt(s) ? ze(
    qe,
    null,
    // #3666, avoid reference pollution when reusing vnode
    s.slice()
  ) : nl(s) ? tr(s) : ze(xu, null, String(s));
}
function tr(s) {
  return s.el === null && s.patchFlag !== -1 || s.memo ? s : Oo(s);
}
function xf(s, e) {
  let n = 0;
  const { shapeFlag: i } = s;
  if (e == null)
    e = null;
  else if (xt(e))
    n = 16;
  else if (typeof e == "object")
    if (i & 65) {
      const r = e.default;
      r && (r._c && (r._d = !1), xf(s, r()), r._c && (r._d = !0));
      return;
    } else {
      n = 32;
      const r = e._;
      !r && !c0(e) ? e._ctx = Fn : r === 3 && Fn && (Fn.slots._ === 1 ? e._ = 1 : (e._ = 2, s.patchFlag |= 1024));
    }
  else Ct(e) ? (e = { default: e, _ctx: Fn }, n = 32) : (e = String(e), i & 64 ? (n = 16, e = [ct(e)]) : n = 8);
  s.children = e, s.shapeFlag |= n;
}
function X_(...s) {
  const e = {};
  for (let n = 0; n < s.length; n++) {
    const i = s[n];
    for (const r in i)
      if (r === "class")
        e.class !== i.class && (e.class = Fe([e.class, i.class]));
      else if (r === "style")
        e.style = yt([e.style, i.style]);
      else if (cu(r)) {
        const o = e[r], a = i[r];
        a && o !== a && !(xt(o) && o.includes(a)) && (e[r] = o ? [].concat(o, a) : a);
      } else r !== "" && (e[r] = i[r]);
  }
  return e;
}
function Zi(s, e, n, i = null) {
  os(s, e, 7, [
    n,
    i
  ]);
}
const j_ = i0();
let Y_ = 0;
function q_(s, e, n) {
  const i = s.type, r = (e ? e.appContext : s.appContext) || j_, o = {
    uid: Y_++,
    vnode: s,
    type: i,
    parent: e,
    appContext: r,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new wg(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(r.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: d0(i, r),
    emitsOptions: o0(i, r),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: en,
    // inheritAttrs
    inheritAttrs: i.inheritAttrs,
    // state
    ctx: en,
    data: en,
    props: en,
    attrs: en,
    slots: en,
    refs: en,
    setupState: en,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = E_.bind(null, o), s.ce && s.ce(o), o;
}
let qn = null;
const bu = () => qn || Fn;
let qc, sh;
{
  const s = pu(), e = (n, i) => {
    let r;
    return (r = s[n]) || (r = s[n] = []), r.push(i), (o) => {
      r.length > 1 ? r.forEach((a) => a(o)) : r[0](o);
    };
  };
  qc = e(
    "__VUE_INSTANCE_SETTERS__",
    (n) => qn = n
  ), sh = e(
    "__VUE_SSR_SETTERS__",
    (n) => il = n
  );
}
const bl = (s) => {
  const e = qn;
  return qc(s), s.scope.on(), () => {
    s.scope.off(), qc(e);
  };
}, Ip = () => {
  qn && qn.scope.off(), qc(null);
};
function _0(s) {
  return s.vnode.shapeFlag & 4;
}
let il = !1;
function Z_(s, e = !1, n = !1) {
  e && sh(e);
  const { props: i, children: r } = s.vnode, o = _0(s);
  k_(s, i, o, e), U_(s, r, n || e);
  const a = o ? K_(s, e) : void 0;
  return e && sh(!1), a;
}
function K_(s, e) {
  const n = s.type;
  s.accessCache = /* @__PURE__ */ Object.create(null), s.proxy = new Proxy(s.ctx, d_);
  const { setup: i } = n;
  if (i) {
    Ds();
    const r = s.setupContext = i.length > 1 ? b0(s) : null, o = bl(s), a = xl(
      i,
      s,
      0,
      [
        s.props,
        r
      ]
    ), l = mg(a);
    if (ks(), o(), (l || s.sp) && !ko(s) && qg(s), l) {
      if (a.then(Ip, Ip), e)
        return a.then((c) => {
          Lp(s, c);
        }).catch((c) => {
          gu(c, s, 0);
        });
      s.asyncDep = a;
    } else
      Lp(s, a);
  } else
    x0(s);
}
function Lp(s, e, n) {
  Ct(e) ? s.type.__ssrInlineRender ? s.ssrRender = e : s.render = e : tn(e) && (s.setupState = Bg(e)), x0(s);
}
function x0(s, e, n) {
  const i = s.type;
  s.render || (s.render = i.render || ss);
  {
    const r = bl(s);
    Ds();
    try {
      p_(s);
    } finally {
      ks(), r();
    }
  }
}
const J_ = {
  get(s, e) {
    return Yn(s, "get", ""), s[e];
  }
};
function b0(s) {
  const e = (n) => {
    s.exposed = n || {};
  };
  return {
    attrs: new Proxy(s.attrs, J_),
    slots: s.slots,
    emit: s.emit,
    expose: e
  };
}
function wu(s) {
  return s.exposed ? s.exposeProxy || (s.exposeProxy = new Proxy(Bg(Ss(s.exposed)), {
    get(e, n) {
      if (n in e)
        return e[n];
      if (n in Na)
        return Na[n](s);
    },
    has(e, n) {
      return n in e || n in Na;
    }
  })) : s.proxy;
}
function Q_(s, e = !0) {
  return Ct(s) ? s.displayName || s.name : s.name || e && s.__name;
}
function ex(s) {
  return Ct(s) && "__vccOpts" in s;
}
const Ie = (s, e) => H1(s, e, il);
function tx(s, e, n) {
  try {
    Yc(-1);
    const i = arguments.length;
    return i === 2 ? tn(e) && !xt(e) ? nl(e) ? ze(s, null, [e]) : ze(s, e) : ze(s, null, e) : (i > 3 ? n = Array.prototype.slice.call(arguments, 2) : i === 3 && nl(n) && (n = [n]), ze(s, e, n));
  } finally {
    Yc(1);
  }
}
const nx = "3.5.25";
/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let rh;
const Fp = typeof window < "u" && window.trustedTypes;
if (Fp)
  try {
    rh = /* @__PURE__ */ Fp.createPolicy("vue", {
      createHTML: (s) => s
    });
  } catch {
  }
const w0 = rh ? (s) => rh.createHTML(s) : (s) => s, ix = "http://www.w3.org/2000/svg", sx = "http://www.w3.org/1998/Math/MathML", ws = typeof document < "u" ? document : null, Up = ws && /* @__PURE__ */ ws.createElement("template"), rx = {
  insert: (s, e, n) => {
    e.insertBefore(s, n || null);
  },
  remove: (s) => {
    const e = s.parentNode;
    e && e.removeChild(s);
  },
  createElement: (s, e, n, i) => {
    const r = e === "svg" ? ws.createElementNS(ix, s) : e === "mathml" ? ws.createElementNS(sx, s) : n ? ws.createElement(s, { is: n }) : ws.createElement(s);
    return s === "select" && i && i.multiple != null && r.setAttribute("multiple", i.multiple), r;
  },
  createText: (s) => ws.createTextNode(s),
  createComment: (s) => ws.createComment(s),
  setText: (s, e) => {
    s.nodeValue = e;
  },
  setElementText: (s, e) => {
    s.textContent = e;
  },
  parentNode: (s) => s.parentNode,
  nextSibling: (s) => s.nextSibling,
  querySelector: (s) => ws.querySelector(s),
  setScopeId(s, e) {
    s.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(s, e, n, i, r, o) {
    const a = n ? n.previousSibling : e.lastChild;
    if (r && (r === o || r.nextSibling))
      for (; e.insertBefore(r.cloneNode(!0), n), !(r === o || !(r = r.nextSibling)); )
        ;
    else {
      Up.innerHTML = w0(
        i === "svg" ? `<svg>${s}</svg>` : i === "mathml" ? `<math>${s}</math>` : s
      );
      const l = Up.content;
      if (i === "svg" || i === "mathml") {
        const c = l.firstChild;
        for (; c.firstChild; )
          l.appendChild(c.firstChild);
        l.removeChild(c);
      }
      e.insertBefore(l, n);
    }
    return [
      // first
      a ? a.nextSibling : e.firstChild,
      // last
      n ? n.previousSibling : e.lastChild
    ];
  }
}, ox = Symbol("_vtc");
function ax(s, e, n) {
  const i = s[ox];
  i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? s.removeAttribute("class") : n ? s.setAttribute("class", e) : s.className = e;
}
const Zc = Symbol("_vod"), S0 = Symbol("_vsh"), Bs = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(s, { value: e }, { transition: n }) {
    s[Zc] = s.style.display === "none" ? "" : s.style.display, n && e ? n.beforeEnter(s) : da(s, e);
  },
  mounted(s, { value: e }, { transition: n }) {
    n && e && n.enter(s);
  },
  updated(s, { value: e, oldValue: n }, { transition: i }) {
    !e != !n && (i ? e ? (i.beforeEnter(s), da(s, !0), i.enter(s)) : i.leave(s, () => {
      da(s, !1);
    }) : da(s, e));
  },
  beforeUnmount(s, { value: e }) {
    da(s, e);
  }
};
function da(s, e) {
  s.style.display = e ? s[Zc] : "none", s[S0] = !e;
}
const lx = Symbol(""), cx = /(?:^|;)\s*display\s*:/;
function ux(s, e, n) {
  const i = s.style, r = yn(n);
  let o = !1;
  if (n && !r) {
    if (e)
      if (yn(e))
        for (const a of e.split(";")) {
          const l = a.slice(0, a.indexOf(":")).trim();
          n[l] == null && Dc(i, l, "");
        }
      else
        for (const a in e)
          n[a] == null && Dc(i, a, "");
    for (const a in n)
      a === "display" && (o = !0), Dc(i, a, n[a]);
  } else if (r) {
    if (e !== n) {
      const a = i[lx];
      a && (n += ";" + a), i.cssText = n, o = cx.test(n);
    }
  } else e && s.removeAttribute("style");
  Zc in s && (s[Zc] = o ? i.display : "", s[S0] && (i.display = "none"));
}
const Op = /\s*!important$/;
function Dc(s, e, n) {
  if (xt(n))
    n.forEach((i) => Dc(s, e, i));
  else if (n == null && (n = ""), e.startsWith("--"))
    s.setProperty(e, n);
  else {
    const i = dx(s, e);
    Op.test(n) ? s.setProperty(
      cr(i),
      n.replace(Op, ""),
      "important"
    ) : s[i] = n;
  }
}
const zp = ["Webkit", "Moz", "ms"], Ku = {};
function dx(s, e) {
  const n = Ku[e];
  if (n)
    return n;
  let i = Di(e);
  if (i !== "filter" && i in s)
    return Ku[e] = i;
  i = hu(i);
  for (let r = 0; r < zp.length; r++) {
    const o = zp[r] + i;
    if (o in s)
      return Ku[e] = o;
  }
  return e;
}
const Np = "http://www.w3.org/1999/xlink";
function Bp(s, e, n, i, r, o = f1(e)) {
  i && e.startsWith("xlink:") ? n == null ? s.removeAttributeNS(Np, e.slice(6, e.length)) : s.setAttributeNS(Np, e, n) : n == null || o && !_g(n) ? s.removeAttribute(e) : s.setAttribute(
    e,
    o ? "" : $i(n) ? String(n) : n
  );
}
function Vp(s, e, n, i, r) {
  if (e === "innerHTML" || e === "textContent") {
    n != null && (s[e] = e === "innerHTML" ? w0(n) : n);
    return;
  }
  const o = s.tagName;
  if (e === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const l = o === "OPTION" ? s.getAttribute("value") || "" : s.value, c = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      s.type === "checkbox" ? "on" : ""
    ) : String(n);
    (l !== c || !("_value" in s)) && (s.value = c), n == null && s.removeAttribute(e), s._value = n;
    return;
  }
  let a = !1;
  if (n === "" || n == null) {
    const l = typeof s[e];
    l === "boolean" ? n = _g(n) : n == null && l === "string" ? (n = "", a = !0) : l === "number" && (n = 0, a = !0);
  }
  try {
    s[e] = n;
  } catch {
  }
  a && s.removeAttribute(r || e);
}
function nr(s, e, n, i) {
  s.addEventListener(e, n, i);
}
function hx(s, e, n, i) {
  s.removeEventListener(e, n, i);
}
const Gp = Symbol("_vei");
function fx(s, e, n, i, r = null) {
  const o = s[Gp] || (s[Gp] = {}), a = o[e];
  if (i && a)
    a.value = i;
  else {
    const [l, c] = px(e);
    if (i) {
      const u = o[e] = gx(
        i,
        r
      );
      nr(s, l, u, c);
    } else a && (hx(s, l, a, c), o[e] = void 0);
  }
}
const Hp = /(?:Once|Passive|Capture)$/;
function px(s) {
  let e;
  if (Hp.test(s)) {
    e = {};
    let i;
    for (; i = s.match(Hp); )
      s = s.slice(0, s.length - i[0].length), e[i[0].toLowerCase()] = !0;
  }
  return [s[2] === ":" ? s.slice(3) : cr(s.slice(2)), e];
}
let Ju = 0;
const mx = /* @__PURE__ */ Promise.resolve(), vx = () => Ju || (mx.then(() => Ju = 0), Ju = Date.now());
function gx(s, e) {
  const n = (i) => {
    if (!i._vts)
      i._vts = Date.now();
    else if (i._vts <= n.attached)
      return;
    os(
      yx(i, n.value),
      e,
      5,
      [i]
    );
  };
  return n.value = s, n.attached = vx(), n;
}
function yx(s, e) {
  if (xt(e)) {
    const n = s.stopImmediatePropagation;
    return s.stopImmediatePropagation = () => {
      n.call(s), s._stopped = !0;
    }, e.map(
      (i) => (r) => !r._stopped && i && i(r)
    );
  } else
    return e;
}
const $p = (s) => s.charCodeAt(0) === 111 && s.charCodeAt(1) === 110 && // lowercase letter
s.charCodeAt(2) > 96 && s.charCodeAt(2) < 123, _x = (s, e, n, i, r, o) => {
  const a = r === "svg";
  e === "class" ? ax(s, i, a) : e === "style" ? ux(s, n, i) : cu(e) ? rf(e) || fx(s, e, n, i, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : xx(s, e, i, a)) ? (Vp(s, e, i), !s.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && Bp(s, e, i, a, o, e !== "value")) : /* #11081 force set props for possible async custom element */ s._isVueCE && (/[A-Z]/.test(e) || !yn(i)) ? Vp(s, Di(e), i, o, e) : (e === "true-value" ? s._trueValue = i : e === "false-value" && (s._falseValue = i), Bp(s, e, i, a));
};
function xx(s, e, n, i) {
  if (i)
    return !!(e === "innerHTML" || e === "textContent" || e in s && $p(e) && Ct(n));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && s.tagName === "IFRAME" || e === "form" || e === "list" && s.tagName === "INPUT" || e === "type" && s.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const r = s.tagName;
    if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE")
      return !1;
  }
  return $p(e) && yn(n) ? !1 : e in s;
}
const zo = (s) => {
  const e = s.props["onUpdate:modelValue"] || !1;
  return xt(e) ? (n) => Tc(e, n) : e;
};
function bx(s) {
  s.target.composing = !0;
}
function Wp(s) {
  const e = s.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const As = Symbol("_assign");
function Xp(s, e, n) {
  return e && (s = s.trim()), n && (s = fu(s)), s;
}
const Ut = {
  created(s, { modifiers: { lazy: e, trim: n, number: i } }, r) {
    s[As] = zo(r);
    const o = i || r.props && r.props.type === "number";
    nr(s, e ? "change" : "input", (a) => {
      a.target.composing || s[As](Xp(s.value, n, o));
    }), (n || o) && nr(s, "change", () => {
      s.value = Xp(s.value, n, o);
    }), e || (nr(s, "compositionstart", bx), nr(s, "compositionend", Wp), nr(s, "change", Wp));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(s, { value: e }) {
    s.value = e ?? "";
  },
  beforeUpdate(s, { value: e, oldValue: n, modifiers: { lazy: i, trim: r, number: o } }, a) {
    if (s[As] = zo(a), s.composing) return;
    const l = (o || s.type === "number") && !/^0\d/.test(s.value) ? fu(s.value) : s.value, c = e ?? "";
    l !== c && (document.activeElement === s && s.type !== "range" && (i && e === n || r && s.value.trim() === c) || (s.value = c));
  }
}, xi = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(s, e, n) {
    s[As] = zo(n), nr(s, "change", () => {
      const i = s._modelValue, r = sl(s), o = s.checked, a = s[As];
      if (xt(i)) {
        const l = af(i, r), c = l !== -1;
        if (o && !c)
          a(i.concat(r));
        else if (!o && c) {
          const u = [...i];
          u.splice(l, 1), a(u);
        }
      } else if (Yo(i)) {
        const l = new Set(i);
        o ? l.add(r) : l.delete(r), a(l);
      } else
        a(M0(s, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: jp,
  beforeUpdate(s, e, n) {
    s[As] = zo(n), jp(s, e, n);
  }
};
function jp(s, { value: e, oldValue: n }, i) {
  s._modelValue = e;
  let r;
  if (xt(e))
    r = af(e, i.props.value) > -1;
  else if (Yo(e))
    r = e.has(i.props.value);
  else {
    if (e === n) return;
    r = _l(e, M0(s, !0));
  }
  s.checked !== r && (s.checked = r);
}
const Cn = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(s, { value: e, modifiers: { number: n } }, i) {
    const r = Yo(e);
    nr(s, "change", () => {
      const o = Array.prototype.filter.call(s.options, (a) => a.selected).map(
        (a) => n ? fu(sl(a)) : sl(a)
      );
      s[As](
        s.multiple ? r ? new Set(o) : o : o[0]
      ), s._assigning = !0, Pi(() => {
        s._assigning = !1;
      });
    }), s[As] = zo(i);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(s, { value: e }) {
    Yp(s, e);
  },
  beforeUpdate(s, e, n) {
    s[As] = zo(n);
  },
  updated(s, { value: e }) {
    s._assigning || Yp(s, e);
  }
};
function Yp(s, e) {
  const n = s.multiple, i = xt(e);
  if (!(n && !i && !Yo(e))) {
    for (let r = 0, o = s.options.length; r < o; r++) {
      const a = s.options[r], l = sl(a);
      if (n)
        if (i) {
          const c = typeof l;
          c === "string" || c === "number" ? a.selected = e.some((u) => String(u) === String(l)) : a.selected = af(e, l) > -1;
        } else
          a.selected = e.has(l);
      else if (_l(sl(a), e)) {
        s.selectedIndex !== r && (s.selectedIndex = r);
        return;
      }
    }
    !n && s.selectedIndex !== -1 && (s.selectedIndex = -1);
  }
}
function sl(s) {
  return "_value" in s ? s._value : s.value;
}
function M0(s, e) {
  const n = e ? "_trueValue" : "_falseValue";
  return n in s ? s[n] : e;
}
const wx = ["ctrl", "shift", "alt", "meta"], Sx = {
  stop: (s) => s.stopPropagation(),
  prevent: (s) => s.preventDefault(),
  self: (s) => s.target !== s.currentTarget,
  ctrl: (s) => !s.ctrlKey,
  shift: (s) => !s.shiftKey,
  alt: (s) => !s.altKey,
  meta: (s) => !s.metaKey,
  left: (s) => "button" in s && s.button !== 0,
  middle: (s) => "button" in s && s.button !== 1,
  right: (s) => "button" in s && s.button !== 2,
  exact: (s, e) => wx.some((n) => s[`${n}Key`] && !e.includes(n))
}, _t = (s, e) => {
  const n = s._withMods || (s._withMods = {}), i = e.join(".");
  return n[i] || (n[i] = (r, ...o) => {
    for (let a = 0; a < e.length; a++) {
      const l = Sx[e[a]];
      if (l && l(r, e)) return;
    }
    return s(r, ...o);
  });
}, Mx = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, rl = (s, e) => {
  const n = s._withKeys || (s._withKeys = {}), i = e.join(".");
  return n[i] || (n[i] = (r) => {
    if (!("key" in r))
      return;
    const o = cr(r.key);
    if (e.some(
      (a) => a === o || Mx[a] === o
    ))
      return s(r);
  });
}, Cx = /* @__PURE__ */ Zn({ patchProp: _x }, rx);
let qp;
function Ex() {
  return qp || (qp = z_(Cx));
}
const Tx = (...s) => {
  const e = Ex().createApp(...s), { mount: n } = e;
  return e.mount = (i) => {
    const r = Px(i);
    if (!r) return;
    const o = e._component;
    !Ct(o) && !o.render && !o.template && (o.template = r.innerHTML), r.nodeType === 1 && (r.textContent = "");
    const a = n(r, !1, Ax(r));
    return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), a;
  }, e;
};
function Ax(s) {
  if (s instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && s instanceof MathMLElement)
    return "mathml";
}
function Px(s) {
  return yn(s) ? document.querySelector(s) : s;
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let C0;
const Su = (s) => C0 = s, E0 = (
  /* istanbul ignore next */
  Symbol()
);
function oh(s) {
  return s && typeof s == "object" && Object.prototype.toString.call(s) === "[object Object]" && typeof s.toJSON != "function";
}
var Va;
(function(s) {
  s.direct = "direct", s.patchObject = "patch object", s.patchFunction = "patch function";
})(Va || (Va = {}));
function Rx() {
  const s = Sg(!0), e = s.run(() => we({}));
  let n = [], i = [];
  const r = Ss({
    install(o) {
      Su(r), r._a = o, o.provide(E0, r), o.config.globalProperties.$pinia = r, i.forEach((a) => n.push(a)), i = [];
    },
    use(o) {
      return this._a ? n.push(o) : i.push(o), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: s,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return r;
}
const T0 = () => {
};
function Zp(s, e, n, i = T0) {
  s.push(e);
  const r = () => {
    const o = s.indexOf(e);
    o > -1 && (s.splice(o, 1), i());
  };
  return !n && Mg() && m1(r), r;
}
function Kr(s, ...e) {
  s.slice().forEach((n) => {
    n(...e);
  });
}
const Dx = (s) => s(), Kp = Symbol(), Qu = Symbol();
function ah(s, e) {
  s instanceof Map && e instanceof Map ? e.forEach((n, i) => s.set(i, n)) : s instanceof Set && e instanceof Set && e.forEach(s.add, s);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const i = e[n], r = s[n];
    oh(r) && oh(i) && s.hasOwnProperty(n) && !gn(i) && !Ts(i) ? s[n] = ah(r, i) : s[n] = i;
  }
  return s;
}
const kx = (
  /* istanbul ignore next */
  Symbol()
);
function Ix(s) {
  return !oh(s) || !s.hasOwnProperty(kx);
}
const { assign: Js } = Object;
function Lx(s) {
  return !!(gn(s) && s.effect);
}
function Fx(s, e, n, i) {
  const { state: r, actions: o, getters: a } = e, l = n.state.value[s];
  let c;
  function u() {
    l || (n.state.value[s] = r ? r() : {});
    const d = N1(n.state.value[s]);
    return Js(d, o, Object.keys(a || {}).reduce((h, m) => (h[m] = Ss(Ie(() => {
      Su(n);
      const p = n._s.get(s);
      return a[m].call(p, p);
    })), h), {}));
  }
  return c = A0(s, u, e, n, i, !0), c;
}
function A0(s, e, n = {}, i, r, o) {
  let a;
  const l = Js({ actions: {} }, n), c = { deep: !0 };
  let u, d, h = [], m = [], p;
  const v = i.state.value[s];
  !o && !v && (i.state.value[s] = {}), we({});
  let x;
  function g(T) {
    let y;
    u = d = !1, typeof T == "function" ? (T(i.state.value[s]), y = {
      type: Va.patchFunction,
      storeId: s,
      events: p
    }) : (ah(i.state.value[s], T), y = {
      type: Va.patchObject,
      payload: T,
      storeId: s,
      events: p
    });
    const w = x = Symbol();
    Pi().then(() => {
      x === w && (u = !0);
    }), d = !0, Kr(h, y, i.state.value[s]);
  }
  const _ = o ? function() {
    const { state: y } = n, w = y ? y() : {};
    this.$patch((D) => {
      Js(D, w);
    });
  } : (
    /* istanbul ignore next */
    T0
  );
  function M() {
    a.stop(), h = [], m = [], i._s.delete(s);
  }
  const S = (T, y = "") => {
    if (Kp in T)
      return T[Qu] = y, T;
    const w = function() {
      Su(i);
      const D = Array.from(arguments), U = [], R = [];
      function O(ue) {
        U.push(ue);
      }
      function A(ue) {
        R.push(ue);
      }
      Kr(m, {
        args: D,
        name: w[Qu],
        store: C,
        after: O,
        onError: A
      });
      let G;
      try {
        G = T.apply(this && this.$id === s ? this : C, D);
      } catch (ue) {
        throw Kr(R, ue), ue;
      }
      return G instanceof Promise ? G.then((ue) => (Kr(U, ue), ue)).catch((ue) => (Kr(R, ue), Promise.reject(ue))) : (Kr(U, G), G);
    };
    return w[Kp] = !0, w[Qu] = y, w;
  }, b = {
    _p: i,
    // _s: scope,
    $id: s,
    $onAction: Zp.bind(null, m),
    $patch: g,
    $reset: _,
    $subscribe(T, y = {}) {
      const w = Zp(h, T, y.detached, () => D()), D = a.run(() => Ft(() => i.state.value[s], (U) => {
        (y.flush === "sync" ? d : u) && T({
          storeId: s,
          type: Va.direct,
          events: p
        }, U);
      }, Js({}, c, y)));
      return w;
    },
    $dispose: M
  }, C = Gr(b);
  i._s.set(s, C);
  const P = (i._a && i._a.runWithContext || Dx)(() => i._e.run(() => (a = Sg()).run(() => e({ action: S }))));
  for (const T in P) {
    const y = P[T];
    if (gn(y) && !Lx(y) || Ts(y))
      o || (v && Ix(y) && (gn(y) ? y.value = v[T] : ah(y, v[T])), i.state.value[s][T] = y);
    else if (typeof y == "function") {
      const w = S(y, T);
      P[T] = w, l.actions[T] = y;
    }
  }
  return Js(C, P), Js(Nt(C), P), Object.defineProperty(C, "$state", {
    get: () => i.state.value[s],
    set: (T) => {
      g((y) => {
        Js(y, T);
      });
    }
  }), i._p.forEach((T) => {
    Js(C, a.run(() => T({
      store: C,
      app: i._a,
      pinia: i,
      options: l
    })));
  }), v && o && n.hydrate && n.hydrate(C.$state, v), u = !0, d = !0, C;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Ux(s, e, n) {
  let i, r;
  const o = typeof e == "function";
  i = s, r = o ? n : e;
  function a(l, c) {
    const u = b_();
    return l = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    l || (u ? Ni(E0, null) : null), l && Su(l), l = C0, l._s.has(i) || (o ? A0(i, e, r, l) : Fx(i, r, l)), l._s.get(i);
  }
  return a.$id = i, a;
}
const ed = {
  __name: "splitpanes",
  props: {
    horizontal: { type: Boolean, default: !1 },
    pushOtherPanes: { type: Boolean, default: !0 },
    maximizePanes: { type: Boolean, default: !0 },
    // Maximize pane on splitter double click/tap.
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean, default: !1 }
  },
  emits: [
    "ready",
    "resize",
    "resized",
    "pane-click",
    "pane-maximize",
    "pane-add",
    "pane-remove",
    "splitter-click",
    "splitter-dblclick"
  ],
  setup(s, { emit: e }) {
    const n = e, i = s, r = h_(), o = we([]), a = Ie(() => o.value.reduce((V, Y) => (V[~~Y.id] = Y) && V, {})), l = Ie(() => o.value.length), c = we(null), u = we(!1), d = we({
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null,
      cursorOffset: 0
      // Cursor offset within the splitter.
    }), h = we({
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }), m = Ie(() => ({
      [`splitpanes splitpanes--${i.horizontal ? "horizontal" : "vertical"}`]: !0,
      "splitpanes--dragging": d.value.dragging
    })), p = () => {
      document.addEventListener("mousemove", g, { passive: !1 }), document.addEventListener("mouseup", _), "ontouchstart" in window && (document.addEventListener("touchmove", g, { passive: !1 }), document.addEventListener("touchend", _));
    }, v = () => {
      document.removeEventListener("mousemove", g, { passive: !1 }), document.removeEventListener("mouseup", _), "ontouchstart" in window && (document.removeEventListener("touchmove", g, { passive: !1 }), document.removeEventListener("touchend", _));
    }, x = (V, Y) => {
      const H = V.target.closest(".splitpanes__splitter");
      if (H) {
        const { left: I, top: F } = H.getBoundingClientRect(), { clientX: L, clientY: ee } = "ontouchstart" in window && V.touches ? V.touches[0] : V;
        d.value.cursorOffset = i.horizontal ? ee - F : L - I;
      }
      p(), d.value.mouseDown = !0, d.value.activeSplitter = Y;
    }, g = (V) => {
      d.value.mouseDown && (V.preventDefault(), d.value.dragging = !0, requestAnimationFrame(() => {
        P(C(V)), ie("resize", { event: V }, !0);
      }));
    }, _ = (V) => {
      d.value.dragging && (window.getSelection().removeAllRanges(), ie("resized", { event: V }, !0)), d.value.mouseDown = !1, d.value.activeSplitter = null, setTimeout(() => {
        d.value.dragging = !1, v();
      }, 100);
    }, M = (V, Y) => {
      "ontouchstart" in window && (V.preventDefault(), h.value.splitter === Y ? (clearTimeout(h.value.timeoutId), h.value.timeoutId = null, S(V, Y), h.value.splitter = null) : (h.value.splitter = Y, h.value.timeoutId = setTimeout(() => h.value.splitter = null, 500))), d.value.dragging || ie("splitter-click", { event: V, index: Y }, !0);
    }, S = (V, Y) => {
      if (ie("splitter-dblclick", { event: V, index: Y }, !0), i.maximizePanes) {
        let H = 0;
        o.value = o.value.map((I, F) => (I.size = F === Y ? I.max : I.min, F !== Y && (H += I.min), I)), o.value[Y].size -= H, ie("pane-maximize", { event: V, index: Y, pane: o.value[Y] }), ie("resized", { event: V, index: Y }, !0);
      }
    }, b = (V, Y) => {
      ie("pane-click", {
        event: V,
        index: a.value[Y].index,
        pane: a.value[Y]
      });
    }, C = (V) => {
      const Y = c.value.getBoundingClientRect(), { clientX: H, clientY: I } = "ontouchstart" in window && V.touches ? V.touches[0] : V;
      return {
        x: H - (i.horizontal ? 0 : d.value.cursorOffset) - Y.left,
        y: I - (i.horizontal ? d.value.cursorOffset : 0) - Y.top
      };
    }, E = (V) => {
      V = V[i.horizontal ? "y" : "x"];
      const Y = c.value[i.horizontal ? "clientHeight" : "clientWidth"];
      return i.rtl && !i.horizontal && (V = Y - V), V * 100 / Y;
    }, P = (V) => {
      const Y = d.value.activeSplitter;
      let H = {
        prevPanesSize: y(Y),
        nextPanesSize: w(Y),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const I = 0 + (i.pushOtherPanes ? 0 : H.prevPanesSize), F = 100 - (i.pushOtherPanes ? 0 : H.nextPanesSize), L = Math.max(Math.min(E(V), F), I);
      let ee = [Y, Y + 1], Z = o.value[ee[0]] || null, k = o.value[ee[1]] || null;
      const ne = Z.max < 100 && L >= Z.max + H.prevPanesSize, J = k.max < 100 && L <= 100 - (k.max + w(Y + 1));
      if (ne || J) {
        ne ? (Z.size = Z.max, k.size = Math.max(100 - Z.max - H.prevPanesSize - H.nextPanesSize, 0)) : (Z.size = Math.max(100 - k.max - H.prevPanesSize - w(Y + 1), 0), k.size = k.max);
        return;
      }
      if (i.pushOtherPanes) {
        const B = T(H, L);
        if (!B) return;
        ({ sums: H, panesToResize: ee } = B), Z = o.value[ee[0]] || null, k = o.value[ee[1]] || null;
      }
      Z !== null && (Z.size = Math.min(Math.max(L - H.prevPanesSize - H.prevReachedMinPanes, Z.min), Z.max)), k !== null && (k.size = Math.min(Math.max(100 - L - H.nextPanesSize - H.nextReachedMinPanes, k.min), k.max));
    }, T = (V, Y) => {
      const H = d.value.activeSplitter, I = [H, H + 1];
      return Y < V.prevPanesSize + o.value[I[0]].min && (I[0] = D(H).index, V.prevReachedMinPanes = 0, I[0] < H && o.value.forEach((F, L) => {
        L > I[0] && L <= H && (F.size = F.min, V.prevReachedMinPanes += F.min);
      }), V.prevPanesSize = y(I[0]), I[0] === void 0) ? (V.prevReachedMinPanes = 0, o.value[0].size = o.value[0].min, o.value.forEach((F, L) => {
        L > 0 && L <= H && (F.size = F.min, V.prevReachedMinPanes += F.min);
      }), o.value[I[1]].size = 100 - V.prevReachedMinPanes - o.value[0].min - V.prevPanesSize - V.nextPanesSize, null) : Y > 100 - V.nextPanesSize - o.value[I[1]].min && (I[1] = U(H).index, V.nextReachedMinPanes = 0, I[1] > H + 1 && o.value.forEach((F, L) => {
        L > H && L < I[1] && (F.size = F.min, V.nextReachedMinPanes += F.min);
      }), V.nextPanesSize = w(I[1] - 1), I[1] === void 0) ? (V.nextReachedMinPanes = 0, o.value.forEach((F, L) => {
        L < l.value - 1 && L >= H + 1 && (F.size = F.min, V.nextReachedMinPanes += F.min);
      }), o.value[I[0]].size = 100 - V.prevPanesSize - w(I[0] - 1), null) : { sums: V, panesToResize: I };
    }, y = (V) => o.value.reduce((Y, H, I) => Y + (I < V ? H.size : 0), 0), w = (V) => o.value.reduce((Y, H, I) => Y + (I > V + 1 ? H.size : 0), 0), D = (V) => [...o.value].reverse().find((Y) => Y.index < V && Y.size > Y.min) || {}, U = (V) => o.value.find((Y) => Y.index > V + 1 && Y.size > Y.min) || {}, R = () => {
      var V;
      const Y = Array.from(((V = c.value) == null ? void 0 : V.children) || []);
      for (const H of Y) {
        const I = H.classList.contains("splitpanes__pane"), F = H.classList.contains("splitpanes__splitter");
        !I && !F && (H.remove(), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      }
    }, O = (V, Y, H = !1) => {
      const I = V - 1, F = document.createElement("div");
      F.classList.add("splitpanes__splitter"), H || (F.onmousedown = (L) => x(L, I), typeof window < "u" && "ontouchstart" in window && (F.ontouchstart = (L) => x(L, I)), F.onclick = (L) => M(L, I + 1)), F.ondblclick = (L) => S(L, I + 1), Y.parentNode.insertBefore(F, Y);
    }, A = (V) => {
      V.onmousedown = void 0, V.onclick = void 0, V.ondblclick = void 0, V.remove();
    }, G = () => {
      var V;
      const Y = Array.from(((V = c.value) == null ? void 0 : V.children) || []);
      for (const I of Y)
        I.className.includes("splitpanes__splitter") && A(I);
      let H = 0;
      for (const I of Y)
        I.className.includes("splitpanes__pane") && (!H && i.firstSplitter ? O(H, I, !0) : H && O(H, I), H++);
    }, ue = ({ uid: V, ...Y }) => {
      const H = a.value[V];
      for (const [I, F] of Object.entries(Y)) H[I] = F;
    }, Q = (V) => {
      var Y;
      let H = -1;
      Array.from(((Y = c.value) == null ? void 0 : Y.children) || []).some((I) => (I.className.includes("splitpanes__pane") && H++, I.isSameNode(V.el))), o.value.splice(H, 0, { ...V, index: H }), o.value.forEach((I, F) => I.index = F), u.value && Pi(() => {
        G(), re({ addedPane: o.value[H] }), ie("pane-add", { pane: o.value[H] });
      });
    }, le = (V) => {
      const Y = o.value.findIndex((I) => I.id === V);
      o.value[Y].el = null;
      const H = o.value.splice(Y, 1)[0];
      o.value.forEach((I, F) => I.index = F), Pi(() => {
        G(), ie("pane-remove", { pane: H }), re({ removedPane: { ...H } });
      });
    }, re = (V = {}) => {
      !V.addedPane && !V.removedPane ? $() : o.value.some((Y) => Y.givenSize !== null || Y.min || Y.max < 100) ? q(V) : j(), u.value && ie("resized");
    }, j = () => {
      const V = 100 / l.value;
      let Y = 0;
      const H = [], I = [];
      for (const F of o.value)
        F.size = Math.max(Math.min(V, F.max), F.min), Y -= F.size, F.size >= F.max && H.push(F.id), F.size <= F.min && I.push(F.id);
      Y > 0.1 && oe(Y, H, I);
    }, $ = () => {
      let V = 100;
      const Y = [], H = [];
      let I = 0;
      for (const L of o.value)
        V -= L.size, L.givenSize !== null && I++, L.size >= L.max && Y.push(L.id), L.size <= L.min && H.push(L.id);
      let F = 100;
      if (V > 0.1) {
        for (const L of o.value)
          L.givenSize === null && (L.size = Math.max(Math.min(V / (l.value - I), L.max), L.min)), F -= L.size;
        F > 0.1 && oe(F, Y, H);
      }
    }, q = ({ addedPane: V, removedPane: Y } = {}) => {
      let H = 100 / l.value, I = 0;
      const F = [], L = [];
      ((V == null ? void 0 : V.givenSize) ?? null) !== null && (H = (100 - V.givenSize) / (l.value - 1));
      for (const ee of o.value)
        I -= ee.size, ee.size >= ee.max && F.push(ee.id), ee.size <= ee.min && L.push(ee.id);
      if (!(Math.abs(I) < 0.1)) {
        for (const ee of o.value)
          (V == null ? void 0 : V.givenSize) !== null && (V == null ? void 0 : V.id) === ee.id || (ee.size = Math.max(Math.min(H, ee.max), ee.min)), I -= ee.size, ee.size >= ee.max && F.push(ee.id), ee.size <= ee.min && L.push(ee.id);
        I > 0.1 && oe(I, F, L);
      }
    }, oe = (V, Y, H) => {
      let I;
      V > 0 ? I = V / (l.value - Y.length) : I = V / (l.value - H.length), o.value.forEach((F, L) => {
        if (V > 0 && !Y.includes(F.id)) {
          const ee = Math.max(Math.min(F.size + I, F.max), F.min), Z = ee - F.size;
          V -= Z, F.size = ee;
        } else if (!H.includes(F.id)) {
          const ee = Math.max(Math.min(F.size + I, F.max), F.min), Z = ee - F.size;
          V -= Z, F.size = ee;
        }
      }), Math.abs(V) > 0.1 && Pi(() => {
        u.value && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }, ie = (V, Y = void 0, H = !1) => {
      const I = (Y == null ? void 0 : Y.index) ?? d.value.activeSplitter ?? null;
      n(V, {
        ...Y,
        ...I !== null && { index: I },
        ...H && I !== null && {
          prevPane: o.value[I - (i.firstSplitter ? 1 : 0)],
          nextPane: o.value[I + (i.firstSplitter ? 0 : 1)]
        },
        panes: o.value.map((F) => ({ min: F.min, max: F.max, size: F.size }))
      });
    };
    Ft(() => i.firstSplitter, () => G()), _n(() => {
      R(), G(), re(), ie("ready"), u.value = !0;
    }), vf(() => u.value = !1);
    const ce = () => {
      var V;
      return tx(
        "div",
        { ref: c, class: m.value },
        (V = r.default) == null ? void 0 : V.call(r)
      );
    };
    return Ks("panes", o), Ks("indexedPanes", a), Ks("horizontal", Ie(() => i.horizontal)), Ks("requestUpdate", ue), Ks("onPaneAdd", Q), Ks("onPaneRemove", le), Ks("onPaneClick", b), (V, Y) => (te(), St(Qg(ce)));
  }
}, pr = {
  __name: "pane",
  props: {
    size: { type: [Number, String] },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  setup(s) {
    var e;
    const n = s, i = Ni("requestUpdate"), r = Ni("onPaneAdd"), o = Ni("horizontal"), a = Ni("onPaneRemove"), l = Ni("onPaneClick"), c = (e = bu()) == null ? void 0 : e.uid, u = Ni("indexedPanes"), d = Ie(() => u.value[c]), h = we(null), m = Ie(() => {
      const g = isNaN(n.size) || n.size === void 0 ? 0 : parseFloat(n.size);
      return Math.max(Math.min(g, v.value), p.value);
    }), p = Ie(() => {
      const g = parseFloat(n.minSize);
      return isNaN(g) ? 0 : g;
    }), v = Ie(() => {
      const g = parseFloat(n.maxSize);
      return isNaN(g) ? 100 : g;
    }), x = Ie(() => {
      var g;
      return `${o.value ? "height" : "width"}: ${(g = d.value) == null ? void 0 : g.size}%`;
    });
    return Ft(() => m.value, (g) => i({ uid: c, size: g })), Ft(() => p.value, (g) => i({ uid: c, min: g })), Ft(() => v.value, (g) => i({ uid: c, max: g })), _n(() => {
      r({
        id: c,
        el: h.value,
        min: p.value,
        max: v.value,
        // The given size (useful to know the user intention).
        givenSize: n.size === void 0 ? null : m.value,
        size: m.value
        // The computed current size at any time.
      });
    }), vf(() => a(c)), (g, _) => (te(), ae("div", {
      ref_key: "paneEl",
      ref: h,
      class: "splitpanes__pane",
      onClick: _[0] || (_[0] = (M) => Ve(l)(M, g._.uid)),
      style: yt(x.value)
    }, [
      u_(g.$slots, "default")
    ], 4));
  }
}, Jp = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  none: 4
}, Kc = {
  level: "warn",
  prefix: "[Weyl]"
};
function ds(s) {
  return Jp[s] >= Jp[Kc.level];
}
function Jr(s, e, n) {
  const i = [];
  return i.push(Kc.prefix), e && i.push(`[${e}]`), i.push(n), i.join(" ");
}
function qo(s) {
  return {
    debug(e, ...n) {
      ds("debug") && console.log(Jr("DEBUG", s, e), ...n);
    },
    info(e, ...n) {
      ds("info") && console.info(Jr("INFO", s, e), ...n);
    },
    warn(e, ...n) {
      ds("warn") && console.warn(Jr("WARN", s, e), ...n);
    },
    error(e, ...n) {
      ds("error") && console.error(Jr("ERROR", s, e), ...n);
    },
    /**
     * Log with a specific level
     */
    log(e, n, ...i) {
      switch (e) {
        case "debug":
          this.debug(n, ...i);
          break;
        case "info":
          this.info(n, ...i);
          break;
        case "warn":
          this.warn(n, ...i);
          break;
        case "error":
          this.error(n, ...i);
          break;
      }
    },
    /**
     * Group related logs (collapsible in console)
     */
    group(e) {
      ds("debug") && console.group(Jr("", s, e));
    },
    groupEnd() {
      ds("debug") && console.groupEnd();
    },
    /**
     * Log a table (useful for arrays/objects)
     */
    table(e) {
      ds("debug") && (console.log(Jr("", s, "Table:")), console.table(e));
    },
    /**
     * Measure time for an operation
     */
    time(e) {
      ds("debug") && console.time(`${Kc.prefix} [${s}] ${e}`);
    },
    timeEnd(e) {
      ds("debug") && console.timeEnd(`${Kc.prefix} [${s}] ${e}`);
    }
  };
}
const Jt = qo("Store"), ts = qo("Engine"), Ti = qo("Layer"), ol = qo("Render");
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const bf = "170", Ox = 0, Qp = 1, zx = 2, P0 = 1, R0 = 2, xs = 3, or = 0, hi = 1, vn = 2, rs = 0, Gi = 1, al = 2, lh = 3, Io = 4, Rr = 5, Bi = 100, D0 = 101, Nx = 102, k0 = 103, I0 = 104, Bx = 200, bs = 201, Vx = 202, ch = 203, Jc = 204, ll = 205, Gx = 206, Hx = 207, $x = 208, L0 = 209, Wx = 210, Xx = 211, jx = 212, Yx = 213, qx = 214, uh = 0, dh = 1, hh = 2, No = 3, fh = 4, ph = 5, mh = 6, vh = 7, F0 = 0, Zx = 1, Kx = 2, rr = 0, U0 = 1, O0 = 2, z0 = 3, wf = 4, Jx = 5, N0 = 6, B0 = 7, V0 = 300, Bo = 301, Vo = 302, gh = 303, yh = 304, Mu = 306, _h = 1e3, Fr = 1001, xh = 1002, On = 1003, Qx = 1004, zl = 1005, Bt = 1006, td = 1007, Ur = 1008, Xi = 1009, G0 = 1010, H0 = 1011, cl = 1012, Sf = 1013, Hr = 1014, di = 1015, ur = 1016, Mf = 1017, Cf = 1018, Go = 1020, $0 = 35902, W0 = 1021, X0 = 1022, Un = 1023, j0 = 1024, Y0 = 1025, Nr = 1026, Ho = 1027, Qc = 1028, Ef = 1029, q0 = 1030, Tf = 1031, Af = 1033, kc = 33776, Ic = 33777, Lc = 33778, Fc = 33779, bh = 35840, wh = 35841, Sh = 35842, Mh = 35843, Ch = 36196, Eh = 37492, Th = 37496, Ah = 37808, Ph = 37809, Rh = 37810, Dh = 37811, kh = 37812, Ih = 37813, Lh = 37814, Fh = 37815, Uh = 37816, Oh = 37817, zh = 37818, Nh = 37819, Bh = 37820, Vh = 37821, Uc = 36492, Gh = 36494, Hh = 36495, Z0 = 36283, $h = 36284, Wh = 36285, Xh = 36286, eb = 3200, Pf = 3201, Rf = 0, tb = 1, ir = "", dn = "srgb", Zo = "srgb-linear", Cu = "linear", qt = "srgb", Qr = 7680, em = 519, nb = 512, ib = 513, sb = 514, K0 = 515, rb = 516, ob = 517, ab = 518, lb = 519, tm = 35044, eo = 35048, nm = "300 es", Es = 2e3, eu = 2001;
class Wr {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(n) === -1 && i[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const o = r.indexOf(n);
      o !== -1 && r.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let o = 0, a = r.length; o < a; o++)
        r[o].call(this, e);
      e.target = null;
    }
  }
}
const Hn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let im = 1234567;
const Ga = Math.PI / 180, $o = 180 / Math.PI;
function Xr() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Hn[s & 255] + Hn[s >> 8 & 255] + Hn[s >> 16 & 255] + Hn[s >> 24 & 255] + "-" + Hn[e & 255] + Hn[e >> 8 & 255] + "-" + Hn[e >> 16 & 15 | 64] + Hn[e >> 24 & 255] + "-" + Hn[n & 63 | 128] + Hn[n >> 8 & 255] + "-" + Hn[n >> 16 & 255] + Hn[n >> 24 & 255] + Hn[i & 255] + Hn[i >> 8 & 255] + Hn[i >> 16 & 255] + Hn[i >> 24 & 255]).toLowerCase();
}
function Ln(s, e, n) {
  return Math.max(e, Math.min(n, s));
}
function Df(s, e) {
  return (s % e + e) % e;
}
function cb(s, e, n, i, r) {
  return i + (s - e) * (r - i) / (n - e);
}
function ub(s, e, n) {
  return s !== e ? (n - s) / (e - s) : 0;
}
function Ha(s, e, n) {
  return (1 - n) * s + n * e;
}
function db(s, e, n, i) {
  return Ha(s, e, 1 - Math.exp(-n * i));
}
function hb(s, e = 1) {
  return e - Math.abs(Df(s, e * 2) - e);
}
function fb(s, e, n) {
  return s <= e ? 0 : s >= n ? 1 : (s = (s - e) / (n - e), s * s * (3 - 2 * s));
}
function pb(s, e, n) {
  return s <= e ? 0 : s >= n ? 1 : (s = (s - e) / (n - e), s * s * s * (s * (s * 6 - 15) + 10));
}
function mb(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function vb(s, e) {
  return s + Math.random() * (e - s);
}
function gb(s) {
  return s * (0.5 - Math.random());
}
function yb(s) {
  s !== void 0 && (im = s);
  let e = im += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function _b(s) {
  return s * Ga;
}
function xb(s) {
  return s * $o;
}
function bb(s) {
  return (s & s - 1) === 0 && s !== 0;
}
function wb(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function Sb(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function Mb(s, e, n, i, r) {
  const o = Math.cos, a = Math.sin, l = o(n / 2), c = a(n / 2), u = o((e + i) / 2), d = a((e + i) / 2), h = o((e - i) / 2), m = a((e - i) / 2), p = o((i - e) / 2), v = a((i - e) / 2);
  switch (r) {
    case "XYX":
      s.set(l * d, c * h, c * m, l * u);
      break;
    case "YZY":
      s.set(c * m, l * d, c * h, l * u);
      break;
    case "ZXZ":
      s.set(c * h, c * m, l * d, l * u);
      break;
    case "XZX":
      s.set(l * d, c * v, c * p, l * u);
      break;
    case "YXY":
      s.set(c * p, l * d, c * v, l * u);
      break;
    case "ZYZ":
      s.set(c * v, c * p, l * d, l * u);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function bo(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Qn(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const mn = {
  DEG2RAD: Ga,
  RAD2DEG: $o,
  generateUUID: Xr,
  clamp: Ln,
  euclideanModulo: Df,
  mapLinear: cb,
  inverseLerp: ub,
  lerp: Ha,
  damp: db,
  pingpong: hb,
  smoothstep: fb,
  smootherstep: pb,
  randInt: mb,
  randFloat: vb,
  randFloatSpread: gb,
  seededRandom: yb,
  degToRad: _b,
  radToDeg: xb,
  isPowerOfTwo: bb,
  ceilPowerOfTwo: wb,
  floorPowerOfTwo: Sb,
  setQuaternionFromProperEuler: Mb,
  normalize: Qn,
  denormalize: bo
};
class rt {
  constructor(e = 0, n = 0) {
    rt.prototype.isVector2 = !0, this.x = e, this.y = n;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, r = e.elements;
    return this.x = r[0] * n + r[3] * i + r[6], this.y = r[1] * n + r[4] * i + r[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Ln(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y;
    return n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this;
  }
  rotateAround(e, n) {
    const i = Math.cos(n), r = Math.sin(n), o = this.x - e.x, a = this.y - e.y;
    return this.x = o * i - a * r + e.x, this.y = o * r + a * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Et {
  constructor(e, n, i, r, o, a, l, c, u) {
    Et.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, r, o, a, l, c, u);
  }
  set(e, n, i, r, o, a, l, c, u) {
    const d = this.elements;
    return d[0] = e, d[1] = r, d[2] = l, d[3] = n, d[4] = o, d[5] = c, d[6] = i, d[7] = a, d[8] = u, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[4],
      n[8],
      n[1],
      n[5],
      n[9],
      n[2],
      n[6],
      n[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, r = n.elements, o = this.elements, a = i[0], l = i[3], c = i[6], u = i[1], d = i[4], h = i[7], m = i[2], p = i[5], v = i[8], x = r[0], g = r[3], _ = r[6], M = r[1], S = r[4], b = r[7], C = r[2], E = r[5], P = r[8];
    return o[0] = a * x + l * M + c * C, o[3] = a * g + l * S + c * E, o[6] = a * _ + l * b + c * P, o[1] = u * x + d * M + h * C, o[4] = u * g + d * S + h * E, o[7] = u * _ + d * b + h * P, o[2] = m * x + p * M + v * C, o[5] = m * g + p * S + v * E, o[8] = m * _ + p * b + v * P, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[1], r = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], d = e[8];
    return n * a * d - n * l * u - i * o * d + i * l * c + r * o * u - r * a * c;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], r = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], d = e[8], h = d * a - l * u, m = l * c - d * o, p = u * o - a * c, v = n * h + i * m + r * p;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / v;
    return e[0] = h * x, e[1] = (r * u - d * i) * x, e[2] = (l * i - r * a) * x, e[3] = m * x, e[4] = (d * n - r * c) * x, e[5] = (r * o - l * n) * x, e[6] = p * x, e[7] = (i * c - u * n) * x, e[8] = (a * n - i * o) * x, this;
  }
  transpose() {
    let e;
    const n = this.elements;
    return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this;
  }
  setUvTransform(e, n, i, r, o, a, l) {
    const c = Math.cos(o), u = Math.sin(o);
    return this.set(
      i * c,
      i * u,
      -i * (c * a + u * l) + a + e,
      -r * u,
      r * c,
      -r * (-u * a + c * l) + l + n,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, n) {
    return this.premultiply(nd.makeScale(e, n)), this;
  }
  rotate(e) {
    return this.premultiply(nd.makeRotation(-e)), this;
  }
  translate(e, n) {
    return this.premultiply(nd.makeTranslation(e, n)), this;
  }
  // for 2D Transforms
  makeTranslation(e, n) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      n,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      i,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n) {
    return this.set(
      e,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let r = 0; r < 9; r++)
      if (n[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const nd = /* @__PURE__ */ new Et();
function J0(s) {
  for (let e = s.length - 1; e >= 0; --e)
    if (s[e] >= 65535) return !0;
  return !1;
}
function ul(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function Cb() {
  const s = ul("canvas");
  return s.style.display = "block", s;
}
const sm = {};
function Pa(s) {
  s in sm || (sm[s] = !0, console.warn(s));
}
function Eb(s, e, n) {
  return new Promise(function(i, r) {
    function o() {
      switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case s.WAIT_FAILED:
          r();
          break;
        case s.TIMEOUT_EXPIRED:
          setTimeout(o, n);
          break;
        default:
          i();
      }
    }
    setTimeout(o, n);
  });
}
function Tb(s) {
  const e = s.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function Ab(s) {
  const e = s.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const It = {
  enabled: !0,
  workingColorSpace: Zo,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(s, e, n) {
    return this.enabled === !1 || e === n || !e || !n || (this.spaces[e].transfer === qt && (s.r = Ps(s.r), s.g = Ps(s.g), s.b = Ps(s.b)), this.spaces[e].primaries !== this.spaces[n].primaries && (s.applyMatrix3(this.spaces[e].toXYZ), s.applyMatrix3(this.spaces[n].fromXYZ)), this.spaces[n].transfer === qt && (s.r = Lo(s.r), s.g = Lo(s.g), s.b = Lo(s.b))), s;
  },
  fromWorkingColorSpace: function(s, e) {
    return this.convert(s, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(s, e) {
    return this.convert(s, e, this.workingColorSpace);
  },
  getPrimaries: function(s) {
    return this.spaces[s].primaries;
  },
  getTransfer: function(s) {
    return s === ir ? Cu : this.spaces[s].transfer;
  },
  getLuminanceCoefficients: function(s, e = this.workingColorSpace) {
    return s.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(s) {
    Object.assign(this.spaces, s);
  },
  // Internal APIs
  _getMatrix: function(s, e, n) {
    return s.copy(this.spaces[e].toXYZ).multiply(this.spaces[n].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(s) {
    return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(s = this.workingColorSpace) {
    return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
  }
};
function Ps(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function Lo(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
const rm = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], om = [0.2126, 0.7152, 0.0722], am = [0.3127, 0.329], lm = /* @__PURE__ */ new Et().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), cm = /* @__PURE__ */ new Et().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
It.define({
  [Zo]: {
    primaries: rm,
    whitePoint: am,
    transfer: Cu,
    toXYZ: lm,
    fromXYZ: cm,
    luminanceCoefficients: om,
    workingColorSpaceConfig: { unpackColorSpace: dn },
    outputColorSpaceConfig: { drawingBufferColorSpace: dn }
  },
  [dn]: {
    primaries: rm,
    whitePoint: am,
    transfer: qt,
    toXYZ: lm,
    fromXYZ: cm,
    luminanceCoefficients: om,
    outputColorSpaceConfig: { drawingBufferColorSpace: dn }
  }
});
let to;
class Pb {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let n;
    if (e instanceof HTMLCanvasElement)
      n = e;
    else {
      to === void 0 && (to = ul("canvas")), to.width = e.width, to.height = e.height;
      const i = to.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), n = to;
    }
    return n.width > 2048 || n.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), n.toDataURL("image/jpeg", 0.6)) : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const n = ul("canvas");
      n.width = e.width, n.height = e.height;
      const i = n.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height), o = r.data;
      for (let a = 0; a < o.length; a++)
        o[a] = Ps(o[a] / 255) * 255;
      return i.putImageData(r, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let i = 0; i < n.length; i++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[i] = Math.floor(Ps(n[i] / 255) * 255) : n[i] = Ps(n[i]);
      return {
        data: n,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let Rb = 0;
class Q0 {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: Rb++ }), this.uuid = Xr(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, r = this.data;
    if (r !== null) {
      let o;
      if (Array.isArray(r)) {
        o = [];
        for (let a = 0, l = r.length; a < l; a++)
          r[a].isDataTexture ? o.push(id(r[a].image)) : o.push(id(r[a]));
      } else
        o = id(r);
      i.url = o;
    }
    return n || (e.images[this.uuid] = i), i;
  }
}
function id(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? Pb.getDataURL(s) : s.data ? {
    data: Array.from(s.data),
    width: s.width,
    height: s.height,
    type: s.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Db = 0;
class xn extends Wr {
  constructor(e = xn.DEFAULT_IMAGE, n = xn.DEFAULT_MAPPING, i = Fr, r = Fr, o = Bt, a = Ur, l = Un, c = Xi, u = xn.DEFAULT_ANISOTROPY, d = ir) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Db++ }), this.uuid = Xr(), this.name = "", this.source = new Q0(e), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = o, this.minFilter = a, this.anisotropy = u, this.format = l, this.internalFormat = null, this.type = c, this.offset = new rt(0, 0), this.repeat = new rt(1, 1), this.center = new rt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Et(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = d, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), n || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== V0) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case _h:
          e.x = e.x - Math.floor(e.x);
          break;
        case Fr:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case xh:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case _h:
          e.y = e.y - Math.floor(e.y);
          break;
        case Fr:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case xh:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
xn.DEFAULT_IMAGE = null;
xn.DEFAULT_MAPPING = V0;
xn.DEFAULT_ANISOTROPY = 1;
class jt {
  constructor(e = 0, n = 0, i = 0, r = 1) {
    jt.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = i, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, i, r) {
    return this.x = e, this.y = n, this.z = i, this.w = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, r = this.z, o = this.w, a = e.elements;
    return this.x = a[0] * n + a[4] * i + a[8] * r + a[12] * o, this.y = a[1] * n + a[5] * i + a[9] * r + a[13] * o, this.z = a[2] * n + a[6] * i + a[10] * r + a[14] * o, this.w = a[3] * n + a[7] * i + a[11] * r + a[15] * o, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, i, r, o;
    const c = e.elements, u = c[0], d = c[4], h = c[8], m = c[1], p = c[5], v = c[9], x = c[2], g = c[6], _ = c[10];
    if (Math.abs(d - m) < 0.01 && Math.abs(h - x) < 0.01 && Math.abs(v - g) < 0.01) {
      if (Math.abs(d + m) < 0.1 && Math.abs(h + x) < 0.1 && Math.abs(v + g) < 0.1 && Math.abs(u + p + _ - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const S = (u + 1) / 2, b = (p + 1) / 2, C = (_ + 1) / 2, E = (d + m) / 4, P = (h + x) / 4, T = (v + g) / 4;
      return S > b && S > C ? S < 0.01 ? (i = 0, r = 0.707106781, o = 0.707106781) : (i = Math.sqrt(S), r = E / i, o = P / i) : b > C ? b < 0.01 ? (i = 0.707106781, r = 0, o = 0.707106781) : (r = Math.sqrt(b), i = E / r, o = T / r) : C < 0.01 ? (i = 0.707106781, r = 0.707106781, o = 0) : (o = Math.sqrt(C), i = P / o, r = T / o), this.set(i, r, o, n), this;
    }
    let M = Math.sqrt((g - v) * (g - v) + (h - x) * (h - x) + (m - d) * (m - d));
    return Math.abs(M) < 1e-3 && (M = 1), this.x = (g - v) / M, this.y = (h - x) / M, this.z = (m - d) / M, this.w = Math.acos((u + p + _ - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this.w = n[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this.w = e.w + (n.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class kb extends Wr {
  constructor(e = 1, n = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = n, this.depth = 1, this.scissor = new jt(0, 0, e, n), this.scissorTest = !1, this.viewport = new jt(0, 0, e, n);
    const r = { width: e, height: n, depth: 1 };
    i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Bt,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, i);
    const o = new xn(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    o.flipY = !1, o.generateMipmaps = i.generateMipmaps, o.internalFormat = i.internalFormat, this.textures = [];
    const a = i.count;
    for (let l = 0; l < a; l++)
      this.textures[l] = o.clone(), this.textures[l].isRenderTargetTexture = !0;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, n, i = 1) {
    if (this.width !== e || this.height !== n || this.depth !== i) {
      this.width = e, this.height = n, this.depth = i;
      for (let r = 0, o = this.textures.length; r < o; r++)
        this.textures[r].image.width = e, this.textures[r].image.height = n, this.textures[r].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let i = 0, r = e.textures.length; i < r; i++)
      this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
    const n = Object.assign({}, e.texture.image);
    return this.texture.source = new Q0(n), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Ri extends kb {
  constructor(e = 1, n = 1, i = {}) {
    super(e, n, i), this.isWebGLRenderTarget = !0;
  }
}
class ey extends xn {
  constructor(e = null, n = 1, i = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: n, height: i, depth: r }, this.magFilter = On, this.minFilter = On, this.wrapR = Fr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Ib extends xn {
  constructor(e = null, n = 1, i = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: n, height: i, depth: r }, this.magFilter = On, this.minFilter = On, this.wrapR = Fr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class ni {
  constructor(e = 0, n = 0, i = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = n, this._z = i, this._w = r;
  }
  static slerpFlat(e, n, i, r, o, a, l) {
    let c = i[r + 0], u = i[r + 1], d = i[r + 2], h = i[r + 3];
    const m = o[a + 0], p = o[a + 1], v = o[a + 2], x = o[a + 3];
    if (l === 0) {
      e[n + 0] = c, e[n + 1] = u, e[n + 2] = d, e[n + 3] = h;
      return;
    }
    if (l === 1) {
      e[n + 0] = m, e[n + 1] = p, e[n + 2] = v, e[n + 3] = x;
      return;
    }
    if (h !== x || c !== m || u !== p || d !== v) {
      let g = 1 - l;
      const _ = c * m + u * p + d * v + h * x, M = _ >= 0 ? 1 : -1, S = 1 - _ * _;
      if (S > Number.EPSILON) {
        const C = Math.sqrt(S), E = Math.atan2(C, _ * M);
        g = Math.sin(g * E) / C, l = Math.sin(l * E) / C;
      }
      const b = l * M;
      if (c = c * g + m * b, u = u * g + p * b, d = d * g + v * b, h = h * g + x * b, g === 1 - l) {
        const C = 1 / Math.sqrt(c * c + u * u + d * d + h * h);
        c *= C, u *= C, d *= C, h *= C;
      }
    }
    e[n] = c, e[n + 1] = u, e[n + 2] = d, e[n + 3] = h;
  }
  static multiplyQuaternionsFlat(e, n, i, r, o, a) {
    const l = i[r], c = i[r + 1], u = i[r + 2], d = i[r + 3], h = o[a], m = o[a + 1], p = o[a + 2], v = o[a + 3];
    return e[n] = l * v + d * h + c * p - u * m, e[n + 1] = c * v + d * m + u * h - l * p, e[n + 2] = u * v + d * p + l * m - c * h, e[n + 3] = d * v - l * h - c * m - u * p, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, n, i, r) {
    return this._x = e, this._y = n, this._z = i, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, n = !0) {
    const i = e._x, r = e._y, o = e._z, a = e._order, l = Math.cos, c = Math.sin, u = l(i / 2), d = l(r / 2), h = l(o / 2), m = c(i / 2), p = c(r / 2), v = c(o / 2);
    switch (a) {
      case "XYZ":
        this._x = m * d * h + u * p * v, this._y = u * p * h - m * d * v, this._z = u * d * v + m * p * h, this._w = u * d * h - m * p * v;
        break;
      case "YXZ":
        this._x = m * d * h + u * p * v, this._y = u * p * h - m * d * v, this._z = u * d * v - m * p * h, this._w = u * d * h + m * p * v;
        break;
      case "ZXY":
        this._x = m * d * h - u * p * v, this._y = u * p * h + m * d * v, this._z = u * d * v + m * p * h, this._w = u * d * h - m * p * v;
        break;
      case "ZYX":
        this._x = m * d * h - u * p * v, this._y = u * p * h + m * d * v, this._z = u * d * v - m * p * h, this._w = u * d * h + m * p * v;
        break;
      case "YZX":
        this._x = m * d * h + u * p * v, this._y = u * p * h + m * d * v, this._z = u * d * v - m * p * h, this._w = u * d * h - m * p * v;
        break;
      case "XZY":
        this._x = m * d * h - u * p * v, this._y = u * p * h - m * d * v, this._z = u * d * v + m * p * h, this._w = u * d * h + m * p * v;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const i = n / 2, r = Math.sin(i);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const n = e.elements, i = n[0], r = n[4], o = n[8], a = n[1], l = n[5], c = n[9], u = n[2], d = n[6], h = n[10], m = i + l + h;
    if (m > 0) {
      const p = 0.5 / Math.sqrt(m + 1);
      this._w = 0.25 / p, this._x = (d - c) * p, this._y = (o - u) * p, this._z = (a - r) * p;
    } else if (i > l && i > h) {
      const p = 2 * Math.sqrt(1 + i - l - h);
      this._w = (d - c) / p, this._x = 0.25 * p, this._y = (r + a) / p, this._z = (o + u) / p;
    } else if (l > h) {
      const p = 2 * Math.sqrt(1 + l - i - h);
      this._w = (o - u) / p, this._x = (r + a) / p, this._y = 0.25 * p, this._z = (c + d) / p;
    } else {
      const p = 2 * Math.sqrt(1 + h - i - l);
      this._w = (a - r) / p, this._x = (o + u) / p, this._y = (c + d) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let i = e.dot(n) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Ln(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, n / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const i = e._x, r = e._y, o = e._z, a = e._w, l = n._x, c = n._y, u = n._z, d = n._w;
    return this._x = i * d + a * l + r * u - o * c, this._y = r * d + a * c + o * l - i * u, this._z = o * d + a * u + i * c - r * l, this._w = a * d - i * l - r * c - o * u, this._onChangeCallback(), this;
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const i = this._x, r = this._y, o = this._z, a = this._w;
    let l = a * e._w + i * e._x + r * e._y + o * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = a, this._x = i, this._y = r, this._z = o, this;
    const c = 1 - l * l;
    if (c <= Number.EPSILON) {
      const p = 1 - n;
      return this._w = p * a + n * this._w, this._x = p * i + n * this._x, this._y = p * r + n * this._y, this._z = p * o + n * this._z, this.normalize(), this;
    }
    const u = Math.sqrt(c), d = Math.atan2(u, l), h = Math.sin((1 - n) * d) / u, m = Math.sin(n * d) / u;
    return this._w = a * h + this._w * m, this._x = i * h + this._x * m, this._y = r * h + this._y * m, this._z = o * h + this._z * m, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, n, i) {
    return this.copy(e).slerp(n, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(), i = Math.random(), r = Math.sqrt(1 - i), o = Math.sqrt(i);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      o * Math.sin(n),
      o * Math.cos(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, n = 0) {
    return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e;
  }
  fromBufferAttribute(e, n) {
    return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class de {
  constructor(e = 0, n = 0, i = 0) {
    de.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = i;
  }
  set(e, n, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = n, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, n) {
    return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(um.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(um.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, r = this.z, o = e.elements;
    return this.x = o[0] * n + o[3] * i + o[6] * r, this.y = o[1] * n + o[4] * i + o[7] * r, this.z = o[2] * n + o[5] * i + o[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, r = this.z, o = e.elements, a = 1 / (o[3] * n + o[7] * i + o[11] * r + o[15]);
    return this.x = (o[0] * n + o[4] * i + o[8] * r + o[12]) * a, this.y = (o[1] * n + o[5] * i + o[9] * r + o[13]) * a, this.z = (o[2] * n + o[6] * i + o[10] * r + o[14]) * a, this;
  }
  applyQuaternion(e) {
    const n = this.x, i = this.y, r = this.z, o = e.x, a = e.y, l = e.z, c = e.w, u = 2 * (a * r - l * i), d = 2 * (l * n - o * r), h = 2 * (o * i - a * n);
    return this.x = n + c * u + a * h - l * d, this.y = i + c * d + l * u - o * h, this.z = r + c * h + o * d - a * u, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const n = this.x, i = this.y, r = this.z, o = e.elements;
    return this.x = o[0] * n + o[4] * i + o[8] * r, this.y = o[1] * n + o[5] * i + o[9] * r, this.z = o[2] * n + o[6] * i + o[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const i = e.x, r = e.y, o = e.z, a = n.x, l = n.y, c = n.z;
    return this.x = r * c - o * l, this.y = o * a - i * c, this.z = i * l - r * a, this;
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / n;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return sd.copy(this).projectOnVector(e), this.sub(sd);
  }
  reflect(e) {
    return this.sub(sd.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Ln(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y, r = this.z - e.z;
    return n * n + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, i) {
    const r = Math.sin(n) * e;
    return this.x = r * Math.sin(i), this.y = Math.cos(n) * e, this.z = r * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, i) {
    return this.x = e * Math.sin(n), this.y = i, this.z = e * Math.cos(n), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = n, this.y = i, this.z = r, this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, n = Math.random() * 2 - 1, i = Math.sqrt(1 - n * n);
    return this.x = i * Math.cos(e), this.y = n, this.z = i * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const sd = /* @__PURE__ */ new de(), um = /* @__PURE__ */ new ni();
class dr {
  constructor(e = new de(1 / 0, 1 / 0, 1 / 0), n = new de(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = n;
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n += 3)
      this.expandByPoint(Fi.fromArray(e, n));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, i = e.count; n < i; n++)
      this.expandByPoint(Fi.fromBufferAttribute(e, n));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const i = Fi.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const o = i.getAttribute("position");
      if (n === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, l = o.count; a < l; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, Fi) : Fi.fromBufferAttribute(o, a), Fi.applyMatrix4(e.matrixWorld), this.expandByPoint(Fi);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Nl.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Nl.copy(i.boundingBox)), Nl.applyMatrix4(e.matrixWorld), this.union(Nl);
    }
    const r = e.children;
    for (let o = 0, a = r.length; o < a; o++)
      this.expandByObject(r[o], n);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Fi), Fi.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let n, i;
    return e.normal.x > 0 ? (n = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, i += e.normal.z * this.min.z), n <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(ha), Bl.subVectors(this.max, ha), no.subVectors(e.a, ha), io.subVectors(e.b, ha), so.subVectors(e.c, ha), Vs.subVectors(io, no), Gs.subVectors(so, io), mr.subVectors(no, so);
    let n = [
      0,
      -Vs.z,
      Vs.y,
      0,
      -Gs.z,
      Gs.y,
      0,
      -mr.z,
      mr.y,
      Vs.z,
      0,
      -Vs.x,
      Gs.z,
      0,
      -Gs.x,
      mr.z,
      0,
      -mr.x,
      -Vs.y,
      Vs.x,
      0,
      -Gs.y,
      Gs.x,
      0,
      -mr.y,
      mr.x,
      0
    ];
    return !rd(n, no, io, so, Bl) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !rd(n, no, io, so, Bl)) ? !1 : (Vl.crossVectors(Vs, Gs), n = [Vl.x, Vl.y, Vl.z], rd(n, no, io, so, Bl));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Fi).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Fi).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (hs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), hs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), hs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), hs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), hs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), hs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), hs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), hs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(hs), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const hs = [
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de()
], Fi = /* @__PURE__ */ new de(), Nl = /* @__PURE__ */ new dr(), no = /* @__PURE__ */ new de(), io = /* @__PURE__ */ new de(), so = /* @__PURE__ */ new de(), Vs = /* @__PURE__ */ new de(), Gs = /* @__PURE__ */ new de(), mr = /* @__PURE__ */ new de(), ha = /* @__PURE__ */ new de(), Bl = /* @__PURE__ */ new de(), Vl = /* @__PURE__ */ new de(), vr = /* @__PURE__ */ new de();
function rd(s, e, n, i, r) {
  for (let o = 0, a = s.length - 3; o <= a; o += 3) {
    vr.fromArray(s, o);
    const l = r.x * Math.abs(vr.x) + r.y * Math.abs(vr.y) + r.z * Math.abs(vr.z), c = e.dot(vr), u = n.dot(vr), d = i.dot(vr);
    if (Math.max(-Math.max(c, u, d), Math.min(c, u, d)) > l)
      return !1;
  }
  return !0;
}
const Lb = /* @__PURE__ */ new dr(), fa = /* @__PURE__ */ new de(), od = /* @__PURE__ */ new de();
class wl {
  constructor(e = new de(), n = -1) {
    this.isSphere = !0, this.center = e, this.radius = n;
  }
  set(e, n) {
    return this.center.copy(e), this.radius = n, this;
  }
  setFromPoints(e, n) {
    const i = this.center;
    n !== void 0 ? i.copy(n) : Lb.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let o = 0, a = e.length; o < a; o++)
      r = Math.max(r, i.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const i = this.center.distanceToSquared(e);
    return n.copy(e), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    fa.subVectors(e, this.center);
    const n = fa.lengthSq();
    if (n > this.radius * this.radius) {
      const i = Math.sqrt(n), r = (i - this.radius) * 0.5;
      this.center.addScaledVector(fa, r / i), this.radius += r;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (od.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(fa.copy(e.center).add(od)), this.expandByPoint(fa.copy(e.center).sub(od))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const fs = /* @__PURE__ */ new de(), ad = /* @__PURE__ */ new de(), Gl = /* @__PURE__ */ new de(), Hs = /* @__PURE__ */ new de(), ld = /* @__PURE__ */ new de(), Hl = /* @__PURE__ */ new de(), cd = /* @__PURE__ */ new de();
class kf {
  constructor(e = new de(), n = new de(0, 0, -1)) {
    this.origin = e, this.direction = n;
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, fs)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const i = n.dot(this.direction);
    return i < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = fs.subVectors(e, this.origin).dot(this.direction);
    return n < 0 ? this.origin.distanceToSquared(e) : (fs.copy(this.origin).addScaledVector(this.direction, n), fs.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, i, r) {
    ad.copy(e).add(n).multiplyScalar(0.5), Gl.copy(n).sub(e).normalize(), Hs.copy(this.origin).sub(ad);
    const o = e.distanceTo(n) * 0.5, a = -this.direction.dot(Gl), l = Hs.dot(this.direction), c = -Hs.dot(Gl), u = Hs.lengthSq(), d = Math.abs(1 - a * a);
    let h, m, p, v;
    if (d > 0)
      if (h = a * c - l, m = a * l - c, v = o * d, h >= 0)
        if (m >= -v)
          if (m <= v) {
            const x = 1 / d;
            h *= x, m *= x, p = h * (h + a * m + 2 * l) + m * (a * h + m + 2 * c) + u;
          } else
            m = o, h = Math.max(0, -(a * m + l)), p = -h * h + m * (m + 2 * c) + u;
        else
          m = -o, h = Math.max(0, -(a * m + l)), p = -h * h + m * (m + 2 * c) + u;
      else
        m <= -v ? (h = Math.max(0, -(-a * o + l)), m = h > 0 ? -o : Math.min(Math.max(-o, -c), o), p = -h * h + m * (m + 2 * c) + u) : m <= v ? (h = 0, m = Math.min(Math.max(-o, -c), o), p = m * (m + 2 * c) + u) : (h = Math.max(0, -(a * o + l)), m = h > 0 ? o : Math.min(Math.max(-o, -c), o), p = -h * h + m * (m + 2 * c) + u);
    else
      m = a > 0 ? -o : o, h = Math.max(0, -(a * m + l)), p = -h * h + m * (m + 2 * c) + u;
    return i && i.copy(this.origin).addScaledVector(this.direction, h), r && r.copy(ad).addScaledVector(Gl, m), p;
  }
  intersectSphere(e, n) {
    fs.subVectors(e.center, this.origin);
    const i = fs.dot(this.direction), r = fs.dot(fs) - i * i, o = e.radius * e.radius;
    if (r > o) return null;
    const a = Math.sqrt(o - r), l = i - a, c = i + a;
    return c < 0 ? null : l < 0 ? this.at(c, n) : this.at(l, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / n;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, n) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let i, r, o, a, l, c;
    const u = 1 / this.direction.x, d = 1 / this.direction.y, h = 1 / this.direction.z, m = this.origin;
    return u >= 0 ? (i = (e.min.x - m.x) * u, r = (e.max.x - m.x) * u) : (i = (e.max.x - m.x) * u, r = (e.min.x - m.x) * u), d >= 0 ? (o = (e.min.y - m.y) * d, a = (e.max.y - m.y) * d) : (o = (e.max.y - m.y) * d, a = (e.min.y - m.y) * d), i > a || o > r || ((o > i || isNaN(i)) && (i = o), (a < r || isNaN(r)) && (r = a), h >= 0 ? (l = (e.min.z - m.z) * h, c = (e.max.z - m.z) * h) : (l = (e.max.z - m.z) * h, c = (e.min.z - m.z) * h), i > c || l > r) || ((l > i || i !== i) && (i = l), (c < r || r !== r) && (r = c), r < 0) ? null : this.at(i >= 0 ? i : r, n);
  }
  intersectsBox(e) {
    return this.intersectBox(e, fs) !== null;
  }
  intersectTriangle(e, n, i, r, o) {
    ld.subVectors(n, e), Hl.subVectors(i, e), cd.crossVectors(ld, Hl);
    let a = this.direction.dot(cd), l;
    if (a > 0) {
      if (r) return null;
      l = 1;
    } else if (a < 0)
      l = -1, a = -a;
    else
      return null;
    Hs.subVectors(this.origin, e);
    const c = l * this.direction.dot(Hl.crossVectors(Hs, Hl));
    if (c < 0)
      return null;
    const u = l * this.direction.dot(ld.cross(Hs));
    if (u < 0 || c + u > a)
      return null;
    const d = -l * Hs.dot(cd);
    return d < 0 ? null : this.at(d / a, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Zt {
  constructor(e, n, i, r, o, a, l, c, u, d, h, m, p, v, x, g) {
    Zt.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, r, o, a, l, c, u, d, h, m, p, v, x, g);
  }
  set(e, n, i, r, o, a, l, c, u, d, h, m, p, v, x, g) {
    const _ = this.elements;
    return _[0] = e, _[4] = n, _[8] = i, _[12] = r, _[1] = o, _[5] = a, _[9] = l, _[13] = c, _[2] = u, _[6] = d, _[10] = h, _[14] = m, _[3] = p, _[7] = v, _[11] = x, _[15] = g, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Zt().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], n[9] = i[9], n[10] = i[10], n[11] = i[11], n[12] = i[12], n[13] = i[13], n[14] = i[14], n[15] = i[15], this;
  }
  copyPosition(e) {
    const n = this.elements, i = e.elements;
    return n[12] = i[12], n[13] = i[13], n[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[3],
      n[6],
      0,
      n[1],
      n[4],
      n[7],
      0,
      n[2],
      n[5],
      n[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, n, i) {
    return this.set(
      e.x,
      n.x,
      i.x,
      0,
      e.y,
      n.y,
      i.y,
      0,
      e.z,
      n.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const n = this.elements, i = e.elements, r = 1 / ro.setFromMatrixColumn(e, 0).length(), o = 1 / ro.setFromMatrixColumn(e, 1).length(), a = 1 / ro.setFromMatrixColumn(e, 2).length();
    return n[0] = i[0] * r, n[1] = i[1] * r, n[2] = i[2] * r, n[3] = 0, n[4] = i[4] * o, n[5] = i[5] * o, n[6] = i[6] * o, n[7] = 0, n[8] = i[8] * a, n[9] = i[9] * a, n[10] = i[10] * a, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const n = this.elements, i = e.x, r = e.y, o = e.z, a = Math.cos(i), l = Math.sin(i), c = Math.cos(r), u = Math.sin(r), d = Math.cos(o), h = Math.sin(o);
    if (e.order === "XYZ") {
      const m = a * d, p = a * h, v = l * d, x = l * h;
      n[0] = c * d, n[4] = -c * h, n[8] = u, n[1] = p + v * u, n[5] = m - x * u, n[9] = -l * c, n[2] = x - m * u, n[6] = v + p * u, n[10] = a * c;
    } else if (e.order === "YXZ") {
      const m = c * d, p = c * h, v = u * d, x = u * h;
      n[0] = m + x * l, n[4] = v * l - p, n[8] = a * u, n[1] = a * h, n[5] = a * d, n[9] = -l, n[2] = p * l - v, n[6] = x + m * l, n[10] = a * c;
    } else if (e.order === "ZXY") {
      const m = c * d, p = c * h, v = u * d, x = u * h;
      n[0] = m - x * l, n[4] = -a * h, n[8] = v + p * l, n[1] = p + v * l, n[5] = a * d, n[9] = x - m * l, n[2] = -a * u, n[6] = l, n[10] = a * c;
    } else if (e.order === "ZYX") {
      const m = a * d, p = a * h, v = l * d, x = l * h;
      n[0] = c * d, n[4] = v * u - p, n[8] = m * u + x, n[1] = c * h, n[5] = x * u + m, n[9] = p * u - v, n[2] = -u, n[6] = l * c, n[10] = a * c;
    } else if (e.order === "YZX") {
      const m = a * c, p = a * u, v = l * c, x = l * u;
      n[0] = c * d, n[4] = x - m * h, n[8] = v * h + p, n[1] = h, n[5] = a * d, n[9] = -l * d, n[2] = -u * d, n[6] = p * h + v, n[10] = m - x * h;
    } else if (e.order === "XZY") {
      const m = a * c, p = a * u, v = l * c, x = l * u;
      n[0] = c * d, n[4] = -h, n[8] = u * d, n[1] = m * h + x, n[5] = a * d, n[9] = p * h - v, n[2] = v * h - p, n[6] = l * d, n[10] = x * h + m;
    }
    return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Fb, e, Ub);
  }
  lookAt(e, n, i) {
    const r = this.elements;
    return yi.subVectors(e, n), yi.lengthSq() === 0 && (yi.z = 1), yi.normalize(), $s.crossVectors(i, yi), $s.lengthSq() === 0 && (Math.abs(i.z) === 1 ? yi.x += 1e-4 : yi.z += 1e-4, yi.normalize(), $s.crossVectors(i, yi)), $s.normalize(), $l.crossVectors(yi, $s), r[0] = $s.x, r[4] = $l.x, r[8] = yi.x, r[1] = $s.y, r[5] = $l.y, r[9] = yi.y, r[2] = $s.z, r[6] = $l.z, r[10] = yi.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, r = n.elements, o = this.elements, a = i[0], l = i[4], c = i[8], u = i[12], d = i[1], h = i[5], m = i[9], p = i[13], v = i[2], x = i[6], g = i[10], _ = i[14], M = i[3], S = i[7], b = i[11], C = i[15], E = r[0], P = r[4], T = r[8], y = r[12], w = r[1], D = r[5], U = r[9], R = r[13], O = r[2], A = r[6], G = r[10], ue = r[14], Q = r[3], le = r[7], re = r[11], j = r[15];
    return o[0] = a * E + l * w + c * O + u * Q, o[4] = a * P + l * D + c * A + u * le, o[8] = a * T + l * U + c * G + u * re, o[12] = a * y + l * R + c * ue + u * j, o[1] = d * E + h * w + m * O + p * Q, o[5] = d * P + h * D + m * A + p * le, o[9] = d * T + h * U + m * G + p * re, o[13] = d * y + h * R + m * ue + p * j, o[2] = v * E + x * w + g * O + _ * Q, o[6] = v * P + x * D + g * A + _ * le, o[10] = v * T + x * U + g * G + _ * re, o[14] = v * y + x * R + g * ue + _ * j, o[3] = M * E + S * w + b * O + C * Q, o[7] = M * P + S * D + b * A + C * le, o[11] = M * T + S * U + b * G + C * re, o[15] = M * y + S * R + b * ue + C * j, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[4], r = e[8], o = e[12], a = e[1], l = e[5], c = e[9], u = e[13], d = e[2], h = e[6], m = e[10], p = e[14], v = e[3], x = e[7], g = e[11], _ = e[15];
    return v * (+o * c * h - r * u * h - o * l * m + i * u * m + r * l * p - i * c * p) + x * (+n * c * p - n * u * m + o * a * m - r * a * p + r * u * d - o * c * d) + g * (+n * u * h - n * l * p - o * a * h + i * a * p + o * l * d - i * u * d) + _ * (-r * l * d - n * c * h + n * l * m + r * a * h - i * a * m + i * c * d);
  }
  transpose() {
    const e = this.elements;
    let n;
    return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this;
  }
  setPosition(e, n, i) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = n, r[14] = i), this;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], r = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], d = e[8], h = e[9], m = e[10], p = e[11], v = e[12], x = e[13], g = e[14], _ = e[15], M = h * g * u - x * m * u + x * c * p - l * g * p - h * c * _ + l * m * _, S = v * m * u - d * g * u - v * c * p + a * g * p + d * c * _ - a * m * _, b = d * x * u - v * h * u + v * l * p - a * x * p - d * l * _ + a * h * _, C = v * h * c - d * x * c - v * l * m + a * x * m + d * l * g - a * h * g, E = n * M + i * S + r * b + o * C;
    if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / E;
    return e[0] = M * P, e[1] = (x * m * o - h * g * o - x * r * p + i * g * p + h * r * _ - i * m * _) * P, e[2] = (l * g * o - x * c * o + x * r * u - i * g * u - l * r * _ + i * c * _) * P, e[3] = (h * c * o - l * m * o - h * r * u + i * m * u + l * r * p - i * c * p) * P, e[4] = S * P, e[5] = (d * g * o - v * m * o + v * r * p - n * g * p - d * r * _ + n * m * _) * P, e[6] = (v * c * o - a * g * o - v * r * u + n * g * u + a * r * _ - n * c * _) * P, e[7] = (a * m * o - d * c * o + d * r * u - n * m * u - a * r * p + n * c * p) * P, e[8] = b * P, e[9] = (v * h * o - d * x * o - v * i * p + n * x * p + d * i * _ - n * h * _) * P, e[10] = (a * x * o - v * l * o + v * i * u - n * x * u - a * i * _ + n * l * _) * P, e[11] = (d * l * o - a * h * o - d * i * u + n * h * u + a * i * p - n * l * p) * P, e[12] = C * P, e[13] = (d * x * r - v * h * r + v * i * m - n * x * m - d * i * g + n * h * g) * P, e[14] = (v * l * r - a * x * r - v * i * c + n * x * c + a * i * g - n * l * g) * P, e[15] = (a * h * r - d * l * r + d * i * c - n * h * c - a * i * m + n * l * m) * P, this;
  }
  scale(e) {
    const n = this.elements, i = e.x, r = e.y, o = e.z;
    return n[0] *= i, n[4] *= r, n[8] *= o, n[1] *= i, n[5] *= r, n[9] *= o, n[2] *= i, n[6] *= r, n[10] *= o, n[3] *= i, n[7] *= r, n[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, i, r));
  }
  makeTranslation(e, n, i) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      n,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, n) {
    const i = Math.cos(n), r = Math.sin(n), o = 1 - i, a = e.x, l = e.y, c = e.z, u = o * a, d = o * l;
    return this.set(
      u * a + i,
      u * l - r * c,
      u * c + r * l,
      0,
      u * l + r * c,
      d * l + i,
      d * c - r * a,
      0,
      u * c - r * l,
      d * c + r * a,
      o * c * c + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, n, i, r, o, a) {
    return this.set(
      1,
      i,
      o,
      0,
      e,
      1,
      a,
      0,
      n,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, n, i) {
    const r = this.elements, o = n._x, a = n._y, l = n._z, c = n._w, u = o + o, d = a + a, h = l + l, m = o * u, p = o * d, v = o * h, x = a * d, g = a * h, _ = l * h, M = c * u, S = c * d, b = c * h, C = i.x, E = i.y, P = i.z;
    return r[0] = (1 - (x + _)) * C, r[1] = (p + b) * C, r[2] = (v - S) * C, r[3] = 0, r[4] = (p - b) * E, r[5] = (1 - (m + _)) * E, r[6] = (g + M) * E, r[7] = 0, r[8] = (v + S) * P, r[9] = (g - M) * P, r[10] = (1 - (m + x)) * P, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, n, i) {
    const r = this.elements;
    let o = ro.set(r[0], r[1], r[2]).length();
    const a = ro.set(r[4], r[5], r[6]).length(), l = ro.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (o = -o), e.x = r[12], e.y = r[13], e.z = r[14], Ui.copy(this);
    const u = 1 / o, d = 1 / a, h = 1 / l;
    return Ui.elements[0] *= u, Ui.elements[1] *= u, Ui.elements[2] *= u, Ui.elements[4] *= d, Ui.elements[5] *= d, Ui.elements[6] *= d, Ui.elements[8] *= h, Ui.elements[9] *= h, Ui.elements[10] *= h, n.setFromRotationMatrix(Ui), i.x = o, i.y = a, i.z = l, this;
  }
  makePerspective(e, n, i, r, o, a, l = Es) {
    const c = this.elements, u = 2 * o / (n - e), d = 2 * o / (i - r), h = (n + e) / (n - e), m = (i + r) / (i - r);
    let p, v;
    if (l === Es)
      p = -(a + o) / (a - o), v = -2 * a * o / (a - o);
    else if (l === eu)
      p = -a / (a - o), v = -a * o / (a - o);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return c[0] = u, c[4] = 0, c[8] = h, c[12] = 0, c[1] = 0, c[5] = d, c[9] = m, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = p, c[14] = v, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  makeOrthographic(e, n, i, r, o, a, l = Es) {
    const c = this.elements, u = 1 / (n - e), d = 1 / (i - r), h = 1 / (a - o), m = (n + e) * u, p = (i + r) * d;
    let v, x;
    if (l === Es)
      v = (a + o) * h, x = -2 * h;
    else if (l === eu)
      v = o * h, x = -1 * h;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return c[0] = 2 * u, c[4] = 0, c[8] = 0, c[12] = -m, c[1] = 0, c[5] = 2 * d, c[9] = 0, c[13] = -p, c[2] = 0, c[6] = 0, c[10] = x, c[14] = -v, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let r = 0; r < 16; r++)
      if (n[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e[n + 9] = i[9], e[n + 10] = i[10], e[n + 11] = i[11], e[n + 12] = i[12], e[n + 13] = i[13], e[n + 14] = i[14], e[n + 15] = i[15], e;
  }
}
const ro = /* @__PURE__ */ new de(), Ui = /* @__PURE__ */ new Zt(), Fb = /* @__PURE__ */ new de(0, 0, 0), Ub = /* @__PURE__ */ new de(1, 1, 1), $s = /* @__PURE__ */ new de(), $l = /* @__PURE__ */ new de(), yi = /* @__PURE__ */ new de(), dm = /* @__PURE__ */ new Zt(), hm = /* @__PURE__ */ new ni();
class Mi {
  constructor(e = 0, n = 0, i = 0, r = Mi.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = n, this._z = i, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, n, i, r = this._order) {
    return this._x = e, this._y = n, this._z = i, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, n = this._order, i = !0) {
    const r = e.elements, o = r[0], a = r[4], l = r[8], c = r[1], u = r[5], d = r[9], h = r[2], m = r[6], p = r[10];
    switch (n) {
      case "XYZ":
        this._y = Math.asin(Ln(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-d, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(m, u), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Ln(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(l, p), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-h, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Ln(m, -1, 1)), Math.abs(m) < 0.9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-a, u)) : (this._y = 0, this._z = Math.atan2(c, o));
        break;
      case "ZYX":
        this._y = Math.asin(-Ln(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(m, p), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, u));
        break;
      case "YZX":
        this._z = Math.asin(Ln(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-d, u), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(l, p));
        break;
      case "XZY":
        this._z = Math.asin(-Ln(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(m, u), this._y = Math.atan2(l, o)) : (this._x = Math.atan2(-d, p), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
    }
    return this._order = n, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, i) {
    return dm.makeRotationFromQuaternion(e), this.setFromRotationMatrix(dm, n, i);
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return hm.setFromEuler(this), this.setFromQuaternion(hm, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Mi.DEFAULT_ORDER = "XYZ";
class If {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let Ob = 0;
const fm = /* @__PURE__ */ new de(), oo = /* @__PURE__ */ new ni(), ps = /* @__PURE__ */ new Zt(), Wl = /* @__PURE__ */ new de(), pa = /* @__PURE__ */ new de(), zb = /* @__PURE__ */ new de(), Nb = /* @__PURE__ */ new ni(), pm = /* @__PURE__ */ new de(1, 0, 0), mm = /* @__PURE__ */ new de(0, 1, 0), vm = /* @__PURE__ */ new de(0, 0, 1), gm = { type: "added" }, Bb = { type: "removed" }, ao = { type: "childadded", child: null }, ud = { type: "childremoved", child: null };
class cn extends Wr {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Ob++ }), this.uuid = Xr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = cn.DEFAULT_UP.clone();
    const e = new de(), n = new Mi(), i = new ni(), r = new de(1, 1, 1);
    function o() {
      i.setFromEuler(n, !1);
    }
    function a() {
      n.setFromQuaternion(i, void 0, !1);
    }
    n._onChange(o), i._onChange(a), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      modelViewMatrix: {
        value: new Zt()
      },
      normalMatrix: {
        value: new Et()
      }
    }), this.matrix = new Zt(), this.matrixWorld = new Zt(), this.matrixAutoUpdate = cn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = cn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new If(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return oo.setFromAxisAngle(e, n), this.quaternion.multiply(oo), this;
  }
  rotateOnWorldAxis(e, n) {
    return oo.setFromAxisAngle(e, n), this.quaternion.premultiply(oo), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(pm, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(mm, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(vm, e);
  }
  translateOnAxis(e, n) {
    return fm.copy(e).applyQuaternion(this.quaternion), this.position.add(fm.multiplyScalar(n)), this;
  }
  translateX(e) {
    return this.translateOnAxis(pm, e);
  }
  translateY(e) {
    return this.translateOnAxis(mm, e);
  }
  translateZ(e) {
    return this.translateOnAxis(vm, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(ps.copy(this.matrixWorld).invert());
  }
  lookAt(e, n, i) {
    e.isVector3 ? Wl.copy(e) : Wl.set(e, n, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), pa.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ps.lookAt(pa, Wl, this.up) : ps.lookAt(Wl, pa, this.up), this.quaternion.setFromRotationMatrix(ps), r && (ps.extractRotation(r.matrixWorld), oo.setFromRotationMatrix(ps), this.quaternion.premultiply(oo.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.add(arguments[n]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(gm), ao.child = e, this.dispatchEvent(ao), ao.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const n = this.children.indexOf(e);
    return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(Bb), ud.child = e, this.dispatchEvent(ud), ud.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), ps.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), ps.multiply(e.parent.matrixWorld)), e.applyMatrix4(ps), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(gm), ao.child = e, this.dispatchEvent(ao), ao.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const a = this.children[i].getObjectByProperty(e, n);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, n, i = []) {
    this[e] === n && i.push(this);
    const r = this.children;
    for (let o = 0, a = r.length; o < a; o++)
      r[o].getObjectsByProperty(e, n, i);
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(pa, e, zb), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(pa, Nb, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++)
      n[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++)
      n[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++)
      n[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, n) {
    const i = this.parent;
    if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), n === !0) {
      const r = this.children;
      for (let o = 0, a = r.length; o < a; o++)
        r[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string", i = {};
    n && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), r.maxInstanceCount = this._maxInstanceCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (r.boundingSphere = {
      center: r.boundingSphere.center.toArray(),
      radius: r.boundingSphere.radius
    }), this.boundingBox !== null && (r.boundingBox = {
      min: r.boundingBox.min.toArray(),
      max: r.boundingBox.max.toArray()
    }));
    function o(l, c) {
      return l[c.uuid] === void 0 && (l[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = o(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const c = l.shapes;
        if (Array.isArray(c))
          for (let u = 0, d = c.length; u < d; u++) {
            const h = c[u];
            o(e.shapes, h);
          }
        else
          o(e.shapes, c);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let c = 0, u = this.material.length; c < u; c++)
          l.push(o(e.materials, this.material[c]));
        r.material = l;
      } else
        r.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let l = 0; l < this.children.length; l++)
        r.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const c = this.animations[l];
        r.animations.push(o(e.animations, c));
      }
    }
    if (n) {
      const l = a(e.geometries), c = a(e.materials), u = a(e.textures), d = a(e.images), h = a(e.shapes), m = a(e.skeletons), p = a(e.animations), v = a(e.nodes);
      l.length > 0 && (i.geometries = l), c.length > 0 && (i.materials = c), u.length > 0 && (i.textures = u), d.length > 0 && (i.images = d), h.length > 0 && (i.shapes = h), m.length > 0 && (i.skeletons = m), p.length > 0 && (i.animations = p), v.length > 0 && (i.nodes = v);
    }
    return i.object = r, i;
    function a(l) {
      const c = [];
      for (const u in l) {
        const d = l[u];
        delete d.metadata, c.push(d);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0)
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
cn.DEFAULT_UP = /* @__PURE__ */ new de(0, 1, 0);
cn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
cn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Oi = /* @__PURE__ */ new de(), ms = /* @__PURE__ */ new de(), dd = /* @__PURE__ */ new de(), vs = /* @__PURE__ */ new de(), lo = /* @__PURE__ */ new de(), co = /* @__PURE__ */ new de(), ym = /* @__PURE__ */ new de(), hd = /* @__PURE__ */ new de(), fd = /* @__PURE__ */ new de(), pd = /* @__PURE__ */ new de(), md = /* @__PURE__ */ new jt(), vd = /* @__PURE__ */ new jt(), gd = /* @__PURE__ */ new jt();
class Vi {
  constructor(e = new de(), n = new de(), i = new de()) {
    this.a = e, this.b = n, this.c = i;
  }
  static getNormal(e, n, i, r) {
    r.subVectors(i, n), Oi.subVectors(e, n), r.cross(Oi);
    const o = r.lengthSq();
    return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, n, i, r, o) {
    Oi.subVectors(r, n), ms.subVectors(i, n), dd.subVectors(e, n);
    const a = Oi.dot(Oi), l = Oi.dot(ms), c = Oi.dot(dd), u = ms.dot(ms), d = ms.dot(dd), h = a * u - l * l;
    if (h === 0)
      return o.set(0, 0, 0), null;
    const m = 1 / h, p = (u * c - l * d) * m, v = (a * d - l * c) * m;
    return o.set(1 - p - v, v, p);
  }
  static containsPoint(e, n, i, r) {
    return this.getBarycoord(e, n, i, r, vs) === null ? !1 : vs.x >= 0 && vs.y >= 0 && vs.x + vs.y <= 1;
  }
  static getInterpolation(e, n, i, r, o, a, l, c) {
    return this.getBarycoord(e, n, i, r, vs) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(o, vs.x), c.addScaledVector(a, vs.y), c.addScaledVector(l, vs.z), c);
  }
  static getInterpolatedAttribute(e, n, i, r, o, a) {
    return md.setScalar(0), vd.setScalar(0), gd.setScalar(0), md.fromBufferAttribute(e, n), vd.fromBufferAttribute(e, i), gd.fromBufferAttribute(e, r), a.setScalar(0), a.addScaledVector(md, o.x), a.addScaledVector(vd, o.y), a.addScaledVector(gd, o.z), a;
  }
  static isFrontFacing(e, n, i, r) {
    return Oi.subVectors(i, n), ms.subVectors(e, n), Oi.cross(ms).dot(r) < 0;
  }
  set(e, n, i) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, n, i, r) {
    return this.a.copy(e[n]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, n, i, r) {
    return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Oi.subVectors(this.c, this.b), ms.subVectors(this.a, this.b), Oi.cross(ms).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Vi.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return Vi.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getInterpolation(e, n, i, r, o) {
    return Vi.getInterpolation(e, this.a, this.b, this.c, n, i, r, o);
  }
  containsPoint(e) {
    return Vi.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Vi.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const i = this.a, r = this.b, o = this.c;
    let a, l;
    lo.subVectors(r, i), co.subVectors(o, i), hd.subVectors(e, i);
    const c = lo.dot(hd), u = co.dot(hd);
    if (c <= 0 && u <= 0)
      return n.copy(i);
    fd.subVectors(e, r);
    const d = lo.dot(fd), h = co.dot(fd);
    if (d >= 0 && h <= d)
      return n.copy(r);
    const m = c * h - d * u;
    if (m <= 0 && c >= 0 && d <= 0)
      return a = c / (c - d), n.copy(i).addScaledVector(lo, a);
    pd.subVectors(e, o);
    const p = lo.dot(pd), v = co.dot(pd);
    if (v >= 0 && p <= v)
      return n.copy(o);
    const x = p * u - c * v;
    if (x <= 0 && u >= 0 && v <= 0)
      return l = u / (u - v), n.copy(i).addScaledVector(co, l);
    const g = d * v - p * h;
    if (g <= 0 && h - d >= 0 && p - v >= 0)
      return ym.subVectors(o, r), l = (h - d) / (h - d + (p - v)), n.copy(r).addScaledVector(ym, l);
    const _ = 1 / (g + x + m);
    return a = x * _, l = m * _, n.copy(i).addScaledVector(lo, a).addScaledVector(co, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const ty = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Ws = { h: 0, s: 0, l: 0 }, Xl = { h: 0, s: 0, l: 0 };
function yd(s, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? s + (e - s) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - n) : s;
}
class Mt {
  constructor(e, n, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, i);
  }
  set(e, n, i) {
    if (n === void 0 && i === void 0) {
      const r = e;
      r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
    } else
      this.setRGB(e, n, i);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, n = dn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, It.toWorkingColorSpace(this, n), this;
  }
  setRGB(e, n, i, r = It.workingColorSpace) {
    return this.r = e, this.g = n, this.b = i, It.toWorkingColorSpace(this, r), this;
  }
  setHSL(e, n, i, r = It.workingColorSpace) {
    if (e = Df(e, 1), n = Ln(n, 0, 1), i = Ln(i, 0, 1), n === 0)
      this.r = this.g = this.b = i;
    else {
      const o = i <= 0.5 ? i * (1 + n) : i + n - i * n, a = 2 * i - o;
      this.r = yd(a, o, e + 1 / 3), this.g = yd(a, o, e), this.b = yd(a, o, e - 1 / 3);
    }
    return It.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, n = dn) {
    function i(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let o;
      const a = r[1], l = r[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setRGB(
              Math.min(255, parseInt(o[1], 10)) / 255,
              Math.min(255, parseInt(o[2], 10)) / 255,
              Math.min(255, parseInt(o[3], 10)) / 255,
              n
            );
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setRGB(
              Math.min(100, parseInt(o[1], 10)) / 100,
              Math.min(100, parseInt(o[2], 10)) / 100,
              Math.min(100, parseInt(o[3], 10)) / 100,
              n
            );
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setHSL(
              parseFloat(o[1]) / 360,
              parseFloat(o[2]) / 100,
              parseFloat(o[3]) / 100,
              n
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const o = r[1], a = o.length;
      if (a === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          n
        );
      if (a === 6)
        return this.setHex(parseInt(o, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, n);
    return this;
  }
  setColorName(e, n = dn) {
    const i = ty[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, n) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Ps(e.r), this.g = Ps(e.g), this.b = Ps(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Lo(e.r), this.g = Lo(e.g), this.b = Lo(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = dn) {
    return It.fromWorkingColorSpace($n.copy(this), e), Math.round(Ln($n.r * 255, 0, 255)) * 65536 + Math.round(Ln($n.g * 255, 0, 255)) * 256 + Math.round(Ln($n.b * 255, 0, 255));
  }
  getHexString(e = dn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = It.workingColorSpace) {
    It.fromWorkingColorSpace($n.copy(this), n);
    const i = $n.r, r = $n.g, o = $n.b, a = Math.max(i, r, o), l = Math.min(i, r, o);
    let c, u;
    const d = (l + a) / 2;
    if (l === a)
      c = 0, u = 0;
    else {
      const h = a - l;
      switch (u = d <= 0.5 ? h / (a + l) : h / (2 - a - l), a) {
        case i:
          c = (r - o) / h + (r < o ? 6 : 0);
          break;
        case r:
          c = (o - i) / h + 2;
          break;
        case o:
          c = (i - r) / h + 4;
          break;
      }
      c /= 6;
    }
    return e.h = c, e.s = u, e.l = d, e;
  }
  getRGB(e, n = It.workingColorSpace) {
    return It.fromWorkingColorSpace($n.copy(this), n), e.r = $n.r, e.g = $n.g, e.b = $n.b, e;
  }
  getStyle(e = dn) {
    It.fromWorkingColorSpace($n.copy(this), e);
    const n = $n.r, i = $n.g, r = $n.b;
    return e !== dn ? `color(${e} ${n.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, n, i) {
    return this.getHSL(Ws), this.setHSL(Ws.h + e, Ws.s + n, Ws.l + i);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, n) {
    return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, n) {
    return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
  }
  lerpColors(e, n, i) {
    return this.r = e.r + (n.r - e.r) * i, this.g = e.g + (n.g - e.g) * i, this.b = e.b + (n.b - e.b) * i, this;
  }
  lerpHSL(e, n) {
    this.getHSL(Ws), e.getHSL(Xl);
    const i = Ha(Ws.h, Xl.h, n), r = Ha(Ws.s, Xl.s, n), o = Ha(Ws.l, Xl.l, n);
    return this.setHSL(i, r, o), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const n = this.r, i = this.g, r = this.b, o = e.elements;
    return this.r = o[0] * n + o[3] * i + o[6] * r, this.g = o[1] * n + o[4] * i + o[7] * r, this.b = o[2] * n + o[5] * i + o[8] * r, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
  }
  fromBufferAttribute(e, n) {
    return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const $n = /* @__PURE__ */ new Mt();
Mt.NAMES = ty;
let Vb = 0;
class jr extends Wr {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(e) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Vb++ }), this.uuid = Xr(), this.name = "", this.blending = Gi, this.side = or, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Jc, this.blendDst = ll, this.blendEquation = Bi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Mt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = No, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = em, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Qr, this.stencilZFail = Qr, this.stencilZPass = Qr, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const n in e) {
        const i = e[n];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);
          continue;
        }
        const r = this[n];
        if (r === void 0) {
          console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);
          continue;
        }
        r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[n] = i;
      }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n && (e = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Gi && (i.blending = this.blending), this.side !== or && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== Jc && (i.blendSrc = this.blendSrc), this.blendDst !== ll && (i.blendDst = this.blendDst), this.blendEquation !== Bi && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== No && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== em && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Qr && (i.stencilFail = this.stencilFail), this.stencilZFail !== Qr && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Qr && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(o) {
      const a = [];
      for (const l in o) {
        const c = o[l];
        delete c.metadata, a.push(c);
      }
      return a;
    }
    if (n) {
      const o = r(e.textures), a = r(e.images);
      o.length > 0 && (i.textures = o), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const n = e.clippingPlanes;
    let i = null;
    if (n !== null) {
      const r = n.length;
      i = new Array(r);
      for (let o = 0; o !== r; ++o)
        i[o] = n[o].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class En extends jr {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Mt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Mi(), this.combine = F0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Mn = /* @__PURE__ */ new de(), jl = /* @__PURE__ */ new rt();
class Si {
  constructor(e, n, i = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = i, this.usage = tm, this.updateRanges = [], this.gpuType = di, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, n, i) {
    e *= this.itemSize, i *= n.itemSize;
    for (let r = 0, o = this.itemSize; r < o; r++)
      this.array[e + r] = n.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, i = this.count; n < i; n++)
        jl.fromBufferAttribute(this, n), jl.applyMatrix3(e), this.setXY(n, jl.x, jl.y);
    else if (this.itemSize === 3)
      for (let n = 0, i = this.count; n < i; n++)
        Mn.fromBufferAttribute(this, n), Mn.applyMatrix3(e), this.setXYZ(n, Mn.x, Mn.y, Mn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Mn.fromBufferAttribute(this, n), Mn.applyMatrix4(e), this.setXYZ(n, Mn.x, Mn.y, Mn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Mn.fromBufferAttribute(this, n), Mn.applyNormalMatrix(e), this.setXYZ(n, Mn.x, Mn.y, Mn.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Mn.fromBufferAttribute(this, n), Mn.transformDirection(e), this.setXYZ(n, Mn.x, Mn.y, Mn.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getComponent(e, n) {
    let i = this.array[e * this.itemSize + n];
    return this.normalized && (i = bo(i, this.array)), i;
  }
  setComponent(e, n, i) {
    return this.normalized && (i = Qn(i, this.array)), this.array[e * this.itemSize + n] = i, this;
  }
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = bo(n, this.array)), n;
  }
  setX(e, n) {
    return this.normalized && (n = Qn(n, this.array)), this.array[e * this.itemSize] = n, this;
  }
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = bo(n, this.array)), n;
  }
  setY(e, n) {
    return this.normalized && (n = Qn(n, this.array)), this.array[e * this.itemSize + 1] = n, this;
  }
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = bo(n, this.array)), n;
  }
  setZ(e, n) {
    return this.normalized && (n = Qn(n, this.array)), this.array[e * this.itemSize + 2] = n, this;
  }
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = bo(n, this.array)), n;
  }
  setW(e, n) {
    return this.normalized && (n = Qn(n, this.array)), this.array[e * this.itemSize + 3] = n, this;
  }
  setXY(e, n, i) {
    return e *= this.itemSize, this.normalized && (n = Qn(n, this.array), i = Qn(i, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this;
  }
  setXYZ(e, n, i, r) {
    return e *= this.itemSize, this.normalized && (n = Qn(n, this.array), i = Qn(i, this.array), r = Qn(r, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = r, this;
  }
  setXYZW(e, n, i, r, o) {
    return e *= this.itemSize, this.normalized && (n = Qn(n, this.array), i = Qn(i, this.array), r = Qn(r, this.array), o = Qn(o, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = o, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== tm && (e.usage = this.usage), e;
  }
}
class ny extends Si {
  constructor(e, n, i) {
    super(new Uint16Array(e), n, i);
  }
}
class iy extends Si {
  constructor(e, n, i) {
    super(new Uint32Array(e), n, i);
  }
}
class Pt extends Si {
  constructor(e, n, i) {
    super(new Float32Array(e), n, i);
  }
}
let Gb = 0;
const Ci = /* @__PURE__ */ new Zt(), _d = /* @__PURE__ */ new cn(), uo = /* @__PURE__ */ new de(), _i = /* @__PURE__ */ new dr(), ma = /* @__PURE__ */ new dr(), Pn = /* @__PURE__ */ new de();
class Vt extends Wr {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Gb++ }), this.uuid = Xr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (J0(e) ? iy : ny)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return this.attributes[e] = n, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, i = 0) {
    this.groups.push({
      start: e,
      count: n,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    this.drawRange.start = e, this.drawRange.count = n;
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const o = new Et().getNormalMatrix(e);
      i.applyNormalMatrix(o), i.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Ci.makeRotationFromQuaternion(e), this.applyMatrix4(Ci), this;
  }
  rotateX(e) {
    return Ci.makeRotationX(e), this.applyMatrix4(Ci), this;
  }
  rotateY(e) {
    return Ci.makeRotationY(e), this.applyMatrix4(Ci), this;
  }
  rotateZ(e) {
    return Ci.makeRotationZ(e), this.applyMatrix4(Ci), this;
  }
  translate(e, n, i) {
    return Ci.makeTranslation(e, n, i), this.applyMatrix4(Ci), this;
  }
  scale(e, n, i) {
    return Ci.makeScale(e, n, i), this.applyMatrix4(Ci), this;
  }
  lookAt(e) {
    return _d.lookAt(e), _d.updateMatrix(), this.applyMatrix4(_d.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(uo).negate(), this.translate(uo.x, uo.y, uo.z), this;
  }
  setFromPoints(e) {
    const n = this.getAttribute("position");
    if (n === void 0) {
      const i = [];
      for (let r = 0, o = e.length; r < o; r++) {
        const a = e[r];
        i.push(a.x, a.y, a.z || 0);
      }
      this.setAttribute("position", new Pt(i, 3));
    } else {
      for (let i = 0, r = n.count; i < r; i++) {
        const o = e[i];
        n.setXYZ(i, o.x, o.y, o.z || 0);
      }
      e.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), n.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new dr());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new de(-1 / 0, -1 / 0, -1 / 0),
        new de(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), n)
        for (let i = 0, r = n.length; i < r; i++) {
          const o = n[i];
          _i.setFromBufferAttribute(o), this.morphTargetsRelative ? (Pn.addVectors(this.boundingBox.min, _i.min), this.boundingBox.expandByPoint(Pn), Pn.addVectors(this.boundingBox.max, _i.max), this.boundingBox.expandByPoint(Pn)) : (this.boundingBox.expandByPoint(_i.min), this.boundingBox.expandByPoint(_i.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new wl());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new de(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (_i.setFromBufferAttribute(e), n)
        for (let o = 0, a = n.length; o < a; o++) {
          const l = n[o];
          ma.setFromBufferAttribute(l), this.morphTargetsRelative ? (Pn.addVectors(_i.min, ma.min), _i.expandByPoint(Pn), Pn.addVectors(_i.max, ma.max), _i.expandByPoint(Pn)) : (_i.expandByPoint(ma.min), _i.expandByPoint(ma.max));
        }
      _i.getCenter(i);
      let r = 0;
      for (let o = 0, a = e.count; o < a; o++)
        Pn.fromBufferAttribute(e, o), r = Math.max(r, i.distanceToSquared(Pn));
      if (n)
        for (let o = 0, a = n.length; o < a; o++) {
          const l = n[o], c = this.morphTargetsRelative;
          for (let u = 0, d = l.count; u < d; u++)
            Pn.fromBufferAttribute(l, u), c && (uo.fromBufferAttribute(e, u), Pn.add(uo)), r = Math.max(r, i.distanceToSquared(Pn));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, n = this.attributes;
    if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = n.position, r = n.normal, o = n.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Si(new Float32Array(4 * i.count), 4));
    const a = this.getAttribute("tangent"), l = [], c = [];
    for (let T = 0; T < i.count; T++)
      l[T] = new de(), c[T] = new de();
    const u = new de(), d = new de(), h = new de(), m = new rt(), p = new rt(), v = new rt(), x = new de(), g = new de();
    function _(T, y, w) {
      u.fromBufferAttribute(i, T), d.fromBufferAttribute(i, y), h.fromBufferAttribute(i, w), m.fromBufferAttribute(o, T), p.fromBufferAttribute(o, y), v.fromBufferAttribute(o, w), d.sub(u), h.sub(u), p.sub(m), v.sub(m);
      const D = 1 / (p.x * v.y - v.x * p.y);
      isFinite(D) && (x.copy(d).multiplyScalar(v.y).addScaledVector(h, -p.y).multiplyScalar(D), g.copy(h).multiplyScalar(p.x).addScaledVector(d, -v.x).multiplyScalar(D), l[T].add(x), l[y].add(x), l[w].add(x), c[T].add(g), c[y].add(g), c[w].add(g));
    }
    let M = this.groups;
    M.length === 0 && (M = [{
      start: 0,
      count: e.count
    }]);
    for (let T = 0, y = M.length; T < y; ++T) {
      const w = M[T], D = w.start, U = w.count;
      for (let R = D, O = D + U; R < O; R += 3)
        _(
          e.getX(R + 0),
          e.getX(R + 1),
          e.getX(R + 2)
        );
    }
    const S = new de(), b = new de(), C = new de(), E = new de();
    function P(T) {
      C.fromBufferAttribute(r, T), E.copy(C);
      const y = l[T];
      S.copy(y), S.sub(C.multiplyScalar(C.dot(y))).normalize(), b.crossVectors(E, y);
      const D = b.dot(c[T]) < 0 ? -1 : 1;
      a.setXYZW(T, S.x, S.y, S.z, D);
    }
    for (let T = 0, y = M.length; T < y; ++T) {
      const w = M[T], D = w.start, U = w.count;
      for (let R = D, O = D + U; R < O; R += 3)
        P(e.getX(R + 0)), P(e.getX(R + 1)), P(e.getX(R + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, n = this.getAttribute("position");
    if (n !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new Si(new Float32Array(n.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let m = 0, p = i.count; m < p; m++)
          i.setXYZ(m, 0, 0, 0);
      const r = new de(), o = new de(), a = new de(), l = new de(), c = new de(), u = new de(), d = new de(), h = new de();
      if (e)
        for (let m = 0, p = e.count; m < p; m += 3) {
          const v = e.getX(m + 0), x = e.getX(m + 1), g = e.getX(m + 2);
          r.fromBufferAttribute(n, v), o.fromBufferAttribute(n, x), a.fromBufferAttribute(n, g), d.subVectors(a, o), h.subVectors(r, o), d.cross(h), l.fromBufferAttribute(i, v), c.fromBufferAttribute(i, x), u.fromBufferAttribute(i, g), l.add(d), c.add(d), u.add(d), i.setXYZ(v, l.x, l.y, l.z), i.setXYZ(x, c.x, c.y, c.z), i.setXYZ(g, u.x, u.y, u.z);
        }
      else
        for (let m = 0, p = n.count; m < p; m += 3)
          r.fromBufferAttribute(n, m + 0), o.fromBufferAttribute(n, m + 1), a.fromBufferAttribute(n, m + 2), d.subVectors(a, o), h.subVectors(r, o), d.cross(h), i.setXYZ(m + 0, d.x, d.y, d.z), i.setXYZ(m + 1, d.x, d.y, d.z), i.setXYZ(m + 2, d.x, d.y, d.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, i = e.count; n < i; n++)
      Pn.fromBufferAttribute(e, n), Pn.normalize(), e.setXYZ(n, Pn.x, Pn.y, Pn.z);
  }
  toNonIndexed() {
    function e(l, c) {
      const u = l.array, d = l.itemSize, h = l.normalized, m = new u.constructor(c.length * d);
      let p = 0, v = 0;
      for (let x = 0, g = c.length; x < g; x++) {
        l.isInterleavedBufferAttribute ? p = c[x] * l.data.stride + l.offset : p = c[x] * d;
        for (let _ = 0; _ < d; _++)
          m[v++] = u[p++];
      }
      return new Si(m, d, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const n = new Vt(), i = this.index.array, r = this.attributes;
    for (const l in r) {
      const c = r[l], u = e(c, i);
      n.setAttribute(l, u);
    }
    const o = this.morphAttributes;
    for (const l in o) {
      const c = [], u = o[l];
      for (let d = 0, h = u.length; d < h; d++) {
        const m = u[d], p = e(m, i);
        c.push(p);
      }
      n.morphAttributes[l] = c;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let l = 0, c = a.length; l < c; l++) {
      const u = a[l];
      n.addGroup(u.start, u.count, u.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const c = this.parameters;
      for (const u in c)
        c[u] !== void 0 && (e[u] = c[u]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null && (e.data.index = {
      type: n.array.constructor.name,
      array: Array.prototype.slice.call(n.array)
    });
    const i = this.attributes;
    for (const c in i) {
      const u = i[c];
      e.data.attributes[c] = u.toJSON(e.data);
    }
    const r = {};
    let o = !1;
    for (const c in this.morphAttributes) {
      const u = this.morphAttributes[c], d = [];
      for (let h = 0, m = u.length; h < m; h++) {
        const p = u[h];
        d.push(p.toJSON(e.data));
      }
      d.length > 0 && (r[c] = d, o = !0);
    }
    o && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const n = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(n));
    const r = e.attributes;
    for (const u in r) {
      const d = r[u];
      this.setAttribute(u, d.clone(n));
    }
    const o = e.morphAttributes;
    for (const u in o) {
      const d = [], h = o[u];
      for (let m = 0, p = h.length; m < p; m++)
        d.push(h[m].clone(n));
      this.morphAttributes[u] = d;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let u = 0, d = a.length; u < d; u++) {
      const h = a[u];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const c = e.boundingSphere;
    return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _m = /* @__PURE__ */ new Zt(), gr = /* @__PURE__ */ new kf(), Yl = /* @__PURE__ */ new wl(), xm = /* @__PURE__ */ new de(), ql = /* @__PURE__ */ new de(), Zl = /* @__PURE__ */ new de(), Kl = /* @__PURE__ */ new de(), xd = /* @__PURE__ */ new de(), Jl = /* @__PURE__ */ new de(), bm = /* @__PURE__ */ new de(), Ql = /* @__PURE__ */ new de();
class Ze extends cn {
  constructor(e = new Vt(), n = new En()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes, i = Object.keys(n);
    if (i.length > 0) {
      const r = n[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, a = r.length; o < a; o++) {
          const l = r[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = o;
        }
      }
    }
  }
  getVertexPosition(e, n) {
    const i = this.geometry, r = i.attributes.position, o = i.morphAttributes.position, a = i.morphTargetsRelative;
    n.fromBufferAttribute(r, e);
    const l = this.morphTargetInfluences;
    if (o && l) {
      Jl.set(0, 0, 0);
      for (let c = 0, u = o.length; c < u; c++) {
        const d = l[c], h = o[c];
        d !== 0 && (xd.fromBufferAttribute(h, e), a ? Jl.addScaledVector(xd, d) : Jl.addScaledVector(xd.sub(n), d));
      }
      n.add(Jl);
    }
    return n;
  }
  raycast(e, n) {
    const i = this.geometry, r = this.material, o = this.matrixWorld;
    r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Yl.copy(i.boundingSphere), Yl.applyMatrix4(o), gr.copy(e.ray).recast(e.near), !(Yl.containsPoint(gr.origin) === !1 && (gr.intersectSphere(Yl, xm) === null || gr.origin.distanceToSquared(xm) > (e.far - e.near) ** 2)) && (_m.copy(o).invert(), gr.copy(e.ray).applyMatrix4(_m), !(i.boundingBox !== null && gr.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, n, gr)));
  }
  _computeIntersections(e, n, i) {
    let r;
    const o = this.geometry, a = this.material, l = o.index, c = o.attributes.position, u = o.attributes.uv, d = o.attributes.uv1, h = o.attributes.normal, m = o.groups, p = o.drawRange;
    if (l !== null)
      if (Array.isArray(a))
        for (let v = 0, x = m.length; v < x; v++) {
          const g = m[v], _ = a[g.materialIndex], M = Math.max(g.start, p.start), S = Math.min(l.count, Math.min(g.start + g.count, p.start + p.count));
          for (let b = M, C = S; b < C; b += 3) {
            const E = l.getX(b), P = l.getX(b + 1), T = l.getX(b + 2);
            r = ec(this, _, e, i, u, d, h, E, P, T), r && (r.faceIndex = Math.floor(b / 3), r.face.materialIndex = g.materialIndex, n.push(r));
          }
        }
      else {
        const v = Math.max(0, p.start), x = Math.min(l.count, p.start + p.count);
        for (let g = v, _ = x; g < _; g += 3) {
          const M = l.getX(g), S = l.getX(g + 1), b = l.getX(g + 2);
          r = ec(this, a, e, i, u, d, h, M, S, b), r && (r.faceIndex = Math.floor(g / 3), n.push(r));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(a))
        for (let v = 0, x = m.length; v < x; v++) {
          const g = m[v], _ = a[g.materialIndex], M = Math.max(g.start, p.start), S = Math.min(c.count, Math.min(g.start + g.count, p.start + p.count));
          for (let b = M, C = S; b < C; b += 3) {
            const E = b, P = b + 1, T = b + 2;
            r = ec(this, _, e, i, u, d, h, E, P, T), r && (r.faceIndex = Math.floor(b / 3), r.face.materialIndex = g.materialIndex, n.push(r));
          }
        }
      else {
        const v = Math.max(0, p.start), x = Math.min(c.count, p.start + p.count);
        for (let g = v, _ = x; g < _; g += 3) {
          const M = g, S = g + 1, b = g + 2;
          r = ec(this, a, e, i, u, d, h, M, S, b), r && (r.faceIndex = Math.floor(g / 3), n.push(r));
        }
      }
  }
}
function Hb(s, e, n, i, r, o, a, l) {
  let c;
  if (e.side === hi ? c = i.intersectTriangle(a, o, r, !0, l) : c = i.intersectTriangle(r, o, a, e.side === or, l), c === null) return null;
  Ql.copy(l), Ql.applyMatrix4(s.matrixWorld);
  const u = n.ray.origin.distanceTo(Ql);
  return u < n.near || u > n.far ? null : {
    distance: u,
    point: Ql.clone(),
    object: s
  };
}
function ec(s, e, n, i, r, o, a, l, c, u) {
  s.getVertexPosition(l, ql), s.getVertexPosition(c, Zl), s.getVertexPosition(u, Kl);
  const d = Hb(s, e, n, i, ql, Zl, Kl, bm);
  if (d) {
    const h = new de();
    Vi.getBarycoord(bm, ql, Zl, Kl, h), r && (d.uv = Vi.getInterpolatedAttribute(r, l, c, u, h, new rt())), o && (d.uv1 = Vi.getInterpolatedAttribute(o, l, c, u, h, new rt())), a && (d.normal = Vi.getInterpolatedAttribute(a, l, c, u, h, new de()), d.normal.dot(i.direction) > 0 && d.normal.multiplyScalar(-1));
    const m = {
      a: l,
      b: c,
      c: u,
      normal: new de(),
      materialIndex: 0
    };
    Vi.getNormal(ql, Zl, Kl, m.normal), d.face = m, d.barycoord = h;
  }
  return d;
}
class pn extends Vt {
  constructor(e = 1, n = 1, i = 1, r = 1, o = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: n,
      depth: i,
      widthSegments: r,
      heightSegments: o,
      depthSegments: a
    };
    const l = this;
    r = Math.floor(r), o = Math.floor(o), a = Math.floor(a);
    const c = [], u = [], d = [], h = [];
    let m = 0, p = 0;
    v("z", "y", "x", -1, -1, i, n, e, a, o, 0), v("z", "y", "x", 1, -1, i, n, -e, a, o, 1), v("x", "z", "y", 1, 1, e, i, n, r, a, 2), v("x", "z", "y", 1, -1, e, i, -n, r, a, 3), v("x", "y", "z", 1, -1, e, n, i, r, o, 4), v("x", "y", "z", -1, -1, e, n, -i, r, o, 5), this.setIndex(c), this.setAttribute("position", new Pt(u, 3)), this.setAttribute("normal", new Pt(d, 3)), this.setAttribute("uv", new Pt(h, 2));
    function v(x, g, _, M, S, b, C, E, P, T, y) {
      const w = b / P, D = C / T, U = b / 2, R = C / 2, O = E / 2, A = P + 1, G = T + 1;
      let ue = 0, Q = 0;
      const le = new de();
      for (let re = 0; re < G; re++) {
        const j = re * D - R;
        for (let $ = 0; $ < A; $++) {
          const q = $ * w - U;
          le[x] = q * M, le[g] = j * S, le[_] = O, u.push(le.x, le.y, le.z), le[x] = 0, le[g] = 0, le[_] = E > 0 ? 1 : -1, d.push(le.x, le.y, le.z), h.push($ / P), h.push(1 - re / T), ue += 1;
        }
      }
      for (let re = 0; re < T; re++)
        for (let j = 0; j < P; j++) {
          const $ = m + j + A * re, q = m + j + A * (re + 1), oe = m + (j + 1) + A * (re + 1), ie = m + (j + 1) + A * re;
          c.push($, q, ie), c.push(q, oe, ie), Q += 6;
        }
      l.addGroup(p, Q, y), p += Q, m += ue;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new pn(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Wo(s) {
  const e = {};
  for (const n in s) {
    e[n] = {};
    for (const i in s[n]) {
      const r = s[n][i];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][i] = null) : e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r;
    }
  }
  return e;
}
function ei(s) {
  const e = {};
  for (let n = 0; n < s.length; n++) {
    const i = Wo(s[n]);
    for (const r in i)
      e[r] = i[r];
  }
  return e;
}
function $b(s) {
  const e = [];
  for (let n = 0; n < s.length; n++)
    e.push(s[n].clone());
  return e;
}
function sy(s) {
  const e = s.getRenderTarget();
  return e === null ? s.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : It.workingColorSpace;
}
const Sl = { clone: Wo, merge: ei };
var Wb = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Xb = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class zn extends jr {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Wb, this.fragmentShader = Xb, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Wo(e.uniforms), this.uniformsGroups = $b(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    n.glslVersion = this.glslVersion, n.uniforms = {};
    for (const r in this.uniforms) {
      const a = this.uniforms[r].value;
      a && a.isTexture ? n.uniforms[r] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? n.uniforms[r] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? n.uniforms[r] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? n.uniforms[r] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? n.uniforms[r] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? n.uniforms[r] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? n.uniforms[r] = {
        type: "m4",
        value: a.toArray()
      } : n.uniforms[r] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader, n.lights = this.lights, n.clipping = this.clipping;
    const i = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (n.extensions = i), n;
  }
}
class ry extends cn {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Zt(), this.projectionMatrix = new Zt(), this.projectionMatrixInverse = new Zt(), this.coordinateSystem = Es;
  }
  copy(e, n) {
    return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Xs = /* @__PURE__ */ new de(), wm = /* @__PURE__ */ new rt(), Sm = /* @__PURE__ */ new rt();
class ui extends ry {
  constructor(e = 50, n = 1, i = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const n = 0.5 * this.getFilmHeight() / e;
    this.fov = $o * 2 * Math.atan(n), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(Ga * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return $o * 2 * Math.atan(
      Math.tan(Ga * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, n, i) {
    Xs.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Xs.x, Xs.y).multiplyScalar(-e / Xs.z), Xs.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Xs.x, Xs.y).multiplyScalar(-e / Xs.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, n) {
    return this.getViewBounds(e, wm, Sm), n.subVectors(Sm, wm);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, n, i, r, o, a) {
    this.aspect = e / n, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = r, this.view.width = o, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = e * Math.tan(Ga * 0.5 * this.fov) / this.zoom, i = 2 * n, r = this.aspect * i, o = -0.5 * r;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = a.fullWidth, u = a.fullHeight;
      o += a.offsetX * r / c, n -= a.offsetY * i / u, r *= a.width / c, i *= a.height / u;
    }
    const l = this.filmOffset;
    l !== 0 && (o += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + r, n, n - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n;
  }
}
const ho = -90, fo = 1;
class jb extends cn {
  constructor(e, n, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new ui(ho, fo, e, n);
    r.layers = this.layers, this.add(r);
    const o = new ui(ho, fo, e, n);
    o.layers = this.layers, this.add(o);
    const a = new ui(ho, fo, e, n);
    a.layers = this.layers, this.add(a);
    const l = new ui(ho, fo, e, n);
    l.layers = this.layers, this.add(l);
    const c = new ui(ho, fo, e, n);
    c.layers = this.layers, this.add(c);
    const u = new ui(ho, fo, e, n);
    u.layers = this.layers, this.add(u);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, n = this.children.concat(), [i, r, o, a, l, c] = n;
    for (const u of n) this.remove(u);
    if (e === Es)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
    else if (e === eu)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const u of n)
      this.add(u), u.updateMatrixWorld();
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [o, a, l, c, u, d] = this.children, h = e.getRenderTarget(), m = e.getActiveCubeFace(), p = e.getActiveMipmapLevel(), v = e.xr.enabled;
    e.xr.enabled = !1;
    const x = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, r), e.render(n, o), e.setRenderTarget(i, 1, r), e.render(n, a), e.setRenderTarget(i, 2, r), e.render(n, l), e.setRenderTarget(i, 3, r), e.render(n, c), e.setRenderTarget(i, 4, r), e.render(n, u), i.texture.generateMipmaps = x, e.setRenderTarget(i, 5, r), e.render(n, d), e.setRenderTarget(h, m, p), e.xr.enabled = v, i.texture.needsPMREMUpdate = !0;
  }
}
class oy extends xn {
  constructor(e, n, i, r, o, a, l, c, u, d) {
    e = e !== void 0 ? e : [], n = n !== void 0 ? n : Bo, super(e, n, i, r, o, a, l, c, u, d), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Yb extends Ri {
  constructor(e = 1, n = {}) {
    super(e, e, n), this.isWebGLCubeRenderTarget = !0;
    const i = { width: e, height: e, depth: 1 }, r = [i, i, i, i, i, i];
    this.texture = new oy(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Bt;
  }
  fromEquirectangularTexture(e, n) {
    this.texture.type = n.type, this.texture.colorSpace = n.colorSpace, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, r = new pn(5, 5, 5), o = new zn({
      name: "CubemapFromEquirect",
      uniforms: Wo(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: hi,
      blending: rs
    });
    o.uniforms.tEquirect.value = n;
    const a = new Ze(r, o), l = n.minFilter;
    return n.minFilter === Ur && (n.minFilter = Bt), new jb(1, 10, this).update(e, a), n.minFilter = l, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(e, n, i, r) {
    const o = e.getRenderTarget();
    for (let a = 0; a < 6; a++)
      e.setRenderTarget(this, a), e.clear(n, i, r);
    e.setRenderTarget(o);
  }
}
const bd = /* @__PURE__ */ new de(), qb = /* @__PURE__ */ new de(), Zb = /* @__PURE__ */ new Et();
class Er {
  constructor(e = new de(1, 0, 0), n = 0) {
    this.isPlane = !0, this.normal = e, this.constant = n;
  }
  set(e, n) {
    return this.normal.copy(e), this.constant = n, this;
  }
  setComponents(e, n, i, r) {
    return this.normal.set(e, n, i), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), this.constant = -n.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, n, i) {
    const r = bd.subVectors(i, n).cross(qb.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, n) {
    const i = e.delta(bd), r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / r;
    return o < 0 || o > 1 ? null : n.copy(e.start).addScaledVector(i, o);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return n < 0 && i > 0 || i < 0 && n > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const i = n || Zb.getNormalMatrix(e), r = this.coplanarPoint(bd).applyMatrix4(e), o = this.normal.applyMatrix3(i).normalize();
    return this.constant = -r.dot(o), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const yr = /* @__PURE__ */ new wl(), tc = /* @__PURE__ */ new de();
class Lf {
  constructor(e = new Er(), n = new Er(), i = new Er(), r = new Er(), o = new Er(), a = new Er()) {
    this.planes = [e, n, i, r, o, a];
  }
  set(e, n, i, r, o, a) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(n), l[2].copy(i), l[3].copy(r), l[4].copy(o), l[5].copy(a), this;
  }
  copy(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      n[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, n = Es) {
    const i = this.planes, r = e.elements, o = r[0], a = r[1], l = r[2], c = r[3], u = r[4], d = r[5], h = r[6], m = r[7], p = r[8], v = r[9], x = r[10], g = r[11], _ = r[12], M = r[13], S = r[14], b = r[15];
    if (i[0].setComponents(c - o, m - u, g - p, b - _).normalize(), i[1].setComponents(c + o, m + u, g + p, b + _).normalize(), i[2].setComponents(c + a, m + d, g + v, b + M).normalize(), i[3].setComponents(c - a, m - d, g - v, b - M).normalize(), i[4].setComponents(c - l, m - h, g - x, b - S).normalize(), n === Es)
      i[5].setComponents(c + l, m + h, g + x, b + S).normalize();
    else if (n === eu)
      i[5].setComponents(l, h, x, S).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), yr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(), yr.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(yr);
  }
  intersectsSprite(e) {
    return yr.center.set(0, 0, 0), yr.radius = 0.7071067811865476, yr.applyMatrix4(e.matrixWorld), this.intersectsSphere(yr);
  }
  intersectsSphere(e) {
    const n = this.planes, i = e.center, r = -e.radius;
    for (let o = 0; o < 6; o++)
      if (n[o].distanceToPoint(i) < r)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = n[i];
      if (tc.x = r.normal.x > 0 ? e.max.x : e.min.x, tc.y = r.normal.y > 0 ? e.max.y : e.min.y, tc.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(tc) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      if (n[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function ay() {
  let s = null, e = !1, n = null, i = null;
  function r(o, a) {
    n(o, a), i = s.requestAnimationFrame(r);
  }
  return {
    start: function() {
      e !== !0 && n !== null && (i = s.requestAnimationFrame(r), e = !0);
    },
    stop: function() {
      s.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function(o) {
      n = o;
    },
    setContext: function(o) {
      s = o;
    }
  };
}
function Kb(s) {
  const e = /* @__PURE__ */ new WeakMap();
  function n(l, c) {
    const u = l.array, d = l.usage, h = u.byteLength, m = s.createBuffer();
    s.bindBuffer(c, m), s.bufferData(c, u, d), l.onUploadCallback();
    let p;
    if (u instanceof Float32Array)
      p = s.FLOAT;
    else if (u instanceof Uint16Array)
      l.isFloat16BufferAttribute ? p = s.HALF_FLOAT : p = s.UNSIGNED_SHORT;
    else if (u instanceof Int16Array)
      p = s.SHORT;
    else if (u instanceof Uint32Array)
      p = s.UNSIGNED_INT;
    else if (u instanceof Int32Array)
      p = s.INT;
    else if (u instanceof Int8Array)
      p = s.BYTE;
    else if (u instanceof Uint8Array)
      p = s.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray)
      p = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
    return {
      buffer: m,
      type: p,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: l.version,
      size: h
    };
  }
  function i(l, c, u) {
    const d = c.array, h = c.updateRanges;
    if (s.bindBuffer(u, l), h.length === 0)
      s.bufferSubData(u, 0, d);
    else {
      h.sort((p, v) => p.start - v.start);
      let m = 0;
      for (let p = 1; p < h.length; p++) {
        const v = h[m], x = h[p];
        x.start <= v.start + v.count + 1 ? v.count = Math.max(
          v.count,
          x.start + x.count - v.start
        ) : (++m, h[m] = x);
      }
      h.length = m + 1;
      for (let p = 0, v = h.length; p < v; p++) {
        const x = h[p];
        s.bufferSubData(
          u,
          x.start * d.BYTES_PER_ELEMENT,
          d,
          x.start,
          x.count
        );
      }
      c.clearUpdateRanges();
    }
    c.onUploadCallback();
  }
  function r(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function o(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const c = e.get(l);
    c && (s.deleteBuffer(c.buffer), e.delete(l));
  }
  function a(l, c) {
    if (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute) {
      const d = e.get(l);
      (!d || d.version < l.version) && e.set(l, {
        buffer: l.buffer,
        type: l.type,
        bytesPerElement: l.elementSize,
        version: l.version
      });
      return;
    }
    const u = e.get(l);
    if (u === void 0)
      e.set(l, n(l, c));
    else if (u.version < l.version) {
      if (u.size !== l.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      i(u.buffer, l, c), u.version = l.version;
    }
  }
  return {
    get: r,
    remove: o,
    update: a
  };
}
class un extends Vt {
  constructor(e = 1, n = 1, i = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: n,
      widthSegments: i,
      heightSegments: r
    };
    const o = e / 2, a = n / 2, l = Math.floor(i), c = Math.floor(r), u = l + 1, d = c + 1, h = e / l, m = n / c, p = [], v = [], x = [], g = [];
    for (let _ = 0; _ < d; _++) {
      const M = _ * m - a;
      for (let S = 0; S < u; S++) {
        const b = S * h - o;
        v.push(b, -M, 0), x.push(0, 0, 1), g.push(S / l), g.push(1 - _ / c);
      }
    }
    for (let _ = 0; _ < c; _++)
      for (let M = 0; M < l; M++) {
        const S = M + u * _, b = M + u * (_ + 1), C = M + 1 + u * (_ + 1), E = M + 1 + u * _;
        p.push(S, b, E), p.push(b, C, E);
      }
    this.setIndex(p), this.setAttribute("position", new Pt(v, 3)), this.setAttribute("normal", new Pt(x, 3)), this.setAttribute("uv", new Pt(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new un(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var Jb = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Qb = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, ew = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, tw = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, nw = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, iw = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, sw = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, rw = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, ow = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, aw = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, lw = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, cw = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, uw = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, dw = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, hw = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, fw = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, pw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, mw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, vw = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, gw = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, yw = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, _w = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, xw = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, bw = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, ww = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Sw = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Mw = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Cw = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, Ew = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Tw = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Aw = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Pw = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, Rw = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Dw = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, kw = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Iw = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, Lw = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Fw = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Uw = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Ow = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, zw = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Nw = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Bw = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Vw = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Gw = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Hw = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, $w = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Ww = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Xw = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, jw = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Yw = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, qw = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Zw = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Kw = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Jw = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Qw = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, eS = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, tS = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, nS = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, iS = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, sS = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, rS = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, oS = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, aS = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, lS = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, cS = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, uS = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, dS = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, hS = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, fS = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, pS = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, mS = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, vS = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, gS = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, yS = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, _S = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, xS = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, bS = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, wS = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, SS = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, MS = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, CS = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, ES = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, TS = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, AS = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, PS = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, RS = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, DS = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, kS = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, IS = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, LS = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, FS = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, US = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, OS = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, zS = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, NS = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, BS = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, VS = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, GS = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, HS = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, $S = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, WS = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, XS = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, jS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, YS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, qS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, ZS = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const KS = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, JS = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, QS = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, eM = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, tM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, nM = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, iM = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, sM = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, rM = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, oM = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, aM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, lM = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, cM = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, uM = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, dM = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, hM = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, fM = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, pM = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, mM = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, vM = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, gM = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, yM = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, _M = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, xM = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, bM = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, wM = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, SM = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, MM = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, CM = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, EM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, TM = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, AM = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, PM = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, RM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Tt = {
  alphahash_fragment: Jb,
  alphahash_pars_fragment: Qb,
  alphamap_fragment: ew,
  alphamap_pars_fragment: tw,
  alphatest_fragment: nw,
  alphatest_pars_fragment: iw,
  aomap_fragment: sw,
  aomap_pars_fragment: rw,
  batching_pars_vertex: ow,
  batching_vertex: aw,
  begin_vertex: lw,
  beginnormal_vertex: cw,
  bsdfs: uw,
  iridescence_fragment: dw,
  bumpmap_pars_fragment: hw,
  clipping_planes_fragment: fw,
  clipping_planes_pars_fragment: pw,
  clipping_planes_pars_vertex: mw,
  clipping_planes_vertex: vw,
  color_fragment: gw,
  color_pars_fragment: yw,
  color_pars_vertex: _w,
  color_vertex: xw,
  common: bw,
  cube_uv_reflection_fragment: ww,
  defaultnormal_vertex: Sw,
  displacementmap_pars_vertex: Mw,
  displacementmap_vertex: Cw,
  emissivemap_fragment: Ew,
  emissivemap_pars_fragment: Tw,
  colorspace_fragment: Aw,
  colorspace_pars_fragment: Pw,
  envmap_fragment: Rw,
  envmap_common_pars_fragment: Dw,
  envmap_pars_fragment: kw,
  envmap_pars_vertex: Iw,
  envmap_physical_pars_fragment: $w,
  envmap_vertex: Lw,
  fog_vertex: Fw,
  fog_pars_vertex: Uw,
  fog_fragment: Ow,
  fog_pars_fragment: zw,
  gradientmap_pars_fragment: Nw,
  lightmap_pars_fragment: Bw,
  lights_lambert_fragment: Vw,
  lights_lambert_pars_fragment: Gw,
  lights_pars_begin: Hw,
  lights_toon_fragment: Ww,
  lights_toon_pars_fragment: Xw,
  lights_phong_fragment: jw,
  lights_phong_pars_fragment: Yw,
  lights_physical_fragment: qw,
  lights_physical_pars_fragment: Zw,
  lights_fragment_begin: Kw,
  lights_fragment_maps: Jw,
  lights_fragment_end: Qw,
  logdepthbuf_fragment: eS,
  logdepthbuf_pars_fragment: tS,
  logdepthbuf_pars_vertex: nS,
  logdepthbuf_vertex: iS,
  map_fragment: sS,
  map_pars_fragment: rS,
  map_particle_fragment: oS,
  map_particle_pars_fragment: aS,
  metalnessmap_fragment: lS,
  metalnessmap_pars_fragment: cS,
  morphinstance_vertex: uS,
  morphcolor_vertex: dS,
  morphnormal_vertex: hS,
  morphtarget_pars_vertex: fS,
  morphtarget_vertex: pS,
  normal_fragment_begin: mS,
  normal_fragment_maps: vS,
  normal_pars_fragment: gS,
  normal_pars_vertex: yS,
  normal_vertex: _S,
  normalmap_pars_fragment: xS,
  clearcoat_normal_fragment_begin: bS,
  clearcoat_normal_fragment_maps: wS,
  clearcoat_pars_fragment: SS,
  iridescence_pars_fragment: MS,
  opaque_fragment: CS,
  packing: ES,
  premultiplied_alpha_fragment: TS,
  project_vertex: AS,
  dithering_fragment: PS,
  dithering_pars_fragment: RS,
  roughnessmap_fragment: DS,
  roughnessmap_pars_fragment: kS,
  shadowmap_pars_fragment: IS,
  shadowmap_pars_vertex: LS,
  shadowmap_vertex: FS,
  shadowmask_pars_fragment: US,
  skinbase_vertex: OS,
  skinning_pars_vertex: zS,
  skinning_vertex: NS,
  skinnormal_vertex: BS,
  specularmap_fragment: VS,
  specularmap_pars_fragment: GS,
  tonemapping_fragment: HS,
  tonemapping_pars_fragment: $S,
  transmission_fragment: WS,
  transmission_pars_fragment: XS,
  uv_pars_fragment: jS,
  uv_pars_vertex: YS,
  uv_vertex: qS,
  worldpos_vertex: ZS,
  background_vert: KS,
  background_frag: JS,
  backgroundCube_vert: QS,
  backgroundCube_frag: eM,
  cube_vert: tM,
  cube_frag: nM,
  depth_vert: iM,
  depth_frag: sM,
  distanceRGBA_vert: rM,
  distanceRGBA_frag: oM,
  equirect_vert: aM,
  equirect_frag: lM,
  linedashed_vert: cM,
  linedashed_frag: uM,
  meshbasic_vert: dM,
  meshbasic_frag: hM,
  meshlambert_vert: fM,
  meshlambert_frag: pM,
  meshmatcap_vert: mM,
  meshmatcap_frag: vM,
  meshnormal_vert: gM,
  meshnormal_frag: yM,
  meshphong_vert: _M,
  meshphong_frag: xM,
  meshphysical_vert: bM,
  meshphysical_frag: wM,
  meshtoon_vert: SM,
  meshtoon_frag: MM,
  points_vert: CM,
  points_frag: EM,
  shadow_vert: TM,
  shadow_frag: AM,
  sprite_vert: PM,
  sprite_frag: RM
}, tt = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Et() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Et() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Et() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Et() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Et() },
    normalScale: { value: /* @__PURE__ */ new rt(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Et() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Mt(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Et() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Et() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new rt(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Et() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Et() },
    alphaTest: { value: 0 }
  }
}, is = {
  basic: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.specularmap,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.fog
    ]),
    vertexShader: Tt.meshbasic_vert,
    fragmentShader: Tt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.specularmap,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) }
      }
    ]),
    vertexShader: Tt.meshlambert_vert,
    fragmentShader: Tt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.specularmap,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) },
        specular: { value: /* @__PURE__ */ new Mt(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Tt.meshphong_vert,
    fragmentShader: Tt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.roughnessmap,
      tt.metalnessmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Tt.meshphysical_vert,
    fragmentShader: Tt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.gradientmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) }
      }
    ]),
    vertexShader: Tt.meshtoon_vert,
    fragmentShader: Tt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Tt.meshmatcap_vert,
    fragmentShader: Tt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ ei([
      tt.points,
      tt.fog
    ]),
    vertexShader: Tt.points_vert,
    fragmentShader: Tt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Tt.linedashed_vert,
    fragmentShader: Tt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.displacementmap
    ]),
    vertexShader: Tt.depth_vert,
    fragmentShader: Tt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Tt.meshnormal_vert,
    fragmentShader: Tt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ ei([
      tt.sprite,
      tt.fog
    ]),
    vertexShader: Tt.sprite_vert,
    fragmentShader: Tt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Et() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Tt.background_vert,
    fragmentShader: Tt.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Et() }
    },
    vertexShader: Tt.backgroundCube_vert,
    fragmentShader: Tt.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Tt.cube_vert,
    fragmentShader: Tt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Tt.equirect_vert,
    fragmentShader: Tt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new de() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Tt.distanceRGBA_vert,
    fragmentShader: Tt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ ei([
      tt.lights,
      tt.fog,
      {
        color: { value: /* @__PURE__ */ new Mt(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Tt.shadow_vert,
    fragmentShader: Tt.shadow_frag
  }
};
is.physical = {
  uniforms: /* @__PURE__ */ ei([
    is.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Et() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Et() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new rt(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Et() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Et() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Et() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Mt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Et() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Et() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Et() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new rt() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Et() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Mt(0) },
      specularColor: { value: /* @__PURE__ */ new Mt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Et() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Et() },
      anisotropyVector: { value: /* @__PURE__ */ new rt() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Et() }
    }
  ]),
  vertexShader: Tt.meshphysical_vert,
  fragmentShader: Tt.meshphysical_frag
};
const nc = { r: 0, b: 0, g: 0 }, _r = /* @__PURE__ */ new Mi(), DM = /* @__PURE__ */ new Zt();
function kM(s, e, n, i, r, o, a) {
  const l = new Mt(0);
  let c = o === !0 ? 0 : 1, u, d, h = null, m = 0, p = null;
  function v(M) {
    let S = M.isScene === !0 ? M.background : null;
    return S && S.isTexture && (S = (M.backgroundBlurriness > 0 ? n : e).get(S)), S;
  }
  function x(M) {
    let S = !1;
    const b = v(M);
    b === null ? _(l, c) : b && b.isColor && (_(b, 1), S = !0);
    const C = s.xr.getEnvironmentBlendMode();
    C === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : C === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (s.autoClear || S) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
  }
  function g(M, S) {
    const b = v(S);
    b && (b.isCubeTexture || b.mapping === Mu) ? (d === void 0 && (d = new Ze(
      new pn(1, 1, 1),
      new zn({
        name: "BackgroundCubeMaterial",
        uniforms: Wo(is.backgroundCube.uniforms),
        vertexShader: is.backgroundCube.vertexShader,
        fragmentShader: is.backgroundCube.fragmentShader,
        side: hi,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), d.geometry.deleteAttribute("normal"), d.geometry.deleteAttribute("uv"), d.onBeforeRender = function(C, E, P) {
      this.matrixWorld.copyPosition(P.matrixWorld);
    }, Object.defineProperty(d.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(d)), _r.copy(S.backgroundRotation), _r.x *= -1, _r.y *= -1, _r.z *= -1, b.isCubeTexture && b.isRenderTargetTexture === !1 && (_r.y *= -1, _r.z *= -1), d.material.uniforms.envMap.value = b, d.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1, d.material.uniforms.backgroundBlurriness.value = S.backgroundBlurriness, d.material.uniforms.backgroundIntensity.value = S.backgroundIntensity, d.material.uniforms.backgroundRotation.value.setFromMatrix4(DM.makeRotationFromEuler(_r)), d.material.toneMapped = It.getTransfer(b.colorSpace) !== qt, (h !== b || m !== b.version || p !== s.toneMapping) && (d.material.needsUpdate = !0, h = b, m = b.version, p = s.toneMapping), d.layers.enableAll(), M.unshift(d, d.geometry, d.material, 0, 0, null)) : b && b.isTexture && (u === void 0 && (u = new Ze(
      new un(2, 2),
      new zn({
        name: "BackgroundMaterial",
        uniforms: Wo(is.background.uniforms),
        vertexShader: is.background.vertexShader,
        fragmentShader: is.background.fragmentShader,
        side: or,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(u)), u.material.uniforms.t2D.value = b, u.material.uniforms.backgroundIntensity.value = S.backgroundIntensity, u.material.toneMapped = It.getTransfer(b.colorSpace) !== qt, b.matrixAutoUpdate === !0 && b.updateMatrix(), u.material.uniforms.uvTransform.value.copy(b.matrix), (h !== b || m !== b.version || p !== s.toneMapping) && (u.material.needsUpdate = !0, h = b, m = b.version, p = s.toneMapping), u.layers.enableAll(), M.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function _(M, S) {
    M.getRGB(nc, sy(s)), i.buffers.color.setClear(nc.r, nc.g, nc.b, S, a);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(M, S = 1) {
      l.set(M), c = S, _(l, c);
    },
    getClearAlpha: function() {
      return c;
    },
    setClearAlpha: function(M) {
      c = M, _(l, c);
    },
    render: x,
    addToRenderList: g
  };
}
function IM(s, e) {
  const n = s.getParameter(s.MAX_VERTEX_ATTRIBS), i = {}, r = m(null);
  let o = r, a = !1;
  function l(w, D, U, R, O) {
    let A = !1;
    const G = h(R, U, D);
    o !== G && (o = G, u(o.object)), A = p(w, R, U, O), A && v(w, R, U, O), O !== null && e.update(O, s.ELEMENT_ARRAY_BUFFER), (A || a) && (a = !1, b(w, D, U, R), O !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(O).buffer));
  }
  function c() {
    return s.createVertexArray();
  }
  function u(w) {
    return s.bindVertexArray(w);
  }
  function d(w) {
    return s.deleteVertexArray(w);
  }
  function h(w, D, U) {
    const R = U.wireframe === !0;
    let O = i[w.id];
    O === void 0 && (O = {}, i[w.id] = O);
    let A = O[D.id];
    A === void 0 && (A = {}, O[D.id] = A);
    let G = A[R];
    return G === void 0 && (G = m(c()), A[R] = G), G;
  }
  function m(w) {
    const D = [], U = [], R = [];
    for (let O = 0; O < n; O++)
      D[O] = 0, U[O] = 0, R[O] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: D,
      enabledAttributes: U,
      attributeDivisors: R,
      object: w,
      attributes: {},
      index: null
    };
  }
  function p(w, D, U, R) {
    const O = o.attributes, A = D.attributes;
    let G = 0;
    const ue = U.getAttributes();
    for (const Q in ue)
      if (ue[Q].location >= 0) {
        const re = O[Q];
        let j = A[Q];
        if (j === void 0 && (Q === "instanceMatrix" && w.instanceMatrix && (j = w.instanceMatrix), Q === "instanceColor" && w.instanceColor && (j = w.instanceColor)), re === void 0 || re.attribute !== j || j && re.data !== j.data) return !0;
        G++;
      }
    return o.attributesNum !== G || o.index !== R;
  }
  function v(w, D, U, R) {
    const O = {}, A = D.attributes;
    let G = 0;
    const ue = U.getAttributes();
    for (const Q in ue)
      if (ue[Q].location >= 0) {
        let re = A[Q];
        re === void 0 && (Q === "instanceMatrix" && w.instanceMatrix && (re = w.instanceMatrix), Q === "instanceColor" && w.instanceColor && (re = w.instanceColor));
        const j = {};
        j.attribute = re, re && re.data && (j.data = re.data), O[Q] = j, G++;
      }
    o.attributes = O, o.attributesNum = G, o.index = R;
  }
  function x() {
    const w = o.newAttributes;
    for (let D = 0, U = w.length; D < U; D++)
      w[D] = 0;
  }
  function g(w) {
    _(w, 0);
  }
  function _(w, D) {
    const U = o.newAttributes, R = o.enabledAttributes, O = o.attributeDivisors;
    U[w] = 1, R[w] === 0 && (s.enableVertexAttribArray(w), R[w] = 1), O[w] !== D && (s.vertexAttribDivisor(w, D), O[w] = D);
  }
  function M() {
    const w = o.newAttributes, D = o.enabledAttributes;
    for (let U = 0, R = D.length; U < R; U++)
      D[U] !== w[U] && (s.disableVertexAttribArray(U), D[U] = 0);
  }
  function S(w, D, U, R, O, A, G) {
    G === !0 ? s.vertexAttribIPointer(w, D, U, O, A) : s.vertexAttribPointer(w, D, U, R, O, A);
  }
  function b(w, D, U, R) {
    x();
    const O = R.attributes, A = U.getAttributes(), G = D.defaultAttributeValues;
    for (const ue in A) {
      const Q = A[ue];
      if (Q.location >= 0) {
        let le = O[ue];
        if (le === void 0 && (ue === "instanceMatrix" && w.instanceMatrix && (le = w.instanceMatrix), ue === "instanceColor" && w.instanceColor && (le = w.instanceColor)), le !== void 0) {
          const re = le.normalized, j = le.itemSize, $ = e.get(le);
          if ($ === void 0) continue;
          const q = $.buffer, oe = $.type, ie = $.bytesPerElement, ce = oe === s.INT || oe === s.UNSIGNED_INT || le.gpuType === Sf;
          if (le.isInterleavedBufferAttribute) {
            const V = le.data, Y = V.stride, H = le.offset;
            if (V.isInstancedInterleavedBuffer) {
              for (let I = 0; I < Q.locationSize; I++)
                _(Q.location + I, V.meshPerAttribute);
              w.isInstancedMesh !== !0 && R._maxInstanceCount === void 0 && (R._maxInstanceCount = V.meshPerAttribute * V.count);
            } else
              for (let I = 0; I < Q.locationSize; I++)
                g(Q.location + I);
            s.bindBuffer(s.ARRAY_BUFFER, q);
            for (let I = 0; I < Q.locationSize; I++)
              S(
                Q.location + I,
                j / Q.locationSize,
                oe,
                re,
                Y * ie,
                (H + j / Q.locationSize * I) * ie,
                ce
              );
          } else {
            if (le.isInstancedBufferAttribute) {
              for (let V = 0; V < Q.locationSize; V++)
                _(Q.location + V, le.meshPerAttribute);
              w.isInstancedMesh !== !0 && R._maxInstanceCount === void 0 && (R._maxInstanceCount = le.meshPerAttribute * le.count);
            } else
              for (let V = 0; V < Q.locationSize; V++)
                g(Q.location + V);
            s.bindBuffer(s.ARRAY_BUFFER, q);
            for (let V = 0; V < Q.locationSize; V++)
              S(
                Q.location + V,
                j / Q.locationSize,
                oe,
                re,
                j * ie,
                j / Q.locationSize * V * ie,
                ce
              );
          }
        } else if (G !== void 0) {
          const re = G[ue];
          if (re !== void 0)
            switch (re.length) {
              case 2:
                s.vertexAttrib2fv(Q.location, re);
                break;
              case 3:
                s.vertexAttrib3fv(Q.location, re);
                break;
              case 4:
                s.vertexAttrib4fv(Q.location, re);
                break;
              default:
                s.vertexAttrib1fv(Q.location, re);
            }
        }
      }
    }
    M();
  }
  function C() {
    T();
    for (const w in i) {
      const D = i[w];
      for (const U in D) {
        const R = D[U];
        for (const O in R)
          d(R[O].object), delete R[O];
        delete D[U];
      }
      delete i[w];
    }
  }
  function E(w) {
    if (i[w.id] === void 0) return;
    const D = i[w.id];
    for (const U in D) {
      const R = D[U];
      for (const O in R)
        d(R[O].object), delete R[O];
      delete D[U];
    }
    delete i[w.id];
  }
  function P(w) {
    for (const D in i) {
      const U = i[D];
      if (U[w.id] === void 0) continue;
      const R = U[w.id];
      for (const O in R)
        d(R[O].object), delete R[O];
      delete U[w.id];
    }
  }
  function T() {
    y(), a = !0, o !== r && (o = r, u(o.object));
  }
  function y() {
    r.geometry = null, r.program = null, r.wireframe = !1;
  }
  return {
    setup: l,
    reset: T,
    resetDefaultState: y,
    dispose: C,
    releaseStatesOfGeometry: E,
    releaseStatesOfProgram: P,
    initAttributes: x,
    enableAttribute: g,
    disableUnusedAttributes: M
  };
}
function LM(s, e, n) {
  let i;
  function r(u) {
    i = u;
  }
  function o(u, d) {
    s.drawArrays(i, u, d), n.update(d, i, 1);
  }
  function a(u, d, h) {
    h !== 0 && (s.drawArraysInstanced(i, u, d, h), n.update(d, i, h));
  }
  function l(u, d, h) {
    if (h === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, u, 0, d, 0, h);
    let p = 0;
    for (let v = 0; v < h; v++)
      p += d[v];
    n.update(p, i, 1);
  }
  function c(u, d, h, m) {
    if (h === 0) return;
    const p = e.get("WEBGL_multi_draw");
    if (p === null)
      for (let v = 0; v < u.length; v++)
        a(u[v], d[v], m[v]);
    else {
      p.multiDrawArraysInstancedWEBGL(i, u, 0, d, 0, m, 0, h);
      let v = 0;
      for (let x = 0; x < h; x++)
        v += d[x] * m[x];
      n.update(v, i, 1);
    }
  }
  this.setMode = r, this.render = o, this.renderInstances = a, this.renderMultiDraw = l, this.renderMultiDrawInstances = c;
}
function FM(s, e, n, i) {
  let r;
  function o() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const P = e.get("EXT_texture_filter_anisotropic");
      r = s.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      r = 0;
    return r;
  }
  function a(P) {
    return !(P !== Un && i.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function l(P) {
    const T = P === ur && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(P !== Xi && i.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    P !== di && !T);
  }
  function c(P) {
    if (P === "highp") {
      if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
        return "highp";
      P = "mediump";
    }
    return P === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let u = n.precision !== void 0 ? n.precision : "highp";
  const d = c(u);
  d !== u && (console.warn("THREE.WebGLRenderer:", u, "not supported, using", d, "instead."), u = d);
  const h = n.logarithmicDepthBuffer === !0, m = n.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), p = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), v = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), x = s.getParameter(s.MAX_TEXTURE_SIZE), g = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), _ = s.getParameter(s.MAX_VERTEX_ATTRIBS), M = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), S = s.getParameter(s.MAX_VARYING_VECTORS), b = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), C = v > 0, E = s.getParameter(s.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: o,
    getMaxPrecision: c,
    textureFormatReadable: a,
    textureTypeReadable: l,
    precision: u,
    logarithmicDepthBuffer: h,
    reverseDepthBuffer: m,
    maxTextures: p,
    maxVertexTextures: v,
    maxTextureSize: x,
    maxCubemapSize: g,
    maxAttributes: _,
    maxVertexUniforms: M,
    maxVaryings: S,
    maxFragmentUniforms: b,
    vertexTextures: C,
    maxSamples: E
  };
}
function UM(s) {
  const e = this;
  let n = null, i = 0, r = !1, o = !1;
  const a = new Er(), l = new Et(), c = { value: null, needsUpdate: !1 };
  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, m) {
    const p = h.length !== 0 || m || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || r;
    return r = m, i = h.length, p;
  }, this.beginShadows = function() {
    o = !0, d(null);
  }, this.endShadows = function() {
    o = !1;
  }, this.setGlobalState = function(h, m) {
    n = d(h, m, 0);
  }, this.setState = function(h, m, p) {
    const v = h.clippingPlanes, x = h.clipIntersection, g = h.clipShadows, _ = s.get(h);
    if (!r || v === null || v.length === 0 || o && !g)
      o ? d(null) : u();
    else {
      const M = o ? 0 : i, S = M * 4;
      let b = _.clippingState || null;
      c.value = b, b = d(v, m, S, p);
      for (let C = 0; C !== S; ++C)
        b[C] = n[C];
      _.clippingState = b, this.numIntersection = x ? this.numPlanes : 0, this.numPlanes += M;
    }
  };
  function u() {
    c.value !== n && (c.value = n, c.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function d(h, m, p, v) {
    const x = h !== null ? h.length : 0;
    let g = null;
    if (x !== 0) {
      if (g = c.value, v !== !0 || g === null) {
        const _ = p + x * 4, M = m.matrixWorldInverse;
        l.getNormalMatrix(M), (g === null || g.length < _) && (g = new Float32Array(_));
        for (let S = 0, b = p; S !== x; ++S, b += 4)
          a.copy(h[S]).applyMatrix4(M, l), a.normal.toArray(g, b), g[b + 3] = a.constant;
      }
      c.value = g, c.needsUpdate = !0;
    }
    return e.numPlanes = x, e.numIntersection = 0, g;
  }
}
function OM(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(a, l) {
    return l === gh ? a.mapping = Bo : l === yh && (a.mapping = Vo), a;
  }
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping;
      if (l === gh || l === yh)
        if (e.has(a)) {
          const c = e.get(a).texture;
          return n(c, a.mapping);
        } else {
          const c = a.image;
          if (c && c.height > 0) {
            const u = new Yb(c.height);
            return u.fromEquirectangularTexture(s, a), e.set(a, u), a.addEventListener("dispose", r), n(u.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function r(a) {
    const l = a.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: o
  };
}
class Eu extends ry {
  constructor(e = -1, n = 1, i = 1, r = -1, o = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = i, this.bottom = r, this.near = o, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, n, i, r, o, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = r, this.view.width = o, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let o = i - e, a = i + e, l = r + n, c = r - n;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += u * this.view.offsetX, a = o + u * this.view.width, l -= d * this.view.offsetY, c = l - d * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, a, l, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n;
  }
}
const Mo = 4, Mm = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Dr = 20, wd = /* @__PURE__ */ new Eu(), Cm = /* @__PURE__ */ new Mt();
let Sd = null, Md = 0, Cd = 0, Ed = !1;
const Tr = (1 + Math.sqrt(5)) / 2, po = 1 / Tr, Em = [
  /* @__PURE__ */ new de(-Tr, po, 0),
  /* @__PURE__ */ new de(Tr, po, 0),
  /* @__PURE__ */ new de(-po, 0, Tr),
  /* @__PURE__ */ new de(po, 0, Tr),
  /* @__PURE__ */ new de(0, Tr, -po),
  /* @__PURE__ */ new de(0, Tr, po),
  /* @__PURE__ */ new de(-1, 1, -1),
  /* @__PURE__ */ new de(1, 1, -1),
  /* @__PURE__ */ new de(-1, 1, 1),
  /* @__PURE__ */ new de(1, 1, 1)
];
class Tm {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, n = 0, i = 0.1, r = 100) {
    Sd = this._renderer.getRenderTarget(), Md = this._renderer.getActiveCubeFace(), Cd = this._renderer.getActiveMipmapLevel(), Ed = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const o = this._allocateTargets();
    return o.depthBuffer = !0, this._sceneToCubeUV(e, i, r, o), n > 0 && this._blur(o, 0, 0, n), this._applyPMREM(o), this._cleanup(o), o;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = Rm(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = Pm(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Sd, Md, Cd), this._renderer.xr.enabled = Ed, e.scissorTest = !1, ic(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === Bo || e.mapping === Vo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Sd = this._renderer.getRenderTarget(), Md = this._renderer.getActiveCubeFace(), Cd = this._renderer.getActiveMipmapLevel(), Ed = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const i = n || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), n = 4 * this._cubeSize, i = {
      magFilter: Bt,
      minFilter: Bt,
      generateMipmaps: !1,
      type: ur,
      format: Un,
      colorSpace: Zo,
      depthBuffer: !1
    }, r = Am(e, n, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Am(e, n, i);
      const { _lodMax: o } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = zM(o)), this._blurMaterial = NM(o, e, n);
    }
    return r;
  }
  _compileMaterial(e) {
    const n = new Ze(this._lodPlanes[0], e);
    this._renderer.compile(n, wd);
  }
  _sceneToCubeUV(e, n, i, r) {
    const l = new ui(90, 1, n, i), c = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], d = this._renderer, h = d.autoClear, m = d.toneMapping;
    d.getClearColor(Cm), d.toneMapping = rr, d.autoClear = !1;
    const p = new En({
      name: "PMREM.Background",
      side: hi,
      depthWrite: !1,
      depthTest: !1
    }), v = new Ze(new pn(), p);
    let x = !1;
    const g = e.background;
    g ? g.isColor && (p.color.copy(g), e.background = null, x = !0) : (p.color.copy(Cm), x = !0);
    for (let _ = 0; _ < 6; _++) {
      const M = _ % 3;
      M === 0 ? (l.up.set(0, c[_], 0), l.lookAt(u[_], 0, 0)) : M === 1 ? (l.up.set(0, 0, c[_]), l.lookAt(0, u[_], 0)) : (l.up.set(0, c[_], 0), l.lookAt(0, 0, u[_]));
      const S = this._cubeSize;
      ic(r, M * S, _ > 2 ? S : 0, S, S), d.setRenderTarget(r), x && d.render(v, l), d.render(e, l);
    }
    v.geometry.dispose(), v.material.dispose(), d.toneMapping = m, d.autoClear = h, e.background = g;
  }
  _textureToCubeUV(e, n) {
    const i = this._renderer, r = e.mapping === Bo || e.mapping === Vo;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = Rm()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Pm());
    const o = r ? this._cubemapMaterial : this._equirectMaterial, a = new Ze(this._lodPlanes[0], o), l = o.uniforms;
    l.envMap.value = e;
    const c = this._cubeSize;
    ic(n, 0, 0, 3 * c, 2 * c), i.setRenderTarget(n), i.render(a, wd);
  }
  _applyPMREM(e) {
    const n = this._renderer, i = n.autoClear;
    n.autoClear = !1;
    const r = this._lodPlanes.length;
    for (let o = 1; o < r; o++) {
      const a = Math.sqrt(this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1]), l = Em[(r - o - 1) % Em.length];
      this._blur(e, o - 1, o, a, l);
    }
    n.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, n, i, r, o) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      a,
      n,
      i,
      r,
      "latitudinal",
      o
    ), this._halfBlur(
      a,
      e,
      i,
      i,
      r,
      "longitudinal",
      o
    );
  }
  _halfBlur(e, n, i, r, o, a, l) {
    const c = this._renderer, u = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const d = 3, h = new Ze(this._lodPlanes[r], u), m = u.uniforms, p = this._sizeLods[i] - 1, v = isFinite(o) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * Dr - 1), x = o / v, g = isFinite(o) ? 1 + Math.floor(d * x) : Dr;
    g > Dr && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Dr}`);
    const _ = [];
    let M = 0;
    for (let P = 0; P < Dr; ++P) {
      const T = P / x, y = Math.exp(-T * T / 2);
      _.push(y), P === 0 ? M += y : P < g && (M += 2 * y);
    }
    for (let P = 0; P < _.length; P++)
      _[P] = _[P] / M;
    m.envMap.value = e.texture, m.samples.value = g, m.weights.value = _, m.latitudinal.value = a === "latitudinal", l && (m.poleAxis.value = l);
    const { _lodMax: S } = this;
    m.dTheta.value = v, m.mipInt.value = S - i;
    const b = this._sizeLods[r], C = 3 * b * (r > S - Mo ? r - S + Mo : 0), E = 4 * (this._cubeSize - b);
    ic(n, C, E, 3 * b, 2 * b), c.setRenderTarget(n), c.render(h, wd);
  }
}
function zM(s) {
  const e = [], n = [], i = [];
  let r = s;
  const o = s - Mo + 1 + Mm.length;
  for (let a = 0; a < o; a++) {
    const l = Math.pow(2, r);
    n.push(l);
    let c = 1 / l;
    a > s - Mo ? c = Mm[a - s + Mo - 1] : a === 0 && (c = 0), i.push(c);
    const u = 1 / (l - 2), d = -u, h = 1 + u, m = [d, d, h, d, h, h, d, d, h, h, d, h], p = 6, v = 6, x = 3, g = 2, _ = 1, M = new Float32Array(x * v * p), S = new Float32Array(g * v * p), b = new Float32Array(_ * v * p);
    for (let E = 0; E < p; E++) {
      const P = E % 3 * 2 / 3 - 1, T = E > 2 ? 0 : -1, y = [
        P,
        T,
        0,
        P + 2 / 3,
        T,
        0,
        P + 2 / 3,
        T + 1,
        0,
        P,
        T,
        0,
        P + 2 / 3,
        T + 1,
        0,
        P,
        T + 1,
        0
      ];
      M.set(y, x * v * E), S.set(m, g * v * E);
      const w = [E, E, E, E, E, E];
      b.set(w, _ * v * E);
    }
    const C = new Vt();
    C.setAttribute("position", new Si(M, x)), C.setAttribute("uv", new Si(S, g)), C.setAttribute("faceIndex", new Si(b, _)), e.push(C), r > Mo && r--;
  }
  return { lodPlanes: e, sizeLods: n, sigmas: i };
}
function Am(s, e, n) {
  const i = new Ri(s, e, n);
  return i.texture.mapping = Mu, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function ic(s, e, n, i, r) {
  s.viewport.set(e, n, i, r), s.scissor.set(e, n, i, r);
}
function NM(s, e, n) {
  const i = new Float32Array(Dr), r = new de(0, 1, 0);
  return new zn({
    name: "SphericalGaussianBlur",
    defines: {
      n: Dr,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${s}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r }
    },
    vertexShader: Ff(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: rs,
    depthTest: !1,
    depthWrite: !1
  });
}
function Pm() {
  return new zn({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: Ff(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: rs,
    depthTest: !1,
    depthWrite: !1
  });
}
function Rm() {
  return new zn({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: Ff(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: rs,
    depthTest: !1,
    depthWrite: !1
  });
}
function Ff() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function BM(s) {
  let e = /* @__PURE__ */ new WeakMap(), n = null;
  function i(l) {
    if (l && l.isTexture) {
      const c = l.mapping, u = c === gh || c === yh, d = c === Bo || c === Vo;
      if (u || d) {
        let h = e.get(l);
        const m = h !== void 0 ? h.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== m)
          return n === null && (n = new Tm(s)), h = u ? n.fromEquirectangular(l, h) : n.fromCubemap(l, h), h.texture.pmremVersion = l.pmremVersion, e.set(l, h), h.texture;
        if (h !== void 0)
          return h.texture;
        {
          const p = l.image;
          return u && p && p.height > 0 || d && p && r(p) ? (n === null && (n = new Tm(s)), h = u ? n.fromEquirectangular(l) : n.fromCubemap(l), h.texture.pmremVersion = l.pmremVersion, e.set(l, h), l.addEventListener("dispose", o), h.texture) : null;
        }
      }
    }
    return l;
  }
  function r(l) {
    let c = 0;
    const u = 6;
    for (let d = 0; d < u; d++)
      l[d] !== void 0 && c++;
    return c === u;
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o);
    const u = e.get(c);
    u !== void 0 && (e.delete(c), u.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap(), n !== null && (n.dispose(), n = null);
  }
  return {
    get: i,
    dispose: a
  };
}
function VM(s) {
  const e = {};
  function n(i) {
    if (e[i] !== void 0)
      return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = s.getExtension(i);
    }
    return e[i] = r, r;
  }
  return {
    has: function(i) {
      return n(i) !== null;
    },
    init: function() {
      n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent");
    },
    get: function(i) {
      const r = n(i);
      return r === null && Pa("THREE.WebGLRenderer: " + i + " extension not supported."), r;
    }
  };
}
function GM(s, e, n, i) {
  const r = {}, o = /* @__PURE__ */ new WeakMap();
  function a(h) {
    const m = h.target;
    m.index !== null && e.remove(m.index);
    for (const v in m.attributes)
      e.remove(m.attributes[v]);
    for (const v in m.morphAttributes) {
      const x = m.morphAttributes[v];
      for (let g = 0, _ = x.length; g < _; g++)
        e.remove(x[g]);
    }
    m.removeEventListener("dispose", a), delete r[m.id];
    const p = o.get(m);
    p && (e.remove(p), o.delete(m)), i.releaseStatesOfGeometry(m), m.isInstancedBufferGeometry === !0 && delete m._maxInstanceCount, n.memory.geometries--;
  }
  function l(h, m) {
    return r[m.id] === !0 || (m.addEventListener("dispose", a), r[m.id] = !0, n.memory.geometries++), m;
  }
  function c(h) {
    const m = h.attributes;
    for (const v in m)
      e.update(m[v], s.ARRAY_BUFFER);
    const p = h.morphAttributes;
    for (const v in p) {
      const x = p[v];
      for (let g = 0, _ = x.length; g < _; g++)
        e.update(x[g], s.ARRAY_BUFFER);
    }
  }
  function u(h) {
    const m = [], p = h.index, v = h.attributes.position;
    let x = 0;
    if (p !== null) {
      const M = p.array;
      x = p.version;
      for (let S = 0, b = M.length; S < b; S += 3) {
        const C = M[S + 0], E = M[S + 1], P = M[S + 2];
        m.push(C, E, E, P, P, C);
      }
    } else if (v !== void 0) {
      const M = v.array;
      x = v.version;
      for (let S = 0, b = M.length / 3 - 1; S < b; S += 3) {
        const C = S + 0, E = S + 1, P = S + 2;
        m.push(C, E, E, P, P, C);
      }
    } else
      return;
    const g = new (J0(m) ? iy : ny)(m, 1);
    g.version = x;
    const _ = o.get(h);
    _ && e.remove(_), o.set(h, g);
  }
  function d(h) {
    const m = o.get(h);
    if (m) {
      const p = h.index;
      p !== null && m.version < p.version && u(h);
    } else
      u(h);
    return o.get(h);
  }
  return {
    get: l,
    update: c,
    getWireframeAttribute: d
  };
}
function HM(s, e, n) {
  let i;
  function r(m) {
    i = m;
  }
  let o, a;
  function l(m) {
    o = m.type, a = m.bytesPerElement;
  }
  function c(m, p) {
    s.drawElements(i, p, o, m * a), n.update(p, i, 1);
  }
  function u(m, p, v) {
    v !== 0 && (s.drawElementsInstanced(i, p, o, m * a, v), n.update(p, i, v));
  }
  function d(m, p, v) {
    if (v === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, p, 0, o, m, 0, v);
    let g = 0;
    for (let _ = 0; _ < v; _++)
      g += p[_];
    n.update(g, i, 1);
  }
  function h(m, p, v, x) {
    if (v === 0) return;
    const g = e.get("WEBGL_multi_draw");
    if (g === null)
      for (let _ = 0; _ < m.length; _++)
        u(m[_] / a, p[_], x[_]);
    else {
      g.multiDrawElementsInstancedWEBGL(i, p, 0, o, m, 0, x, 0, v);
      let _ = 0;
      for (let M = 0; M < v; M++)
        _ += p[M] * x[M];
      n.update(_, i, 1);
    }
  }
  this.setMode = r, this.setIndex = l, this.render = c, this.renderInstances = u, this.renderMultiDraw = d, this.renderMultiDrawInstances = h;
}
function $M(s) {
  const e = {
    geometries: 0,
    textures: 0
  }, n = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(o, a, l) {
    switch (n.calls++, a) {
      case s.TRIANGLES:
        n.triangles += l * (o / 3);
        break;
      case s.LINES:
        n.lines += l * (o / 2);
        break;
      case s.LINE_STRIP:
        n.lines += l * (o - 1);
        break;
      case s.LINE_LOOP:
        n.lines += l * o;
        break;
      case s.POINTS:
        n.points += l * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function r() {
    n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0;
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i
  };
}
function WM(s, e, n) {
  const i = /* @__PURE__ */ new WeakMap(), r = new jt();
  function o(a, l, c) {
    const u = a.morphTargetInfluences, d = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color, h = d !== void 0 ? d.length : 0;
    let m = i.get(l);
    if (m === void 0 || m.count !== h) {
      let p = function() {
        T.dispose(), i.delete(l), l.removeEventListener("dispose", p);
      };
      m !== void 0 && m.texture.dispose();
      const v = l.morphAttributes.position !== void 0, x = l.morphAttributes.normal !== void 0, g = l.morphAttributes.color !== void 0, _ = l.morphAttributes.position || [], M = l.morphAttributes.normal || [], S = l.morphAttributes.color || [];
      let b = 0;
      v === !0 && (b = 1), x === !0 && (b = 2), g === !0 && (b = 3);
      let C = l.attributes.position.count * b, E = 1;
      C > e.maxTextureSize && (E = Math.ceil(C / e.maxTextureSize), C = e.maxTextureSize);
      const P = new Float32Array(C * E * 4 * h), T = new ey(P, C, E, h);
      T.type = di, T.needsUpdate = !0;
      const y = b * 4;
      for (let w = 0; w < h; w++) {
        const D = _[w], U = M[w], R = S[w], O = C * E * 4 * w;
        for (let A = 0; A < D.count; A++) {
          const G = A * y;
          v === !0 && (r.fromBufferAttribute(D, A), P[O + G + 0] = r.x, P[O + G + 1] = r.y, P[O + G + 2] = r.z, P[O + G + 3] = 0), x === !0 && (r.fromBufferAttribute(U, A), P[O + G + 4] = r.x, P[O + G + 5] = r.y, P[O + G + 6] = r.z, P[O + G + 7] = 0), g === !0 && (r.fromBufferAttribute(R, A), P[O + G + 8] = r.x, P[O + G + 9] = r.y, P[O + G + 10] = r.z, P[O + G + 11] = R.itemSize === 4 ? r.w : 1);
        }
      }
      m = {
        count: h,
        texture: T,
        size: new rt(C, E)
      }, i.set(l, m), l.addEventListener("dispose", p);
    }
    if (a.isInstancedMesh === !0 && a.morphTexture !== null)
      c.getUniforms().setValue(s, "morphTexture", a.morphTexture, n);
    else {
      let p = 0;
      for (let x = 0; x < u.length; x++)
        p += u[x];
      const v = l.morphTargetsRelative ? 1 : 1 - p;
      c.getUniforms().setValue(s, "morphTargetBaseInfluence", v), c.getUniforms().setValue(s, "morphTargetInfluences", u);
    }
    c.getUniforms().setValue(s, "morphTargetsTexture", m.texture, n), c.getUniforms().setValue(s, "morphTargetsTextureSize", m.size);
  }
  return {
    update: o
  };
}
function XM(s, e, n, i) {
  let r = /* @__PURE__ */ new WeakMap();
  function o(c) {
    const u = i.render.frame, d = c.geometry, h = e.get(c, d);
    if (r.get(h) !== u && (e.update(h), r.set(h, u)), c.isInstancedMesh && (c.hasEventListener("dispose", l) === !1 && c.addEventListener("dispose", l), r.get(c) !== u && (n.update(c.instanceMatrix, s.ARRAY_BUFFER), c.instanceColor !== null && n.update(c.instanceColor, s.ARRAY_BUFFER), r.set(c, u))), c.isSkinnedMesh) {
      const m = c.skeleton;
      r.get(m) !== u && (m.update(), r.set(m, u));
    }
    return h;
  }
  function a() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function l(c) {
    const u = c.target;
    u.removeEventListener("dispose", l), n.remove(u.instanceMatrix), u.instanceColor !== null && n.remove(u.instanceColor);
  }
  return {
    update: o,
    dispose: a
  };
}
class Uf extends xn {
  constructor(e, n, i, r, o, a, l, c, u, d = Nr) {
    if (d !== Nr && d !== Ho)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && d === Nr && (i = Hr), i === void 0 && d === Ho && (i = Go), super(null, r, o, a, l, c, d, i, u), this.isDepthTexture = !0, this.image = { width: e, height: n }, this.magFilter = l !== void 0 ? l : On, this.minFilter = c !== void 0 ? c : On, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n;
  }
}
const ly = /* @__PURE__ */ new xn(), Dm = /* @__PURE__ */ new Uf(1, 1), cy = /* @__PURE__ */ new ey(), uy = /* @__PURE__ */ new Ib(), dy = /* @__PURE__ */ new oy(), km = [], Im = [], Lm = new Float32Array(16), Fm = new Float32Array(9), Um = new Float32Array(4);
function Ko(s, e, n) {
  const i = s[0];
  if (i <= 0 || i > 0) return s;
  const r = e * n;
  let o = km[r];
  if (o === void 0 && (o = new Float32Array(r), km[r] = o), e !== 0) {
    i.toArray(o, 0);
    for (let a = 1, l = 0; a !== e; ++a)
      l += n, s[a].toArray(o, l);
  }
  return o;
}
function Tn(s, e) {
  if (s.length !== e.length) return !1;
  for (let n = 0, i = s.length; n < i; n++)
    if (s[n] !== e[n]) return !1;
  return !0;
}
function An(s, e) {
  for (let n = 0, i = e.length; n < i; n++)
    s[n] = e[n];
}
function Tu(s, e) {
  let n = Im[e];
  n === void 0 && (n = new Int32Array(e), Im[e] = n);
  for (let i = 0; i !== e; ++i)
    n[i] = s.allocateTextureUnit();
  return n;
}
function jM(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1f(this.addr, e), n[0] = e);
}
function YM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Tn(n, e)) return;
    s.uniform2fv(this.addr, e), An(n, e);
  }
}
function qM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
  else {
    if (Tn(n, e)) return;
    s.uniform3fv(this.addr, e), An(n, e);
  }
}
function ZM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Tn(n, e)) return;
    s.uniform4fv(this.addr, e), An(n, e);
  }
}
function KM(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Tn(n, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), An(n, e);
  } else {
    if (Tn(n, i)) return;
    Um.set(i), s.uniformMatrix2fv(this.addr, !1, Um), An(n, i);
  }
}
function JM(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Tn(n, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), An(n, e);
  } else {
    if (Tn(n, i)) return;
    Fm.set(i), s.uniformMatrix3fv(this.addr, !1, Fm), An(n, i);
  }
}
function QM(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Tn(n, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), An(n, e);
  } else {
    if (Tn(n, i)) return;
    Lm.set(i), s.uniformMatrix4fv(this.addr, !1, Lm), An(n, i);
  }
}
function eC(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1i(this.addr, e), n[0] = e);
}
function tC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Tn(n, e)) return;
    s.uniform2iv(this.addr, e), An(n, e);
  }
}
function nC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (Tn(n, e)) return;
    s.uniform3iv(this.addr, e), An(n, e);
  }
}
function iC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Tn(n, e)) return;
    s.uniform4iv(this.addr, e), An(n, e);
  }
}
function sC(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1ui(this.addr, e), n[0] = e);
}
function rC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Tn(n, e)) return;
    s.uniform2uiv(this.addr, e), An(n, e);
  }
}
function oC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (Tn(n, e)) return;
    s.uniform3uiv(this.addr, e), An(n, e);
  }
}
function aC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Tn(n, e)) return;
    s.uniform4uiv(this.addr, e), An(n, e);
  }
}
function lC(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r);
  let o;
  this.type === s.SAMPLER_2D_SHADOW ? (Dm.compareFunction = K0, o = Dm) : o = ly, n.setTexture2D(e || o, r);
}
function cC(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || uy, r);
}
function uC(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || dy, r);
}
function dC(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || cy, r);
}
function hC(s) {
  switch (s) {
    case 5126:
      return jM;
    case 35664:
      return YM;
    case 35665:
      return qM;
    case 35666:
      return ZM;
    case 35674:
      return KM;
    case 35675:
      return JM;
    case 35676:
      return QM;
    case 5124:
    case 35670:
      return eC;
    case 35667:
    case 35671:
      return tC;
    case 35668:
    case 35672:
      return nC;
    case 35669:
    case 35673:
      return iC;
    case 5125:
      return sC;
    case 36294:
      return rC;
    case 36295:
      return oC;
    case 36296:
      return aC;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return lC;
    case 35679:
    case 36299:
    case 36307:
      return cC;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return uC;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return dC;
  }
}
function fC(s, e) {
  s.uniform1fv(this.addr, e);
}
function pC(s, e) {
  const n = Ko(e, this.size, 2);
  s.uniform2fv(this.addr, n);
}
function mC(s, e) {
  const n = Ko(e, this.size, 3);
  s.uniform3fv(this.addr, n);
}
function vC(s, e) {
  const n = Ko(e, this.size, 4);
  s.uniform4fv(this.addr, n);
}
function gC(s, e) {
  const n = Ko(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, n);
}
function yC(s, e) {
  const n = Ko(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, n);
}
function _C(s, e) {
  const n = Ko(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, n);
}
function xC(s, e) {
  s.uniform1iv(this.addr, e);
}
function bC(s, e) {
  s.uniform2iv(this.addr, e);
}
function wC(s, e) {
  s.uniform3iv(this.addr, e);
}
function SC(s, e) {
  s.uniform4iv(this.addr, e);
}
function MC(s, e) {
  s.uniform1uiv(this.addr, e);
}
function CC(s, e) {
  s.uniform2uiv(this.addr, e);
}
function EC(s, e) {
  s.uniform3uiv(this.addr, e);
}
function TC(s, e) {
  s.uniform4uiv(this.addr, e);
}
function AC(s, e, n) {
  const i = this.cache, r = e.length, o = Tu(n, r);
  Tn(i, o) || (s.uniform1iv(this.addr, o), An(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTexture2D(e[a] || ly, o[a]);
}
function PC(s, e, n) {
  const i = this.cache, r = e.length, o = Tu(n, r);
  Tn(i, o) || (s.uniform1iv(this.addr, o), An(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTexture3D(e[a] || uy, o[a]);
}
function RC(s, e, n) {
  const i = this.cache, r = e.length, o = Tu(n, r);
  Tn(i, o) || (s.uniform1iv(this.addr, o), An(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTextureCube(e[a] || dy, o[a]);
}
function DC(s, e, n) {
  const i = this.cache, r = e.length, o = Tu(n, r);
  Tn(i, o) || (s.uniform1iv(this.addr, o), An(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTexture2DArray(e[a] || cy, o[a]);
}
function kC(s) {
  switch (s) {
    case 5126:
      return fC;
    case 35664:
      return pC;
    case 35665:
      return mC;
    case 35666:
      return vC;
    case 35674:
      return gC;
    case 35675:
      return yC;
    case 35676:
      return _C;
    case 5124:
    case 35670:
      return xC;
    case 35667:
    case 35671:
      return bC;
    case 35668:
    case 35672:
      return wC;
    case 35669:
    case 35673:
      return SC;
    case 5125:
      return MC;
    case 36294:
      return CC;
    case 36295:
      return EC;
    case 36296:
      return TC;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return AC;
    case 35679:
    case 36299:
    case 36307:
      return PC;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return RC;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return DC;
  }
}
class IC {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = n.type, this.setValue = hC(n.type);
  }
}
class LC {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = n.type, this.size = n.size, this.setValue = kC(n.type);
  }
}
class FC {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, n, i) {
    const r = this.seq;
    for (let o = 0, a = r.length; o !== a; ++o) {
      const l = r[o];
      l.setValue(e, n[l.id], i);
    }
  }
}
const Td = /(\w+)(\])?(\[|\.)?/g;
function Om(s, e) {
  s.seq.push(e), s.map[e.id] = e;
}
function UC(s, e, n) {
  const i = s.name, r = i.length;
  for (Td.lastIndex = 0; ; ) {
    const o = Td.exec(i), a = Td.lastIndex;
    let l = o[1];
    const c = o[2] === "]", u = o[3];
    if (c && (l = l | 0), u === void 0 || u === "[" && a + 2 === r) {
      Om(n, u === void 0 ? new IC(l, s, e) : new LC(l, s, e));
      break;
    } else {
      let h = n.map[l];
      h === void 0 && (h = new FC(l), Om(n, h)), n = h;
    }
  }
}
class Oc {
  constructor(e, n) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const o = e.getActiveUniform(n, r), a = e.getUniformLocation(n, o.name);
      UC(o, a, this);
    }
  }
  setValue(e, n, i, r) {
    const o = this.map[n];
    o !== void 0 && o.setValue(e, i, r);
  }
  setOptional(e, n, i) {
    const r = n[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, n, i, r) {
    for (let o = 0, a = n.length; o !== a; ++o) {
      const l = n[o], c = i[l.id];
      c.needsUpdate !== !1 && l.setValue(e, c.value, r);
    }
  }
  static seqWithValue(e, n) {
    const i = [];
    for (let r = 0, o = e.length; r !== o; ++r) {
      const a = e[r];
      a.id in n && i.push(a);
    }
    return i;
  }
}
function zm(s, e, n) {
  const i = s.createShader(e);
  return s.shaderSource(i, n), s.compileShader(i), i;
}
const OC = 37297;
let zC = 0;
function NC(s, e) {
  const n = s.split(`
`), i = [], r = Math.max(e - 6, 0), o = Math.min(e + 6, n.length);
  for (let a = r; a < o; a++) {
    const l = a + 1;
    i.push(`${l === e ? ">" : " "} ${l}: ${n[a]}`);
  }
  return i.join(`
`);
}
const Nm = /* @__PURE__ */ new Et();
function BC(s) {
  It._getMatrix(Nm, It.workingColorSpace, s);
  const e = `mat3( ${Nm.elements.map((n) => n.toFixed(4))} )`;
  switch (It.getTransfer(s)) {
    case Cu:
      return [e, "LinearTransferOETF"];
    case qt:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", s), [e, "LinearTransferOETF"];
  }
}
function Bm(s, e, n) {
  const i = s.getShaderParameter(e, s.COMPILE_STATUS), r = s.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(r);
  if (o) {
    const a = parseInt(o[1]);
    return n.toUpperCase() + `

` + r + `

` + NC(s.getShaderSource(e), a);
  } else
    return r;
}
function VC(s, e) {
  const n = BC(e);
  return [
    `vec4 ${s}( vec4 value ) {`,
    `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function GC(s, e) {
  let n;
  switch (e) {
    case U0:
      n = "Linear";
      break;
    case O0:
      n = "Reinhard";
      break;
    case z0:
      n = "Cineon";
      break;
    case wf:
      n = "ACESFilmic";
      break;
    case N0:
      n = "AgX";
      break;
    case B0:
      n = "Neutral";
      break;
    case Jx:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }
  return "vec3 " + s + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}
const sc = /* @__PURE__ */ new de();
function HC() {
  It.getLuminanceCoefficients(sc);
  const s = sc.x.toFixed(4), e = sc.y.toFixed(4), n = sc.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${s}, ${e}, ${n} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function $C(s) {
  return [
    s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(Ra).join(`
`);
}
function WC(s) {
  const e = [];
  for (const n in s) {
    const i = s[n];
    i !== !1 && e.push("#define " + n + " " + i);
  }
  return e.join(`
`);
}
function XC(s, e) {
  const n = {}, i = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const o = s.getActiveAttrib(e, r), a = o.name;
    let l = 1;
    o.type === s.FLOAT_MAT2 && (l = 2), o.type === s.FLOAT_MAT3 && (l = 3), o.type === s.FLOAT_MAT4 && (l = 4), n[a] = {
      type: o.type,
      location: s.getAttribLocation(e, a),
      locationSize: l
    };
  }
  return n;
}
function Ra(s) {
  return s !== "";
}
function Vm(s, e) {
  const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Gm(s, e) {
  return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const jC = /^[ \t]*#include +<([\w\d./]+)>/gm;
function jh(s) {
  return s.replace(jC, qC);
}
const YC = /* @__PURE__ */ new Map();
function qC(s, e) {
  let n = Tt[e];
  if (n === void 0) {
    const i = YC.get(e);
    if (i !== void 0)
      n = Tt[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return jh(n);
}
const ZC = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Hm(s) {
  return s.replace(ZC, KC);
}
function KC(s, e, n, i) {
  let r = "";
  for (let o = parseInt(e); o < parseInt(n); o++)
    r += i.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return r;
}
function $m(s) {
  let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
  return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function JC(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return s.shadowMapType === P0 ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === R0 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === xs && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function QC(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case Bo:
      case Vo:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Mu:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function e2(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case Vo:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function t2(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case F0:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Zx:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case Kx:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function n2(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const n = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)), texelHeight: i, maxMip: n };
}
function i2(s, e, n, i) {
  const r = s.getContext(), o = n.defines;
  let a = n.vertexShader, l = n.fragmentShader;
  const c = JC(n), u = QC(n), d = e2(n), h = t2(n), m = n2(n), p = $C(n), v = WC(o), x = r.createProgram();
  let g, _, M = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
  n.isRawShaderMaterial ? (g = [
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    v
  ].filter(Ra).join(`
`), g.length > 0 && (g += `
`), _ = [
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    v
  ].filter(Ra).join(`
`), _.length > 0 && (_ += `
`)) : (g = [
    $m(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    v,
    n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    n.batching ? "#define USE_BATCHING" : "",
    n.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    n.instancing ? "#define USE_INSTANCING" : "",
    n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + d : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    n.mapUv ? "#define MAP_UV " + n.mapUv : "",
    n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
    n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
    n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
    n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
    n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
    n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
    n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "",
    n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
    n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
    n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "",
    n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
    n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "",
    n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "",
    n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "",
    n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "",
    n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "",
    n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "",
    n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
    n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "",
    n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "",
    n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "",
    n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
    //
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.skinning ? "#define USE_SKINNING" : "",
    n.morphTargets ? "#define USE_MORPHTARGETS" : "",
    n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    n.morphColors ? "#define USE_MORPHCOLORS" : "",
    n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "",
    n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Ra).join(`
`), _ = [
    $m(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    v,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    n.map ? "#define USE_MAP" : "",
    n.matcap ? "#define USE_MATCAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + u : "",
    n.envMap ? "#define " + d : "",
    n.envMap ? "#define " + h : "",
    m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "",
    m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "",
    m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoat ? "#define USE_CLEARCOAT" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.dispersion ? "#define USE_DISPERSION" : "",
    n.iridescence ? "#define USE_IRIDESCENCE" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaTest ? "#define USE_ALPHATEST" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.sheen ? "#define USE_SHEEN" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.gradientMap ? "#define USE_GRADIENTMAP" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    n.toneMapping !== rr ? "#define TONE_MAPPING" : "",
    n.toneMapping !== rr ? Tt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    n.toneMapping !== rr ? GC("toneMapping", n.toneMapping) : "",
    n.dithering ? "#define DITHERING" : "",
    n.opaque ? "#define OPAQUE" : "",
    Tt.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    VC("linearToOutputTexel", n.outputColorSpace),
    HC(),
    n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
    `
`
  ].filter(Ra).join(`
`)), a = jh(a), a = Vm(a, n), a = Gm(a, n), l = jh(l), l = Vm(l, n), l = Gm(l, n), a = Hm(a), l = Hm(l), n.isRawShaderMaterial !== !0 && (M = `#version 300 es
`, g = [
    p,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + g, _ = [
    "#define varying in",
    n.glslVersion === nm ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    n.glslVersion === nm ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + _);
  const S = M + g + a, b = M + _ + l, C = zm(r, r.VERTEX_SHADER, S), E = zm(r, r.FRAGMENT_SHADER, b);
  r.attachShader(x, C), r.attachShader(x, E), n.index0AttributeName !== void 0 ? r.bindAttribLocation(x, 0, n.index0AttributeName) : n.morphTargets === !0 && r.bindAttribLocation(x, 0, "position"), r.linkProgram(x);
  function P(D) {
    if (s.debug.checkShaderErrors) {
      const U = r.getProgramInfoLog(x).trim(), R = r.getShaderInfoLog(C).trim(), O = r.getShaderInfoLog(E).trim();
      let A = !0, G = !0;
      if (r.getProgramParameter(x, r.LINK_STATUS) === !1)
        if (A = !1, typeof s.debug.onShaderError == "function")
          s.debug.onShaderError(r, x, C, E);
        else {
          const ue = Bm(r, C, "vertex"), Q = Bm(r, E, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(x, r.VALIDATE_STATUS) + `

Material Name: ` + D.name + `
Material Type: ` + D.type + `

Program Info Log: ` + U + `
` + ue + `
` + Q
          );
        }
      else U !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", U) : (R === "" || O === "") && (G = !1);
      G && (D.diagnostics = {
        runnable: A,
        programLog: U,
        vertexShader: {
          log: R,
          prefix: g
        },
        fragmentShader: {
          log: O,
          prefix: _
        }
      });
    }
    r.deleteShader(C), r.deleteShader(E), T = new Oc(r, x), y = XC(r, x);
  }
  let T;
  this.getUniforms = function() {
    return T === void 0 && P(this), T;
  };
  let y;
  this.getAttributes = function() {
    return y === void 0 && P(this), y;
  };
  let w = n.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return w === !1 && (w = r.getProgramParameter(x, OC)), w;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), r.deleteProgram(x), this.program = void 0;
  }, this.type = n.shaderType, this.name = n.shaderName, this.id = zC++, this.cacheKey = e, this.usedTimes = 1, this.program = x, this.vertexShader = C, this.fragmentShader = E, this;
}
let s2 = 0;
class r2 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const n = e.vertexShader, i = e.fragmentShader, r = this._getShaderStage(n), o = this._getShaderStage(i), a = this._getShaderCacheForMaterial(e);
    return a.has(r) === !1 && (a.add(r), r.usedTimes++), a.has(o) === !1 && (a.add(o), o.usedTimes++), this;
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const i of n)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    let i = n.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), n.set(e, i)), i;
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    let i = n.get(e);
    return i === void 0 && (i = new o2(e), n.set(e, i)), i;
  }
}
class o2 {
  constructor(e) {
    this.id = s2++, this.code = e, this.usedTimes = 0;
  }
}
function a2(s, e, n, i, r, o, a) {
  const l = new If(), c = new r2(), u = /* @__PURE__ */ new Set(), d = [], h = r.logarithmicDepthBuffer, m = r.vertexTextures;
  let p = r.precision;
  const v = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function x(y) {
    return u.add(y), y === 0 ? "uv" : `uv${y}`;
  }
  function g(y, w, D, U, R) {
    const O = U.fog, A = R.geometry, G = y.isMeshStandardMaterial ? U.environment : null, ue = (y.isMeshStandardMaterial ? n : e).get(y.envMap || G), Q = ue && ue.mapping === Mu ? ue.image.height : null, le = v[y.type];
    y.precision !== null && (p = r.getMaxPrecision(y.precision), p !== y.precision && console.warn("THREE.WebGLProgram.getParameters:", y.precision, "not supported, using", p, "instead."));
    const re = A.morphAttributes.position || A.morphAttributes.normal || A.morphAttributes.color, j = re !== void 0 ? re.length : 0;
    let $ = 0;
    A.morphAttributes.position !== void 0 && ($ = 1), A.morphAttributes.normal !== void 0 && ($ = 2), A.morphAttributes.color !== void 0 && ($ = 3);
    let q, oe, ie, ce;
    if (le) {
      const pt = is[le];
      q = pt.vertexShader, oe = pt.fragmentShader;
    } else
      q = y.vertexShader, oe = y.fragmentShader, c.update(y), ie = c.getVertexShaderID(y), ce = c.getFragmentShaderID(y);
    const V = s.getRenderTarget(), Y = s.state.buffers.depth.getReversed(), H = R.isInstancedMesh === !0, I = R.isBatchedMesh === !0, F = !!y.map, L = !!y.matcap, ee = !!ue, Z = !!y.aoMap, k = !!y.lightMap, ne = !!y.bumpMap, J = !!y.normalMap, B = !!y.displacementMap, X = !!y.emissiveMap, se = !!y.metalnessMap, z = !!y.roughnessMap, N = y.anisotropy > 0, K = y.clearcoat > 0, he = y.dispersion > 0, me = y.iridescence > 0, ge = y.sheen > 0, Me = y.transmission > 0, Te = N && !!y.anisotropyMap, Ae = K && !!y.clearcoatMap, Xe = K && !!y.clearcoatNormalMap, Oe = K && !!y.clearcoatRoughnessMap, He = me && !!y.iridescenceMap, Ye = me && !!y.iridescenceThicknessMap, $e = ge && !!y.sheenColorMap, Le = ge && !!y.sheenRoughnessMap, nt = !!y.specularMap, Je = !!y.specularColorMap, bt = !!y.specularIntensityMap, Se = Me && !!y.transmissionMap, Ne = Me && !!y.thicknessMap, Re = !!y.gradientMap, Be = !!y.alphaMap, je = y.alphaTest > 0, Ge = !!y.alphaHash, ut = !!y.extensions;
    let at = rr;
    y.toneMapped && (V === null || V.isXRRenderTarget === !0) && (at = s.toneMapping);
    const dt = {
      shaderID: le,
      shaderType: y.type,
      shaderName: y.name,
      vertexShader: q,
      fragmentShader: oe,
      defines: y.defines,
      customVertexShaderID: ie,
      customFragmentShaderID: ce,
      isRawShaderMaterial: y.isRawShaderMaterial === !0,
      glslVersion: y.glslVersion,
      precision: p,
      batching: I,
      batchingColor: I && R._colorsTexture !== null,
      instancing: H,
      instancingColor: H && R.instanceColor !== null,
      instancingMorph: H && R.morphTexture !== null,
      supportsVertexTextures: m,
      outputColorSpace: V === null ? s.outputColorSpace : V.isXRRenderTarget === !0 ? V.texture.colorSpace : Zo,
      alphaToCoverage: !!y.alphaToCoverage,
      map: F,
      matcap: L,
      envMap: ee,
      envMapMode: ee && ue.mapping,
      envMapCubeUVHeight: Q,
      aoMap: Z,
      lightMap: k,
      bumpMap: ne,
      normalMap: J,
      displacementMap: m && B,
      emissiveMap: X,
      normalMapObjectSpace: J && y.normalMapType === tb,
      normalMapTangentSpace: J && y.normalMapType === Rf,
      metalnessMap: se,
      roughnessMap: z,
      anisotropy: N,
      anisotropyMap: Te,
      clearcoat: K,
      clearcoatMap: Ae,
      clearcoatNormalMap: Xe,
      clearcoatRoughnessMap: Oe,
      dispersion: he,
      iridescence: me,
      iridescenceMap: He,
      iridescenceThicknessMap: Ye,
      sheen: ge,
      sheenColorMap: $e,
      sheenRoughnessMap: Le,
      specularMap: nt,
      specularColorMap: Je,
      specularIntensityMap: bt,
      transmission: Me,
      transmissionMap: Se,
      thicknessMap: Ne,
      gradientMap: Re,
      opaque: y.transparent === !1 && y.blending === Gi && y.alphaToCoverage === !1,
      alphaMap: Be,
      alphaTest: je,
      alphaHash: Ge,
      combine: y.combine,
      //
      mapUv: F && x(y.map.channel),
      aoMapUv: Z && x(y.aoMap.channel),
      lightMapUv: k && x(y.lightMap.channel),
      bumpMapUv: ne && x(y.bumpMap.channel),
      normalMapUv: J && x(y.normalMap.channel),
      displacementMapUv: B && x(y.displacementMap.channel),
      emissiveMapUv: X && x(y.emissiveMap.channel),
      metalnessMapUv: se && x(y.metalnessMap.channel),
      roughnessMapUv: z && x(y.roughnessMap.channel),
      anisotropyMapUv: Te && x(y.anisotropyMap.channel),
      clearcoatMapUv: Ae && x(y.clearcoatMap.channel),
      clearcoatNormalMapUv: Xe && x(y.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Oe && x(y.clearcoatRoughnessMap.channel),
      iridescenceMapUv: He && x(y.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ye && x(y.iridescenceThicknessMap.channel),
      sheenColorMapUv: $e && x(y.sheenColorMap.channel),
      sheenRoughnessMapUv: Le && x(y.sheenRoughnessMap.channel),
      specularMapUv: nt && x(y.specularMap.channel),
      specularColorMapUv: Je && x(y.specularColorMap.channel),
      specularIntensityMapUv: bt && x(y.specularIntensityMap.channel),
      transmissionMapUv: Se && x(y.transmissionMap.channel),
      thicknessMapUv: Ne && x(y.thicknessMap.channel),
      alphaMapUv: Be && x(y.alphaMap.channel),
      //
      vertexTangents: !!A.attributes.tangent && (J || N),
      vertexColors: y.vertexColors,
      vertexAlphas: y.vertexColors === !0 && !!A.attributes.color && A.attributes.color.itemSize === 4,
      pointsUvs: R.isPoints === !0 && !!A.attributes.uv && (F || Be),
      fog: !!O,
      useFog: y.fog === !0,
      fogExp2: !!O && O.isFogExp2,
      flatShading: y.flatShading === !0,
      sizeAttenuation: y.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      reverseDepthBuffer: Y,
      skinning: R.isSkinnedMesh === !0,
      morphTargets: A.morphAttributes.position !== void 0,
      morphNormals: A.morphAttributes.normal !== void 0,
      morphColors: A.morphAttributes.color !== void 0,
      morphTargetsCount: j,
      morphTextureStride: $,
      numDirLights: w.directional.length,
      numPointLights: w.point.length,
      numSpotLights: w.spot.length,
      numSpotLightMaps: w.spotLightMap.length,
      numRectAreaLights: w.rectArea.length,
      numHemiLights: w.hemi.length,
      numDirLightShadows: w.directionalShadowMap.length,
      numPointLightShadows: w.pointShadowMap.length,
      numSpotLightShadows: w.spotShadowMap.length,
      numSpotLightShadowsWithMaps: w.numSpotLightShadowsWithMaps,
      numLightProbes: w.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: y.dithering,
      shadowMapEnabled: s.shadowMap.enabled && D.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: at,
      decodeVideoTexture: F && y.map.isVideoTexture === !0 && It.getTransfer(y.map.colorSpace) === qt,
      decodeVideoTextureEmissive: X && y.emissiveMap.isVideoTexture === !0 && It.getTransfer(y.emissiveMap.colorSpace) === qt,
      premultipliedAlpha: y.premultipliedAlpha,
      doubleSided: y.side === vn,
      flipSided: y.side === hi,
      useDepthPacking: y.depthPacking >= 0,
      depthPacking: y.depthPacking || 0,
      index0AttributeName: y.index0AttributeName,
      extensionClipCullDistance: ut && y.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (ut && y.extensions.multiDraw === !0 || I) && i.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: y.customProgramCacheKey()
    };
    return dt.vertexUv1s = u.has(1), dt.vertexUv2s = u.has(2), dt.vertexUv3s = u.has(3), u.clear(), dt;
  }
  function _(y) {
    const w = [];
    if (y.shaderID ? w.push(y.shaderID) : (w.push(y.customVertexShaderID), w.push(y.customFragmentShaderID)), y.defines !== void 0)
      for (const D in y.defines)
        w.push(D), w.push(y.defines[D]);
    return y.isRawShaderMaterial === !1 && (M(w, y), S(w, y), w.push(s.outputColorSpace)), w.push(y.customProgramCacheKey), w.join();
  }
  function M(y, w) {
    y.push(w.precision), y.push(w.outputColorSpace), y.push(w.envMapMode), y.push(w.envMapCubeUVHeight), y.push(w.mapUv), y.push(w.alphaMapUv), y.push(w.lightMapUv), y.push(w.aoMapUv), y.push(w.bumpMapUv), y.push(w.normalMapUv), y.push(w.displacementMapUv), y.push(w.emissiveMapUv), y.push(w.metalnessMapUv), y.push(w.roughnessMapUv), y.push(w.anisotropyMapUv), y.push(w.clearcoatMapUv), y.push(w.clearcoatNormalMapUv), y.push(w.clearcoatRoughnessMapUv), y.push(w.iridescenceMapUv), y.push(w.iridescenceThicknessMapUv), y.push(w.sheenColorMapUv), y.push(w.sheenRoughnessMapUv), y.push(w.specularMapUv), y.push(w.specularColorMapUv), y.push(w.specularIntensityMapUv), y.push(w.transmissionMapUv), y.push(w.thicknessMapUv), y.push(w.combine), y.push(w.fogExp2), y.push(w.sizeAttenuation), y.push(w.morphTargetsCount), y.push(w.morphAttributeCount), y.push(w.numDirLights), y.push(w.numPointLights), y.push(w.numSpotLights), y.push(w.numSpotLightMaps), y.push(w.numHemiLights), y.push(w.numRectAreaLights), y.push(w.numDirLightShadows), y.push(w.numPointLightShadows), y.push(w.numSpotLightShadows), y.push(w.numSpotLightShadowsWithMaps), y.push(w.numLightProbes), y.push(w.shadowMapType), y.push(w.toneMapping), y.push(w.numClippingPlanes), y.push(w.numClipIntersection), y.push(w.depthPacking);
  }
  function S(y, w) {
    l.disableAll(), w.supportsVertexTextures && l.enable(0), w.instancing && l.enable(1), w.instancingColor && l.enable(2), w.instancingMorph && l.enable(3), w.matcap && l.enable(4), w.envMap && l.enable(5), w.normalMapObjectSpace && l.enable(6), w.normalMapTangentSpace && l.enable(7), w.clearcoat && l.enable(8), w.iridescence && l.enable(9), w.alphaTest && l.enable(10), w.vertexColors && l.enable(11), w.vertexAlphas && l.enable(12), w.vertexUv1s && l.enable(13), w.vertexUv2s && l.enable(14), w.vertexUv3s && l.enable(15), w.vertexTangents && l.enable(16), w.anisotropy && l.enable(17), w.alphaHash && l.enable(18), w.batching && l.enable(19), w.dispersion && l.enable(20), w.batchingColor && l.enable(21), y.push(l.mask), l.disableAll(), w.fog && l.enable(0), w.useFog && l.enable(1), w.flatShading && l.enable(2), w.logarithmicDepthBuffer && l.enable(3), w.reverseDepthBuffer && l.enable(4), w.skinning && l.enable(5), w.morphTargets && l.enable(6), w.morphNormals && l.enable(7), w.morphColors && l.enable(8), w.premultipliedAlpha && l.enable(9), w.shadowMapEnabled && l.enable(10), w.doubleSided && l.enable(11), w.flipSided && l.enable(12), w.useDepthPacking && l.enable(13), w.dithering && l.enable(14), w.transmission && l.enable(15), w.sheen && l.enable(16), w.opaque && l.enable(17), w.pointsUvs && l.enable(18), w.decodeVideoTexture && l.enable(19), w.decodeVideoTextureEmissive && l.enable(20), w.alphaToCoverage && l.enable(21), y.push(l.mask);
  }
  function b(y) {
    const w = v[y.type];
    let D;
    if (w) {
      const U = is[w];
      D = Sl.clone(U.uniforms);
    } else
      D = y.uniforms;
    return D;
  }
  function C(y, w) {
    let D;
    for (let U = 0, R = d.length; U < R; U++) {
      const O = d[U];
      if (O.cacheKey === w) {
        D = O, ++D.usedTimes;
        break;
      }
    }
    return D === void 0 && (D = new i2(s, w, y, o), d.push(D)), D;
  }
  function E(y) {
    if (--y.usedTimes === 0) {
      const w = d.indexOf(y);
      d[w] = d[d.length - 1], d.pop(), y.destroy();
    }
  }
  function P(y) {
    c.remove(y);
  }
  function T() {
    c.dispose();
  }
  return {
    getParameters: g,
    getProgramCacheKey: _,
    getUniforms: b,
    acquireProgram: C,
    releaseProgram: E,
    releaseShaderCache: P,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: d,
    dispose: T
  };
}
function l2() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(a) {
    return s.has(a);
  }
  function n(a) {
    let l = s.get(a);
    return l === void 0 && (l = {}, s.set(a, l)), l;
  }
  function i(a) {
    s.delete(a);
  }
  function r(a, l, c) {
    s.get(a)[l] = c;
  }
  function o() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: n,
    remove: i,
    update: r,
    dispose: o
  };
}
function c2(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
}
function Wm(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
}
function Xm() {
  const s = [];
  let e = 0;
  const n = [], i = [], r = [];
  function o() {
    e = 0, n.length = 0, i.length = 0, r.length = 0;
  }
  function a(h, m, p, v, x, g) {
    let _ = s[e];
    return _ === void 0 ? (_ = {
      id: h.id,
      object: h,
      geometry: m,
      material: p,
      groupOrder: v,
      renderOrder: h.renderOrder,
      z: x,
      group: g
    }, s[e] = _) : (_.id = h.id, _.object = h, _.geometry = m, _.material = p, _.groupOrder = v, _.renderOrder = h.renderOrder, _.z = x, _.group = g), e++, _;
  }
  function l(h, m, p, v, x, g) {
    const _ = a(h, m, p, v, x, g);
    p.transmission > 0 ? i.push(_) : p.transparent === !0 ? r.push(_) : n.push(_);
  }
  function c(h, m, p, v, x, g) {
    const _ = a(h, m, p, v, x, g);
    p.transmission > 0 ? i.unshift(_) : p.transparent === !0 ? r.unshift(_) : n.unshift(_);
  }
  function u(h, m) {
    n.length > 1 && n.sort(h || c2), i.length > 1 && i.sort(m || Wm), r.length > 1 && r.sort(m || Wm);
  }
  function d() {
    for (let h = e, m = s.length; h < m; h++) {
      const p = s[h];
      if (p.id === null) break;
      p.id = null, p.object = null, p.geometry = null, p.material = null, p.group = null;
    }
  }
  return {
    opaque: n,
    transmissive: i,
    transparent: r,
    init: o,
    push: l,
    unshift: c,
    finish: d,
    sort: u
  };
}
function u2() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(i, r) {
    const o = s.get(i);
    let a;
    return o === void 0 ? (a = new Xm(), s.set(i, [a])) : r >= o.length ? (a = new Xm(), o.push(a)) : a = o[r], a;
  }
  function n() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: n
  };
}
function d2() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new de(),
            color: new Mt()
          };
          break;
        case "SpotLight":
          n = {
            position: new de(),
            direction: new de(),
            color: new Mt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          n = {
            position: new de(),
            color: new Mt(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          n = {
            direction: new de(),
            skyColor: new Mt(),
            groundColor: new Mt()
          };
          break;
        case "RectAreaLight":
          n = {
            color: new Mt(),
            position: new de(),
            halfWidth: new de(),
            halfHeight: new de()
          };
          break;
      }
      return s[e.id] = n, n;
    }
  };
}
function h2() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new rt()
          };
          break;
        case "SpotLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new rt()
          };
          break;
        case "PointLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new rt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return s[e.id] = n, n;
    }
  };
}
let f2 = 0;
function p2(s, e) {
  return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
}
function m2(s) {
  const e = new d2(), n = h2(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let u = 0; u < 9; u++) i.probe.push(new de());
  const r = new de(), o = new Zt(), a = new Zt();
  function l(u) {
    let d = 0, h = 0, m = 0;
    for (let y = 0; y < 9; y++) i.probe[y].set(0, 0, 0);
    let p = 0, v = 0, x = 0, g = 0, _ = 0, M = 0, S = 0, b = 0, C = 0, E = 0, P = 0;
    u.sort(p2);
    for (let y = 0, w = u.length; y < w; y++) {
      const D = u[y], U = D.color, R = D.intensity, O = D.distance, A = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
      if (D.isAmbientLight)
        d += U.r * R, h += U.g * R, m += U.b * R;
      else if (D.isLightProbe) {
        for (let G = 0; G < 9; G++)
          i.probe[G].addScaledVector(D.sh.coefficients[G], R);
        P++;
      } else if (D.isDirectionalLight) {
        const G = e.get(D);
        if (G.color.copy(D.color).multiplyScalar(D.intensity), D.castShadow) {
          const ue = D.shadow, Q = n.get(D);
          Q.shadowIntensity = ue.intensity, Q.shadowBias = ue.bias, Q.shadowNormalBias = ue.normalBias, Q.shadowRadius = ue.radius, Q.shadowMapSize = ue.mapSize, i.directionalShadow[p] = Q, i.directionalShadowMap[p] = A, i.directionalShadowMatrix[p] = D.shadow.matrix, M++;
        }
        i.directional[p] = G, p++;
      } else if (D.isSpotLight) {
        const G = e.get(D);
        G.position.setFromMatrixPosition(D.matrixWorld), G.color.copy(U).multiplyScalar(R), G.distance = O, G.coneCos = Math.cos(D.angle), G.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), G.decay = D.decay, i.spot[x] = G;
        const ue = D.shadow;
        if (D.map && (i.spotLightMap[C] = D.map, C++, ue.updateMatrices(D), D.castShadow && E++), i.spotLightMatrix[x] = ue.matrix, D.castShadow) {
          const Q = n.get(D);
          Q.shadowIntensity = ue.intensity, Q.shadowBias = ue.bias, Q.shadowNormalBias = ue.normalBias, Q.shadowRadius = ue.radius, Q.shadowMapSize = ue.mapSize, i.spotShadow[x] = Q, i.spotShadowMap[x] = A, b++;
        }
        x++;
      } else if (D.isRectAreaLight) {
        const G = e.get(D);
        G.color.copy(U).multiplyScalar(R), G.halfWidth.set(D.width * 0.5, 0, 0), G.halfHeight.set(0, D.height * 0.5, 0), i.rectArea[g] = G, g++;
      } else if (D.isPointLight) {
        const G = e.get(D);
        if (G.color.copy(D.color).multiplyScalar(D.intensity), G.distance = D.distance, G.decay = D.decay, D.castShadow) {
          const ue = D.shadow, Q = n.get(D);
          Q.shadowIntensity = ue.intensity, Q.shadowBias = ue.bias, Q.shadowNormalBias = ue.normalBias, Q.shadowRadius = ue.radius, Q.shadowMapSize = ue.mapSize, Q.shadowCameraNear = ue.camera.near, Q.shadowCameraFar = ue.camera.far, i.pointShadow[v] = Q, i.pointShadowMap[v] = A, i.pointShadowMatrix[v] = D.shadow.matrix, S++;
        }
        i.point[v] = G, v++;
      } else if (D.isHemisphereLight) {
        const G = e.get(D);
        G.skyColor.copy(D.color).multiplyScalar(R), G.groundColor.copy(D.groundColor).multiplyScalar(R), i.hemi[_] = G, _++;
      }
    }
    g > 0 && (s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = tt.LTC_FLOAT_1, i.rectAreaLTC2 = tt.LTC_FLOAT_2) : (i.rectAreaLTC1 = tt.LTC_HALF_1, i.rectAreaLTC2 = tt.LTC_HALF_2)), i.ambient[0] = d, i.ambient[1] = h, i.ambient[2] = m;
    const T = i.hash;
    (T.directionalLength !== p || T.pointLength !== v || T.spotLength !== x || T.rectAreaLength !== g || T.hemiLength !== _ || T.numDirectionalShadows !== M || T.numPointShadows !== S || T.numSpotShadows !== b || T.numSpotMaps !== C || T.numLightProbes !== P) && (i.directional.length = p, i.spot.length = x, i.rectArea.length = g, i.point.length = v, i.hemi.length = _, i.directionalShadow.length = M, i.directionalShadowMap.length = M, i.pointShadow.length = S, i.pointShadowMap.length = S, i.spotShadow.length = b, i.spotShadowMap.length = b, i.directionalShadowMatrix.length = M, i.pointShadowMatrix.length = S, i.spotLightMatrix.length = b + C - E, i.spotLightMap.length = C, i.numSpotLightShadowsWithMaps = E, i.numLightProbes = P, T.directionalLength = p, T.pointLength = v, T.spotLength = x, T.rectAreaLength = g, T.hemiLength = _, T.numDirectionalShadows = M, T.numPointShadows = S, T.numSpotShadows = b, T.numSpotMaps = C, T.numLightProbes = P, i.version = f2++);
  }
  function c(u, d) {
    let h = 0, m = 0, p = 0, v = 0, x = 0;
    const g = d.matrixWorldInverse;
    for (let _ = 0, M = u.length; _ < M; _++) {
      const S = u[_];
      if (S.isDirectionalLight) {
        const b = i.directional[h];
        b.direction.setFromMatrixPosition(S.matrixWorld), r.setFromMatrixPosition(S.target.matrixWorld), b.direction.sub(r), b.direction.transformDirection(g), h++;
      } else if (S.isSpotLight) {
        const b = i.spot[p];
        b.position.setFromMatrixPosition(S.matrixWorld), b.position.applyMatrix4(g), b.direction.setFromMatrixPosition(S.matrixWorld), r.setFromMatrixPosition(S.target.matrixWorld), b.direction.sub(r), b.direction.transformDirection(g), p++;
      } else if (S.isRectAreaLight) {
        const b = i.rectArea[v];
        b.position.setFromMatrixPosition(S.matrixWorld), b.position.applyMatrix4(g), a.identity(), o.copy(S.matrixWorld), o.premultiply(g), a.extractRotation(o), b.halfWidth.set(S.width * 0.5, 0, 0), b.halfHeight.set(0, S.height * 0.5, 0), b.halfWidth.applyMatrix4(a), b.halfHeight.applyMatrix4(a), v++;
      } else if (S.isPointLight) {
        const b = i.point[m];
        b.position.setFromMatrixPosition(S.matrixWorld), b.position.applyMatrix4(g), m++;
      } else if (S.isHemisphereLight) {
        const b = i.hemi[x];
        b.direction.setFromMatrixPosition(S.matrixWorld), b.direction.transformDirection(g), x++;
      }
    }
  }
  return {
    setup: l,
    setupView: c,
    state: i
  };
}
function jm(s) {
  const e = new m2(s), n = [], i = [];
  function r(d) {
    u.camera = d, n.length = 0, i.length = 0;
  }
  function o(d) {
    n.push(d);
  }
  function a(d) {
    i.push(d);
  }
  function l() {
    e.setup(n);
  }
  function c(d) {
    e.setupView(n, d);
  }
  const u = {
    lightsArray: n,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: r,
    state: u,
    setupLights: l,
    setupLightsView: c,
    pushLight: o,
    pushShadow: a
  };
}
function v2(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(r, o = 0) {
    const a = e.get(r);
    let l;
    return a === void 0 ? (l = new jm(s), e.set(r, [l])) : o >= a.length ? (l = new jm(s), a.push(l)) : l = a[o], l;
  }
  function i() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: i
  };
}
class Of extends jr {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.depthPacking = eb, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class hy extends jr {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const g2 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, y2 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function _2(s, e, n) {
  let i = new Lf();
  const r = new rt(), o = new rt(), a = new jt(), l = new Of({ depthPacking: Pf }), c = new hy(), u = {}, d = n.maxTextureSize, h = { [or]: hi, [hi]: or, [vn]: vn }, m = new zn({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new rt() },
      radius: { value: 4 }
    },
    vertexShader: g2,
    fragmentShader: y2
  }), p = m.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const v = new Vt();
  v.setAttribute(
    "position",
    new Si(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const x = new Ze(v, m), g = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = P0;
  let _ = this.type;
  this.render = function(E, P, T) {
    if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || E.length === 0) return;
    const y = s.getRenderTarget(), w = s.getActiveCubeFace(), D = s.getActiveMipmapLevel(), U = s.state;
    U.setBlending(rs), U.buffers.color.setClear(1, 1, 1, 1), U.buffers.depth.setTest(!0), U.setScissorTest(!1);
    const R = _ !== xs && this.type === xs, O = _ === xs && this.type !== xs;
    for (let A = 0, G = E.length; A < G; A++) {
      const ue = E[A], Q = ue.shadow;
      if (Q === void 0) {
        console.warn("THREE.WebGLShadowMap:", ue, "has no shadow.");
        continue;
      }
      if (Q.autoUpdate === !1 && Q.needsUpdate === !1) continue;
      r.copy(Q.mapSize);
      const le = Q.getFrameExtents();
      if (r.multiply(le), o.copy(Q.mapSize), (r.x > d || r.y > d) && (r.x > d && (o.x = Math.floor(d / le.x), r.x = o.x * le.x, Q.mapSize.x = o.x), r.y > d && (o.y = Math.floor(d / le.y), r.y = o.y * le.y, Q.mapSize.y = o.y)), Q.map === null || R === !0 || O === !0) {
        const j = this.type !== xs ? { minFilter: On, magFilter: On } : {};
        Q.map !== null && Q.map.dispose(), Q.map = new Ri(r.x, r.y, j), Q.map.texture.name = ue.name + ".shadowMap", Q.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(Q.map), s.clear();
      const re = Q.getViewportCount();
      for (let j = 0; j < re; j++) {
        const $ = Q.getViewport(j);
        a.set(
          o.x * $.x,
          o.y * $.y,
          o.x * $.z,
          o.y * $.w
        ), U.viewport(a), Q.updateMatrices(ue, j), i = Q.getFrustum(), b(P, T, Q.camera, ue, this.type);
      }
      Q.isPointLightShadow !== !0 && this.type === xs && M(Q, T), Q.needsUpdate = !1;
    }
    _ = this.type, g.needsUpdate = !1, s.setRenderTarget(y, w, D);
  };
  function M(E, P) {
    const T = e.update(x);
    m.defines.VSM_SAMPLES !== E.blurSamples && (m.defines.VSM_SAMPLES = E.blurSamples, p.defines.VSM_SAMPLES = E.blurSamples, m.needsUpdate = !0, p.needsUpdate = !0), E.mapPass === null && (E.mapPass = new Ri(r.x, r.y)), m.uniforms.shadow_pass.value = E.map.texture, m.uniforms.resolution.value = E.mapSize, m.uniforms.radius.value = E.radius, s.setRenderTarget(E.mapPass), s.clear(), s.renderBufferDirect(P, null, T, m, x, null), p.uniforms.shadow_pass.value = E.mapPass.texture, p.uniforms.resolution.value = E.mapSize, p.uniforms.radius.value = E.radius, s.setRenderTarget(E.map), s.clear(), s.renderBufferDirect(P, null, T, p, x, null);
  }
  function S(E, P, T, y) {
    let w = null;
    const D = T.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
    if (D !== void 0)
      w = D;
    else if (w = T.isPointLight === !0 ? c : l, s.localClippingEnabled && P.clipShadows === !0 && Array.isArray(P.clippingPlanes) && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0 || P.map && P.alphaTest > 0) {
      const U = w.uuid, R = P.uuid;
      let O = u[U];
      O === void 0 && (O = {}, u[U] = O);
      let A = O[R];
      A === void 0 && (A = w.clone(), O[R] = A, P.addEventListener("dispose", C)), w = A;
    }
    if (w.visible = P.visible, w.wireframe = P.wireframe, y === xs ? w.side = P.shadowSide !== null ? P.shadowSide : P.side : w.side = P.shadowSide !== null ? P.shadowSide : h[P.side], w.alphaMap = P.alphaMap, w.alphaTest = P.alphaTest, w.map = P.map, w.clipShadows = P.clipShadows, w.clippingPlanes = P.clippingPlanes, w.clipIntersection = P.clipIntersection, w.displacementMap = P.displacementMap, w.displacementScale = P.displacementScale, w.displacementBias = P.displacementBias, w.wireframeLinewidth = P.wireframeLinewidth, w.linewidth = P.linewidth, T.isPointLight === !0 && w.isMeshDistanceMaterial === !0) {
      const U = s.properties.get(w);
      U.light = T;
    }
    return w;
  }
  function b(E, P, T, y, w) {
    if (E.visible === !1) return;
    if (E.layers.test(P.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && w === xs) && (!E.frustumCulled || i.intersectsObject(E))) {
      E.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, E.matrixWorld);
      const R = e.update(E), O = E.material;
      if (Array.isArray(O)) {
        const A = R.groups;
        for (let G = 0, ue = A.length; G < ue; G++) {
          const Q = A[G], le = O[Q.materialIndex];
          if (le && le.visible) {
            const re = S(E, le, y, w);
            E.onBeforeShadow(s, E, P, T, R, re, Q), s.renderBufferDirect(T, null, R, re, E, Q), E.onAfterShadow(s, E, P, T, R, re, Q);
          }
        }
      } else if (O.visible) {
        const A = S(E, O, y, w);
        E.onBeforeShadow(s, E, P, T, R, A, null), s.renderBufferDirect(T, null, R, A, E, null), E.onAfterShadow(s, E, P, T, R, A, null);
      }
    }
    const U = E.children;
    for (let R = 0, O = U.length; R < O; R++)
      b(U[R], P, T, y, w);
  }
  function C(E) {
    E.target.removeEventListener("dispose", C);
    for (const T in u) {
      const y = u[T], w = E.target.uuid;
      w in y && (y[w].dispose(), delete y[w]);
    }
  }
}
const x2 = {
  [uh]: dh,
  [hh]: mh,
  [fh]: vh,
  [No]: ph,
  [dh]: uh,
  [mh]: hh,
  [vh]: fh,
  [ph]: No
};
function b2(s, e) {
  function n() {
    let Se = !1;
    const Ne = new jt();
    let Re = null;
    const Be = new jt(0, 0, 0, 0);
    return {
      setMask: function(je) {
        Re !== je && !Se && (s.colorMask(je, je, je, je), Re = je);
      },
      setLocked: function(je) {
        Se = je;
      },
      setClear: function(je, Ge, ut, at, dt) {
        dt === !0 && (je *= at, Ge *= at, ut *= at), Ne.set(je, Ge, ut, at), Be.equals(Ne) === !1 && (s.clearColor(je, Ge, ut, at), Be.copy(Ne));
      },
      reset: function() {
        Se = !1, Re = null, Be.set(-1, 0, 0, 0);
      }
    };
  }
  function i() {
    let Se = !1, Ne = !1, Re = null, Be = null, je = null;
    return {
      setReversed: function(Ge) {
        if (Ne !== Ge) {
          const ut = e.get("EXT_clip_control");
          Ne ? ut.clipControlEXT(ut.LOWER_LEFT_EXT, ut.ZERO_TO_ONE_EXT) : ut.clipControlEXT(ut.LOWER_LEFT_EXT, ut.NEGATIVE_ONE_TO_ONE_EXT);
          const at = je;
          je = null, this.setClear(at);
        }
        Ne = Ge;
      },
      getReversed: function() {
        return Ne;
      },
      setTest: function(Ge) {
        Ge ? V(s.DEPTH_TEST) : Y(s.DEPTH_TEST);
      },
      setMask: function(Ge) {
        Re !== Ge && !Se && (s.depthMask(Ge), Re = Ge);
      },
      setFunc: function(Ge) {
        if (Ne && (Ge = x2[Ge]), Be !== Ge) {
          switch (Ge) {
            case uh:
              s.depthFunc(s.NEVER);
              break;
            case dh:
              s.depthFunc(s.ALWAYS);
              break;
            case hh:
              s.depthFunc(s.LESS);
              break;
            case No:
              s.depthFunc(s.LEQUAL);
              break;
            case fh:
              s.depthFunc(s.EQUAL);
              break;
            case ph:
              s.depthFunc(s.GEQUAL);
              break;
            case mh:
              s.depthFunc(s.GREATER);
              break;
            case vh:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          Be = Ge;
        }
      },
      setLocked: function(Ge) {
        Se = Ge;
      },
      setClear: function(Ge) {
        je !== Ge && (Ne && (Ge = 1 - Ge), s.clearDepth(Ge), je = Ge);
      },
      reset: function() {
        Se = !1, Re = null, Be = null, je = null, Ne = !1;
      }
    };
  }
  function r() {
    let Se = !1, Ne = null, Re = null, Be = null, je = null, Ge = null, ut = null, at = null, dt = null;
    return {
      setTest: function(pt) {
        Se || (pt ? V(s.STENCIL_TEST) : Y(s.STENCIL_TEST));
      },
      setMask: function(pt) {
        Ne !== pt && !Se && (s.stencilMask(pt), Ne = pt);
      },
      setFunc: function(pt, zt, Kt) {
        (Re !== pt || Be !== zt || je !== Kt) && (s.stencilFunc(pt, zt, Kt), Re = pt, Be = zt, je = Kt);
      },
      setOp: function(pt, zt, Kt) {
        (Ge !== pt || ut !== zt || at !== Kt) && (s.stencilOp(pt, zt, Kt), Ge = pt, ut = zt, at = Kt);
      },
      setLocked: function(pt) {
        Se = pt;
      },
      setClear: function(pt) {
        dt !== pt && (s.clearStencil(pt), dt = pt);
      },
      reset: function() {
        Se = !1, Ne = null, Re = null, Be = null, je = null, Ge = null, ut = null, at = null, dt = null;
      }
    };
  }
  const o = new n(), a = new i(), l = new r(), c = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
  let d = {}, h = {}, m = /* @__PURE__ */ new WeakMap(), p = [], v = null, x = !1, g = null, _ = null, M = null, S = null, b = null, C = null, E = null, P = new Mt(0, 0, 0), T = 0, y = !1, w = null, D = null, U = null, R = null, O = null;
  const A = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let G = !1, ue = 0;
  const Q = s.getParameter(s.VERSION);
  Q.indexOf("WebGL") !== -1 ? (ue = parseFloat(/^WebGL (\d)/.exec(Q)[1]), G = ue >= 1) : Q.indexOf("OpenGL ES") !== -1 && (ue = parseFloat(/^OpenGL ES (\d)/.exec(Q)[1]), G = ue >= 2);
  let le = null, re = {};
  const j = s.getParameter(s.SCISSOR_BOX), $ = s.getParameter(s.VIEWPORT), q = new jt().fromArray(j), oe = new jt().fromArray($);
  function ie(Se, Ne, Re, Be) {
    const je = new Uint8Array(4), Ge = s.createTexture();
    s.bindTexture(Se, Ge), s.texParameteri(Se, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(Se, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let ut = 0; ut < Re; ut++)
      Se === s.TEXTURE_3D || Se === s.TEXTURE_2D_ARRAY ? s.texImage3D(Ne, 0, s.RGBA, 1, 1, Be, 0, s.RGBA, s.UNSIGNED_BYTE, je) : s.texImage2D(Ne + ut, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, je);
    return Ge;
  }
  const ce = {};
  ce[s.TEXTURE_2D] = ie(s.TEXTURE_2D, s.TEXTURE_2D, 1), ce[s.TEXTURE_CUBE_MAP] = ie(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ce[s.TEXTURE_2D_ARRAY] = ie(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), ce[s.TEXTURE_3D] = ie(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), o.setClear(0, 0, 0, 1), a.setClear(1), l.setClear(0), V(s.DEPTH_TEST), a.setFunc(No), ne(!1), J(Qp), V(s.CULL_FACE), Z(rs);
  function V(Se) {
    d[Se] !== !0 && (s.enable(Se), d[Se] = !0);
  }
  function Y(Se) {
    d[Se] !== !1 && (s.disable(Se), d[Se] = !1);
  }
  function H(Se, Ne) {
    return h[Se] !== Ne ? (s.bindFramebuffer(Se, Ne), h[Se] = Ne, Se === s.DRAW_FRAMEBUFFER && (h[s.FRAMEBUFFER] = Ne), Se === s.FRAMEBUFFER && (h[s.DRAW_FRAMEBUFFER] = Ne), !0) : !1;
  }
  function I(Se, Ne) {
    let Re = p, Be = !1;
    if (Se) {
      Re = m.get(Ne), Re === void 0 && (Re = [], m.set(Ne, Re));
      const je = Se.textures;
      if (Re.length !== je.length || Re[0] !== s.COLOR_ATTACHMENT0) {
        for (let Ge = 0, ut = je.length; Ge < ut; Ge++)
          Re[Ge] = s.COLOR_ATTACHMENT0 + Ge;
        Re.length = je.length, Be = !0;
      }
    } else
      Re[0] !== s.BACK && (Re[0] = s.BACK, Be = !0);
    Be && s.drawBuffers(Re);
  }
  function F(Se) {
    return v !== Se ? (s.useProgram(Se), v = Se, !0) : !1;
  }
  const L = {
    [Bi]: s.FUNC_ADD,
    [D0]: s.FUNC_SUBTRACT,
    [Nx]: s.FUNC_REVERSE_SUBTRACT
  };
  L[k0] = s.MIN, L[I0] = s.MAX;
  const ee = {
    [Bx]: s.ZERO,
    [bs]: s.ONE,
    [Vx]: s.SRC_COLOR,
    [Jc]: s.SRC_ALPHA,
    [Wx]: s.SRC_ALPHA_SATURATE,
    [$x]: s.DST_COLOR,
    [Gx]: s.DST_ALPHA,
    [ch]: s.ONE_MINUS_SRC_COLOR,
    [ll]: s.ONE_MINUS_SRC_ALPHA,
    [L0]: s.ONE_MINUS_DST_COLOR,
    [Hx]: s.ONE_MINUS_DST_ALPHA,
    [Xx]: s.CONSTANT_COLOR,
    [jx]: s.ONE_MINUS_CONSTANT_COLOR,
    [Yx]: s.CONSTANT_ALPHA,
    [qx]: s.ONE_MINUS_CONSTANT_ALPHA
  };
  function Z(Se, Ne, Re, Be, je, Ge, ut, at, dt, pt) {
    if (Se === rs) {
      x === !0 && (Y(s.BLEND), x = !1);
      return;
    }
    if (x === !1 && (V(s.BLEND), x = !0), Se !== Rr) {
      if (Se !== g || pt !== y) {
        if ((_ !== Bi || b !== Bi) && (s.blendEquation(s.FUNC_ADD), _ = Bi, b = Bi), pt)
          switch (Se) {
            case Gi:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case al:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case lh:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Io:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Se);
              break;
          }
        else
          switch (Se) {
            case Gi:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case al:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case lh:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Io:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Se);
              break;
          }
        M = null, S = null, C = null, E = null, P.set(0, 0, 0), T = 0, g = Se, y = pt;
      }
      return;
    }
    je = je || Ne, Ge = Ge || Re, ut = ut || Be, (Ne !== _ || je !== b) && (s.blendEquationSeparate(L[Ne], L[je]), _ = Ne, b = je), (Re !== M || Be !== S || Ge !== C || ut !== E) && (s.blendFuncSeparate(ee[Re], ee[Be], ee[Ge], ee[ut]), M = Re, S = Be, C = Ge, E = ut), (at.equals(P) === !1 || dt !== T) && (s.blendColor(at.r, at.g, at.b, dt), P.copy(at), T = dt), g = Se, y = !1;
  }
  function k(Se, Ne) {
    Se.side === vn ? Y(s.CULL_FACE) : V(s.CULL_FACE);
    let Re = Se.side === hi;
    Ne && (Re = !Re), ne(Re), Se.blending === Gi && Se.transparent === !1 ? Z(rs) : Z(Se.blending, Se.blendEquation, Se.blendSrc, Se.blendDst, Se.blendEquationAlpha, Se.blendSrcAlpha, Se.blendDstAlpha, Se.blendColor, Se.blendAlpha, Se.premultipliedAlpha), a.setFunc(Se.depthFunc), a.setTest(Se.depthTest), a.setMask(Se.depthWrite), o.setMask(Se.colorWrite);
    const Be = Se.stencilWrite;
    l.setTest(Be), Be && (l.setMask(Se.stencilWriteMask), l.setFunc(Se.stencilFunc, Se.stencilRef, Se.stencilFuncMask), l.setOp(Se.stencilFail, Se.stencilZFail, Se.stencilZPass)), X(Se.polygonOffset, Se.polygonOffsetFactor, Se.polygonOffsetUnits), Se.alphaToCoverage === !0 ? V(s.SAMPLE_ALPHA_TO_COVERAGE) : Y(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ne(Se) {
    w !== Se && (Se ? s.frontFace(s.CW) : s.frontFace(s.CCW), w = Se);
  }
  function J(Se) {
    Se !== Ox ? (V(s.CULL_FACE), Se !== D && (Se === Qp ? s.cullFace(s.BACK) : Se === zx ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : Y(s.CULL_FACE), D = Se;
  }
  function B(Se) {
    Se !== U && (G && s.lineWidth(Se), U = Se);
  }
  function X(Se, Ne, Re) {
    Se ? (V(s.POLYGON_OFFSET_FILL), (R !== Ne || O !== Re) && (s.polygonOffset(Ne, Re), R = Ne, O = Re)) : Y(s.POLYGON_OFFSET_FILL);
  }
  function se(Se) {
    Se ? V(s.SCISSOR_TEST) : Y(s.SCISSOR_TEST);
  }
  function z(Se) {
    Se === void 0 && (Se = s.TEXTURE0 + A - 1), le !== Se && (s.activeTexture(Se), le = Se);
  }
  function N(Se, Ne, Re) {
    Re === void 0 && (le === null ? Re = s.TEXTURE0 + A - 1 : Re = le);
    let Be = re[Re];
    Be === void 0 && (Be = { type: void 0, texture: void 0 }, re[Re] = Be), (Be.type !== Se || Be.texture !== Ne) && (le !== Re && (s.activeTexture(Re), le = Re), s.bindTexture(Se, Ne || ce[Se]), Be.type = Se, Be.texture = Ne);
  }
  function K() {
    const Se = re[le];
    Se !== void 0 && Se.type !== void 0 && (s.bindTexture(Se.type, null), Se.type = void 0, Se.texture = void 0);
  }
  function he() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function me() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function ge() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Me() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Te() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Ae() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Xe() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Oe() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function He() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Ye() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function $e(Se) {
    q.equals(Se) === !1 && (s.scissor(Se.x, Se.y, Se.z, Se.w), q.copy(Se));
  }
  function Le(Se) {
    oe.equals(Se) === !1 && (s.viewport(Se.x, Se.y, Se.z, Se.w), oe.copy(Se));
  }
  function nt(Se, Ne) {
    let Re = u.get(Ne);
    Re === void 0 && (Re = /* @__PURE__ */ new WeakMap(), u.set(Ne, Re));
    let Be = Re.get(Se);
    Be === void 0 && (Be = s.getUniformBlockIndex(Ne, Se.name), Re.set(Se, Be));
  }
  function Je(Se, Ne) {
    const Be = u.get(Ne).get(Se);
    c.get(Ne) !== Be && (s.uniformBlockBinding(Ne, Be, Se.__bindingPointIndex), c.set(Ne, Be));
  }
  function bt() {
    s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), a.setReversed(!1), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), d = {}, le = null, re = {}, h = {}, m = /* @__PURE__ */ new WeakMap(), p = [], v = null, x = !1, g = null, _ = null, M = null, S = null, b = null, C = null, E = null, P = new Mt(0, 0, 0), T = 0, y = !1, w = null, D = null, U = null, R = null, O = null, q.set(0, 0, s.canvas.width, s.canvas.height), oe.set(0, 0, s.canvas.width, s.canvas.height), o.reset(), a.reset(), l.reset();
  }
  return {
    buffers: {
      color: o,
      depth: a,
      stencil: l
    },
    enable: V,
    disable: Y,
    bindFramebuffer: H,
    drawBuffers: I,
    useProgram: F,
    setBlending: Z,
    setMaterial: k,
    setFlipSided: ne,
    setCullFace: J,
    setLineWidth: B,
    setPolygonOffset: X,
    setScissorTest: se,
    activeTexture: z,
    bindTexture: N,
    unbindTexture: K,
    compressedTexImage2D: he,
    compressedTexImage3D: me,
    texImage2D: He,
    texImage3D: Ye,
    updateUBOMapping: nt,
    uniformBlockBinding: Je,
    texStorage2D: Xe,
    texStorage3D: Oe,
    texSubImage2D: ge,
    texSubImage3D: Me,
    compressedTexSubImage2D: Te,
    compressedTexSubImage3D: Ae,
    scissor: $e,
    viewport: Le,
    reset: bt
  };
}
function Ym(s, e, n, i) {
  const r = w2(i);
  switch (n) {
    case W0:
      return s * e;
    case j0:
      return s * e;
    case Y0:
      return s * e * 2;
    case Qc:
      return s * e / r.components * r.byteLength;
    case Ef:
      return s * e / r.components * r.byteLength;
    case q0:
      return s * e * 2 / r.components * r.byteLength;
    case Tf:
      return s * e * 2 / r.components * r.byteLength;
    case X0:
      return s * e * 3 / r.components * r.byteLength;
    case Un:
      return s * e * 4 / r.components * r.byteLength;
    case Af:
      return s * e * 4 / r.components * r.byteLength;
    case kc:
    case Ic:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Lc:
    case Fc:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case wh:
    case Mh:
      return Math.max(s, 16) * Math.max(e, 8) / 4;
    case bh:
    case Sh:
      return Math.max(s, 8) * Math.max(e, 8) / 2;
    case Ch:
    case Eh:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Th:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Ah:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Ph:
      return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Rh:
      return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Dh:
      return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case kh:
      return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Ih:
      return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Lh:
      return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Fh:
      return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Uh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Oh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case zh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Nh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Bh:
      return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Vh:
      return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Uc:
    case Gh:
    case Hh:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    case Z0:
    case $h:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case Wh:
    case Xh:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${n} format.`
  );
}
function w2(s) {
  switch (s) {
    case Xi:
    case G0:
      return { byteLength: 1, components: 1 };
    case cl:
    case H0:
    case ur:
      return { byteLength: 2, components: 1 };
    case Mf:
    case Cf:
      return { byteLength: 2, components: 4 };
    case Hr:
    case Sf:
    case di:
      return { byteLength: 4, components: 1 };
    case $0:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${s}.`);
}
function S2(s, e, n, i, r, o, a) {
  const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), u = new rt(), d = /* @__PURE__ */ new WeakMap();
  let h;
  const m = /* @__PURE__ */ new WeakMap();
  let p = !1;
  try {
    p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function v(z, N) {
    return p ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(z, N)
    ) : ul("canvas");
  }
  function x(z, N, K) {
    let he = 1;
    const me = se(z);
    if ((me.width > K || me.height > K) && (he = K / Math.max(me.width, me.height)), he < 1)
      if (typeof HTMLImageElement < "u" && z instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && z instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && z instanceof ImageBitmap || typeof VideoFrame < "u" && z instanceof VideoFrame) {
        const ge = Math.floor(he * me.width), Me = Math.floor(he * me.height);
        h === void 0 && (h = v(ge, Me));
        const Te = N ? v(ge, Me) : h;
        return Te.width = ge, Te.height = Me, Te.getContext("2d").drawImage(z, 0, 0, ge, Me), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + me.width + "x" + me.height + ") to (" + ge + "x" + Me + ")."), Te;
      } else
        return "data" in z && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + me.width + "x" + me.height + ")."), z;
    return z;
  }
  function g(z) {
    return z.generateMipmaps;
  }
  function _(z) {
    s.generateMipmap(z);
  }
  function M(z) {
    return z.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : z.isWebGL3DRenderTarget ? s.TEXTURE_3D : z.isWebGLArrayRenderTarget || z.isCompressedArrayTexture ? s.TEXTURE_2D_ARRAY : s.TEXTURE_2D;
  }
  function S(z, N, K, he, me = !1) {
    if (z !== null) {
      if (s[z] !== void 0) return s[z];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + z + "'");
    }
    let ge = N;
    if (N === s.RED && (K === s.FLOAT && (ge = s.R32F), K === s.HALF_FLOAT && (ge = s.R16F), K === s.UNSIGNED_BYTE && (ge = s.R8)), N === s.RED_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.R8UI), K === s.UNSIGNED_SHORT && (ge = s.R16UI), K === s.UNSIGNED_INT && (ge = s.R32UI), K === s.BYTE && (ge = s.R8I), K === s.SHORT && (ge = s.R16I), K === s.INT && (ge = s.R32I)), N === s.RG && (K === s.FLOAT && (ge = s.RG32F), K === s.HALF_FLOAT && (ge = s.RG16F), K === s.UNSIGNED_BYTE && (ge = s.RG8)), N === s.RG_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.RG8UI), K === s.UNSIGNED_SHORT && (ge = s.RG16UI), K === s.UNSIGNED_INT && (ge = s.RG32UI), K === s.BYTE && (ge = s.RG8I), K === s.SHORT && (ge = s.RG16I), K === s.INT && (ge = s.RG32I)), N === s.RGB_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.RGB8UI), K === s.UNSIGNED_SHORT && (ge = s.RGB16UI), K === s.UNSIGNED_INT && (ge = s.RGB32UI), K === s.BYTE && (ge = s.RGB8I), K === s.SHORT && (ge = s.RGB16I), K === s.INT && (ge = s.RGB32I)), N === s.RGBA_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.RGBA8UI), K === s.UNSIGNED_SHORT && (ge = s.RGBA16UI), K === s.UNSIGNED_INT && (ge = s.RGBA32UI), K === s.BYTE && (ge = s.RGBA8I), K === s.SHORT && (ge = s.RGBA16I), K === s.INT && (ge = s.RGBA32I)), N === s.RGB && K === s.UNSIGNED_INT_5_9_9_9_REV && (ge = s.RGB9_E5), N === s.RGBA) {
      const Me = me ? Cu : It.getTransfer(he);
      K === s.FLOAT && (ge = s.RGBA32F), K === s.HALF_FLOAT && (ge = s.RGBA16F), K === s.UNSIGNED_BYTE && (ge = Me === qt ? s.SRGB8_ALPHA8 : s.RGBA8), K === s.UNSIGNED_SHORT_4_4_4_4 && (ge = s.RGBA4), K === s.UNSIGNED_SHORT_5_5_5_1 && (ge = s.RGB5_A1);
    }
    return (ge === s.R16F || ge === s.R32F || ge === s.RG16F || ge === s.RG32F || ge === s.RGBA16F || ge === s.RGBA32F) && e.get("EXT_color_buffer_float"), ge;
  }
  function b(z, N) {
    let K;
    return z ? N === null || N === Hr || N === Go ? K = s.DEPTH24_STENCIL8 : N === di ? K = s.DEPTH32F_STENCIL8 : N === cl && (K = s.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : N === null || N === Hr || N === Go ? K = s.DEPTH_COMPONENT24 : N === di ? K = s.DEPTH_COMPONENT32F : N === cl && (K = s.DEPTH_COMPONENT16), K;
  }
  function C(z, N) {
    return g(z) === !0 || z.isFramebufferTexture && z.minFilter !== On && z.minFilter !== Bt ? Math.log2(Math.max(N.width, N.height)) + 1 : z.mipmaps !== void 0 && z.mipmaps.length > 0 ? z.mipmaps.length : z.isCompressedTexture && Array.isArray(z.image) ? N.mipmaps.length : 1;
  }
  function E(z) {
    const N = z.target;
    N.removeEventListener("dispose", E), T(N), N.isVideoTexture && d.delete(N);
  }
  function P(z) {
    const N = z.target;
    N.removeEventListener("dispose", P), w(N);
  }
  function T(z) {
    const N = i.get(z);
    if (N.__webglInit === void 0) return;
    const K = z.source, he = m.get(K);
    if (he) {
      const me = he[N.__cacheKey];
      me.usedTimes--, me.usedTimes === 0 && y(z), Object.keys(he).length === 0 && m.delete(K);
    }
    i.remove(z);
  }
  function y(z) {
    const N = i.get(z);
    s.deleteTexture(N.__webglTexture);
    const K = z.source, he = m.get(K);
    delete he[N.__cacheKey], a.memory.textures--;
  }
  function w(z) {
    const N = i.get(z);
    if (z.depthTexture && (z.depthTexture.dispose(), i.remove(z.depthTexture)), z.isWebGLCubeRenderTarget)
      for (let he = 0; he < 6; he++) {
        if (Array.isArray(N.__webglFramebuffer[he]))
          for (let me = 0; me < N.__webglFramebuffer[he].length; me++) s.deleteFramebuffer(N.__webglFramebuffer[he][me]);
        else
          s.deleteFramebuffer(N.__webglFramebuffer[he]);
        N.__webglDepthbuffer && s.deleteRenderbuffer(N.__webglDepthbuffer[he]);
      }
    else {
      if (Array.isArray(N.__webglFramebuffer))
        for (let he = 0; he < N.__webglFramebuffer.length; he++) s.deleteFramebuffer(N.__webglFramebuffer[he]);
      else
        s.deleteFramebuffer(N.__webglFramebuffer);
      if (N.__webglDepthbuffer && s.deleteRenderbuffer(N.__webglDepthbuffer), N.__webglMultisampledFramebuffer && s.deleteFramebuffer(N.__webglMultisampledFramebuffer), N.__webglColorRenderbuffer)
        for (let he = 0; he < N.__webglColorRenderbuffer.length; he++)
          N.__webglColorRenderbuffer[he] && s.deleteRenderbuffer(N.__webglColorRenderbuffer[he]);
      N.__webglDepthRenderbuffer && s.deleteRenderbuffer(N.__webglDepthRenderbuffer);
    }
    const K = z.textures;
    for (let he = 0, me = K.length; he < me; he++) {
      const ge = i.get(K[he]);
      ge.__webglTexture && (s.deleteTexture(ge.__webglTexture), a.memory.textures--), i.remove(K[he]);
    }
    i.remove(z);
  }
  let D = 0;
  function U() {
    D = 0;
  }
  function R() {
    const z = D;
    return z >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + z + " texture units while this GPU supports only " + r.maxTextures), D += 1, z;
  }
  function O(z) {
    const N = [];
    return N.push(z.wrapS), N.push(z.wrapT), N.push(z.wrapR || 0), N.push(z.magFilter), N.push(z.minFilter), N.push(z.anisotropy), N.push(z.internalFormat), N.push(z.format), N.push(z.type), N.push(z.generateMipmaps), N.push(z.premultiplyAlpha), N.push(z.flipY), N.push(z.unpackAlignment), N.push(z.colorSpace), N.join();
  }
  function A(z, N) {
    const K = i.get(z);
    if (z.isVideoTexture && B(z), z.isRenderTargetTexture === !1 && z.version > 0 && K.__version !== z.version) {
      const he = z.image;
      if (he === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (he.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        oe(K, z, N);
        return;
      }
    }
    n.bindTexture(s.TEXTURE_2D, K.__webglTexture, s.TEXTURE0 + N);
  }
  function G(z, N) {
    const K = i.get(z);
    if (z.version > 0 && K.__version !== z.version) {
      oe(K, z, N);
      return;
    }
    n.bindTexture(s.TEXTURE_2D_ARRAY, K.__webglTexture, s.TEXTURE0 + N);
  }
  function ue(z, N) {
    const K = i.get(z);
    if (z.version > 0 && K.__version !== z.version) {
      oe(K, z, N);
      return;
    }
    n.bindTexture(s.TEXTURE_3D, K.__webglTexture, s.TEXTURE0 + N);
  }
  function Q(z, N) {
    const K = i.get(z);
    if (z.version > 0 && K.__version !== z.version) {
      ie(K, z, N);
      return;
    }
    n.bindTexture(s.TEXTURE_CUBE_MAP, K.__webglTexture, s.TEXTURE0 + N);
  }
  const le = {
    [_h]: s.REPEAT,
    [Fr]: s.CLAMP_TO_EDGE,
    [xh]: s.MIRRORED_REPEAT
  }, re = {
    [On]: s.NEAREST,
    [Qx]: s.NEAREST_MIPMAP_NEAREST,
    [zl]: s.NEAREST_MIPMAP_LINEAR,
    [Bt]: s.LINEAR,
    [td]: s.LINEAR_MIPMAP_NEAREST,
    [Ur]: s.LINEAR_MIPMAP_LINEAR
  }, j = {
    [nb]: s.NEVER,
    [lb]: s.ALWAYS,
    [ib]: s.LESS,
    [K0]: s.LEQUAL,
    [sb]: s.EQUAL,
    [ab]: s.GEQUAL,
    [rb]: s.GREATER,
    [ob]: s.NOTEQUAL
  };
  function $(z, N) {
    if (N.type === di && e.has("OES_texture_float_linear") === !1 && (N.magFilter === Bt || N.magFilter === td || N.magFilter === zl || N.magFilter === Ur || N.minFilter === Bt || N.minFilter === td || N.minFilter === zl || N.minFilter === Ur) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(z, s.TEXTURE_WRAP_S, le[N.wrapS]), s.texParameteri(z, s.TEXTURE_WRAP_T, le[N.wrapT]), (z === s.TEXTURE_3D || z === s.TEXTURE_2D_ARRAY) && s.texParameteri(z, s.TEXTURE_WRAP_R, le[N.wrapR]), s.texParameteri(z, s.TEXTURE_MAG_FILTER, re[N.magFilter]), s.texParameteri(z, s.TEXTURE_MIN_FILTER, re[N.minFilter]), N.compareFunction && (s.texParameteri(z, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(z, s.TEXTURE_COMPARE_FUNC, j[N.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (N.magFilter === On || N.minFilter !== zl && N.minFilter !== Ur || N.type === di && e.has("OES_texture_float_linear") === !1) return;
      if (N.anisotropy > 1 || i.get(N).__currentAnisotropy) {
        const K = e.get("EXT_texture_filter_anisotropic");
        s.texParameterf(z, K.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(N.anisotropy, r.getMaxAnisotropy())), i.get(N).__currentAnisotropy = N.anisotropy;
      }
    }
  }
  function q(z, N) {
    let K = !1;
    z.__webglInit === void 0 && (z.__webglInit = !0, N.addEventListener("dispose", E));
    const he = N.source;
    let me = m.get(he);
    me === void 0 && (me = {}, m.set(he, me));
    const ge = O(N);
    if (ge !== z.__cacheKey) {
      me[ge] === void 0 && (me[ge] = {
        texture: s.createTexture(),
        usedTimes: 0
      }, a.memory.textures++, K = !0), me[ge].usedTimes++;
      const Me = me[z.__cacheKey];
      Me !== void 0 && (me[z.__cacheKey].usedTimes--, Me.usedTimes === 0 && y(N)), z.__cacheKey = ge, z.__webglTexture = me[ge].texture;
    }
    return K;
  }
  function oe(z, N, K) {
    let he = s.TEXTURE_2D;
    (N.isDataArrayTexture || N.isCompressedArrayTexture) && (he = s.TEXTURE_2D_ARRAY), N.isData3DTexture && (he = s.TEXTURE_3D);
    const me = q(z, N), ge = N.source;
    n.bindTexture(he, z.__webglTexture, s.TEXTURE0 + K);
    const Me = i.get(ge);
    if (ge.version !== Me.__version || me === !0) {
      n.activeTexture(s.TEXTURE0 + K);
      const Te = It.getPrimaries(It.workingColorSpace), Ae = N.colorSpace === ir ? null : It.getPrimaries(N.colorSpace), Xe = N.colorSpace === ir || Te === Ae ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, N.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, N.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Xe);
      let Oe = x(N.image, !1, r.maxTextureSize);
      Oe = X(N, Oe);
      const He = o.convert(N.format, N.colorSpace), Ye = o.convert(N.type);
      let $e = S(N.internalFormat, He, Ye, N.colorSpace, N.isVideoTexture);
      $(he, N);
      let Le;
      const nt = N.mipmaps, Je = N.isVideoTexture !== !0, bt = Me.__version === void 0 || me === !0, Se = ge.dataReady, Ne = C(N, Oe);
      if (N.isDepthTexture)
        $e = b(N.format === Ho, N.type), bt && (Je ? n.texStorage2D(s.TEXTURE_2D, 1, $e, Oe.width, Oe.height) : n.texImage2D(s.TEXTURE_2D, 0, $e, Oe.width, Oe.height, 0, He, Ye, null));
      else if (N.isDataTexture)
        if (nt.length > 0) {
          Je && bt && n.texStorage2D(s.TEXTURE_2D, Ne, $e, nt[0].width, nt[0].height);
          for (let Re = 0, Be = nt.length; Re < Be; Re++)
            Le = nt[Re], Je ? Se && n.texSubImage2D(s.TEXTURE_2D, Re, 0, 0, Le.width, Le.height, He, Ye, Le.data) : n.texImage2D(s.TEXTURE_2D, Re, $e, Le.width, Le.height, 0, He, Ye, Le.data);
          N.generateMipmaps = !1;
        } else
          Je ? (bt && n.texStorage2D(s.TEXTURE_2D, Ne, $e, Oe.width, Oe.height), Se && n.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Oe.width, Oe.height, He, Ye, Oe.data)) : n.texImage2D(s.TEXTURE_2D, 0, $e, Oe.width, Oe.height, 0, He, Ye, Oe.data);
      else if (N.isCompressedTexture)
        if (N.isCompressedArrayTexture) {
          Je && bt && n.texStorage3D(s.TEXTURE_2D_ARRAY, Ne, $e, nt[0].width, nt[0].height, Oe.depth);
          for (let Re = 0, Be = nt.length; Re < Be; Re++)
            if (Le = nt[Re], N.format !== Un)
              if (He !== null)
                if (Je) {
                  if (Se)
                    if (N.layerUpdates.size > 0) {
                      const je = Ym(Le.width, Le.height, N.format, N.type);
                      for (const Ge of N.layerUpdates) {
                        const ut = Le.data.subarray(
                          Ge * je / Le.data.BYTES_PER_ELEMENT,
                          (Ge + 1) * je / Le.data.BYTES_PER_ELEMENT
                        );
                        n.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, Re, 0, 0, Ge, Le.width, Le.height, 1, He, ut);
                      }
                      N.clearLayerUpdates();
                    } else
                      n.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, Re, 0, 0, 0, Le.width, Le.height, Oe.depth, He, Le.data);
                } else
                  n.compressedTexImage3D(s.TEXTURE_2D_ARRAY, Re, $e, Le.width, Le.height, Oe.depth, 0, Le.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              Je ? Se && n.texSubImage3D(s.TEXTURE_2D_ARRAY, Re, 0, 0, 0, Le.width, Le.height, Oe.depth, He, Ye, Le.data) : n.texImage3D(s.TEXTURE_2D_ARRAY, Re, $e, Le.width, Le.height, Oe.depth, 0, He, Ye, Le.data);
        } else {
          Je && bt && n.texStorage2D(s.TEXTURE_2D, Ne, $e, nt[0].width, nt[0].height);
          for (let Re = 0, Be = nt.length; Re < Be; Re++)
            Le = nt[Re], N.format !== Un ? He !== null ? Je ? Se && n.compressedTexSubImage2D(s.TEXTURE_2D, Re, 0, 0, Le.width, Le.height, He, Le.data) : n.compressedTexImage2D(s.TEXTURE_2D, Re, $e, Le.width, Le.height, 0, Le.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Je ? Se && n.texSubImage2D(s.TEXTURE_2D, Re, 0, 0, Le.width, Le.height, He, Ye, Le.data) : n.texImage2D(s.TEXTURE_2D, Re, $e, Le.width, Le.height, 0, He, Ye, Le.data);
        }
      else if (N.isDataArrayTexture)
        if (Je) {
          if (bt && n.texStorage3D(s.TEXTURE_2D_ARRAY, Ne, $e, Oe.width, Oe.height, Oe.depth), Se)
            if (N.layerUpdates.size > 0) {
              const Re = Ym(Oe.width, Oe.height, N.format, N.type);
              for (const Be of N.layerUpdates) {
                const je = Oe.data.subarray(
                  Be * Re / Oe.data.BYTES_PER_ELEMENT,
                  (Be + 1) * Re / Oe.data.BYTES_PER_ELEMENT
                );
                n.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, Be, Oe.width, Oe.height, 1, He, Ye, je);
              }
              N.clearLayerUpdates();
            } else
              n.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Oe.width, Oe.height, Oe.depth, He, Ye, Oe.data);
        } else
          n.texImage3D(s.TEXTURE_2D_ARRAY, 0, $e, Oe.width, Oe.height, Oe.depth, 0, He, Ye, Oe.data);
      else if (N.isData3DTexture)
        Je ? (bt && n.texStorage3D(s.TEXTURE_3D, Ne, $e, Oe.width, Oe.height, Oe.depth), Se && n.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, Oe.width, Oe.height, Oe.depth, He, Ye, Oe.data)) : n.texImage3D(s.TEXTURE_3D, 0, $e, Oe.width, Oe.height, Oe.depth, 0, He, Ye, Oe.data);
      else if (N.isFramebufferTexture) {
        if (bt)
          if (Je)
            n.texStorage2D(s.TEXTURE_2D, Ne, $e, Oe.width, Oe.height);
          else {
            let Re = Oe.width, Be = Oe.height;
            for (let je = 0; je < Ne; je++)
              n.texImage2D(s.TEXTURE_2D, je, $e, Re, Be, 0, He, Ye, null), Re >>= 1, Be >>= 1;
          }
      } else if (nt.length > 0) {
        if (Je && bt) {
          const Re = se(nt[0]);
          n.texStorage2D(s.TEXTURE_2D, Ne, $e, Re.width, Re.height);
        }
        for (let Re = 0, Be = nt.length; Re < Be; Re++)
          Le = nt[Re], Je ? Se && n.texSubImage2D(s.TEXTURE_2D, Re, 0, 0, He, Ye, Le) : n.texImage2D(s.TEXTURE_2D, Re, $e, He, Ye, Le);
        N.generateMipmaps = !1;
      } else if (Je) {
        if (bt) {
          const Re = se(Oe);
          n.texStorage2D(s.TEXTURE_2D, Ne, $e, Re.width, Re.height);
        }
        Se && n.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, He, Ye, Oe);
      } else
        n.texImage2D(s.TEXTURE_2D, 0, $e, He, Ye, Oe);
      g(N) && _(he), Me.__version = ge.version, N.onUpdate && N.onUpdate(N);
    }
    z.__version = N.version;
  }
  function ie(z, N, K) {
    if (N.image.length !== 6) return;
    const he = q(z, N), me = N.source;
    n.bindTexture(s.TEXTURE_CUBE_MAP, z.__webglTexture, s.TEXTURE0 + K);
    const ge = i.get(me);
    if (me.version !== ge.__version || he === !0) {
      n.activeTexture(s.TEXTURE0 + K);
      const Me = It.getPrimaries(It.workingColorSpace), Te = N.colorSpace === ir ? null : It.getPrimaries(N.colorSpace), Ae = N.colorSpace === ir || Me === Te ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, N.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, N.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ae);
      const Xe = N.isCompressedTexture || N.image[0].isCompressedTexture, Oe = N.image[0] && N.image[0].isDataTexture, He = [];
      for (let Be = 0; Be < 6; Be++)
        !Xe && !Oe ? He[Be] = x(N.image[Be], !0, r.maxCubemapSize) : He[Be] = Oe ? N.image[Be].image : N.image[Be], He[Be] = X(N, He[Be]);
      const Ye = He[0], $e = o.convert(N.format, N.colorSpace), Le = o.convert(N.type), nt = S(N.internalFormat, $e, Le, N.colorSpace), Je = N.isVideoTexture !== !0, bt = ge.__version === void 0 || he === !0, Se = me.dataReady;
      let Ne = C(N, Ye);
      $(s.TEXTURE_CUBE_MAP, N);
      let Re;
      if (Xe) {
        Je && bt && n.texStorage2D(s.TEXTURE_CUBE_MAP, Ne, nt, Ye.width, Ye.height);
        for (let Be = 0; Be < 6; Be++) {
          Re = He[Be].mipmaps;
          for (let je = 0; je < Re.length; je++) {
            const Ge = Re[je];
            N.format !== Un ? $e !== null ? Je ? Se && n.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, 0, 0, Ge.width, Ge.height, $e, Ge.data) : n.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, nt, Ge.width, Ge.height, 0, Ge.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Je ? Se && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, 0, 0, Ge.width, Ge.height, $e, Le, Ge.data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, nt, Ge.width, Ge.height, 0, $e, Le, Ge.data);
          }
        }
      } else {
        if (Re = N.mipmaps, Je && bt) {
          Re.length > 0 && Ne++;
          const Be = se(He[0]);
          n.texStorage2D(s.TEXTURE_CUBE_MAP, Ne, nt, Be.width, Be.height);
        }
        for (let Be = 0; Be < 6; Be++)
          if (Oe) {
            Je ? Se && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, 0, 0, He[Be].width, He[Be].height, $e, Le, He[Be].data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, nt, He[Be].width, He[Be].height, 0, $e, Le, He[Be].data);
            for (let je = 0; je < Re.length; je++) {
              const ut = Re[je].image[Be].image;
              Je ? Se && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, 0, 0, ut.width, ut.height, $e, Le, ut.data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, nt, ut.width, ut.height, 0, $e, Le, ut.data);
            }
          } else {
            Je ? Se && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, 0, 0, $e, Le, He[Be]) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, nt, $e, Le, He[Be]);
            for (let je = 0; je < Re.length; je++) {
              const Ge = Re[je];
              Je ? Se && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, 0, 0, $e, Le, Ge.image[Be]) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, nt, $e, Le, Ge.image[Be]);
            }
          }
      }
      g(N) && _(s.TEXTURE_CUBE_MAP), ge.__version = me.version, N.onUpdate && N.onUpdate(N);
    }
    z.__version = N.version;
  }
  function ce(z, N, K, he, me, ge) {
    const Me = o.convert(K.format, K.colorSpace), Te = o.convert(K.type), Ae = S(K.internalFormat, Me, Te, K.colorSpace), Xe = i.get(N), Oe = i.get(K);
    if (Oe.__renderTarget = N, !Xe.__hasExternalTextures) {
      const He = Math.max(1, N.width >> ge), Ye = Math.max(1, N.height >> ge);
      me === s.TEXTURE_3D || me === s.TEXTURE_2D_ARRAY ? n.texImage3D(me, ge, Ae, He, Ye, N.depth, 0, Me, Te, null) : n.texImage2D(me, ge, Ae, He, Ye, 0, Me, Te, null);
    }
    n.bindFramebuffer(s.FRAMEBUFFER, z), J(N) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, he, me, Oe.__webglTexture, 0, ne(N)) : (me === s.TEXTURE_2D || me >= s.TEXTURE_CUBE_MAP_POSITIVE_X && me <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, he, me, Oe.__webglTexture, ge), n.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function V(z, N, K) {
    if (s.bindRenderbuffer(s.RENDERBUFFER, z), N.depthBuffer) {
      const he = N.depthTexture, me = he && he.isDepthTexture ? he.type : null, ge = b(N.stencilBuffer, me), Me = N.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Te = ne(N);
      J(N) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Te, ge, N.width, N.height) : K ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Te, ge, N.width, N.height) : s.renderbufferStorage(s.RENDERBUFFER, ge, N.width, N.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, Me, s.RENDERBUFFER, z);
    } else {
      const he = N.textures;
      for (let me = 0; me < he.length; me++) {
        const ge = he[me], Me = o.convert(ge.format, ge.colorSpace), Te = o.convert(ge.type), Ae = S(ge.internalFormat, Me, Te, ge.colorSpace), Xe = ne(N);
        K && J(N) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Xe, Ae, N.width, N.height) : J(N) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Xe, Ae, N.width, N.height) : s.renderbufferStorage(s.RENDERBUFFER, Ae, N.width, N.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function Y(z, N) {
    if (N && N.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (n.bindFramebuffer(s.FRAMEBUFFER, z), !(N.depthTexture && N.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const he = i.get(N.depthTexture);
    he.__renderTarget = N, (!he.__webglTexture || N.depthTexture.image.width !== N.width || N.depthTexture.image.height !== N.height) && (N.depthTexture.image.width = N.width, N.depthTexture.image.height = N.height, N.depthTexture.needsUpdate = !0), A(N.depthTexture, 0);
    const me = he.__webglTexture, ge = ne(N);
    if (N.depthTexture.format === Nr)
      J(N) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, me, 0, ge) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, me, 0);
    else if (N.depthTexture.format === Ho)
      J(N) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, me, 0, ge) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, me, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function H(z) {
    const N = i.get(z), K = z.isWebGLCubeRenderTarget === !0;
    if (N.__boundDepthTexture !== z.depthTexture) {
      const he = z.depthTexture;
      if (N.__depthDisposeCallback && N.__depthDisposeCallback(), he) {
        const me = () => {
          delete N.__boundDepthTexture, delete N.__depthDisposeCallback, he.removeEventListener("dispose", me);
        };
        he.addEventListener("dispose", me), N.__depthDisposeCallback = me;
      }
      N.__boundDepthTexture = he;
    }
    if (z.depthTexture && !N.__autoAllocateDepthBuffer) {
      if (K) throw new Error("target.depthTexture not supported in Cube render targets");
      Y(N.__webglFramebuffer, z);
    } else if (K) {
      N.__webglDepthbuffer = [];
      for (let he = 0; he < 6; he++)
        if (n.bindFramebuffer(s.FRAMEBUFFER, N.__webglFramebuffer[he]), N.__webglDepthbuffer[he] === void 0)
          N.__webglDepthbuffer[he] = s.createRenderbuffer(), V(N.__webglDepthbuffer[he], z, !1);
        else {
          const me = z.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, ge = N.__webglDepthbuffer[he];
          s.bindRenderbuffer(s.RENDERBUFFER, ge), s.framebufferRenderbuffer(s.FRAMEBUFFER, me, s.RENDERBUFFER, ge);
        }
    } else if (n.bindFramebuffer(s.FRAMEBUFFER, N.__webglFramebuffer), N.__webglDepthbuffer === void 0)
      N.__webglDepthbuffer = s.createRenderbuffer(), V(N.__webglDepthbuffer, z, !1);
    else {
      const he = z.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, me = N.__webglDepthbuffer;
      s.bindRenderbuffer(s.RENDERBUFFER, me), s.framebufferRenderbuffer(s.FRAMEBUFFER, he, s.RENDERBUFFER, me);
    }
    n.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function I(z, N, K) {
    const he = i.get(z);
    N !== void 0 && ce(he.__webglFramebuffer, z, z.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), K !== void 0 && H(z);
  }
  function F(z) {
    const N = z.texture, K = i.get(z), he = i.get(N);
    z.addEventListener("dispose", P);
    const me = z.textures, ge = z.isWebGLCubeRenderTarget === !0, Me = me.length > 1;
    if (Me || (he.__webglTexture === void 0 && (he.__webglTexture = s.createTexture()), he.__version = N.version, a.memory.textures++), ge) {
      K.__webglFramebuffer = [];
      for (let Te = 0; Te < 6; Te++)
        if (N.mipmaps && N.mipmaps.length > 0) {
          K.__webglFramebuffer[Te] = [];
          for (let Ae = 0; Ae < N.mipmaps.length; Ae++)
            K.__webglFramebuffer[Te][Ae] = s.createFramebuffer();
        } else
          K.__webglFramebuffer[Te] = s.createFramebuffer();
    } else {
      if (N.mipmaps && N.mipmaps.length > 0) {
        K.__webglFramebuffer = [];
        for (let Te = 0; Te < N.mipmaps.length; Te++)
          K.__webglFramebuffer[Te] = s.createFramebuffer();
      } else
        K.__webglFramebuffer = s.createFramebuffer();
      if (Me)
        for (let Te = 0, Ae = me.length; Te < Ae; Te++) {
          const Xe = i.get(me[Te]);
          Xe.__webglTexture === void 0 && (Xe.__webglTexture = s.createTexture(), a.memory.textures++);
        }
      if (z.samples > 0 && J(z) === !1) {
        K.__webglMultisampledFramebuffer = s.createFramebuffer(), K.__webglColorRenderbuffer = [], n.bindFramebuffer(s.FRAMEBUFFER, K.__webglMultisampledFramebuffer);
        for (let Te = 0; Te < me.length; Te++) {
          const Ae = me[Te];
          K.__webglColorRenderbuffer[Te] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, K.__webglColorRenderbuffer[Te]);
          const Xe = o.convert(Ae.format, Ae.colorSpace), Oe = o.convert(Ae.type), He = S(Ae.internalFormat, Xe, Oe, Ae.colorSpace, z.isXRRenderTarget === !0), Ye = ne(z);
          s.renderbufferStorageMultisample(s.RENDERBUFFER, Ye, He, z.width, z.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Te, s.RENDERBUFFER, K.__webglColorRenderbuffer[Te]);
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null), z.depthBuffer && (K.__webglDepthRenderbuffer = s.createRenderbuffer(), V(K.__webglDepthRenderbuffer, z, !0)), n.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (ge) {
      n.bindTexture(s.TEXTURE_CUBE_MAP, he.__webglTexture), $(s.TEXTURE_CUBE_MAP, N);
      for (let Te = 0; Te < 6; Te++)
        if (N.mipmaps && N.mipmaps.length > 0)
          for (let Ae = 0; Ae < N.mipmaps.length; Ae++)
            ce(K.__webglFramebuffer[Te][Ae], z, N, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Ae);
        else
          ce(K.__webglFramebuffer[Te], z, N, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0);
      g(N) && _(s.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (Me) {
      for (let Te = 0, Ae = me.length; Te < Ae; Te++) {
        const Xe = me[Te], Oe = i.get(Xe);
        n.bindTexture(s.TEXTURE_2D, Oe.__webglTexture), $(s.TEXTURE_2D, Xe), ce(K.__webglFramebuffer, z, Xe, s.COLOR_ATTACHMENT0 + Te, s.TEXTURE_2D, 0), g(Xe) && _(s.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      let Te = s.TEXTURE_2D;
      if ((z.isWebGL3DRenderTarget || z.isWebGLArrayRenderTarget) && (Te = z.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), n.bindTexture(Te, he.__webglTexture), $(Te, N), N.mipmaps && N.mipmaps.length > 0)
        for (let Ae = 0; Ae < N.mipmaps.length; Ae++)
          ce(K.__webglFramebuffer[Ae], z, N, s.COLOR_ATTACHMENT0, Te, Ae);
      else
        ce(K.__webglFramebuffer, z, N, s.COLOR_ATTACHMENT0, Te, 0);
      g(N) && _(Te), n.unbindTexture();
    }
    z.depthBuffer && H(z);
  }
  function L(z) {
    const N = z.textures;
    for (let K = 0, he = N.length; K < he; K++) {
      const me = N[K];
      if (g(me)) {
        const ge = M(z), Me = i.get(me).__webglTexture;
        n.bindTexture(ge, Me), _(ge), n.unbindTexture();
      }
    }
  }
  const ee = [], Z = [];
  function k(z) {
    if (z.samples > 0) {
      if (J(z) === !1) {
        const N = z.textures, K = z.width, he = z.height;
        let me = s.COLOR_BUFFER_BIT;
        const ge = z.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Me = i.get(z), Te = N.length > 1;
        if (Te)
          for (let Ae = 0; Ae < N.length; Ae++)
            n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.RENDERBUFFER, null), n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.TEXTURE_2D, null, 0);
        n.bindFramebuffer(s.READ_FRAMEBUFFER, Me.__webglMultisampledFramebuffer), n.bindFramebuffer(s.DRAW_FRAMEBUFFER, Me.__webglFramebuffer);
        for (let Ae = 0; Ae < N.length; Ae++) {
          if (z.resolveDepthBuffer && (z.depthBuffer && (me |= s.DEPTH_BUFFER_BIT), z.stencilBuffer && z.resolveStencilBuffer && (me |= s.STENCIL_BUFFER_BIT)), Te) {
            s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Me.__webglColorRenderbuffer[Ae]);
            const Xe = i.get(N[Ae]).__webglTexture;
            s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, Xe, 0);
          }
          s.blitFramebuffer(0, 0, K, he, 0, 0, K, he, me, s.NEAREST), c === !0 && (ee.length = 0, Z.length = 0, ee.push(s.COLOR_ATTACHMENT0 + Ae), z.depthBuffer && z.resolveDepthBuffer === !1 && (ee.push(ge), Z.push(ge), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, Z)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, ee));
        }
        if (n.bindFramebuffer(s.READ_FRAMEBUFFER, null), n.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), Te)
          for (let Ae = 0; Ae < N.length; Ae++) {
            n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.RENDERBUFFER, Me.__webglColorRenderbuffer[Ae]);
            const Xe = i.get(N[Ae]).__webglTexture;
            n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.TEXTURE_2D, Xe, 0);
          }
        n.bindFramebuffer(s.DRAW_FRAMEBUFFER, Me.__webglMultisampledFramebuffer);
      } else if (z.depthBuffer && z.resolveDepthBuffer === !1 && c) {
        const N = z.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
        s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [N]);
      }
    }
  }
  function ne(z) {
    return Math.min(r.maxSamples, z.samples);
  }
  function J(z) {
    const N = i.get(z);
    return z.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && N.__useRenderToTexture !== !1;
  }
  function B(z) {
    const N = a.render.frame;
    d.get(z) !== N && (d.set(z, N), z.update());
  }
  function X(z, N) {
    const K = z.colorSpace, he = z.format, me = z.type;
    return z.isCompressedTexture === !0 || z.isVideoTexture === !0 || K !== Zo && K !== ir && (It.getTransfer(K) === qt ? (he !== Un || me !== Xi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", K)), N;
  }
  function se(z) {
    return typeof HTMLImageElement < "u" && z instanceof HTMLImageElement ? (u.width = z.naturalWidth || z.width, u.height = z.naturalHeight || z.height) : typeof VideoFrame < "u" && z instanceof VideoFrame ? (u.width = z.displayWidth, u.height = z.displayHeight) : (u.width = z.width, u.height = z.height), u;
  }
  this.allocateTextureUnit = R, this.resetTextureUnits = U, this.setTexture2D = A, this.setTexture2DArray = G, this.setTexture3D = ue, this.setTextureCube = Q, this.rebindTextures = I, this.setupRenderTarget = F, this.updateRenderTargetMipmap = L, this.updateMultisampleRenderTarget = k, this.setupDepthRenderbuffer = H, this.setupFrameBufferTexture = ce, this.useMultisampledRTT = J;
}
function M2(s, e) {
  function n(i, r = ir) {
    let o;
    const a = It.getTransfer(r);
    if (i === Xi) return s.UNSIGNED_BYTE;
    if (i === Mf) return s.UNSIGNED_SHORT_4_4_4_4;
    if (i === Cf) return s.UNSIGNED_SHORT_5_5_5_1;
    if (i === $0) return s.UNSIGNED_INT_5_9_9_9_REV;
    if (i === G0) return s.BYTE;
    if (i === H0) return s.SHORT;
    if (i === cl) return s.UNSIGNED_SHORT;
    if (i === Sf) return s.INT;
    if (i === Hr) return s.UNSIGNED_INT;
    if (i === di) return s.FLOAT;
    if (i === ur) return s.HALF_FLOAT;
    if (i === W0) return s.ALPHA;
    if (i === X0) return s.RGB;
    if (i === Un) return s.RGBA;
    if (i === j0) return s.LUMINANCE;
    if (i === Y0) return s.LUMINANCE_ALPHA;
    if (i === Nr) return s.DEPTH_COMPONENT;
    if (i === Ho) return s.DEPTH_STENCIL;
    if (i === Qc) return s.RED;
    if (i === Ef) return s.RED_INTEGER;
    if (i === q0) return s.RG;
    if (i === Tf) return s.RG_INTEGER;
    if (i === Af) return s.RGBA_INTEGER;
    if (i === kc || i === Ic || i === Lc || i === Fc)
      if (a === qt)
        if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (i === kc) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === Ic) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === Lc) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === Fc) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (i === kc) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (i === Ic) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (i === Lc) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (i === Fc) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (i === bh || i === wh || i === Sh || i === Mh)
      if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (i === bh) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (i === wh) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (i === Sh) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (i === Mh) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (i === Ch || i === Eh || i === Th)
      if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (i === Ch || i === Eh) return a === qt ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (i === Th) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (i === Ah || i === Ph || i === Rh || i === Dh || i === kh || i === Ih || i === Lh || i === Fh || i === Uh || i === Oh || i === zh || i === Nh || i === Bh || i === Vh)
      if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (i === Ah) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (i === Ph) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (i === Rh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (i === Dh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (i === kh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (i === Ih) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (i === Lh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (i === Fh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (i === Uh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (i === Oh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (i === zh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (i === Nh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (i === Bh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (i === Vh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (i === Uc || i === Gh || i === Hh)
      if (o = e.get("EXT_texture_compression_bptc"), o !== null) {
        if (i === Uc) return a === qt ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (i === Gh) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (i === Hh) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (i === Z0 || i === $h || i === Wh || i === Xh)
      if (o = e.get("EXT_texture_compression_rgtc"), o !== null) {
        if (i === Uc) return o.COMPRESSED_RED_RGTC1_EXT;
        if (i === $h) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (i === Wh) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (i === Xh) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return i === Go ? s.UNSIGNED_INT_24_8 : s[i] !== void 0 ? s[i] : null;
  }
  return { convert: n };
}
class C2 extends ui {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Ai extends cn {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const E2 = { type: "move" };
class Ad {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Ai(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Ai(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new de(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new de()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Ai(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new de(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new de()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const n = this._hand;
      if (n)
        for (const i of e.hand.values())
          this._getHandJoint(n, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, n, i) {
    let r = null, o = null, a = null;
    const l = this._targetRay, c = this._grip, u = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        a = !0;
        for (const x of e.hand.values()) {
          const g = n.getJointPose(x, i), _ = this._getHandJoint(u, x);
          g !== null && (_.matrix.fromArray(g.transform.matrix), _.matrix.decompose(_.position, _.rotation, _.scale), _.matrixWorldNeedsUpdate = !0, _.jointRadius = g.radius), _.visible = g !== null;
        }
        const d = u.joints["index-finger-tip"], h = u.joints["thumb-tip"], m = d.position.distanceTo(h.position), p = 0.02, v = 5e-3;
        u.inputState.pinching && m > p + v ? (u.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !u.inputState.pinching && m <= p - v && (u.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        c !== null && e.gripSpace && (o = n.getPose(e.gripSpace, i), o !== null && (c.matrix.fromArray(o.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(o.linearVelocity)) : c.hasLinearVelocity = !1, o.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(o.angularVelocity)) : c.hasAngularVelocity = !1));
      l !== null && (r = n.getPose(e.targetRaySpace, i), r === null && o !== null && (r = o), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent(E2)));
    }
    return l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), u !== null && (u.visible = a !== null), this;
  }
  // private method
  _getHandJoint(e, n) {
    if (e.joints[n.jointName] === void 0) {
      const i = new Ai();
      i.matrixAutoUpdate = !1, i.visible = !1, e.joints[n.jointName] = i, e.add(i);
    }
    return e.joints[n.jointName];
  }
}
const T2 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, A2 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class P2 {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, n, i) {
    if (this.texture === null) {
      const r = new xn(), o = e.properties.get(r);
      o.__webglTexture = n.texture, (n.depthNear != i.depthNear || n.depthFar != i.depthFar) && (this.depthNear = n.depthNear, this.depthFar = n.depthFar), this.texture = r;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const n = e.cameras[0].viewport, i = new zn({
        vertexShader: T2,
        fragmentShader: A2,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: n.z },
          depthHeight: { value: n.w }
        }
      });
      this.mesh = new Ze(new un(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class R2 extends Wr {
  constructor(e, n) {
    super();
    const i = this;
    let r = null, o = 1, a = null, l = "local-floor", c = 1, u = null, d = null, h = null, m = null, p = null, v = null;
    const x = new P2(), g = n.getContextAttributes();
    let _ = null, M = null;
    const S = [], b = [], C = new rt();
    let E = null;
    const P = new ui();
    P.viewport = new jt();
    const T = new ui();
    T.viewport = new jt();
    const y = [P, T], w = new C2();
    let D = null, U = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(oe) {
      let ie = S[oe];
      return ie === void 0 && (ie = new Ad(), S[oe] = ie), ie.getTargetRaySpace();
    }, this.getControllerGrip = function(oe) {
      let ie = S[oe];
      return ie === void 0 && (ie = new Ad(), S[oe] = ie), ie.getGripSpace();
    }, this.getHand = function(oe) {
      let ie = S[oe];
      return ie === void 0 && (ie = new Ad(), S[oe] = ie), ie.getHandSpace();
    };
    function R(oe) {
      const ie = b.indexOf(oe.inputSource);
      if (ie === -1)
        return;
      const ce = S[ie];
      ce !== void 0 && (ce.update(oe.inputSource, oe.frame, u || a), ce.dispatchEvent({ type: oe.type, data: oe.inputSource }));
    }
    function O() {
      r.removeEventListener("select", R), r.removeEventListener("selectstart", R), r.removeEventListener("selectend", R), r.removeEventListener("squeeze", R), r.removeEventListener("squeezestart", R), r.removeEventListener("squeezeend", R), r.removeEventListener("end", O), r.removeEventListener("inputsourceschange", A);
      for (let oe = 0; oe < S.length; oe++) {
        const ie = b[oe];
        ie !== null && (b[oe] = null, S[oe].disconnect(ie));
      }
      D = null, U = null, x.reset(), e.setRenderTarget(_), p = null, m = null, h = null, r = null, M = null, q.stop(), i.isPresenting = !1, e.setPixelRatio(E), e.setSize(C.width, C.height, !1), i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(oe) {
      o = oe, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(oe) {
      l = oe, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return u || a;
    }, this.setReferenceSpace = function(oe) {
      u = oe;
    }, this.getBaseLayer = function() {
      return m !== null ? m : p;
    }, this.getBinding = function() {
      return h;
    }, this.getFrame = function() {
      return v;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(oe) {
      if (r = oe, r !== null) {
        if (_ = e.getRenderTarget(), r.addEventListener("select", R), r.addEventListener("selectstart", R), r.addEventListener("selectend", R), r.addEventListener("squeeze", R), r.addEventListener("squeezestart", R), r.addEventListener("squeezeend", R), r.addEventListener("end", O), r.addEventListener("inputsourceschange", A), g.xrCompatible !== !0 && await n.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(C), r.renderState.layers === void 0) {
          const ie = {
            antialias: g.antialias,
            alpha: !0,
            depth: g.depth,
            stencil: g.stencil,
            framebufferScaleFactor: o
          };
          p = new XRWebGLLayer(r, n, ie), r.updateRenderState({ baseLayer: p }), e.setPixelRatio(1), e.setSize(p.framebufferWidth, p.framebufferHeight, !1), M = new Ri(
            p.framebufferWidth,
            p.framebufferHeight,
            {
              format: Un,
              type: Xi,
              colorSpace: e.outputColorSpace,
              stencilBuffer: g.stencil
            }
          );
        } else {
          let ie = null, ce = null, V = null;
          g.depth && (V = g.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24, ie = g.stencil ? Ho : Nr, ce = g.stencil ? Go : Hr);
          const Y = {
            colorFormat: n.RGBA8,
            depthFormat: V,
            scaleFactor: o
          };
          h = new XRWebGLBinding(r, n), m = h.createProjectionLayer(Y), r.updateRenderState({ layers: [m] }), e.setPixelRatio(1), e.setSize(m.textureWidth, m.textureHeight, !1), M = new Ri(
            m.textureWidth,
            m.textureHeight,
            {
              format: Un,
              type: Xi,
              depthTexture: new Uf(m.textureWidth, m.textureHeight, ce, void 0, void 0, void 0, void 0, void 0, void 0, ie),
              stencilBuffer: g.stencil,
              colorSpace: e.outputColorSpace,
              samples: g.antialias ? 4 : 0,
              resolveDepthBuffer: m.ignoreDepthValues === !1
            }
          );
        }
        M.isXRRenderTarget = !0, this.setFoveation(c), u = null, a = await r.requestReferenceSpace(l), q.setContext(r), q.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null)
        return r.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return x.getDepthTexture();
    };
    function A(oe) {
      for (let ie = 0; ie < oe.removed.length; ie++) {
        const ce = oe.removed[ie], V = b.indexOf(ce);
        V >= 0 && (b[V] = null, S[V].disconnect(ce));
      }
      for (let ie = 0; ie < oe.added.length; ie++) {
        const ce = oe.added[ie];
        let V = b.indexOf(ce);
        if (V === -1) {
          for (let H = 0; H < S.length; H++)
            if (H >= b.length) {
              b.push(ce), V = H;
              break;
            } else if (b[H] === null) {
              b[H] = ce, V = H;
              break;
            }
          if (V === -1) break;
        }
        const Y = S[V];
        Y && Y.connect(ce);
      }
    }
    const G = new de(), ue = new de();
    function Q(oe, ie, ce) {
      G.setFromMatrixPosition(ie.matrixWorld), ue.setFromMatrixPosition(ce.matrixWorld);
      const V = G.distanceTo(ue), Y = ie.projectionMatrix.elements, H = ce.projectionMatrix.elements, I = Y[14] / (Y[10] - 1), F = Y[14] / (Y[10] + 1), L = (Y[9] + 1) / Y[5], ee = (Y[9] - 1) / Y[5], Z = (Y[8] - 1) / Y[0], k = (H[8] + 1) / H[0], ne = I * Z, J = I * k, B = V / (-Z + k), X = B * -Z;
      if (ie.matrixWorld.decompose(oe.position, oe.quaternion, oe.scale), oe.translateX(X), oe.translateZ(B), oe.matrixWorld.compose(oe.position, oe.quaternion, oe.scale), oe.matrixWorldInverse.copy(oe.matrixWorld).invert(), Y[10] === -1)
        oe.projectionMatrix.copy(ie.projectionMatrix), oe.projectionMatrixInverse.copy(ie.projectionMatrixInverse);
      else {
        const se = I + B, z = F + B, N = ne - X, K = J + (V - X), he = L * F / z * se, me = ee * F / z * se;
        oe.projectionMatrix.makePerspective(N, K, he, me, se, z), oe.projectionMatrixInverse.copy(oe.projectionMatrix).invert();
      }
    }
    function le(oe, ie) {
      ie === null ? oe.matrixWorld.copy(oe.matrix) : oe.matrixWorld.multiplyMatrices(ie.matrixWorld, oe.matrix), oe.matrixWorldInverse.copy(oe.matrixWorld).invert();
    }
    this.updateCamera = function(oe) {
      if (r === null) return;
      let ie = oe.near, ce = oe.far;
      x.texture !== null && (x.depthNear > 0 && (ie = x.depthNear), x.depthFar > 0 && (ce = x.depthFar)), w.near = T.near = P.near = ie, w.far = T.far = P.far = ce, (D !== w.near || U !== w.far) && (r.updateRenderState({
        depthNear: w.near,
        depthFar: w.far
      }), D = w.near, U = w.far), P.layers.mask = oe.layers.mask | 2, T.layers.mask = oe.layers.mask | 4, w.layers.mask = P.layers.mask | T.layers.mask;
      const V = oe.parent, Y = w.cameras;
      le(w, V);
      for (let H = 0; H < Y.length; H++)
        le(Y[H], V);
      Y.length === 2 ? Q(w, P, T) : w.projectionMatrix.copy(P.projectionMatrix), re(oe, w, V);
    };
    function re(oe, ie, ce) {
      ce === null ? oe.matrix.copy(ie.matrixWorld) : (oe.matrix.copy(ce.matrixWorld), oe.matrix.invert(), oe.matrix.multiply(ie.matrixWorld)), oe.matrix.decompose(oe.position, oe.quaternion, oe.scale), oe.updateMatrixWorld(!0), oe.projectionMatrix.copy(ie.projectionMatrix), oe.projectionMatrixInverse.copy(ie.projectionMatrixInverse), oe.isPerspectiveCamera && (oe.fov = $o * 2 * Math.atan(1 / oe.projectionMatrix.elements[5]), oe.zoom = 1);
    }
    this.getCamera = function() {
      return w;
    }, this.getFoveation = function() {
      if (!(m === null && p === null))
        return c;
    }, this.setFoveation = function(oe) {
      c = oe, m !== null && (m.fixedFoveation = oe), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = oe);
    }, this.hasDepthSensing = function() {
      return x.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return x.getMesh(w);
    };
    let j = null;
    function $(oe, ie) {
      if (d = ie.getViewerPose(u || a), v = ie, d !== null) {
        const ce = d.views;
        p !== null && (e.setRenderTargetFramebuffer(M, p.framebuffer), e.setRenderTarget(M));
        let V = !1;
        ce.length !== w.cameras.length && (w.cameras.length = 0, V = !0);
        for (let H = 0; H < ce.length; H++) {
          const I = ce[H];
          let F = null;
          if (p !== null)
            F = p.getViewport(I);
          else {
            const ee = h.getViewSubImage(m, I);
            F = ee.viewport, H === 0 && (e.setRenderTargetTextures(
              M,
              ee.colorTexture,
              m.ignoreDepthValues ? void 0 : ee.depthStencilTexture
            ), e.setRenderTarget(M));
          }
          let L = y[H];
          L === void 0 && (L = new ui(), L.layers.enable(H), L.viewport = new jt(), y[H] = L), L.matrix.fromArray(I.transform.matrix), L.matrix.decompose(L.position, L.quaternion, L.scale), L.projectionMatrix.fromArray(I.projectionMatrix), L.projectionMatrixInverse.copy(L.projectionMatrix).invert(), L.viewport.set(F.x, F.y, F.width, F.height), H === 0 && (w.matrix.copy(L.matrix), w.matrix.decompose(w.position, w.quaternion, w.scale)), V === !0 && w.cameras.push(L);
        }
        const Y = r.enabledFeatures;
        if (Y && Y.includes("depth-sensing")) {
          const H = h.getDepthInformation(ce[0]);
          H && H.isValid && H.texture && x.init(e, H, r.renderState);
        }
      }
      for (let ce = 0; ce < S.length; ce++) {
        const V = b[ce], Y = S[ce];
        V !== null && Y !== void 0 && Y.update(V, ie, u || a);
      }
      j && j(oe, ie), ie.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: ie }), v = null;
    }
    const q = new ay();
    q.setAnimationLoop($), this.setAnimationLoop = function(oe) {
      j = oe;
    }, this.dispose = function() {
    };
  }
}
const xr = /* @__PURE__ */ new Mi(), D2 = /* @__PURE__ */ new Zt();
function k2(s, e) {
  function n(g, _) {
    g.matrixAutoUpdate === !0 && g.updateMatrix(), _.value.copy(g.matrix);
  }
  function i(g, _) {
    _.color.getRGB(g.fogColor.value, sy(s)), _.isFog ? (g.fogNear.value = _.near, g.fogFar.value = _.far) : _.isFogExp2 && (g.fogDensity.value = _.density);
  }
  function r(g, _, M, S, b) {
    _.isMeshBasicMaterial || _.isMeshLambertMaterial ? o(g, _) : _.isMeshToonMaterial ? (o(g, _), h(g, _)) : _.isMeshPhongMaterial ? (o(g, _), d(g, _)) : _.isMeshStandardMaterial ? (o(g, _), m(g, _), _.isMeshPhysicalMaterial && p(g, _, b)) : _.isMeshMatcapMaterial ? (o(g, _), v(g, _)) : _.isMeshDepthMaterial ? o(g, _) : _.isMeshDistanceMaterial ? (o(g, _), x(g, _)) : _.isMeshNormalMaterial ? o(g, _) : _.isLineBasicMaterial ? (a(g, _), _.isLineDashedMaterial && l(g, _)) : _.isPointsMaterial ? c(g, _, M, S) : _.isSpriteMaterial ? u(g, _) : _.isShadowMaterial ? (g.color.value.copy(_.color), g.opacity.value = _.opacity) : _.isShaderMaterial && (_.uniformsNeedUpdate = !1);
  }
  function o(g, _) {
    g.opacity.value = _.opacity, _.color && g.diffuse.value.copy(_.color), _.emissive && g.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity), _.map && (g.map.value = _.map, n(_.map, g.mapTransform)), _.alphaMap && (g.alphaMap.value = _.alphaMap, n(_.alphaMap, g.alphaMapTransform)), _.bumpMap && (g.bumpMap.value = _.bumpMap, n(_.bumpMap, g.bumpMapTransform), g.bumpScale.value = _.bumpScale, _.side === hi && (g.bumpScale.value *= -1)), _.normalMap && (g.normalMap.value = _.normalMap, n(_.normalMap, g.normalMapTransform), g.normalScale.value.copy(_.normalScale), _.side === hi && g.normalScale.value.negate()), _.displacementMap && (g.displacementMap.value = _.displacementMap, n(_.displacementMap, g.displacementMapTransform), g.displacementScale.value = _.displacementScale, g.displacementBias.value = _.displacementBias), _.emissiveMap && (g.emissiveMap.value = _.emissiveMap, n(_.emissiveMap, g.emissiveMapTransform)), _.specularMap && (g.specularMap.value = _.specularMap, n(_.specularMap, g.specularMapTransform)), _.alphaTest > 0 && (g.alphaTest.value = _.alphaTest);
    const M = e.get(_), S = M.envMap, b = M.envMapRotation;
    S && (g.envMap.value = S, xr.copy(b), xr.x *= -1, xr.y *= -1, xr.z *= -1, S.isCubeTexture && S.isRenderTargetTexture === !1 && (xr.y *= -1, xr.z *= -1), g.envMapRotation.value.setFromMatrix4(D2.makeRotationFromEuler(xr)), g.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, g.reflectivity.value = _.reflectivity, g.ior.value = _.ior, g.refractionRatio.value = _.refractionRatio), _.lightMap && (g.lightMap.value = _.lightMap, g.lightMapIntensity.value = _.lightMapIntensity, n(_.lightMap, g.lightMapTransform)), _.aoMap && (g.aoMap.value = _.aoMap, g.aoMapIntensity.value = _.aoMapIntensity, n(_.aoMap, g.aoMapTransform));
  }
  function a(g, _) {
    g.diffuse.value.copy(_.color), g.opacity.value = _.opacity, _.map && (g.map.value = _.map, n(_.map, g.mapTransform));
  }
  function l(g, _) {
    g.dashSize.value = _.dashSize, g.totalSize.value = _.dashSize + _.gapSize, g.scale.value = _.scale;
  }
  function c(g, _, M, S) {
    g.diffuse.value.copy(_.color), g.opacity.value = _.opacity, g.size.value = _.size * M, g.scale.value = S * 0.5, _.map && (g.map.value = _.map, n(_.map, g.uvTransform)), _.alphaMap && (g.alphaMap.value = _.alphaMap, n(_.alphaMap, g.alphaMapTransform)), _.alphaTest > 0 && (g.alphaTest.value = _.alphaTest);
  }
  function u(g, _) {
    g.diffuse.value.copy(_.color), g.opacity.value = _.opacity, g.rotation.value = _.rotation, _.map && (g.map.value = _.map, n(_.map, g.mapTransform)), _.alphaMap && (g.alphaMap.value = _.alphaMap, n(_.alphaMap, g.alphaMapTransform)), _.alphaTest > 0 && (g.alphaTest.value = _.alphaTest);
  }
  function d(g, _) {
    g.specular.value.copy(_.specular), g.shininess.value = Math.max(_.shininess, 1e-4);
  }
  function h(g, _) {
    _.gradientMap && (g.gradientMap.value = _.gradientMap);
  }
  function m(g, _) {
    g.metalness.value = _.metalness, _.metalnessMap && (g.metalnessMap.value = _.metalnessMap, n(_.metalnessMap, g.metalnessMapTransform)), g.roughness.value = _.roughness, _.roughnessMap && (g.roughnessMap.value = _.roughnessMap, n(_.roughnessMap, g.roughnessMapTransform)), _.envMap && (g.envMapIntensity.value = _.envMapIntensity);
  }
  function p(g, _, M) {
    g.ior.value = _.ior, _.sheen > 0 && (g.sheenColor.value.copy(_.sheenColor).multiplyScalar(_.sheen), g.sheenRoughness.value = _.sheenRoughness, _.sheenColorMap && (g.sheenColorMap.value = _.sheenColorMap, n(_.sheenColorMap, g.sheenColorMapTransform)), _.sheenRoughnessMap && (g.sheenRoughnessMap.value = _.sheenRoughnessMap, n(_.sheenRoughnessMap, g.sheenRoughnessMapTransform))), _.clearcoat > 0 && (g.clearcoat.value = _.clearcoat, g.clearcoatRoughness.value = _.clearcoatRoughness, _.clearcoatMap && (g.clearcoatMap.value = _.clearcoatMap, n(_.clearcoatMap, g.clearcoatMapTransform)), _.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = _.clearcoatRoughnessMap, n(_.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), _.clearcoatNormalMap && (g.clearcoatNormalMap.value = _.clearcoatNormalMap, n(_.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(_.clearcoatNormalScale), _.side === hi && g.clearcoatNormalScale.value.negate())), _.dispersion > 0 && (g.dispersion.value = _.dispersion), _.iridescence > 0 && (g.iridescence.value = _.iridescence, g.iridescenceIOR.value = _.iridescenceIOR, g.iridescenceThicknessMinimum.value = _.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = _.iridescenceThicknessRange[1], _.iridescenceMap && (g.iridescenceMap.value = _.iridescenceMap, n(_.iridescenceMap, g.iridescenceMapTransform)), _.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = _.iridescenceThicknessMap, n(_.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), _.transmission > 0 && (g.transmission.value = _.transmission, g.transmissionSamplerMap.value = M.texture, g.transmissionSamplerSize.value.set(M.width, M.height), _.transmissionMap && (g.transmissionMap.value = _.transmissionMap, n(_.transmissionMap, g.transmissionMapTransform)), g.thickness.value = _.thickness, _.thicknessMap && (g.thicknessMap.value = _.thicknessMap, n(_.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = _.attenuationDistance, g.attenuationColor.value.copy(_.attenuationColor)), _.anisotropy > 0 && (g.anisotropyVector.value.set(_.anisotropy * Math.cos(_.anisotropyRotation), _.anisotropy * Math.sin(_.anisotropyRotation)), _.anisotropyMap && (g.anisotropyMap.value = _.anisotropyMap, n(_.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = _.specularIntensity, g.specularColor.value.copy(_.specularColor), _.specularColorMap && (g.specularColorMap.value = _.specularColorMap, n(_.specularColorMap, g.specularColorMapTransform)), _.specularIntensityMap && (g.specularIntensityMap.value = _.specularIntensityMap, n(_.specularIntensityMap, g.specularIntensityMapTransform));
  }
  function v(g, _) {
    _.matcap && (g.matcap.value = _.matcap);
  }
  function x(g, _) {
    const M = e.get(_).light;
    g.referencePosition.value.setFromMatrixPosition(M.matrixWorld), g.nearDistance.value = M.shadow.camera.near, g.farDistance.value = M.shadow.camera.far;
  }
  return {
    refreshFogUniforms: i,
    refreshMaterialUniforms: r
  };
}
function I2(s, e, n, i) {
  let r = {}, o = {}, a = [];
  const l = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
  function c(M, S) {
    const b = S.program;
    i.uniformBlockBinding(M, b);
  }
  function u(M, S) {
    let b = r[M.id];
    b === void 0 && (v(M), b = d(M), r[M.id] = b, M.addEventListener("dispose", g));
    const C = S.program;
    i.updateUBOMapping(M, C);
    const E = e.render.frame;
    o[M.id] !== E && (m(M), o[M.id] = E);
  }
  function d(M) {
    const S = h();
    M.__bindingPointIndex = S;
    const b = s.createBuffer(), C = M.__size, E = M.usage;
    return s.bindBuffer(s.UNIFORM_BUFFER, b), s.bufferData(s.UNIFORM_BUFFER, C, E), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, S, b), b;
  }
  function h() {
    for (let M = 0; M < l; M++)
      if (a.indexOf(M) === -1)
        return a.push(M), M;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function m(M) {
    const S = r[M.id], b = M.uniforms, C = M.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, S);
    for (let E = 0, P = b.length; E < P; E++) {
      const T = Array.isArray(b[E]) ? b[E] : [b[E]];
      for (let y = 0, w = T.length; y < w; y++) {
        const D = T[y];
        if (p(D, E, y, C) === !0) {
          const U = D.__offset, R = Array.isArray(D.value) ? D.value : [D.value];
          let O = 0;
          for (let A = 0; A < R.length; A++) {
            const G = R[A], ue = x(G);
            typeof G == "number" || typeof G == "boolean" ? (D.__data[0] = G, s.bufferSubData(s.UNIFORM_BUFFER, U + O, D.__data)) : G.isMatrix3 ? (D.__data[0] = G.elements[0], D.__data[1] = G.elements[1], D.__data[2] = G.elements[2], D.__data[3] = 0, D.__data[4] = G.elements[3], D.__data[5] = G.elements[4], D.__data[6] = G.elements[5], D.__data[7] = 0, D.__data[8] = G.elements[6], D.__data[9] = G.elements[7], D.__data[10] = G.elements[8], D.__data[11] = 0) : (G.toArray(D.__data, O), O += ue.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          s.bufferSubData(s.UNIFORM_BUFFER, U, D.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function p(M, S, b, C) {
    const E = M.value, P = S + "_" + b;
    if (C[P] === void 0)
      return typeof E == "number" || typeof E == "boolean" ? C[P] = E : C[P] = E.clone(), !0;
    {
      const T = C[P];
      if (typeof E == "number" || typeof E == "boolean") {
        if (T !== E)
          return C[P] = E, !0;
      } else if (T.equals(E) === !1)
        return T.copy(E), !0;
    }
    return !1;
  }
  function v(M) {
    const S = M.uniforms;
    let b = 0;
    const C = 16;
    for (let P = 0, T = S.length; P < T; P++) {
      const y = Array.isArray(S[P]) ? S[P] : [S[P]];
      for (let w = 0, D = y.length; w < D; w++) {
        const U = y[w], R = Array.isArray(U.value) ? U.value : [U.value];
        for (let O = 0, A = R.length; O < A; O++) {
          const G = R[O], ue = x(G), Q = b % C, le = Q % ue.boundary, re = Q + le;
          b += le, re !== 0 && C - re < ue.storage && (b += C - re), U.__data = new Float32Array(ue.storage / Float32Array.BYTES_PER_ELEMENT), U.__offset = b, b += ue.storage;
        }
      }
    }
    const E = b % C;
    return E > 0 && (b += C - E), M.__size = b, M.__cache = {}, this;
  }
  function x(M) {
    const S = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof M == "number" || typeof M == "boolean" ? (S.boundary = 4, S.storage = 4) : M.isVector2 ? (S.boundary = 8, S.storage = 8) : M.isVector3 || M.isColor ? (S.boundary = 16, S.storage = 12) : M.isVector4 ? (S.boundary = 16, S.storage = 16) : M.isMatrix3 ? (S.boundary = 48, S.storage = 48) : M.isMatrix4 ? (S.boundary = 64, S.storage = 64) : M.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", M), S;
  }
  function g(M) {
    const S = M.target;
    S.removeEventListener("dispose", g);
    const b = a.indexOf(S.__bindingPointIndex);
    a.splice(b, 1), s.deleteBuffer(r[S.id]), delete r[S.id], delete o[S.id];
  }
  function _() {
    for (const M in r)
      s.deleteBuffer(r[M]);
    a = [], r = {}, o = {};
  }
  return {
    bind: c,
    update: u,
    dispose: _
  };
}
class L2 {
  constructor(e = {}) {
    const {
      canvas: n = Cb(),
      context: i = null,
      depth: r = !0,
      stencil: o = !1,
      alpha: a = !1,
      antialias: l = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: d = "default",
      failIfMajorPerformanceCaveat: h = !1,
      reverseDepthBuffer: m = !1
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    if (i !== null) {
      if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      p = i.getContextAttributes().alpha;
    } else
      p = a;
    const v = new Uint32Array(4), x = new Int32Array(4);
    let g = null, _ = null;
    const M = [], S = [];
    this.domElement = n, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = dn, this.toneMapping = rr, this.toneMappingExposure = 1;
    const b = this;
    let C = !1, E = 0, P = 0, T = null, y = -1, w = null;
    const D = new jt(), U = new jt();
    let R = null;
    const O = new Mt(0);
    let A = 0, G = n.width, ue = n.height, Q = 1, le = null, re = null;
    const j = new jt(0, 0, G, ue), $ = new jt(0, 0, G, ue);
    let q = !1;
    const oe = new Lf();
    let ie = !1, ce = !1;
    const V = new Zt(), Y = new Zt(), H = new de(), I = new jt(), F = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let L = !1;
    function ee() {
      return T === null ? Q : 1;
    }
    let Z = i;
    function k(W, ve) {
      return n.getContext(W, ve);
    }
    try {
      const W = {
        alpha: !0,
        depth: r,
        stencil: o,
        antialias: l,
        premultipliedAlpha: c,
        preserveDrawingBuffer: u,
        powerPreference: d,
        failIfMajorPerformanceCaveat: h
      };
      if ("setAttribute" in n && n.setAttribute("data-engine", `three.js r${bf}`), n.addEventListener("webglcontextlost", Be, !1), n.addEventListener("webglcontextrestored", je, !1), n.addEventListener("webglcontextcreationerror", Ge, !1), Z === null) {
        const ve = "webgl2";
        if (Z = k(ve, W), Z === null)
          throw k(ve) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (W) {
      throw console.error("THREE.WebGLRenderer: " + W.message), W;
    }
    let ne, J, B, X, se, z, N, K, he, me, ge, Me, Te, Ae, Xe, Oe, He, Ye, $e, Le, nt, Je, bt, Se;
    function Ne() {
      ne = new VM(Z), ne.init(), Je = new M2(Z, ne), J = new FM(Z, ne, e, Je), B = new b2(Z, ne), J.reverseDepthBuffer && m && B.buffers.depth.setReversed(!0), X = new $M(Z), se = new l2(), z = new S2(Z, ne, B, se, J, Je, X), N = new OM(b), K = new BM(b), he = new Kb(Z), bt = new IM(Z, he), me = new GM(Z, he, X, bt), ge = new XM(Z, me, he, X), $e = new WM(Z, J, z), Oe = new UM(se), Me = new a2(b, N, K, ne, J, bt, Oe), Te = new k2(b, se), Ae = new u2(), Xe = new v2(ne), Ye = new kM(b, N, K, B, ge, p, c), He = new _2(b, ge, J), Se = new I2(Z, X, J, B), Le = new LM(Z, ne, X), nt = new HM(Z, ne, X), X.programs = Me.programs, b.capabilities = J, b.extensions = ne, b.properties = se, b.renderLists = Ae, b.shadowMap = He, b.state = B, b.info = X;
    }
    Ne();
    const Re = new R2(b, Z);
    this.xr = Re, this.getContext = function() {
      return Z;
    }, this.getContextAttributes = function() {
      return Z.getContextAttributes();
    }, this.forceContextLoss = function() {
      const W = ne.get("WEBGL_lose_context");
      W && W.loseContext();
    }, this.forceContextRestore = function() {
      const W = ne.get("WEBGL_lose_context");
      W && W.restoreContext();
    }, this.getPixelRatio = function() {
      return Q;
    }, this.setPixelRatio = function(W) {
      W !== void 0 && (Q = W, this.setSize(G, ue, !1));
    }, this.getSize = function(W) {
      return W.set(G, ue);
    }, this.setSize = function(W, ve, ye = !0) {
      if (Re.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      G = W, ue = ve, n.width = Math.floor(W * Q), n.height = Math.floor(ve * Q), ye === !0 && (n.style.width = W + "px", n.style.height = ve + "px"), this.setViewport(0, 0, W, ve);
    }, this.getDrawingBufferSize = function(W) {
      return W.set(G * Q, ue * Q).floor();
    }, this.setDrawingBufferSize = function(W, ve, ye) {
      G = W, ue = ve, Q = ye, n.width = Math.floor(W * ye), n.height = Math.floor(ve * ye), this.setViewport(0, 0, W, ve);
    }, this.getCurrentViewport = function(W) {
      return W.copy(D);
    }, this.getViewport = function(W) {
      return W.copy(j);
    }, this.setViewport = function(W, ve, ye, Ce) {
      W.isVector4 ? j.set(W.x, W.y, W.z, W.w) : j.set(W, ve, ye, Ce), B.viewport(D.copy(j).multiplyScalar(Q).round());
    }, this.getScissor = function(W) {
      return W.copy($);
    }, this.setScissor = function(W, ve, ye, Ce) {
      W.isVector4 ? $.set(W.x, W.y, W.z, W.w) : $.set(W, ve, ye, Ce), B.scissor(U.copy($).multiplyScalar(Q).round());
    }, this.getScissorTest = function() {
      return q;
    }, this.setScissorTest = function(W) {
      B.setScissorTest(q = W);
    }, this.setOpaqueSort = function(W) {
      le = W;
    }, this.setTransparentSort = function(W) {
      re = W;
    }, this.getClearColor = function(W) {
      return W.copy(Ye.getClearColor());
    }, this.setClearColor = function() {
      Ye.setClearColor.apply(Ye, arguments);
    }, this.getClearAlpha = function() {
      return Ye.getClearAlpha();
    }, this.setClearAlpha = function() {
      Ye.setClearAlpha.apply(Ye, arguments);
    }, this.clear = function(W = !0, ve = !0, ye = !0) {
      let Ce = 0;
      if (W) {
        let be = !1;
        if (T !== null) {
          const ke = T.texture.format;
          be = ke === Af || ke === Tf || ke === Ef;
        }
        if (be) {
          const ke = T.texture.type, De = ke === Xi || ke === Hr || ke === cl || ke === Go || ke === Mf || ke === Cf, Qe = Ye.getClearColor(), it = Ye.getClearAlpha(), mt = Qe.r, gt = Qe.g, lt = Qe.b;
          De ? (v[0] = mt, v[1] = gt, v[2] = lt, v[3] = it, Z.clearBufferuiv(Z.COLOR, 0, v)) : (x[0] = mt, x[1] = gt, x[2] = lt, x[3] = it, Z.clearBufferiv(Z.COLOR, 0, x));
        } else
          Ce |= Z.COLOR_BUFFER_BIT;
      }
      ve && (Ce |= Z.DEPTH_BUFFER_BIT), ye && (Ce |= Z.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Z.clear(Ce);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      n.removeEventListener("webglcontextlost", Be, !1), n.removeEventListener("webglcontextrestored", je, !1), n.removeEventListener("webglcontextcreationerror", Ge, !1), Ae.dispose(), Xe.dispose(), se.dispose(), N.dispose(), K.dispose(), ge.dispose(), bt.dispose(), Se.dispose(), Me.dispose(), Re.dispose(), Re.removeEventListener("sessionstart", rn), Re.removeEventListener("sessionend", Bn), bn.stop();
    };
    function Be(W) {
      W.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), C = !0;
    }
    function je() {
      console.log("THREE.WebGLRenderer: Context Restored."), C = !1;
      const W = X.autoReset, ve = He.enabled, ye = He.autoUpdate, Ce = He.needsUpdate, be = He.type;
      Ne(), X.autoReset = W, He.enabled = ve, He.autoUpdate = ye, He.needsUpdate = Ce, He.type = be;
    }
    function Ge(W) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", W.statusMessage);
    }
    function ut(W) {
      const ve = W.target;
      ve.removeEventListener("dispose", ut), at(ve);
    }
    function at(W) {
      dt(W), se.remove(W);
    }
    function dt(W) {
      const ve = se.get(W).programs;
      ve !== void 0 && (ve.forEach(function(ye) {
        Me.releaseProgram(ye);
      }), W.isShaderMaterial && Me.releaseShaderCache(W));
    }
    this.renderBufferDirect = function(W, ve, ye, Ce, be, ke) {
      ve === null && (ve = F);
      const De = be.isMesh && be.matrixWorld.determinant() < 0, Qe = _e(W, ve, ye, Ce, be);
      B.setMaterial(Ce, De);
      let it = ye.index, mt = 1;
      if (Ce.wireframe === !0) {
        if (it = me.getWireframeAttribute(ye), it === void 0) return;
        mt = 2;
      }
      const gt = ye.drawRange, lt = ye.attributes.position;
      let Rt = gt.start * mt, Ht = (gt.start + gt.count) * mt;
      ke !== null && (Rt = Math.max(Rt, ke.start * mt), Ht = Math.min(Ht, (ke.start + ke.count) * mt)), it !== null ? (Rt = Math.max(Rt, 0), Ht = Math.min(Ht, it.count)) : lt != null && (Rt = Math.max(Rt, 0), Ht = Math.min(Ht, lt.count));
      const $t = Ht - Rt;
      if ($t < 0 || $t === 1 / 0) return;
      bt.setup(be, Ce, Qe, ye, it);
      let Rn, kt = Le;
      if (it !== null && (Rn = he.get(it), kt = nt, kt.setIndex(Rn)), be.isMesh)
        Ce.wireframe === !0 ? (B.setLineWidth(Ce.wireframeLinewidth * ee()), kt.setMode(Z.LINES)) : kt.setMode(Z.TRIANGLES);
      else if (be.isLine) {
        let ht = Ce.linewidth;
        ht === void 0 && (ht = 1), B.setLineWidth(ht * ee()), be.isLineSegments ? kt.setMode(Z.LINES) : be.isLineLoop ? kt.setMode(Z.LINE_LOOP) : kt.setMode(Z.LINE_STRIP);
      } else be.isPoints ? kt.setMode(Z.POINTS) : be.isSprite && kt.setMode(Z.TRIANGLES);
      if (be.isBatchedMesh)
        if (be._multiDrawInstances !== null)
          kt.renderMultiDrawInstances(be._multiDrawStarts, be._multiDrawCounts, be._multiDrawCount, be._multiDrawInstances);
        else if (ne.get("WEBGL_multi_draw"))
          kt.renderMultiDraw(be._multiDrawStarts, be._multiDrawCounts, be._multiDrawCount);
        else {
          const ht = be._multiDrawStarts, mi = be._multiDrawCounts, Lt = be._multiDrawCount, Dn = it ? he.get(it).bytesPerElement : 1, qi = se.get(Ce).currentProgram.getUniforms();
          for (let Sn = 0; Sn < Lt; Sn++)
            qi.setValue(Z, "_gl_DrawID", Sn), kt.render(ht[Sn] / Dn, mi[Sn]);
        }
      else if (be.isInstancedMesh)
        kt.renderInstances(Rt, $t, be.count);
      else if (ye.isInstancedBufferGeometry) {
        const ht = ye._maxInstanceCount !== void 0 ? ye._maxInstanceCount : 1 / 0, mi = Math.min(ye.instanceCount, ht);
        kt.renderInstances(Rt, $t, mi);
      } else
        kt.render(Rt, $t);
    };
    function pt(W, ve, ye) {
      W.transparent === !0 && W.side === vn && W.forceSinglePass === !1 ? (W.side = hi, W.needsUpdate = !0, si(W, ve, ye), W.side = or, W.needsUpdate = !0, si(W, ve, ye), W.side = vn) : si(W, ve, ye);
    }
    this.compile = function(W, ve, ye = null) {
      ye === null && (ye = W), _ = Xe.get(ye), _.init(ve), S.push(_), ye.traverseVisible(function(be) {
        be.isLight && be.layers.test(ve.layers) && (_.pushLight(be), be.castShadow && _.pushShadow(be));
      }), W !== ye && W.traverseVisible(function(be) {
        be.isLight && be.layers.test(ve.layers) && (_.pushLight(be), be.castShadow && _.pushShadow(be));
      }), _.setupLights();
      const Ce = /* @__PURE__ */ new Set();
      return W.traverse(function(be) {
        if (!(be.isMesh || be.isPoints || be.isLine || be.isSprite))
          return;
        const ke = be.material;
        if (ke)
          if (Array.isArray(ke))
            for (let De = 0; De < ke.length; De++) {
              const Qe = ke[De];
              pt(Qe, ye, be), Ce.add(Qe);
            }
          else
            pt(ke, ye, be), Ce.add(ke);
      }), S.pop(), _ = null, Ce;
    }, this.compileAsync = function(W, ve, ye = null) {
      const Ce = this.compile(W, ve, ye);
      return new Promise((be) => {
        function ke() {
          if (Ce.forEach(function(De) {
            se.get(De).currentProgram.isReady() && Ce.delete(De);
          }), Ce.size === 0) {
            be(W);
            return;
          }
          setTimeout(ke, 10);
        }
        ne.get("KHR_parallel_shader_compile") !== null ? ke() : setTimeout(ke, 10);
      });
    };
    let zt = null;
    function Kt(W) {
      zt && zt(W);
    }
    function rn() {
      bn.stop();
    }
    function Bn() {
      bn.start();
    }
    const bn = new ay();
    bn.setAnimationLoop(Kt), typeof self < "u" && bn.setContext(self), this.setAnimationLoop = function(W) {
      zt = W, Re.setAnimationLoop(W), W === null ? bn.stop() : bn.start();
    }, Re.addEventListener("sessionstart", rn), Re.addEventListener("sessionend", Bn), this.render = function(W, ve) {
      if (ve !== void 0 && ve.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (C === !0) return;
      if (W.matrixWorldAutoUpdate === !0 && W.updateMatrixWorld(), ve.parent === null && ve.matrixWorldAutoUpdate === !0 && ve.updateMatrixWorld(), Re.enabled === !0 && Re.isPresenting === !0 && (Re.cameraAutoUpdate === !0 && Re.updateCamera(ve), ve = Re.getCamera()), W.isScene === !0 && W.onBeforeRender(b, W, ve, T), _ = Xe.get(W, S.length), _.init(ve), S.push(_), Y.multiplyMatrices(ve.projectionMatrix, ve.matrixWorldInverse), oe.setFromProjectionMatrix(Y), ce = this.localClippingEnabled, ie = Oe.init(this.clippingPlanes, ce), g = Ae.get(W, M.length), g.init(), M.push(g), Re.enabled === !0 && Re.isPresenting === !0) {
        const ke = b.xr.getDepthSensingMesh();
        ke !== null && Kn(ke, ve, -1 / 0, b.sortObjects);
      }
      Kn(W, ve, 0, b.sortObjects), g.finish(), b.sortObjects === !0 && g.sort(le, re), L = Re.enabled === !1 || Re.isPresenting === !1 || Re.hasDepthSensing() === !1, L && Ye.addToRenderList(g, W), this.info.render.frame++, ie === !0 && Oe.beginShadows();
      const ye = _.state.shadowsArray;
      He.render(ye, W, ve), ie === !0 && Oe.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const Ce = g.opaque, be = g.transmissive;
      if (_.setupLights(), ve.isArrayCamera) {
        const ke = ve.cameras;
        if (be.length > 0)
          for (let De = 0, Qe = ke.length; De < Qe; De++) {
            const it = ke[De];
            pi(Ce, be, W, it);
          }
        L && Ye.render(W);
        for (let De = 0, Qe = ke.length; De < Qe; De++) {
          const it = ke[De];
          fi(g, W, it, it.viewport);
        }
      } else
        be.length > 0 && pi(Ce, be, W, ve), L && Ye.render(W), fi(g, W, ve);
      T !== null && (z.updateMultisampleRenderTarget(T), z.updateRenderTargetMipmap(T)), W.isScene === !0 && W.onAfterRender(b, W, ve), bt.resetDefaultState(), y = -1, w = null, S.pop(), S.length > 0 ? (_ = S[S.length - 1], ie === !0 && Oe.setGlobalState(b.clippingPlanes, _.state.camera)) : _ = null, M.pop(), M.length > 0 ? g = M[M.length - 1] : g = null;
    };
    function Kn(W, ve, ye, Ce) {
      if (W.visible === !1) return;
      if (W.layers.test(ve.layers)) {
        if (W.isGroup)
          ye = W.renderOrder;
        else if (W.isLOD)
          W.autoUpdate === !0 && W.update(ve);
        else if (W.isLight)
          _.pushLight(W), W.castShadow && _.pushShadow(W);
        else if (W.isSprite) {
          if (!W.frustumCulled || oe.intersectsSprite(W)) {
            Ce && I.setFromMatrixPosition(W.matrixWorld).applyMatrix4(Y);
            const De = ge.update(W), Qe = W.material;
            Qe.visible && g.push(W, De, Qe, ye, I.z, null);
          }
        } else if ((W.isMesh || W.isLine || W.isPoints) && (!W.frustumCulled || oe.intersectsObject(W))) {
          const De = ge.update(W), Qe = W.material;
          if (Ce && (W.boundingSphere !== void 0 ? (W.boundingSphere === null && W.computeBoundingSphere(), I.copy(W.boundingSphere.center)) : (De.boundingSphere === null && De.computeBoundingSphere(), I.copy(De.boundingSphere.center)), I.applyMatrix4(W.matrixWorld).applyMatrix4(Y)), Array.isArray(Qe)) {
            const it = De.groups;
            for (let mt = 0, gt = it.length; mt < gt; mt++) {
              const lt = it[mt], Rt = Qe[lt.materialIndex];
              Rt && Rt.visible && g.push(W, De, Rt, ye, I.z, lt);
            }
          } else Qe.visible && g.push(W, De, Qe, ye, I.z, null);
        }
      }
      const ke = W.children;
      for (let De = 0, Qe = ke.length; De < Qe; De++)
        Kn(ke[De], ve, ye, Ce);
    }
    function fi(W, ve, ye, Ce) {
      const be = W.opaque, ke = W.transmissive, De = W.transparent;
      _.setupLightsView(ye), ie === !0 && Oe.setGlobalState(b.clippingPlanes, ye), Ce && B.viewport(D.copy(Ce)), be.length > 0 && Vn(be, ve, ye), ke.length > 0 && Vn(ke, ve, ye), De.length > 0 && Vn(De, ve, ye), B.buffers.depth.setTest(!0), B.buffers.depth.setMask(!0), B.buffers.color.setMask(!0), B.setPolygonOffset(!1);
    }
    function pi(W, ve, ye, Ce) {
      if ((ye.isScene === !0 ? ye.overrideMaterial : null) !== null)
        return;
      _.state.transmissionRenderTarget[Ce.id] === void 0 && (_.state.transmissionRenderTarget[Ce.id] = new Ri(1, 1, {
        generateMipmaps: !0,
        type: ne.has("EXT_color_buffer_half_float") || ne.has("EXT_color_buffer_float") ? ur : Xi,
        minFilter: Ur,
        samples: 4,
        stencilBuffer: o,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: It.workingColorSpace
      }));
      const ke = _.state.transmissionRenderTarget[Ce.id], De = Ce.viewport || D;
      ke.setSize(De.z, De.w);
      const Qe = b.getRenderTarget();
      b.setRenderTarget(ke), b.getClearColor(O), A = b.getClearAlpha(), A < 1 && b.setClearColor(16777215, 0.5), b.clear(), L && Ye.render(ye);
      const it = b.toneMapping;
      b.toneMapping = rr;
      const mt = Ce.viewport;
      if (Ce.viewport !== void 0 && (Ce.viewport = void 0), _.setupLightsView(Ce), ie === !0 && Oe.setGlobalState(b.clippingPlanes, Ce), Vn(W, ye, Ce), z.updateMultisampleRenderTarget(ke), z.updateRenderTargetMipmap(ke), ne.has("WEBGL_multisampled_render_to_texture") === !1) {
        let gt = !1;
        for (let lt = 0, Rt = ve.length; lt < Rt; lt++) {
          const Ht = ve[lt], $t = Ht.object, Rn = Ht.geometry, kt = Ht.material, ht = Ht.group;
          if (kt.side === vn && $t.layers.test(Ce.layers)) {
            const mi = kt.side;
            kt.side = hi, kt.needsUpdate = !0, wn($t, ye, Ce, Rn, kt, ht), kt.side = mi, kt.needsUpdate = !0, gt = !0;
          }
        }
        gt === !0 && (z.updateMultisampleRenderTarget(ke), z.updateRenderTargetMipmap(ke));
      }
      b.setRenderTarget(Qe), b.setClearColor(O, A), mt !== void 0 && (Ce.viewport = mt), b.toneMapping = it;
    }
    function Vn(W, ve, ye) {
      const Ce = ve.isScene === !0 ? ve.overrideMaterial : null;
      for (let be = 0, ke = W.length; be < ke; be++) {
        const De = W[be], Qe = De.object, it = De.geometry, mt = Ce === null ? De.material : Ce, gt = De.group;
        Qe.layers.test(ye.layers) && wn(Qe, ve, ye, it, mt, gt);
      }
    }
    function wn(W, ve, ye, Ce, be, ke) {
      W.onBeforeRender(b, ve, ye, Ce, be, ke), W.modelViewMatrix.multiplyMatrices(ye.matrixWorldInverse, W.matrixWorld), W.normalMatrix.getNormalMatrix(W.modelViewMatrix), be.onBeforeRender(b, ve, ye, Ce, W, ke), be.transparent === !0 && be.side === vn && be.forceSinglePass === !1 ? (be.side = hi, be.needsUpdate = !0, b.renderBufferDirect(ye, ve, Ce, be, W, ke), be.side = or, be.needsUpdate = !0, b.renderBufferDirect(ye, ve, Ce, be, W, ke), be.side = vn) : b.renderBufferDirect(ye, ve, Ce, be, W, ke), W.onAfterRender(b, ve, ye, Ce, be, ke);
    }
    function si(W, ve, ye) {
      ve.isScene !== !0 && (ve = F);
      const Ce = se.get(W), be = _.state.lights, ke = _.state.shadowsArray, De = be.state.version, Qe = Me.getParameters(W, be.state, ke, ve, ye), it = Me.getProgramCacheKey(Qe);
      let mt = Ce.programs;
      Ce.environment = W.isMeshStandardMaterial ? ve.environment : null, Ce.fog = ve.fog, Ce.envMap = (W.isMeshStandardMaterial ? K : N).get(W.envMap || Ce.environment), Ce.envMapRotation = Ce.environment !== null && W.envMap === null ? ve.environmentRotation : W.envMapRotation, mt === void 0 && (W.addEventListener("dispose", ut), mt = /* @__PURE__ */ new Map(), Ce.programs = mt);
      let gt = mt.get(it);
      if (gt !== void 0) {
        if (Ce.currentProgram === gt && Ce.lightsStateVersion === De)
          return pe(W, Qe), gt;
      } else
        Qe.uniforms = Me.getUniforms(W), W.onBeforeCompile(Qe, b), gt = Me.acquireProgram(Qe, it), mt.set(it, gt), Ce.uniforms = Qe.uniforms;
      const lt = Ce.uniforms;
      return (!W.isShaderMaterial && !W.isRawShaderMaterial || W.clipping === !0) && (lt.clippingPlanes = Oe.uniform), pe(W, Qe), Ce.needsLights = Ue(W), Ce.lightsStateVersion = De, Ce.needsLights && (lt.ambientLightColor.value = be.state.ambient, lt.lightProbe.value = be.state.probe, lt.directionalLights.value = be.state.directional, lt.directionalLightShadows.value = be.state.directionalShadow, lt.spotLights.value = be.state.spot, lt.spotLightShadows.value = be.state.spotShadow, lt.rectAreaLights.value = be.state.rectArea, lt.ltc_1.value = be.state.rectAreaLTC1, lt.ltc_2.value = be.state.rectAreaLTC2, lt.pointLights.value = be.state.point, lt.pointLightShadows.value = be.state.pointShadow, lt.hemisphereLights.value = be.state.hemi, lt.directionalShadowMap.value = be.state.directionalShadowMap, lt.directionalShadowMatrix.value = be.state.directionalShadowMatrix, lt.spotShadowMap.value = be.state.spotShadowMap, lt.spotLightMatrix.value = be.state.spotLightMatrix, lt.spotLightMap.value = be.state.spotLightMap, lt.pointShadowMap.value = be.state.pointShadowMap, lt.pointShadowMatrix.value = be.state.pointShadowMatrix), Ce.currentProgram = gt, Ce.uniformsList = null, gt;
    }
    function ki(W) {
      if (W.uniformsList === null) {
        const ve = W.currentProgram.getUniforms();
        W.uniformsList = Oc.seqWithValue(ve.seq, W.uniforms);
      }
      return W.uniformsList;
    }
    function pe(W, ve) {
      const ye = se.get(W);
      ye.outputColorSpace = ve.outputColorSpace, ye.batching = ve.batching, ye.batchingColor = ve.batchingColor, ye.instancing = ve.instancing, ye.instancingColor = ve.instancingColor, ye.instancingMorph = ve.instancingMorph, ye.skinning = ve.skinning, ye.morphTargets = ve.morphTargets, ye.morphNormals = ve.morphNormals, ye.morphColors = ve.morphColors, ye.morphTargetsCount = ve.morphTargetsCount, ye.numClippingPlanes = ve.numClippingPlanes, ye.numIntersection = ve.numClipIntersection, ye.vertexAlphas = ve.vertexAlphas, ye.vertexTangents = ve.vertexTangents, ye.toneMapping = ve.toneMapping;
    }
    function _e(W, ve, ye, Ce, be) {
      ve.isScene !== !0 && (ve = F), z.resetTextureUnits();
      const ke = ve.fog, De = Ce.isMeshStandardMaterial ? ve.environment : null, Qe = T === null ? b.outputColorSpace : T.isXRRenderTarget === !0 ? T.texture.colorSpace : Zo, it = (Ce.isMeshStandardMaterial ? K : N).get(Ce.envMap || De), mt = Ce.vertexColors === !0 && !!ye.attributes.color && ye.attributes.color.itemSize === 4, gt = !!ye.attributes.tangent && (!!Ce.normalMap || Ce.anisotropy > 0), lt = !!ye.morphAttributes.position, Rt = !!ye.morphAttributes.normal, Ht = !!ye.morphAttributes.color;
      let $t = rr;
      Ce.toneMapped && (T === null || T.isXRRenderTarget === !0) && ($t = b.toneMapping);
      const Rn = ye.morphAttributes.position || ye.morphAttributes.normal || ye.morphAttributes.color, kt = Rn !== void 0 ? Rn.length : 0, ht = se.get(Ce), mi = _.state.lights;
      if (ie === !0 && (ce === !0 || W !== w)) {
        const oi = W === w && Ce.id === y;
        Oe.setState(Ce, W, oi);
      }
      let Lt = !1;
      Ce.version === ht.__version ? (ht.needsLights && ht.lightsStateVersion !== mi.state.version || ht.outputColorSpace !== Qe || be.isBatchedMesh && ht.batching === !1 || !be.isBatchedMesh && ht.batching === !0 || be.isBatchedMesh && ht.batchingColor === !0 && be.colorTexture === null || be.isBatchedMesh && ht.batchingColor === !1 && be.colorTexture !== null || be.isInstancedMesh && ht.instancing === !1 || !be.isInstancedMesh && ht.instancing === !0 || be.isSkinnedMesh && ht.skinning === !1 || !be.isSkinnedMesh && ht.skinning === !0 || be.isInstancedMesh && ht.instancingColor === !0 && be.instanceColor === null || be.isInstancedMesh && ht.instancingColor === !1 && be.instanceColor !== null || be.isInstancedMesh && ht.instancingMorph === !0 && be.morphTexture === null || be.isInstancedMesh && ht.instancingMorph === !1 && be.morphTexture !== null || ht.envMap !== it || Ce.fog === !0 && ht.fog !== ke || ht.numClippingPlanes !== void 0 && (ht.numClippingPlanes !== Oe.numPlanes || ht.numIntersection !== Oe.numIntersection) || ht.vertexAlphas !== mt || ht.vertexTangents !== gt || ht.morphTargets !== lt || ht.morphNormals !== Rt || ht.morphColors !== Ht || ht.toneMapping !== $t || ht.morphTargetsCount !== kt) && (Lt = !0) : (Lt = !0, ht.__version = Ce.version);
      let Dn = ht.currentProgram;
      Lt === !0 && (Dn = si(Ce, ve, be));
      let qi = !1, Sn = !1, cs = !1;
      const Yt = Dn.getUniforms(), ri = ht.uniforms;
      if (B.useProgram(Dn.program) && (qi = !0, Sn = !0, cs = !0), Ce.id !== y && (y = Ce.id, Sn = !0), qi || w !== W) {
        B.buffers.depth.getReversed() ? (V.copy(W.projectionMatrix), Tb(V), Ab(V), Yt.setValue(Z, "projectionMatrix", V)) : Yt.setValue(Z, "projectionMatrix", W.projectionMatrix), Yt.setValue(Z, "viewMatrix", W.matrixWorldInverse);
        const vi = Yt.map.cameraPosition;
        vi !== void 0 && vi.setValue(Z, H.setFromMatrixPosition(W.matrixWorld)), J.logarithmicDepthBuffer && Yt.setValue(
          Z,
          "logDepthBufFC",
          2 / (Math.log(W.far + 1) / Math.LN2)
        ), (Ce.isMeshPhongMaterial || Ce.isMeshToonMaterial || Ce.isMeshLambertMaterial || Ce.isMeshBasicMaterial || Ce.isMeshStandardMaterial || Ce.isShaderMaterial) && Yt.setValue(Z, "isOrthographic", W.isOrthographicCamera === !0), w !== W && (w = W, Sn = !0, cs = !0);
      }
      if (be.isSkinnedMesh) {
        Yt.setOptional(Z, be, "bindMatrix"), Yt.setOptional(Z, be, "bindMatrixInverse");
        const oi = be.skeleton;
        oi && (oi.boneTexture === null && oi.computeBoneTexture(), Yt.setValue(Z, "boneTexture", oi.boneTexture, z));
      }
      be.isBatchedMesh && (Yt.setOptional(Z, be, "batchingTexture"), Yt.setValue(Z, "batchingTexture", be._matricesTexture, z), Yt.setOptional(Z, be, "batchingIdTexture"), Yt.setValue(Z, "batchingIdTexture", be._indirectTexture, z), Yt.setOptional(Z, be, "batchingColorTexture"), be._colorsTexture !== null && Yt.setValue(Z, "batchingColorTexture", be._colorsTexture, z));
      const Gn = ye.morphAttributes;
      if ((Gn.position !== void 0 || Gn.normal !== void 0 || Gn.color !== void 0) && $e.update(be, ye, Dn), (Sn || ht.receiveShadow !== be.receiveShadow) && (ht.receiveShadow = be.receiveShadow, Yt.setValue(Z, "receiveShadow", be.receiveShadow)), Ce.isMeshGouraudMaterial && Ce.envMap !== null && (ri.envMap.value = it, ri.flipEnvMap.value = it.isCubeTexture && it.isRenderTargetTexture === !1 ? -1 : 1), Ce.isMeshStandardMaterial && Ce.envMap === null && ve.environment !== null && (ri.envMapIntensity.value = ve.environmentIntensity), Sn && (Yt.setValue(Z, "toneMappingExposure", b.toneMappingExposure), ht.needsLights && Ee(ri, cs), ke && Ce.fog === !0 && Te.refreshFogUniforms(ri, ke), Te.refreshMaterialUniforms(ri, Ce, Q, ue, _.state.transmissionRenderTarget[W.id]), Oc.upload(Z, ki(ht), ri, z)), Ce.isShaderMaterial && Ce.uniformsNeedUpdate === !0 && (Oc.upload(Z, ki(ht), ri, z), Ce.uniformsNeedUpdate = !1), Ce.isSpriteMaterial && Yt.setValue(Z, "center", be.center), Yt.setValue(Z, "modelViewMatrix", be.modelViewMatrix), Yt.setValue(Z, "normalMatrix", be.normalMatrix), Yt.setValue(Z, "modelMatrix", be.matrixWorld), Ce.isShaderMaterial || Ce.isRawShaderMaterial) {
        const oi = Ce.uniformsGroups;
        for (let vi = 0, ai = oi.length; vi < ai; vi++) {
          const ta = oi[vi];
          Se.update(ta, Dn), Se.bind(ta, Dn);
        }
      }
      return Dn;
    }
    function Ee(W, ve) {
      W.ambientLightColor.needsUpdate = ve, W.lightProbe.needsUpdate = ve, W.directionalLights.needsUpdate = ve, W.directionalLightShadows.needsUpdate = ve, W.pointLights.needsUpdate = ve, W.pointLightShadows.needsUpdate = ve, W.spotLights.needsUpdate = ve, W.spotLightShadows.needsUpdate = ve, W.rectAreaLights.needsUpdate = ve, W.hemisphereLights.needsUpdate = ve;
    }
    function Ue(W) {
      return W.isMeshLambertMaterial || W.isMeshToonMaterial || W.isMeshPhongMaterial || W.isMeshStandardMaterial || W.isShadowMaterial || W.isShaderMaterial && W.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return E;
    }, this.getActiveMipmapLevel = function() {
      return P;
    }, this.getRenderTarget = function() {
      return T;
    }, this.setRenderTargetTextures = function(W, ve, ye) {
      se.get(W.texture).__webglTexture = ve, se.get(W.depthTexture).__webglTexture = ye;
      const Ce = se.get(W);
      Ce.__hasExternalTextures = !0, Ce.__autoAllocateDepthBuffer = ye === void 0, Ce.__autoAllocateDepthBuffer || ne.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Ce.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(W, ve) {
      const ye = se.get(W);
      ye.__webglFramebuffer = ve, ye.__useDefaultFramebuffer = ve === void 0;
    }, this.setRenderTarget = function(W, ve = 0, ye = 0) {
      T = W, E = ve, P = ye;
      let Ce = !0, be = null, ke = !1, De = !1;
      if (W) {
        const it = se.get(W);
        if (it.__useDefaultFramebuffer !== void 0)
          B.bindFramebuffer(Z.FRAMEBUFFER, null), Ce = !1;
        else if (it.__webglFramebuffer === void 0)
          z.setupRenderTarget(W);
        else if (it.__hasExternalTextures)
          z.rebindTextures(W, se.get(W.texture).__webglTexture, se.get(W.depthTexture).__webglTexture);
        else if (W.depthBuffer) {
          const lt = W.depthTexture;
          if (it.__boundDepthTexture !== lt) {
            if (lt !== null && se.has(lt) && (W.width !== lt.image.width || W.height !== lt.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            z.setupDepthRenderbuffer(W);
          }
        }
        const mt = W.texture;
        (mt.isData3DTexture || mt.isDataArrayTexture || mt.isCompressedArrayTexture) && (De = !0);
        const gt = se.get(W).__webglFramebuffer;
        W.isWebGLCubeRenderTarget ? (Array.isArray(gt[ve]) ? be = gt[ve][ye] : be = gt[ve], ke = !0) : W.samples > 0 && z.useMultisampledRTT(W) === !1 ? be = se.get(W).__webglMultisampledFramebuffer : Array.isArray(gt) ? be = gt[ye] : be = gt, D.copy(W.viewport), U.copy(W.scissor), R = W.scissorTest;
      } else
        D.copy(j).multiplyScalar(Q).floor(), U.copy($).multiplyScalar(Q).floor(), R = q;
      if (B.bindFramebuffer(Z.FRAMEBUFFER, be) && Ce && B.drawBuffers(W, be), B.viewport(D), B.scissor(U), B.setScissorTest(R), ke) {
        const it = se.get(W.texture);
        Z.framebufferTexture2D(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_CUBE_MAP_POSITIVE_X + ve, it.__webglTexture, ye);
      } else if (De) {
        const it = se.get(W.texture), mt = ve || 0;
        Z.framebufferTextureLayer(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, it.__webglTexture, ye || 0, mt);
      }
      y = -1;
    }, this.readRenderTargetPixels = function(W, ve, ye, Ce, be, ke, De) {
      if (!(W && W.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Qe = se.get(W).__webglFramebuffer;
      if (W.isWebGLCubeRenderTarget && De !== void 0 && (Qe = Qe[De]), Qe) {
        B.bindFramebuffer(Z.FRAMEBUFFER, Qe);
        try {
          const it = W.texture, mt = it.format, gt = it.type;
          if (!J.textureFormatReadable(mt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!J.textureTypeReadable(gt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          ve >= 0 && ve <= W.width - Ce && ye >= 0 && ye <= W.height - be && Z.readPixels(ve, ye, Ce, be, Je.convert(mt), Je.convert(gt), ke);
        } finally {
          const it = T !== null ? se.get(T).__webglFramebuffer : null;
          B.bindFramebuffer(Z.FRAMEBUFFER, it);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(W, ve, ye, Ce, be, ke, De) {
      if (!(W && W.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Qe = se.get(W).__webglFramebuffer;
      if (W.isWebGLCubeRenderTarget && De !== void 0 && (Qe = Qe[De]), Qe) {
        const it = W.texture, mt = it.format, gt = it.type;
        if (!J.textureFormatReadable(mt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!J.textureTypeReadable(gt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (ve >= 0 && ve <= W.width - Ce && ye >= 0 && ye <= W.height - be) {
          B.bindFramebuffer(Z.FRAMEBUFFER, Qe);
          const lt = Z.createBuffer();
          Z.bindBuffer(Z.PIXEL_PACK_BUFFER, lt), Z.bufferData(Z.PIXEL_PACK_BUFFER, ke.byteLength, Z.STREAM_READ), Z.readPixels(ve, ye, Ce, be, Je.convert(mt), Je.convert(gt), 0);
          const Rt = T !== null ? se.get(T).__webglFramebuffer : null;
          B.bindFramebuffer(Z.FRAMEBUFFER, Rt);
          const Ht = Z.fenceSync(Z.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return Z.flush(), await Eb(Z, Ht, 4), Z.bindBuffer(Z.PIXEL_PACK_BUFFER, lt), Z.getBufferSubData(Z.PIXEL_PACK_BUFFER, 0, ke), Z.deleteBuffer(lt), Z.deleteSync(Ht), ke;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(W, ve = null, ye = 0) {
      W.isTexture !== !0 && (Pa("WebGLRenderer: copyFramebufferToTexture function signature has changed."), ve = arguments[0] || null, W = arguments[1]);
      const Ce = Math.pow(2, -ye), be = Math.floor(W.image.width * Ce), ke = Math.floor(W.image.height * Ce), De = ve !== null ? ve.x : 0, Qe = ve !== null ? ve.y : 0;
      z.setTexture2D(W, 0), Z.copyTexSubImage2D(Z.TEXTURE_2D, ye, 0, 0, De, Qe, be, ke), B.unbindTexture();
    }, this.copyTextureToTexture = function(W, ve, ye = null, Ce = null, be = 0) {
      W.isTexture !== !0 && (Pa("WebGLRenderer: copyTextureToTexture function signature has changed."), Ce = arguments[0] || null, W = arguments[1], ve = arguments[2], be = arguments[3] || 0, ye = null);
      let ke, De, Qe, it, mt, gt, lt, Rt, Ht;
      const $t = W.isCompressedTexture ? W.mipmaps[be] : W.image;
      ye !== null ? (ke = ye.max.x - ye.min.x, De = ye.max.y - ye.min.y, Qe = ye.isBox3 ? ye.max.z - ye.min.z : 1, it = ye.min.x, mt = ye.min.y, gt = ye.isBox3 ? ye.min.z : 0) : (ke = $t.width, De = $t.height, Qe = $t.depth || 1, it = 0, mt = 0, gt = 0), Ce !== null ? (lt = Ce.x, Rt = Ce.y, Ht = Ce.z) : (lt = 0, Rt = 0, Ht = 0);
      const Rn = Je.convert(ve.format), kt = Je.convert(ve.type);
      let ht;
      ve.isData3DTexture ? (z.setTexture3D(ve, 0), ht = Z.TEXTURE_3D) : ve.isDataArrayTexture || ve.isCompressedArrayTexture ? (z.setTexture2DArray(ve, 0), ht = Z.TEXTURE_2D_ARRAY) : (z.setTexture2D(ve, 0), ht = Z.TEXTURE_2D), Z.pixelStorei(Z.UNPACK_FLIP_Y_WEBGL, ve.flipY), Z.pixelStorei(Z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ve.premultiplyAlpha), Z.pixelStorei(Z.UNPACK_ALIGNMENT, ve.unpackAlignment);
      const mi = Z.getParameter(Z.UNPACK_ROW_LENGTH), Lt = Z.getParameter(Z.UNPACK_IMAGE_HEIGHT), Dn = Z.getParameter(Z.UNPACK_SKIP_PIXELS), qi = Z.getParameter(Z.UNPACK_SKIP_ROWS), Sn = Z.getParameter(Z.UNPACK_SKIP_IMAGES);
      Z.pixelStorei(Z.UNPACK_ROW_LENGTH, $t.width), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, $t.height), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, it), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, mt), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, gt);
      const cs = W.isDataArrayTexture || W.isData3DTexture, Yt = ve.isDataArrayTexture || ve.isData3DTexture;
      if (W.isRenderTargetTexture || W.isDepthTexture) {
        const ri = se.get(W), Gn = se.get(ve), oi = se.get(ri.__renderTarget), vi = se.get(Gn.__renderTarget);
        B.bindFramebuffer(Z.READ_FRAMEBUFFER, oi.__webglFramebuffer), B.bindFramebuffer(Z.DRAW_FRAMEBUFFER, vi.__webglFramebuffer);
        for (let ai = 0; ai < Qe; ai++)
          cs && Z.framebufferTextureLayer(Z.READ_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, se.get(W).__webglTexture, be, gt + ai), W.isDepthTexture ? (Yt && Z.framebufferTextureLayer(Z.DRAW_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, se.get(ve).__webglTexture, be, Ht + ai), Z.blitFramebuffer(it, mt, ke, De, lt, Rt, ke, De, Z.DEPTH_BUFFER_BIT, Z.NEAREST)) : Yt ? Z.copyTexSubImage3D(ht, be, lt, Rt, Ht + ai, it, mt, ke, De) : Z.copyTexSubImage2D(ht, be, lt, Rt, Ht + ai, it, mt, ke, De);
        B.bindFramebuffer(Z.READ_FRAMEBUFFER, null), B.bindFramebuffer(Z.DRAW_FRAMEBUFFER, null);
      } else
        Yt ? W.isDataTexture || W.isData3DTexture ? Z.texSubImage3D(ht, be, lt, Rt, Ht, ke, De, Qe, Rn, kt, $t.data) : ve.isCompressedArrayTexture ? Z.compressedTexSubImage3D(ht, be, lt, Rt, Ht, ke, De, Qe, Rn, $t.data) : Z.texSubImage3D(ht, be, lt, Rt, Ht, ke, De, Qe, Rn, kt, $t) : W.isDataTexture ? Z.texSubImage2D(Z.TEXTURE_2D, be, lt, Rt, ke, De, Rn, kt, $t.data) : W.isCompressedTexture ? Z.compressedTexSubImage2D(Z.TEXTURE_2D, be, lt, Rt, $t.width, $t.height, Rn, $t.data) : Z.texSubImage2D(Z.TEXTURE_2D, be, lt, Rt, ke, De, Rn, kt, $t);
      Z.pixelStorei(Z.UNPACK_ROW_LENGTH, mi), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, Lt), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, Dn), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, qi), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, Sn), be === 0 && ve.generateMipmaps && Z.generateMipmap(ht), B.unbindTexture();
    }, this.copyTextureToTexture3D = function(W, ve, ye = null, Ce = null, be = 0) {
      return W.isTexture !== !0 && (Pa("WebGLRenderer: copyTextureToTexture3D function signature has changed."), ye = arguments[0] || null, Ce = arguments[1] || null, W = arguments[2], ve = arguments[3], be = arguments[4] || 0), Pa('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(W, ve, ye, Ce, be);
    }, this.initRenderTarget = function(W) {
      se.get(W).__webglFramebuffer === void 0 && z.setupRenderTarget(W);
    }, this.initTexture = function(W) {
      W.isCubeTexture ? z.setTextureCube(W, 0) : W.isData3DTexture ? z.setTexture3D(W, 0) : W.isDataArrayTexture || W.isCompressedArrayTexture ? z.setTexture2DArray(W, 0) : z.setTexture2D(W, 0), B.unbindTexture();
    }, this.resetState = function() {
      E = 0, P = 0, T = null, B.reset(), bt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Es;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const n = this.getContext();
    n.drawingBufferColorspace = It._getDrawingBufferColorSpace(e), n.unpackColorSpace = It._getUnpackColorSpace();
  }
}
class F2 extends cn {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Mi(), this.environmentIntensity = 1, this.environmentRotation = new Mi(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, n) {
    return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity), n.object.environmentRotation = this.environmentRotation.toArray(), n;
  }
}
class $a extends xn {
  constructor(e = null, n = 1, i = 1, r, o, a, l, c, u = On, d = On, h, m) {
    super(null, a, l, c, u, d, r, o, h, m), this.isDataTexture = !0, this.image = { data: e, width: n, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Ar extends Si {
  constructor(e, n, i, r = 1) {
    super(e, n, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
class ji extends jr {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.color = new Mt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const tu = /* @__PURE__ */ new de(), nu = /* @__PURE__ */ new de(), qm = /* @__PURE__ */ new Zt(), va = /* @__PURE__ */ new kf(), rc = /* @__PURE__ */ new wl(), Pd = /* @__PURE__ */ new de(), Zm = /* @__PURE__ */ new de();
class ln extends cn {
  constructor(e = new Vt(), n = new ji()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, i = [0];
      for (let r = 1, o = n.count; r < o; r++)
        tu.fromBufferAttribute(n, r - 1), nu.fromBufferAttribute(n, r), i[r] = i[r - 1], i[r] += tu.distanceTo(nu);
      e.setAttribute("lineDistance", new Pt(i, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, n) {
    const i = this.geometry, r = this.matrixWorld, o = e.params.Line.threshold, a = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), rc.copy(i.boundingSphere), rc.applyMatrix4(r), rc.radius += o, e.ray.intersectsSphere(rc) === !1) return;
    qm.copy(r).invert(), va.copy(e.ray).applyMatrix4(qm);
    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = l * l, u = this.isLineSegments ? 2 : 1, d = i.index, m = i.attributes.position;
    if (d !== null) {
      const p = Math.max(0, a.start), v = Math.min(d.count, a.start + a.count);
      for (let x = p, g = v - 1; x < g; x += u) {
        const _ = d.getX(x), M = d.getX(x + 1), S = oc(this, e, va, c, _, M);
        S && n.push(S);
      }
      if (this.isLineLoop) {
        const x = d.getX(v - 1), g = d.getX(p), _ = oc(this, e, va, c, x, g);
        _ && n.push(_);
      }
    } else {
      const p = Math.max(0, a.start), v = Math.min(m.count, a.start + a.count);
      for (let x = p, g = v - 1; x < g; x += u) {
        const _ = oc(this, e, va, c, x, x + 1);
        _ && n.push(_);
      }
      if (this.isLineLoop) {
        const x = oc(this, e, va, c, v - 1, p);
        x && n.push(x);
      }
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes, i = Object.keys(n);
    if (i.length > 0) {
      const r = n[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, a = r.length; o < a; o++) {
          const l = r[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = o;
        }
      }
    }
  }
}
function oc(s, e, n, i, r, o) {
  const a = s.geometry.attributes.position;
  if (tu.fromBufferAttribute(a, r), nu.fromBufferAttribute(a, o), n.distanceSqToSegment(tu, nu, Pd, Zm) > i) return;
  Pd.applyMatrix4(s.matrixWorld);
  const c = e.ray.origin.distanceTo(Pd);
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: Zm.clone().applyMatrix4(s.matrixWorld),
      index: r,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: s
    };
}
const Km = /* @__PURE__ */ new de(), Jm = /* @__PURE__ */ new de();
class zf extends ln {
  constructor(e, n) {
    super(e, n), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, i = [];
      for (let r = 0, o = n.count; r < o; r += 2)
        Km.fromBufferAttribute(n, r), Jm.fromBufferAttribute(n, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + Km.distanceTo(Jm);
      e.setAttribute("lineDistance", new Pt(i, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class U2 extends ln {
  constructor(e, n) {
    super(e, n), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class O2 extends xn {
  constructor(e, n, i, r, o, a, l, c, u) {
    super(e, n, i, r, o, a, l, c, u), this.isVideoTexture = !0, this.minFilter = a !== void 0 ? a : Bt, this.magFilter = o !== void 0 ? o : Bt, this.generateMipmaps = !1;
    const d = this;
    function h() {
      d.needsUpdate = !0, e.requestVideoFrameCallback(h);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class Qm extends xn {
  constructor(e, n, i, r, o, a, l, c, u) {
    super(e, n, i, r, o, a, l, c, u), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class ls {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, n);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return n;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPointAt(i / e));
    return n;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const n = [];
    let i, r = this.getPoint(0), o = 0;
    n.push(0);
    for (let a = 1; a <= e; a++)
      i = this.getPoint(a / e), o += i.distanceTo(r), n.push(o), r = i;
    return this.cacheArcLengths = n, n;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, n) {
    const i = this.getLengths();
    let r = 0;
    const o = i.length;
    let a;
    n ? a = n : a = e * i[o - 1];
    let l = 0, c = o - 1, u;
    for (; l <= c; )
      if (r = Math.floor(l + (c - l) / 2), u = i[r] - a, u < 0)
        l = r + 1;
      else if (u > 0)
        c = r - 1;
      else {
        c = r;
        break;
      }
    if (r = c, i[r] === a)
      return r / (o - 1);
    const d = i[r], m = i[r + 1] - d, p = (a - d) / m;
    return (r + p) / (o - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, n) {
    let r = e - 1e-4, o = e + 1e-4;
    r < 0 && (r = 0), o > 1 && (o = 1);
    const a = this.getPoint(r), l = this.getPoint(o), c = n || (a.isVector2 ? new rt() : new de());
    return c.copy(l).sub(a).normalize(), c;
  }
  getTangentAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, n);
  }
  computeFrenetFrames(e, n) {
    const i = new de(), r = [], o = [], a = [], l = new de(), c = new Zt();
    for (let p = 0; p <= e; p++) {
      const v = p / e;
      r[p] = this.getTangentAt(v, new de());
    }
    o[0] = new de(), a[0] = new de();
    let u = Number.MAX_VALUE;
    const d = Math.abs(r[0].x), h = Math.abs(r[0].y), m = Math.abs(r[0].z);
    d <= u && (u = d, i.set(1, 0, 0)), h <= u && (u = h, i.set(0, 1, 0)), m <= u && i.set(0, 0, 1), l.crossVectors(r[0], i).normalize(), o[0].crossVectors(r[0], l), a[0].crossVectors(r[0], o[0]);
    for (let p = 1; p <= e; p++) {
      if (o[p] = o[p - 1].clone(), a[p] = a[p - 1].clone(), l.crossVectors(r[p - 1], r[p]), l.length() > Number.EPSILON) {
        l.normalize();
        const v = Math.acos(Ln(r[p - 1].dot(r[p]), -1, 1));
        o[p].applyMatrix4(c.makeRotationAxis(l, v));
      }
      a[p].crossVectors(r[p], o[p]);
    }
    if (n === !0) {
      let p = Math.acos(Ln(o[0].dot(o[e]), -1, 1));
      p /= e, r[0].dot(l.crossVectors(o[0], o[e])) > 0 && (p = -p);
      for (let v = 1; v <= e; v++)
        o[v].applyMatrix4(c.makeRotationAxis(r[v], p * v)), a[v].crossVectors(r[v], o[v]);
    }
    return {
      tangents: r,
      normals: o,
      binormals: a
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Nf extends ls {
  constructor(e = 0, n = 0, i = 1, r = 1, o = 0, a = Math.PI * 2, l = !1, c = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = n, this.xRadius = i, this.yRadius = r, this.aStartAngle = o, this.aEndAngle = a, this.aClockwise = l, this.aRotation = c;
  }
  getPoint(e, n = new rt()) {
    const i = n, r = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += r;
    for (; o > r; ) o -= r;
    o < Number.EPSILON && (a ? o = 0 : o = r), this.aClockwise === !0 && !a && (o === r ? o = -r : o = o - r);
    const l = this.aStartAngle + e * o;
    let c = this.aX + this.xRadius * Math.cos(l), u = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const d = Math.cos(this.aRotation), h = Math.sin(this.aRotation), m = c - this.aX, p = u - this.aY;
      c = m * d - p * h + this.aX, u = m * h + p * d + this.aY;
    }
    return i.set(c, u);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class z2 extends Nf {
  constructor(e, n, i, r, o, a) {
    super(e, n, i, i, r, o, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function Bf() {
  let s = 0, e = 0, n = 0, i = 0;
  function r(o, a, l, c) {
    s = o, e = l, n = -3 * o + 3 * a - 2 * l - c, i = 2 * o - 2 * a + l + c;
  }
  return {
    initCatmullRom: function(o, a, l, c, u) {
      r(a, l, u * (l - o), u * (c - a));
    },
    initNonuniformCatmullRom: function(o, a, l, c, u, d, h) {
      let m = (a - o) / u - (l - o) / (u + d) + (l - a) / d, p = (l - a) / d - (c - a) / (d + h) + (c - l) / h;
      m *= d, p *= d, r(a, l, m, p);
    },
    calc: function(o) {
      const a = o * o, l = a * o;
      return s + e * o + n * a + i * l;
    }
  };
}
const ac = /* @__PURE__ */ new de(), Rd = /* @__PURE__ */ new Bf(), Dd = /* @__PURE__ */ new Bf(), kd = /* @__PURE__ */ new Bf();
class N2 extends ls {
  constructor(e = [], n = !1, i = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = n, this.curveType = i, this.tension = r;
  }
  getPoint(e, n = new de()) {
    const i = n, r = this.points, o = r.length, a = (o - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(a), c = a - l;
    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / o) + 1) * o : c === 0 && l === o - 1 && (l = o - 2, c = 1);
    let u, d;
    this.closed || l > 0 ? u = r[(l - 1) % o] : (ac.subVectors(r[0], r[1]).add(r[0]), u = ac);
    const h = r[l % o], m = r[(l + 1) % o];
    if (this.closed || l + 2 < o ? d = r[(l + 2) % o] : (ac.subVectors(r[o - 1], r[o - 2]).add(r[o - 1]), d = ac), this.curveType === "centripetal" || this.curveType === "chordal") {
      const p = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(u.distanceToSquared(h), p), x = Math.pow(h.distanceToSquared(m), p), g = Math.pow(m.distanceToSquared(d), p);
      x < 1e-4 && (x = 1), v < 1e-4 && (v = x), g < 1e-4 && (g = x), Rd.initNonuniformCatmullRom(u.x, h.x, m.x, d.x, v, x, g), Dd.initNonuniformCatmullRom(u.y, h.y, m.y, d.y, v, x, g), kd.initNonuniformCatmullRom(u.z, h.z, m.z, d.z, v, x, g);
    } else this.curveType === "catmullrom" && (Rd.initCatmullRom(u.x, h.x, m.x, d.x, this.tension), Dd.initCatmullRom(u.y, h.y, m.y, d.y, this.tension), kd.initCatmullRom(u.z, h.z, m.z, d.z, this.tension));
    return i.set(
      Rd.calc(c),
      Dd.calc(c),
      kd.calc(c)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const r = this.points[n];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(new de().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function ev(s, e, n, i, r) {
  const o = (i - e) * 0.5, a = (r - n) * 0.5, l = s * s, c = s * l;
  return (2 * n - 2 * i + o + a) * c + (-3 * n + 3 * i - 2 * o - a) * l + o * s + n;
}
function B2(s, e) {
  const n = 1 - s;
  return n * n * e;
}
function V2(s, e) {
  return 2 * (1 - s) * s * e;
}
function G2(s, e) {
  return s * s * e;
}
function Wa(s, e, n, i) {
  return B2(s, e) + V2(s, n) + G2(s, i);
}
function H2(s, e) {
  const n = 1 - s;
  return n * n * n * e;
}
function $2(s, e) {
  const n = 1 - s;
  return 3 * n * n * s * e;
}
function W2(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function X2(s, e) {
  return s * s * s * e;
}
function Xa(s, e, n, i, r) {
  return H2(s, e) + $2(s, n) + W2(s, i) + X2(s, r);
}
class fy extends ls {
  constructor(e = new rt(), n = new rt(), i = new rt(), r = new rt()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = r;
  }
  getPoint(e, n = new rt()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2, l = this.v3;
    return i.set(
      Xa(e, r.x, o.x, a.x, l.x),
      Xa(e, r.y, o.y, a.y, l.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class dl extends ls {
  constructor(e = new de(), n = new de(), i = new de(), r = new de()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = r;
  }
  getPoint(e, n = new de()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2, l = this.v3;
    return i.set(
      Xa(e, r.x, o.x, a.x, l.x),
      Xa(e, r.y, o.y, a.y, l.y),
      Xa(e, r.z, o.z, a.z, l.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class py extends ls {
  constructor(e = new rt(), n = new rt()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = n;
  }
  getPoint(e, n = new rt()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new rt()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class j2 extends ls {
  constructor(e = new de(), n = new de()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = n;
  }
  getPoint(e, n = new de()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new de()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class my extends ls {
  constructor(e = new rt(), n = new rt(), i = new rt()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  getPoint(e, n = new rt()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2;
    return i.set(
      Wa(e, r.x, o.x, a.x),
      Wa(e, r.y, o.y, a.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Y2 extends ls {
  constructor(e = new de(), n = new de(), i = new de()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  getPoint(e, n = new de()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2;
    return i.set(
      Wa(e, r.x, o.x, a.x),
      Wa(e, r.y, o.y, a.y),
      Wa(e, r.z, o.z, a.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class vy extends ls {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, n = new rt()) {
    const i = n, r = this.points, o = (r.length - 1) * e, a = Math.floor(o), l = o - a, c = r[a === 0 ? a : a - 1], u = r[a], d = r[a > r.length - 2 ? r.length - 1 : a + 1], h = r[a > r.length - 3 ? r.length - 1 : a + 2];
    return i.set(
      ev(l, c.x, u.x, d.x, h.x),
      ev(l, c.y, u.y, d.y, h.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const r = this.points[n];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(new rt().fromArray(r));
    }
    return this;
  }
}
var tv = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: z2,
  CatmullRomCurve3: N2,
  CubicBezierCurve: fy,
  CubicBezierCurve3: dl,
  EllipseCurve: Nf,
  LineCurve: py,
  LineCurve3: j2,
  QuadraticBezierCurve: my,
  QuadraticBezierCurve3: Y2,
  SplineCurve: vy
});
class Vf extends ls {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), n = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(n)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new tv[i](n, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, n) {
    const i = e * this.getLength(), r = this.getCurveLengths();
    let o = 0;
    for (; o < r.length; ) {
      if (r[o] >= i) {
        const a = r[o] - i, l = this.curves[o], c = l.getLength(), u = c === 0 ? 0 : 1 - a / c;
        return l.getPointAt(u, n);
      }
      o++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let n = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      n += this.curves[i].getLength(), e.push(n);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return this.autoClose && n.push(n[0]), n;
  }
  getPoints(e = 12) {
    const n = [];
    let i;
    for (let r = 0, o = this.curves; r < o.length; r++) {
      const a = o[r], l = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, c = a.getPoints(l);
      for (let u = 0; u < c.length; u++) {
        const d = c[u];
        i && i.equals(d) || (n.push(d), i = d);
      }
    }
    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const r = e.curves[n];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let n = 0, i = this.curves.length; n < i; n++) {
      const r = this.curves[n];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const r = e.curves[n];
      this.curves.push(new tv[r.type]().fromJSON(r));
    }
    return this;
  }
}
class nv extends Vf {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new rt(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let n = 1, i = e.length; n < i; n++)
      this.lineTo(e[n].x, e[n].y);
    return this;
  }
  moveTo(e, n) {
    return this.currentPoint.set(e, n), this;
  }
  lineTo(e, n) {
    const i = new py(this.currentPoint.clone(), new rt(e, n));
    return this.curves.push(i), this.currentPoint.set(e, n), this;
  }
  quadraticCurveTo(e, n, i, r) {
    const o = new my(
      this.currentPoint.clone(),
      new rt(e, n),
      new rt(i, r)
    );
    return this.curves.push(o), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, n, i, r, o, a) {
    const l = new fy(
      this.currentPoint.clone(),
      new rt(e, n),
      new rt(i, r),
      new rt(o, a)
    );
    return this.curves.push(l), this.currentPoint.set(o, a), this;
  }
  splineThru(e) {
    const n = [this.currentPoint.clone()].concat(e), i = new vy(n);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, n, i, r, o, a) {
    const l = this.currentPoint.x, c = this.currentPoint.y;
    return this.absarc(
      e + l,
      n + c,
      i,
      r,
      o,
      a
    ), this;
  }
  absarc(e, n, i, r, o, a) {
    return this.absellipse(e, n, i, i, r, o, a), this;
  }
  ellipse(e, n, i, r, o, a, l, c) {
    const u = this.currentPoint.x, d = this.currentPoint.y;
    return this.absellipse(e + u, n + d, i, r, o, a, l, c), this;
  }
  absellipse(e, n, i, r, o, a, l, c) {
    const u = new Nf(e, n, i, r, o, a, l, c);
    if (this.curves.length > 0) {
      const h = u.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(u);
    const d = u.getPoint(1);
    return this.currentPoint.copy(d), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Au extends Vt {
  constructor(e = 1, n = 32, i = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: n,
      thetaStart: i,
      thetaLength: r
    }, n = Math.max(3, n);
    const o = [], a = [], l = [], c = [], u = new de(), d = new rt();
    a.push(0, 0, 0), l.push(0, 0, 1), c.push(0.5, 0.5);
    for (let h = 0, m = 3; h <= n; h++, m += 3) {
      const p = i + h / n * r;
      u.x = e * Math.cos(p), u.y = e * Math.sin(p), a.push(u.x, u.y, u.z), l.push(0, 0, 1), d.x = (a[m] / e + 1) / 2, d.y = (a[m + 1] / e + 1) / 2, c.push(d.x, d.y);
    }
    for (let h = 1; h <= n; h++)
      o.push(h, h + 1, 0);
    this.setIndex(o), this.setAttribute("position", new Pt(a, 3)), this.setAttribute("normal", new Pt(l, 3)), this.setAttribute("uv", new Pt(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Au(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class In extends Vt {
  constructor(e = 1, n = 1, i = 1, r = 32, o = 1, a = !1, l = 0, c = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: n,
      height: i,
      radialSegments: r,
      heightSegments: o,
      openEnded: a,
      thetaStart: l,
      thetaLength: c
    };
    const u = this;
    r = Math.floor(r), o = Math.floor(o);
    const d = [], h = [], m = [], p = [];
    let v = 0;
    const x = [], g = i / 2;
    let _ = 0;
    M(), a === !1 && (e > 0 && S(!0), n > 0 && S(!1)), this.setIndex(d), this.setAttribute("position", new Pt(h, 3)), this.setAttribute("normal", new Pt(m, 3)), this.setAttribute("uv", new Pt(p, 2));
    function M() {
      const b = new de(), C = new de();
      let E = 0;
      const P = (n - e) / i;
      for (let T = 0; T <= o; T++) {
        const y = [], w = T / o, D = w * (n - e) + e;
        for (let U = 0; U <= r; U++) {
          const R = U / r, O = R * c + l, A = Math.sin(O), G = Math.cos(O);
          C.x = D * A, C.y = -w * i + g, C.z = D * G, h.push(C.x, C.y, C.z), b.set(A, P, G).normalize(), m.push(b.x, b.y, b.z), p.push(R, 1 - w), y.push(v++);
        }
        x.push(y);
      }
      for (let T = 0; T < r; T++)
        for (let y = 0; y < o; y++) {
          const w = x[y][T], D = x[y + 1][T], U = x[y + 1][T + 1], R = x[y][T + 1];
          (e > 0 || y !== 0) && (d.push(w, D, R), E += 3), (n > 0 || y !== o - 1) && (d.push(D, U, R), E += 3);
        }
      u.addGroup(_, E, 0), _ += E;
    }
    function S(b) {
      const C = v, E = new rt(), P = new de();
      let T = 0;
      const y = b === !0 ? e : n, w = b === !0 ? 1 : -1;
      for (let U = 1; U <= r; U++)
        h.push(0, g * w, 0), m.push(0, w, 0), p.push(0.5, 0.5), v++;
      const D = v;
      for (let U = 0; U <= r; U++) {
        const O = U / r * c + l, A = Math.cos(O), G = Math.sin(O);
        P.x = y * G, P.y = g * w, P.z = y * A, h.push(P.x, P.y, P.z), m.push(0, w, 0), E.x = A * 0.5 + 0.5, E.y = G * 0.5 * w + 0.5, p.push(E.x, E.y), v++;
      }
      for (let U = 0; U < r; U++) {
        const R = C + U, O = D + U;
        b === !0 ? d.push(O, O + 1, R) : d.push(O + 1, O, R), T += 3;
      }
      u.addGroup(_, T, b === !0 ? 1 : 2), _ += T;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new In(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Gf extends In {
  constructor(e = 1, n = 1, i = 32, r = 1, o = !1, a = 0, l = Math.PI * 2) {
    super(0, e, n, i, r, o, a, l), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: n,
      radialSegments: i,
      heightSegments: r,
      openEnded: o,
      thetaStart: a,
      thetaLength: l
    };
  }
  static fromJSON(e) {
    return new Gf(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Hf extends Vt {
  constructor(e = [], n = [], i = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: n,
      radius: i,
      detail: r
    };
    const o = [], a = [];
    l(r), u(i), d(), this.setAttribute("position", new Pt(o, 3)), this.setAttribute("normal", new Pt(o.slice(), 3)), this.setAttribute("uv", new Pt(a, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function l(M) {
      const S = new de(), b = new de(), C = new de();
      for (let E = 0; E < n.length; E += 3)
        p(n[E + 0], S), p(n[E + 1], b), p(n[E + 2], C), c(S, b, C, M);
    }
    function c(M, S, b, C) {
      const E = C + 1, P = [];
      for (let T = 0; T <= E; T++) {
        P[T] = [];
        const y = M.clone().lerp(b, T / E), w = S.clone().lerp(b, T / E), D = E - T;
        for (let U = 0; U <= D; U++)
          U === 0 && T === E ? P[T][U] = y : P[T][U] = y.clone().lerp(w, U / D);
      }
      for (let T = 0; T < E; T++)
        for (let y = 0; y < 2 * (E - T) - 1; y++) {
          const w = Math.floor(y / 2);
          y % 2 === 0 ? (m(P[T][w + 1]), m(P[T + 1][w]), m(P[T][w])) : (m(P[T][w + 1]), m(P[T + 1][w + 1]), m(P[T + 1][w]));
        }
    }
    function u(M) {
      const S = new de();
      for (let b = 0; b < o.length; b += 3)
        S.x = o[b + 0], S.y = o[b + 1], S.z = o[b + 2], S.normalize().multiplyScalar(M), o[b + 0] = S.x, o[b + 1] = S.y, o[b + 2] = S.z;
    }
    function d() {
      const M = new de();
      for (let S = 0; S < o.length; S += 3) {
        M.x = o[S + 0], M.y = o[S + 1], M.z = o[S + 2];
        const b = g(M) / 2 / Math.PI + 0.5, C = _(M) / Math.PI + 0.5;
        a.push(b, 1 - C);
      }
      v(), h();
    }
    function h() {
      for (let M = 0; M < a.length; M += 6) {
        const S = a[M + 0], b = a[M + 2], C = a[M + 4], E = Math.max(S, b, C), P = Math.min(S, b, C);
        E > 0.9 && P < 0.1 && (S < 0.2 && (a[M + 0] += 1), b < 0.2 && (a[M + 2] += 1), C < 0.2 && (a[M + 4] += 1));
      }
    }
    function m(M) {
      o.push(M.x, M.y, M.z);
    }
    function p(M, S) {
      const b = M * 3;
      S.x = e[b + 0], S.y = e[b + 1], S.z = e[b + 2];
    }
    function v() {
      const M = new de(), S = new de(), b = new de(), C = new de(), E = new rt(), P = new rt(), T = new rt();
      for (let y = 0, w = 0; y < o.length; y += 9, w += 6) {
        M.set(o[y + 0], o[y + 1], o[y + 2]), S.set(o[y + 3], o[y + 4], o[y + 5]), b.set(o[y + 6], o[y + 7], o[y + 8]), E.set(a[w + 0], a[w + 1]), P.set(a[w + 2], a[w + 3]), T.set(a[w + 4], a[w + 5]), C.copy(M).add(S).add(b).divideScalar(3);
        const D = g(C);
        x(E, w + 0, M, D), x(P, w + 2, S, D), x(T, w + 4, b, D);
      }
    }
    function x(M, S, b, C) {
      C < 0 && M.x === 1 && (a[S] = M.x - 1), b.x === 0 && b.z === 0 && (a[S] = C / 2 / Math.PI + 0.5);
    }
    function g(M) {
      return Math.atan2(M.z, -M.x);
    }
    function _(M) {
      return Math.atan2(-M.y, Math.sqrt(M.x * M.x + M.z * M.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Hf(e.vertices, e.indices, e.radius, e.details);
  }
}
class gy extends nv {
  constructor(e) {
    super(e), this.uuid = Xr(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const n = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      n[i] = this.holes[i].getPoints(e);
    return n;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const r = e.holes[n];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let n = 0, i = this.holes.length; n < i; n++) {
      const r = this.holes[n];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const r = e.holes[n];
      this.holes.push(new nv().fromJSON(r));
    }
    return this;
  }
}
const q2 = {
  triangulate: function(s, e, n = 2) {
    const i = e && e.length, r = i ? e[0] * n : s.length;
    let o = yy(s, 0, r, n, !0);
    const a = [];
    if (!o || o.next === o.prev) return a;
    let l, c, u, d, h, m, p;
    if (i && (o = eE(s, e, o, n)), s.length > 80 * n) {
      l = u = s[0], c = d = s[1];
      for (let v = n; v < r; v += n)
        h = s[v], m = s[v + 1], h < l && (l = h), m < c && (c = m), h > u && (u = h), m > d && (d = m);
      p = Math.max(u - l, d - c), p = p !== 0 ? 32767 / p : 0;
    }
    return hl(o, a, n, l, c, p, 0), a;
  }
};
function yy(s, e, n, i, r) {
  let o, a;
  if (r === dE(s, e, n, i) > 0)
    for (o = e; o < n; o += i) a = iv(o, s[o], s[o + 1], a);
  else
    for (o = n - i; o >= e; o -= i) a = iv(o, s[o], s[o + 1], a);
  return a && Pu(a, a.next) && (pl(a), a = a.next), a;
}
function $r(s, e) {
  if (!s) return s;
  e || (e = s);
  let n = s, i;
  do
    if (i = !1, !n.steiner && (Pu(n, n.next) || hn(n.prev, n, n.next) === 0)) {
      if (pl(n), n = e = n.prev, n === n.next) break;
      i = !0;
    } else
      n = n.next;
  while (i || n !== e);
  return e;
}
function hl(s, e, n, i, r, o, a) {
  if (!s) return;
  !a && o && rE(s, i, r, o);
  let l = s, c, u;
  for (; s.prev !== s.next; ) {
    if (c = s.prev, u = s.next, o ? K2(s, i, r, o) : Z2(s)) {
      e.push(c.i / n | 0), e.push(s.i / n | 0), e.push(u.i / n | 0), pl(s), s = u.next, l = u.next;
      continue;
    }
    if (s = u, s === l) {
      a ? a === 1 ? (s = J2($r(s), e, n), hl(s, e, n, i, r, o, 2)) : a === 2 && Q2(s, e, n, i, r, o) : hl($r(s), e, n, i, r, o, 1);
      break;
    }
  }
}
function Z2(s) {
  const e = s.prev, n = s, i = s.next;
  if (hn(e, n, i) >= 0) return !1;
  const r = e.x, o = n.x, a = i.x, l = e.y, c = n.y, u = i.y, d = r < o ? r < a ? r : a : o < a ? o : a, h = l < c ? l < u ? l : u : c < u ? c : u, m = r > o ? r > a ? r : a : o > a ? o : a, p = l > c ? l > u ? l : u : c > u ? c : u;
  let v = i.next;
  for (; v !== e; ) {
    if (v.x >= d && v.x <= m && v.y >= h && v.y <= p && Co(r, l, o, c, a, u, v.x, v.y) && hn(v.prev, v, v.next) >= 0) return !1;
    v = v.next;
  }
  return !0;
}
function K2(s, e, n, i) {
  const r = s.prev, o = s, a = s.next;
  if (hn(r, o, a) >= 0) return !1;
  const l = r.x, c = o.x, u = a.x, d = r.y, h = o.y, m = a.y, p = l < c ? l < u ? l : u : c < u ? c : u, v = d < h ? d < m ? d : m : h < m ? h : m, x = l > c ? l > u ? l : u : c > u ? c : u, g = d > h ? d > m ? d : m : h > m ? h : m, _ = Yh(p, v, e, n, i), M = Yh(x, g, e, n, i);
  let S = s.prevZ, b = s.nextZ;
  for (; S && S.z >= _ && b && b.z <= M; ) {
    if (S.x >= p && S.x <= x && S.y >= v && S.y <= g && S !== r && S !== a && Co(l, d, c, h, u, m, S.x, S.y) && hn(S.prev, S, S.next) >= 0 || (S = S.prevZ, b.x >= p && b.x <= x && b.y >= v && b.y <= g && b !== r && b !== a && Co(l, d, c, h, u, m, b.x, b.y) && hn(b.prev, b, b.next) >= 0)) return !1;
    b = b.nextZ;
  }
  for (; S && S.z >= _; ) {
    if (S.x >= p && S.x <= x && S.y >= v && S.y <= g && S !== r && S !== a && Co(l, d, c, h, u, m, S.x, S.y) && hn(S.prev, S, S.next) >= 0) return !1;
    S = S.prevZ;
  }
  for (; b && b.z <= M; ) {
    if (b.x >= p && b.x <= x && b.y >= v && b.y <= g && b !== r && b !== a && Co(l, d, c, h, u, m, b.x, b.y) && hn(b.prev, b, b.next) >= 0) return !1;
    b = b.nextZ;
  }
  return !0;
}
function J2(s, e, n) {
  let i = s;
  do {
    const r = i.prev, o = i.next.next;
    !Pu(r, o) && _y(r, i, i.next, o) && fl(r, o) && fl(o, r) && (e.push(r.i / n | 0), e.push(i.i / n | 0), e.push(o.i / n | 0), pl(i), pl(i.next), i = s = o), i = i.next;
  } while (i !== s);
  return $r(i);
}
function Q2(s, e, n, i, r, o) {
  let a = s;
  do {
    let l = a.next.next;
    for (; l !== a.prev; ) {
      if (a.i !== l.i && lE(a, l)) {
        let c = xy(a, l);
        a = $r(a, a.next), c = $r(c, c.next), hl(a, e, n, i, r, o, 0), hl(c, e, n, i, r, o, 0);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== s);
}
function eE(s, e, n, i) {
  const r = [];
  let o, a, l, c, u;
  for (o = 0, a = e.length; o < a; o++)
    l = e[o] * i, c = o < a - 1 ? e[o + 1] * i : s.length, u = yy(s, l, c, i, !1), u === u.next && (u.steiner = !0), r.push(aE(u));
  for (r.sort(tE), o = 0; o < r.length; o++)
    n = nE(r[o], n);
  return n;
}
function tE(s, e) {
  return s.x - e.x;
}
function nE(s, e) {
  const n = iE(s, e);
  if (!n)
    return e;
  const i = xy(n, s);
  return $r(i, i.next), $r(n, n.next);
}
function iE(s, e) {
  let n = e, i = -1 / 0, r;
  const o = s.x, a = s.y;
  do {
    if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
      const m = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (m <= o && m > i && (i = m, r = n.x < n.next.x ? n : n.next, m === o))
        return r;
    }
    n = n.next;
  } while (n !== e);
  if (!r) return null;
  const l = r, c = r.x, u = r.y;
  let d = 1 / 0, h;
  n = r;
  do
    o >= n.x && n.x >= c && o !== n.x && Co(a < u ? o : i, a, c, u, a < u ? i : o, a, n.x, n.y) && (h = Math.abs(a - n.y) / (o - n.x), fl(n, s) && (h < d || h === d && (n.x > r.x || n.x === r.x && sE(r, n))) && (r = n, d = h)), n = n.next;
  while (n !== l);
  return r;
}
function sE(s, e) {
  return hn(s.prev, s, e.prev) < 0 && hn(e.next, s, s.next) < 0;
}
function rE(s, e, n, i) {
  let r = s;
  do
    r.z === 0 && (r.z = Yh(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== s);
  r.prevZ.nextZ = null, r.prevZ = null, oE(r);
}
function oE(s) {
  let e, n, i, r, o, a, l, c, u = 1;
  do {
    for (n = s, s = null, o = null, a = 0; n; ) {
      for (a++, i = n, l = 0, e = 0; e < u && (l++, i = i.nextZ, !!i); e++)
        ;
      for (c = u; l > 0 || c > 0 && i; )
        l !== 0 && (c === 0 || !i || n.z <= i.z) ? (r = n, n = n.nextZ, l--) : (r = i, i = i.nextZ, c--), o ? o.nextZ = r : s = r, r.prevZ = o, o = r;
      n = i;
    }
    o.nextZ = null, u *= 2;
  } while (a > 1);
  return s;
}
function Yh(s, e, n, i, r) {
  return s = (s - n) * r | 0, e = (e - i) * r | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function aE(s) {
  let e = s, n = s;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== s);
  return n;
}
function Co(s, e, n, i, r, o, a, l) {
  return (r - a) * (e - l) >= (s - a) * (o - l) && (s - a) * (i - l) >= (n - a) * (e - l) && (n - a) * (o - l) >= (r - a) * (i - l);
}
function lE(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !cE(s, e) && // dones't intersect other edges
  (fl(s, e) && fl(e, s) && uE(s, e) && // locally visible
  (hn(s.prev, s, e.prev) || hn(s, e.prev, e)) || // does not create opposite-facing sectors
  Pu(s, e) && hn(s.prev, s, s.next) > 0 && hn(e.prev, e, e.next) > 0);
}
function hn(s, e, n) {
  return (e.y - s.y) * (n.x - e.x) - (e.x - s.x) * (n.y - e.y);
}
function Pu(s, e) {
  return s.x === e.x && s.y === e.y;
}
function _y(s, e, n, i) {
  const r = cc(hn(s, e, n)), o = cc(hn(s, e, i)), a = cc(hn(n, i, s)), l = cc(hn(n, i, e));
  return !!(r !== o && a !== l || r === 0 && lc(s, n, e) || o === 0 && lc(s, i, e) || a === 0 && lc(n, s, i) || l === 0 && lc(n, e, i));
}
function lc(s, e, n) {
  return e.x <= Math.max(s.x, n.x) && e.x >= Math.min(s.x, n.x) && e.y <= Math.max(s.y, n.y) && e.y >= Math.min(s.y, n.y);
}
function cc(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function cE(s, e) {
  let n = s;
  do {
    if (n.i !== s.i && n.next.i !== s.i && n.i !== e.i && n.next.i !== e.i && _y(n, n.next, s, e)) return !0;
    n = n.next;
  } while (n !== s);
  return !1;
}
function fl(s, e) {
  return hn(s.prev, s, s.next) < 0 ? hn(s, e, s.next) >= 0 && hn(s, s.prev, e) >= 0 : hn(s, e, s.prev) < 0 || hn(s, s.next, e) < 0;
}
function uE(s, e) {
  let n = s, i = !1;
  const r = (s.x + e.x) / 2, o = (s.y + e.y) / 2;
  do
    n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next;
  while (n !== s);
  return i;
}
function xy(s, e) {
  const n = new qh(s.i, s.x, s.y), i = new qh(e.i, e.x, e.y), r = s.next, o = e.prev;
  return s.next = e, e.prev = s, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i;
}
function iv(s, e, n, i) {
  const r = new qh(s, e, n);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function pl(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function qh(s, e, n) {
  this.i = s, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function dE(s, e, n, i) {
  let r = 0;
  for (let o = e, a = n - i; o < n; o += i)
    r += (s[a] - s[o]) * (s[o + 1] + s[a + 1]), a = o;
  return r;
}
class ja {
  // calculate area of the contour polygon
  static area(e) {
    const n = e.length;
    let i = 0;
    for (let r = n - 1, o = 0; o < n; r = o++)
      i += e[r].x * e[o].y - e[o].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return ja.area(e) < 0;
  }
  static triangulateShape(e, n) {
    const i = [], r = [], o = [];
    sv(e), rv(i, e);
    let a = e.length;
    n.forEach(sv);
    for (let c = 0; c < n.length; c++)
      r.push(a), a += n[c].length, rv(i, n[c]);
    const l = q2.triangulate(i, r);
    for (let c = 0; c < l.length; c += 3)
      o.push(l.slice(c, c + 3));
    return o;
  }
}
function sv(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function rv(s, e) {
  for (let n = 0; n < e.length; n++)
    s.push(e[n].x), s.push(e[n].y);
}
class Eo extends Hf {
  constructor(e = 1, n = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], r = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, r, e, n), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  static fromJSON(e) {
    return new Eo(e.radius, e.detail);
  }
}
class $f extends Vt {
  constructor(e = new gy([new rt(0, 0.5), new rt(-0.5, -0.5), new rt(0.5, -0.5)]), n = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: n
    };
    const i = [], r = [], o = [], a = [];
    let l = 0, c = 0;
    if (Array.isArray(e) === !1)
      u(e);
    else
      for (let d = 0; d < e.length; d++)
        u(e[d]), this.addGroup(l, c, d), l += c, c = 0;
    this.setIndex(i), this.setAttribute("position", new Pt(r, 3)), this.setAttribute("normal", new Pt(o, 3)), this.setAttribute("uv", new Pt(a, 2));
    function u(d) {
      const h = r.length / 3, m = d.extractPoints(n);
      let p = m.shape;
      const v = m.holes;
      ja.isClockWise(p) === !1 && (p = p.reverse());
      for (let g = 0, _ = v.length; g < _; g++) {
        const M = v[g];
        ja.isClockWise(M) === !0 && (v[g] = M.reverse());
      }
      const x = ja.triangulateShape(p, v);
      for (let g = 0, _ = v.length; g < _; g++) {
        const M = v[g];
        p = p.concat(M);
      }
      for (let g = 0, _ = p.length; g < _; g++) {
        const M = p[g];
        r.push(M.x, M.y, 0), o.push(0, 0, 1), a.push(M.x, M.y);
      }
      for (let g = 0, _ = x.length; g < _; g++) {
        const M = x[g], S = M[0] + h, b = M[1] + h, C = M[2] + h;
        i.push(S, b, C), c += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes;
    return hE(n, e);
  }
  static fromJSON(e, n) {
    const i = [];
    for (let r = 0, o = e.shapes.length; r < o; r++) {
      const a = n[e.shapes[r]];
      i.push(a);
    }
    return new $f(i, e.curveSegments);
  }
}
function hE(s, e) {
  if (e.shapes = [], Array.isArray(s))
    for (let n = 0, i = s.length; n < i; n++) {
      const r = s[n];
      e.shapes.push(r.uuid);
    }
  else
    e.shapes.push(s.uuid);
  return e;
}
class Ru extends Vt {
  constructor(e = 1, n = 32, i = 16, r = 0, o = Math.PI * 2, a = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: i,
      phiStart: r,
      phiLength: o,
      thetaStart: a,
      thetaLength: l
    }, n = Math.max(3, Math.floor(n)), i = Math.max(2, Math.floor(i));
    const c = Math.min(a + l, Math.PI);
    let u = 0;
    const d = [], h = new de(), m = new de(), p = [], v = [], x = [], g = [];
    for (let _ = 0; _ <= i; _++) {
      const M = [], S = _ / i;
      let b = 0;
      _ === 0 && a === 0 ? b = 0.5 / n : _ === i && c === Math.PI && (b = -0.5 / n);
      for (let C = 0; C <= n; C++) {
        const E = C / n;
        h.x = -e * Math.cos(r + E * o) * Math.sin(a + S * l), h.y = e * Math.cos(a + S * l), h.z = e * Math.sin(r + E * o) * Math.sin(a + S * l), v.push(h.x, h.y, h.z), m.copy(h).normalize(), x.push(m.x, m.y, m.z), g.push(E + b, 1 - S), M.push(u++);
      }
      d.push(M);
    }
    for (let _ = 0; _ < i; _++)
      for (let M = 0; M < n; M++) {
        const S = d[_][M + 1], b = d[_][M], C = d[_ + 1][M], E = d[_ + 1][M + 1];
        (_ !== 0 || a > 0) && p.push(S, b, E), (_ !== i - 1 || c < Math.PI) && p.push(b, C, E);
      }
    this.setIndex(p), this.setAttribute("position", new Pt(v, 3)), this.setAttribute("normal", new Pt(x, 3)), this.setAttribute("uv", new Pt(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ru(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class kr extends Vt {
  constructor(e = 1, n = 0.4, i = 12, r = 48, o = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: n,
      radialSegments: i,
      tubularSegments: r,
      arc: o
    }, i = Math.floor(i), r = Math.floor(r);
    const a = [], l = [], c = [], u = [], d = new de(), h = new de(), m = new de();
    for (let p = 0; p <= i; p++)
      for (let v = 0; v <= r; v++) {
        const x = v / r * o, g = p / i * Math.PI * 2;
        h.x = (e + n * Math.cos(g)) * Math.cos(x), h.y = (e + n * Math.cos(g)) * Math.sin(x), h.z = n * Math.sin(g), l.push(h.x, h.y, h.z), d.x = e * Math.cos(x), d.y = e * Math.sin(x), m.subVectors(h, d).normalize(), c.push(m.x, m.y, m.z), u.push(v / r), u.push(p / i);
      }
    for (let p = 1; p <= i; p++)
      for (let v = 1; v <= r; v++) {
        const x = (r + 1) * p + v - 1, g = (r + 1) * (p - 1) + v - 1, _ = (r + 1) * (p - 1) + v, M = (r + 1) * p + v;
        a.push(x, g, M), a.push(g, _, M);
      }
    this.setIndex(a), this.setAttribute("position", new Pt(l, 3)), this.setAttribute("normal", new Pt(c, 3)), this.setAttribute("uv", new Pt(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new kr(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class fE extends zn {
  static get type() {
    return "RawShaderMaterial";
  }
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0;
  }
}
class pE extends jr {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.color = new Mt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Mt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rf, this.normalScale = new rt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Mi(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class mE extends jr {
  static get type() {
    return "MeshNormalMaterial";
  }
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Rf, this.normalScale = new rt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
const ov = {
  enabled: !1,
  files: {},
  add: function(s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function(s) {
    if (this.enabled !== !1)
      return this.files[s];
  },
  remove: function(s) {
    delete this.files[s];
  },
  clear: function() {
    this.files = {};
  }
};
class vE {
  constructor(e, n, i) {
    const r = this;
    let o = !1, a = 0, l = 0, c;
    const u = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = n, this.onError = i, this.itemStart = function(d) {
      l++, o === !1 && r.onStart !== void 0 && r.onStart(d, a, l), o = !0;
    }, this.itemEnd = function(d) {
      a++, r.onProgress !== void 0 && r.onProgress(d, a, l), a === l && (o = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(d) {
      r.onError !== void 0 && r.onError(d);
    }, this.resolveURL = function(d) {
      return c ? c(d) : d;
    }, this.setURLModifier = function(d) {
      return c = d, this;
    }, this.addHandler = function(d, h) {
      return u.push(d, h), this;
    }, this.removeHandler = function(d) {
      const h = u.indexOf(d);
      return h !== -1 && u.splice(h, 2), this;
    }, this.getHandler = function(d) {
      for (let h = 0, m = u.length; h < m; h += 2) {
        const p = u[h], v = u[h + 1];
        if (p.global && (p.lastIndex = 0), p.test(d))
          return v;
      }
      return null;
    };
  }
}
const gE = /* @__PURE__ */ new vE();
class Wf {
  constructor(e) {
    this.manager = e !== void 0 ? e : gE, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, n) {
    const i = this;
    return new Promise(function(r, o) {
      i.load(e, r, n, o);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Wf.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class yE extends Wf {
  constructor(e) {
    super(e);
  }
  load(e, n, i, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, a = ov.get(e);
    if (a !== void 0)
      return o.manager.itemStart(e), setTimeout(function() {
        n && n(a), o.manager.itemEnd(e);
      }, 0), a;
    const l = ul("img");
    function c() {
      d(), ov.add(e, this), n && n(this), o.manager.itemEnd(e);
    }
    function u(h) {
      d(), r && r(h), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function d() {
      l.removeEventListener("load", c, !1), l.removeEventListener("error", u, !1);
    }
    return l.addEventListener("load", c, !1), l.addEventListener("error", u, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), o.manager.itemStart(e), l.src = e, l;
  }
}
class _E extends Wf {
  constructor(e) {
    super(e);
  }
  load(e, n, i, r) {
    const o = new xn(), a = new yE(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(l) {
      o.image = l, o.needsUpdate = !0, n !== void 0 && n(o);
    }, i, r), o;
  }
}
class Du extends cn {
  constructor(e, n = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Mt(e), this.intensity = n;
  }
  dispose() {
  }
  copy(e, n) {
    return super.copy(e, n), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (n.object.distance = this.distance), this.angle !== void 0 && (n.object.angle = this.angle), this.decay !== void 0 && (n.object.decay = this.decay), this.penumbra !== void 0 && (n.object.penumbra = this.penumbra), this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (n.object.target = this.target.uuid), n;
  }
}
const Id = /* @__PURE__ */ new Zt(), av = /* @__PURE__ */ new de(), lv = /* @__PURE__ */ new de();
class Xf {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new rt(512, 512), this.map = null, this.mapPass = null, this.matrix = new Zt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Lf(), this._frameExtents = new rt(1, 1), this._viewportCount = 1, this._viewports = [
      new jt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const n = this.camera, i = this.matrix;
    av.setFromMatrixPosition(e.matrixWorld), n.position.copy(av), lv.setFromMatrixPosition(e.target.matrixWorld), n.lookAt(lv), n.updateMatrixWorld(), Id.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Id), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(Id);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class xE extends Xf {
  constructor() {
    super(new ui(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const n = this.camera, i = $o * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, o = e.distance || n.far;
    (i !== n.fov || r !== n.aspect || o !== n.far) && (n.fov = i, n.aspect = r, n.far = o, n.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class js extends Du {
  constructor(e, n, i = 0, r = Math.PI / 3, o = 0, a = 2) {
    super(e, n), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(cn.DEFAULT_UP), this.updateMatrix(), this.target = new cn(), this.distance = i, this.angle = r, this.penumbra = o, this.decay = a, this.map = null, this.shadow = new xE();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return super.copy(e, n), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const cv = /* @__PURE__ */ new Zt(), ga = /* @__PURE__ */ new de(), Ld = /* @__PURE__ */ new de();
class bE extends Xf {
  constructor() {
    super(new ui(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new rt(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new jt(2, 1, 1, 1),
      // negative X
      new jt(0, 1, 1, 1),
      // positive Z
      new jt(3, 1, 1, 1),
      // negative Z
      new jt(1, 1, 1, 1),
      // positive Y
      new jt(3, 0, 1, 1),
      // negative Y
      new jt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new de(1, 0, 0),
      new de(-1, 0, 0),
      new de(0, 0, 1),
      new de(0, 0, -1),
      new de(0, 1, 0),
      new de(0, -1, 0)
    ], this._cubeUps = [
      new de(0, 1, 0),
      new de(0, 1, 0),
      new de(0, 1, 0),
      new de(0, 1, 0),
      new de(0, 0, 1),
      new de(0, 0, -1)
    ];
  }
  updateMatrices(e, n = 0) {
    const i = this.camera, r = this.matrix, o = e.distance || i.far;
    o !== i.far && (i.far = o, i.updateProjectionMatrix()), ga.setFromMatrixPosition(e.matrixWorld), i.position.copy(ga), Ld.copy(i.position), Ld.add(this._cubeDirections[n]), i.up.copy(this._cubeUps[n]), i.lookAt(Ld), i.updateMatrixWorld(), r.makeTranslation(-ga.x, -ga.y, -ga.z), cv.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(cv);
  }
}
class ya extends Du {
  constructor(e, n, i = 0, r = 2) {
    super(e, n), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new bE();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return super.copy(e, n), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class wE extends Xf {
  constructor() {
    super(new Eu(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class To extends Du {
  constructor(e, n) {
    super(e, n), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(cn.DEFAULT_UP), this.updateMatrix(), this.target = new cn(), this.shadow = new wE();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class by extends Du {
  constructor(e, n) {
    super(e, n), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class wy extends Vt {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class SE {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = uv(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const n = uv();
      e = (n - this.oldTime) / 1e3, this.oldTime = n, this.elapsedTime += e;
    }
    return e;
  }
}
function uv() {
  return performance.now();
}
const dv = /* @__PURE__ */ new Zt();
class jf {
  constructor(e, n, i = 0, r = 1 / 0) {
    this.ray = new kf(e, n), this.near = i, this.far = r, this.camera = null, this.layers = new If(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, n) {
    this.ray.set(e, n);
  }
  setFromCamera(e, n) {
    n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type);
  }
  setFromXRController(e) {
    return dv.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(dv), this;
  }
  intersectObject(e, n = !0, i = []) {
    return Zh(e, this, i, n), i.sort(hv), i;
  }
  intersectObjects(e, n = !0, i = []) {
    for (let r = 0, o = e.length; r < o; r++)
      Zh(e[r], this, i, n);
    return i.sort(hv), i;
  }
}
function hv(s, e) {
  return s.distance - e.distance;
}
function Zh(s, e, n, i) {
  let r = !0;
  if (s.layers.test(e.layers) && s.raycast(e, n) === !1 && (r = !1), r === !0 && i === !0) {
    const o = s.children;
    for (let a = 0, l = o.length; a < l; a++)
      Zh(o[a], e, n, !0);
  }
}
const fv = /* @__PURE__ */ new de();
class uc extends cn {
  constructor(e, n) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = n, this.type = "SpotLightHelper";
    const i = new Vt(), r = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let a = 0, l = 1, c = 32; a < c; a++, l++) {
      const u = a / c * Math.PI * 2, d = l / c * Math.PI * 2;
      r.push(
        Math.cos(u),
        Math.sin(u),
        1,
        Math.cos(d),
        Math.sin(d),
        1
      );
    }
    i.setAttribute("position", new Pt(r, 3));
    const o = new ji({ fog: !1, toneMapped: !1 });
    this.cone = new zf(i, o), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, n = e * Math.tan(this.light.angle);
    this.cone.scale.set(n, n, e), fv.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(fv), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
class pv extends Ze {
  constructor(e, n, i) {
    const r = new Ru(n, 4, 2), o = new En({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, o), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
class ME extends zf {
  constructor(e = 10, n = 10, i = 4473924, r = 8947848) {
    i = new Mt(i), r = new Mt(r);
    const o = n / 2, a = e / n, l = e / 2, c = [], u = [];
    for (let m = 0, p = 0, v = -l; m <= n; m++, v += a) {
      c.push(-l, 0, v, l, 0, v), c.push(v, 0, -l, v, 0, l);
      const x = m === o ? i : r;
      x.toArray(u, p), p += 3, x.toArray(u, p), p += 3, x.toArray(u, p), p += 3, x.toArray(u, p), p += 3;
    }
    const d = new Vt();
    d.setAttribute("position", new Pt(c, 3)), d.setAttribute("color", new Pt(u, 3));
    const h = new ji({ vertexColors: !0, toneMapped: !1 });
    super(d, h), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const mv = /* @__PURE__ */ new de(), dc = /* @__PURE__ */ new de(), vv = /* @__PURE__ */ new de();
class gv extends cn {
  constructor(e, n, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", n === void 0 && (n = 1);
    let r = new Vt();
    r.setAttribute("position", new Pt([
      -n,
      n,
      0,
      n,
      n,
      0,
      n,
      -n,
      0,
      -n,
      -n,
      0,
      -n,
      n,
      0
    ], 3));
    const o = new ji({ fog: !1, toneMapped: !1 });
    this.lightPlane = new ln(r, o), this.add(this.lightPlane), r = new Vt(), r.setAttribute("position", new Pt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ln(r, o), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), mv.setFromMatrixPosition(this.light.matrixWorld), dc.setFromMatrixPosition(this.light.target.matrixWorld), vv.subVectors(dc, mv), this.lightPlane.lookAt(dc), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(dc), this.targetLine.scale.z = vv.length();
  }
}
class CE extends zf {
  constructor(e = 1) {
    const n = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], i = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], r = new Vt();
    r.setAttribute("position", new Pt(n, 3)), r.setAttribute("color", new Pt(i, 3));
    const o = new ji({ vertexColors: !0, toneMapped: !1 });
    super(r, o), this.type = "AxesHelper";
  }
  setColors(e, n, i) {
    const r = new Mt(), o = this.geometry.attributes.color.array;
    return r.set(e), r.toArray(o, 0), r.toArray(o, 3), r.set(n), r.toArray(o, 6), r.toArray(o, 9), r.set(i), r.toArray(o, 12), r.toArray(o, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class EE extends Wr {
  constructor(e, n = null) {
    super(), this.object = e, this.domElement = n, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: bf
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = bf);
const zc = {
  // ============================================================================
  // LINEAR
  // ============================================================================
  linear: (s) => s,
  // ============================================================================
  // SINE
  // ============================================================================
  easeInSine: (s) => 1 - Math.cos(s * Math.PI / 2),
  easeOutSine: (s) => Math.sin(s * Math.PI / 2),
  easeInOutSine: (s) => -(Math.cos(Math.PI * s) - 1) / 2,
  // ============================================================================
  // QUADRATIC
  // ============================================================================
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => 1 - (1 - s) * (1 - s),
  easeInOutQuad: (s) => s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2,
  // ============================================================================
  // CUBIC
  // ============================================================================
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => 1 - Math.pow(1 - s, 3),
  easeInOutCubic: (s) => s < 0.5 ? 4 * s * s * s : 1 - Math.pow(-2 * s + 2, 3) / 2,
  // ============================================================================
  // QUARTIC
  // ============================================================================
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => 1 - Math.pow(1 - s, 4),
  easeInOutQuart: (s) => s < 0.5 ? 8 * s * s * s * s : 1 - Math.pow(-2 * s + 2, 4) / 2,
  // ============================================================================
  // QUINTIC
  // ============================================================================
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => 1 - Math.pow(1 - s, 5),
  easeInOutQuint: (s) => s < 0.5 ? 16 * s * s * s * s * s : 1 - Math.pow(-2 * s + 2, 5) / 2,
  // ============================================================================
  // EXPONENTIAL
  // ============================================================================
  easeInExpo: (s) => s === 0 ? 0 : Math.pow(2, 10 * s - 10),
  easeOutExpo: (s) => s === 1 ? 1 : 1 - Math.pow(2, -10 * s),
  easeInOutExpo: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? Math.pow(2, 20 * s - 10) / 2 : (2 - Math.pow(2, -20 * s + 10)) / 2,
  // ============================================================================
  // CIRCULAR
  // ============================================================================
  easeInCirc: (s) => 1 - Math.sqrt(1 - Math.pow(s, 2)),
  easeOutCirc: (s) => Math.sqrt(1 - Math.pow(s - 1, 2)),
  easeInOutCirc: (s) => s < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * s, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * s + 2, 2)) + 1) / 2,
  // ============================================================================
  // BACK (OVERSHOOT)
  // ============================================================================
  easeInBack: (s) => 2.70158 * s * s * s - 1.70158 * s * s,
  easeOutBack: (s) => 1 + 2.70158 * Math.pow(s - 1, 3) + 1.70158 * Math.pow(s - 1, 2),
  easeInOutBack: (s) => {
    const n = 2.5949095;
    return s < 0.5 ? Math.pow(2 * s, 2) * ((n + 1) * 2 * s - n) / 2 : (Math.pow(2 * s - 2, 2) * ((n + 1) * (s * 2 - 2) + n) + 2) / 2;
  },
  // ============================================================================
  // ELASTIC
  // ============================================================================
  easeInElastic: (s) => {
    const e = 2 * Math.PI / 3;
    return s === 0 ? 0 : s === 1 ? 1 : -Math.pow(2, 10 * s - 10) * Math.sin((s * 10 - 10.75) * e);
  },
  easeOutElastic: (s) => {
    const e = 2 * Math.PI / 3;
    return s === 0 ? 0 : s === 1 ? 1 : Math.pow(2, -10 * s) * Math.sin((s * 10 - 0.75) * e) + 1;
  },
  easeInOutElastic: (s) => {
    const e = 2 * Math.PI / 4.5;
    return s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? -(Math.pow(2, 20 * s - 10) * Math.sin((20 * s - 11.125) * e)) / 2 : Math.pow(2, -20 * s + 10) * Math.sin((20 * s - 11.125) * e) / 2 + 1;
  },
  // ============================================================================
  // BOUNCE
  // ============================================================================
  easeInBounce: (s) => 1 - zc.easeOutBounce(1 - s),
  easeOutBounce: (s) => s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375,
  easeInOutBounce: (s) => s < 0.5 ? (1 - zc.easeOutBounce(1 - 2 * s)) / 2 : (1 + zc.easeOutBounce(2 * s - 1)) / 2
};
class Ml {
  constructor() {
    // Cache for recent evaluations (cleared per frame batch)
    fe(this, "cache", /* @__PURE__ */ new Map());
  }
  /**
   * Evaluate an animatable property at a given frame
   */
  evaluate(e, n) {
    const i = e.id, r = this.cache.get(i);
    if (r && r.frame === n)
      return r.value;
    let o;
    return !e.animated || !e.keyframes || e.keyframes.length === 0 ? o = e.value : o = this.evaluateKeyframes(e.keyframes, n, e.value), this.cache.set(i, { frame: n, value: o }), o;
  }
  /**
   * Evaluate keyframes at a given frame
   */
  evaluateKeyframes(e, n, i) {
    const r = [...e].sort((d, h) => d.frame - h.frame);
    if (n <= r[0].frame)
      return r[0].value;
    if (n >= r[r.length - 1].frame)
      return r[r.length - 1].value;
    let o = r[0], a = r[r.length - 1];
    for (let d = 0; d < r.length - 1; d++)
      if (r[d].frame <= n && r[d + 1].frame > n) {
        o = r[d], a = r[d + 1];
        break;
      }
    const l = a.frame - o.frame, c = l > 0 ? (n - o.frame) / l : 0, u = this.applyEasing(c, o.interpolation, o, a);
    return this.interpolateValue(o.value, a.value, u, i);
  }
  /**
   * Apply easing function to raw t value
   */
  applyEasing(e, n, i, r) {
    switch (n) {
      case "hold":
        return 0;
      case "linear":
        return e;
      case "bezier":
        return this.evaluateBezier(e, i, r);
      default:
        const o = zc[n];
        return o ? o(e) : e;
    }
  }
  /**
   * Evaluate bezier curve using keyframe handles
   */
  evaluateBezier(e, n, i) {
    const r = n.outHandle, o = i.inHandle;
    if (!(r != null && r.enabled) && !(o != null && o.enabled))
      return e;
    const a = i.frame - n.frame, l = { x: 0, y: 0 }, c = {
      x: r != null && r.enabled ? Math.min(1, Math.max(0, r.frame / a)) : 0.33,
      y: r != null && r.enabled ? r.value : 0
    }, u = {
      x: o != null && o.enabled ? Math.min(1, Math.max(0, 1 + o.frame / a)) : 0.67,
      y: o != null && o.enabled ? 1 + o.value : 1
    }, d = { x: 1, y: 1 };
    return this.solveCubicBezier(e, l.x, c.x, u.x, d.x, l.y, c.y, u.y, d.y);
  }
  /**
   * Solve cubic bezier curve for Y given X
   */
  solveCubicBezier(e, n, i, r, o, a, l, c, u) {
    let d = e;
    const h = 1e-4;
    for (let m = 0; m < 10; m++) {
      const v = this.cubicBezier(d, n, i, r, o) - e;
      if (Math.abs(v) < h)
        break;
      const x = this.cubicBezierDerivative(d, n, i, r, o);
      if (Math.abs(x) < h)
        break;
      d -= v / x, d = Math.max(0, Math.min(1, d));
    }
    return this.cubicBezier(d, a, l, c, u);
  }
  /**
   * Evaluate cubic bezier at t
   */
  cubicBezier(e, n, i, r, o) {
    const a = 1 - e;
    return a * a * a * n + 3 * a * a * e * i + 3 * a * e * e * r + e * e * e * o;
  }
  /**
   * Evaluate cubic bezier derivative at t
   */
  cubicBezierDerivative(e, n, i, r, o) {
    const a = 1 - e;
    return 3 * a * a * (i - n) + 6 * a * e * (r - i) + 3 * e * e * (o - r);
  }
  /**
   * Interpolate between two values
   */
  interpolateValue(e, n, i, r) {
    return typeof e == "number" && typeof n == "number" ? e + (n - e) * i : this.isPositionLike(e) && this.isPositionLike(n) ? this.interpolatePosition(e, n, i) : typeof e == "string" && typeof n == "string" && e.startsWith("#") && n.startsWith("#") ? this.interpolateColor(e, n, i) : Array.isArray(e) && Array.isArray(n) ? this.interpolateArray(e, n, i) : i < 0.5 ? e : n;
  }
  /**
   * Check if value is position-like (has x, y properties)
   */
  isPositionLike(e) {
    return e !== null && typeof e == "object" && "x" in e && "y" in e;
  }
  /**
   * Interpolate position/vector values
   */
  interpolatePosition(e, n, i) {
    const r = {
      x: e.x + (n.x - e.x) * i,
      y: e.y + (n.y - e.y) * i
    };
    return ("z" in e || "z" in n) && (r.z = (e.z ?? 0) + ((n.z ?? 0) - (e.z ?? 0)) * i), r;
  }
  /**
   * Interpolate hex color strings
   */
  interpolateColor(e, n, i) {
    const r = this.hexToRGB(e), o = this.hexToRGB(n), a = Math.round(r.r + (o.r - r.r) * i), l = Math.round(r.g + (o.g - r.g) * i), c = Math.round(r.b + (o.b - r.b) * i);
    return this.rgbToHex(a, l, c);
  }
  /**
   * Interpolate arrays
   */
  interpolateArray(e, n, i) {
    const r = Math.max(e.length, n.length), o = [];
    for (let a = 0; a < r; a++) {
      const l = e[a] ?? 0, c = n[a] ?? 0;
      o.push(l + (c - l) * i);
    }
    return o;
  }
  /**
   * Convert hex color to RGB
   */
  hexToRGB(e) {
    const n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
    return n ? {
      r: parseInt(n[1], 16),
      g: parseInt(n[2], 16),
      b: parseInt(n[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  /**
   * Convert RGB to hex color
   */
  rgbToHex(e, n, i) {
    return "#" + [e, n, i].map((r) => Math.max(0, Math.min(255, r)).toString(16).padStart(2, "0")).join("");
  }
  /**
   * Clear the evaluation cache
   */
  clearCache() {
    this.cache.clear();
  }
}
const Ya = Math.PI, iu = 1.70158, hc = iu * 1.525, yv = iu + 1, _v = 2 * Ya / 3, xv = 2 * Ya / 4.5, Br = {
  // Linear - no easing
  linear: (s) => s,
  // Sine easing
  easeInSine: (s) => 1 - Math.cos(s * Ya / 2),
  easeOutSine: (s) => Math.sin(s * Ya / 2),
  easeInOutSine: (s) => -(Math.cos(Ya * s) - 1) / 2,
  // Quad (power of 2)
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => 1 - (1 - s) * (1 - s),
  easeInOutQuad: (s) => s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2,
  // Cubic (power of 3)
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => 1 - Math.pow(1 - s, 3),
  easeInOutCubic: (s) => s < 0.5 ? 4 * s * s * s : 1 - Math.pow(-2 * s + 2, 3) / 2,
  // Quart (power of 4)
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => 1 - Math.pow(1 - s, 4),
  easeInOutQuart: (s) => s < 0.5 ? 8 * s * s * s * s : 1 - Math.pow(-2 * s + 2, 4) / 2,
  // Quint (power of 5)
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => 1 - Math.pow(1 - s, 5),
  easeInOutQuint: (s) => s < 0.5 ? 16 * s * s * s * s * s : 1 - Math.pow(-2 * s + 2, 5) / 2,
  // Expo (exponential)
  easeInExpo: (s) => s === 0 ? 0 : Math.pow(2, 10 * s - 10),
  easeOutExpo: (s) => s === 1 ? 1 : 1 - Math.pow(2, -10 * s),
  easeInOutExpo: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? Math.pow(2, 20 * s - 10) / 2 : (2 - Math.pow(2, -20 * s + 10)) / 2,
  // Circ (circular)
  easeInCirc: (s) => 1 - Math.sqrt(1 - Math.pow(s, 2)),
  easeOutCirc: (s) => Math.sqrt(1 - Math.pow(s - 1, 2)),
  easeInOutCirc: (s) => s < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * s, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * s + 2, 2)) + 1) / 2,
  // Back (overshoot)
  easeInBack: (s) => yv * s * s * s - iu * s * s,
  easeOutBack: (s) => 1 + yv * Math.pow(s - 1, 3) + iu * Math.pow(s - 1, 2),
  easeInOutBack: (s) => s < 0.5 ? Math.pow(2 * s, 2) * ((hc + 1) * 2 * s - hc) / 2 : (Math.pow(2 * s - 2, 2) * ((hc + 1) * (s * 2 - 2) + hc) + 2) / 2,
  // Elastic
  easeInElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : -Math.pow(2, 10 * s - 10) * Math.sin((s * 10 - 10.75) * _v),
  easeOutElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : Math.pow(2, -10 * s) * Math.sin((s * 10 - 0.75) * _v) + 1,
  easeInOutElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? -(Math.pow(2, 20 * s - 10) * Math.sin((20 * s - 11.125) * xv)) / 2 : Math.pow(2, -20 * s + 10) * Math.sin((20 * s - 11.125) * xv) / 2 + 1,
  // Bounce
  easeOutBounce: (s) => s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375,
  easeInBounce: (s) => 1 - Br.easeOutBounce(1 - s),
  easeInOutBounce: (s) => s < 0.5 ? (1 - Br.easeOutBounce(1 - 2 * s)) / 2 : (1 + Br.easeOutBounce(2 * s - 1)) / 2
};
function TE(s) {
  return s in Br ? Br[s] : Br.linear;
}
function AE(s, e) {
  let n = 0, i = s.length - 2;
  for (; n <= i; ) {
    const r = n + i >>> 1, o = s[r].frame, a = s[r + 1].frame;
    if (e >= o && e <= a)
      return r;
    e < o ? i = r - 1 : n = r + 1;
  }
  return Math.max(0, Math.min(n, s.length - 2));
}
function PE(s, e) {
  if (typeof s == "number" && typeof e == "number")
    return e - s;
  if (typeof s == "object" && s !== null && "x" in s && "y" in s && typeof e == "object" && e !== null && "x" in e && "y" in e) {
    const n = e.x - s.x, i = e.y - s.y;
    return Math.sqrt(n * n + i * i) || 1;
  }
  return 1;
}
function an(s, e) {
  if (!s.animated || s.keyframes.length === 0)
    return s.value;
  const n = s.keyframes;
  if (e <= n[0].frame)
    return n[0].value;
  if (e >= n[n.length - 1].frame)
    return n[n.length - 1].value;
  const i = AE(n, e), r = n[i], o = n[i + 1], a = o.frame - r.frame, l = e - r.frame;
  let c = a > 0 ? l / a : 0;
  const u = r.interpolation || "linear";
  if (u === "hold")
    return r.value;
  if (u === "bezier") {
    const d = PE(r.value, o.value);
    c = RE(c, r.outHandle, o.inHandle, a, d);
  } else u === "linear" || (u in Br ? c = TE(u)(c) : ol.warn(`Unknown interpolation type: ${u}, using linear`));
  return kE(r.value, o.value, c);
}
function RE(s, e, n, i = 1, r = 1) {
  if (!e.enabled && !n.enabled)
    return s;
  const o = i > 0 ? Math.abs(e.frame) / i : 0.33, a = r !== 0 ? e.value / r : 0.33, l = i > 0 ? 1 - Math.abs(n.frame) / i : 0.67, c = r !== 0 ? 1 - n.value / r : 0.67;
  let u = s;
  const d = 1e-6, h = 8;
  for (let m = 0; m < h; m++) {
    const v = su(u, 0, o, l, 1) - s;
    if (Math.abs(v) < d) break;
    const x = DE(u, 0, o, l, 1);
    if (Math.abs(x) < d) break;
    u -= v / x, u = Math.max(0, Math.min(1, u));
  }
  return su(u, 0, a, c, 1);
}
function su(s, e, n, i, r) {
  const o = 1 - s;
  return o * o * o * e + 3 * o * o * s * n + 3 * o * s * s * i + s * s * s * r;
}
function DE(s, e, n, i, r) {
  const o = 1 - s;
  return 3 * o * o * (n - e) + 6 * o * s * (i - n) + 3 * s * s * (r - i);
}
function kE(s, e, n) {
  if (typeof s == "number" && typeof e == "number")
    return s + (e - s) * n;
  if (typeof s == "object" && s !== null && typeof e == "object" && e !== null && "x" in s && "y" in s && "x" in e && "y" in e) {
    const i = s, r = e, o = {
      x: i.x + (r.x - i.x) * n,
      y: i.y + (r.y - i.y) * n
    };
    return "z" in i && "z" in r ? o.z = i.z + (r.z - i.z) * n : "z" in i ? o.z = i.z * (1 - n) : "z" in r && (o.z = r.z * n), o;
  }
  return typeof s == "string" && typeof e == "string" && s.startsWith("#") && e.startsWith("#") ? IE(s, e, n) : n < 0.5 ? s : e;
}
function IE(s, e, n) {
  const i = parseInt(s.slice(1, 3), 16), r = parseInt(s.slice(3, 5), 16), o = parseInt(s.slice(5, 7), 16), a = parseInt(e.slice(1, 3), 16), l = parseInt(e.slice(3, 5), 16), c = parseInt(e.slice(5, 7), 16), u = Math.round(i + (a - i) * n), d = Math.round(r + (l - r) * n), h = Math.round(o + (c - o) * n);
  return `#${u.toString(16).padStart(2, "0")}${d.toString(16).padStart(2, "0")}${h.toString(16).padStart(2, "0")}`;
}
const LE = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
}, ru = LE;
function FE(s, e, n) {
  const i = e.x, r = e.y, o = 1 - n.x, a = 1 - n.y;
  return {
    x: su(s, 0, i, o, 1),
    y: su(s, 0, r, a, 1)
  };
}
function UE(s, e) {
  const n = Math.max(0, Math.min(1, s));
  return FE(n, e.outHandle, e.inHandle).y;
}
const Sy = /* @__PURE__ */ new Map();
function wo(s, e) {
  Sy.set(s, e);
}
function OE(s, e) {
  const n = {};
  for (const [i, r] of Object.entries(s.parameters)) {
    const o = r;
    n[i] = an(o, e);
  }
  return n;
}
function zE(s, e, n) {
  const i = document.createElement("canvas");
  i.width = e.width, i.height = e.height;
  const r = i.getContext("2d");
  r.drawImage(e, 0, 0);
  let o = {
    canvas: i,
    ctx: r
  };
  for (const a of s) {
    if (!a.enabled)
      continue;
    const l = Sy.get(a.effectKey);
    if (!l) {
      ol.warn(`No renderer registered for effect: ${a.effectKey}`);
      continue;
    }
    const c = OE(a, n);
    try {
      o = l(o, c);
    } catch (u) {
      ol.error(`Error applying effect ${a.name}:`, u);
    }
  }
  return o;
}
function Jo(s) {
  const e = document.createElement("canvas");
  e.width = s.width, e.height = s.height;
  const n = e.getContext("2d");
  return { canvas: e, ctx: n };
}
function NE(s) {
  return s.some((e) => e.enabled);
}
class Yi {
  constructor(e) {
    /** Unique layer identifier */
    fe(this, "id");
    /** Layer type */
    fe(this, "type");
    /** The Three.js group containing this layer's content */
    fe(this, "group");
    /** Keyframe evaluator for animated properties */
    fe(this, "evaluator");
    /** Layer visibility */
    fe(this, "visible");
    /** Layer locked state */
    fe(this, "locked");
    /** In point (start frame) */
    fe(this, "inPoint");
    /** Out point (end frame) */
    fe(this, "outPoint");
    /** Layer opacity (0-100) */
    fe(this, "opacity");
    /** Layer transform */
    fe(this, "transform");
    /** 3D layer flag */
    fe(this, "threeD");
    /** Blend mode */
    fe(this, "blendMode");
    /** Parent layer ID (for parenting hierarchy) */
    fe(this, "parentId");
    /** Reference to parent layer (set by LayerManager) */
    fe(this, "parentLayer", null);
    /** Driven values override (from property drivers/expressions) */
    fe(this, "drivenValues", /* @__PURE__ */ new Map());
    /** Audio reactive values (from audio analysis mapping) */
    fe(this, "audioReactiveValues", /* @__PURE__ */ new Map());
    /** Effects stack for this layer */
    fe(this, "effects", []);
    /** Source canvas for effect processing (lazy initialized) */
    fe(this, "effectSourceCanvas", null);
    /** Flag to track if effects need processing */
    fe(this, "effectsDirty", !1);
    this.id = e.id, this.type = e.type, this.group = new Ai(), this.group.name = `layer_${this.id}`, this.group.userData.layerId = this.id, this.group.userData.layerType = this.type, this.evaluator = new Ml(), this.visible = e.visible, this.locked = e.locked, this.inPoint = e.inPoint, this.outPoint = e.outPoint, this.opacity = e.opacity, this.transform = e.transform, this.threeD = e.threeD ?? !1, this.blendMode = e.blendMode ?? "normal", this.parentId = e.parentId ?? null, this.effects = e.effects ?? [];
  }
  /** Three.js object representing this layer (from LayerInstance) */
  get object() {
    return this.group;
  }
  /**
   * Initialize blend mode after subclass creates mesh
   * Subclasses should call this at the end of their constructor
   */
  initializeBlendMode() {
    this.blendMode !== "normal" && this.applyBlendMode(this.blendMode);
  }
  // ============================================================================
  // OBJECT ACCESS
  // ============================================================================
  /**
   * Get the Three.js object representing this layer
   */
  getObject() {
    return this.group;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all animated properties at the given frame
   */
  evaluateFrame(e) {
    const n = e >= this.inPoint && e <= this.outPoint;
    if (this.group.visible = this.visible && n, !this.group.visible)
      return;
    let i = this.evaluator.evaluate(this.opacity, e);
    i = this.getDrivenOrBase("opacity", i);
    const r = this.applyAudioModulation(i, "layer.opacity", "multiply", { min: 0, max: 100 });
    this.applyOpacity(r), this.evaluateTransform(e), this.onEvaluateFrame(e);
  }
  /**
   * Evaluate and apply transform at the given frame
   */
  evaluateTransform(e) {
    const n = this.evaluator.evaluate(this.transform.position, e);
    let i = this.getDrivenOrBase("transform.position.x", n.x), r = this.getDrivenOrBase("transform.position.y", n.y);
    const o = this.getDrivenOrBase("transform.position.z", n.z ?? 0);
    i = this.applyAudioModulation(i, "layer.x", "add"), r = this.applyAudioModulation(r, "layer.y", "add");
    const a = { x: i, y: r, z: o }, l = this.evaluator.evaluate(this.transform.scale, e);
    let c = this.getDrivenOrBase("transform.scale.x", l.x ?? 100), u = this.getDrivenOrBase("transform.scale.y", l.y ?? 100);
    const d = this.getDrivenOrBase("transform.scale.z", l.z ?? 100), h = this.getAudioReactiveValue("layer.scale");
    if (h !== 0) {
      const S = 0.5 + h;
      c *= S, u *= S;
    }
    const m = { x: c, y: u, z: d }, p = this.evaluator.evaluate(this.transform.anchorPoint, e), v = {
      x: this.getDrivenOrBase("transform.anchorPoint.x", p.x ?? 0),
      y: this.getDrivenOrBase("transform.anchorPoint.y", p.y ?? 0),
      z: this.getDrivenOrBase("transform.anchorPoint.z", p.z ?? 0)
    };
    let x = 0, g = 0, _ = 0;
    if (this.threeD) {
      const S = this.transform.rotationX ? this.evaluator.evaluate(this.transform.rotationX, e) : 0;
      g = this.getDrivenOrBase("transform.rotationX", S);
      const b = this.transform.rotationY ? this.evaluator.evaluate(this.transform.rotationY, e) : 0;
      _ = this.getDrivenOrBase("transform.rotationY", b);
      const C = this.transform.rotationZ ? this.evaluator.evaluate(this.transform.rotationZ, e) : 0;
      x = this.getDrivenOrBase("transform.rotationZ", C);
    } else {
      const S = this.evaluator.evaluate(this.transform.rotation, e);
      x = this.getDrivenOrBase("transform.rotation", S);
    }
    const M = this.getAudioReactiveValue("layer.rotation");
    M !== 0 && (x += M * 360), this.applyTransform({
      position: {
        x: a.x,
        y: a.y,
        z: a.z
      },
      rotation: {
        x: g,
        y: _,
        z: x
      },
      scale: {
        x: m.x / 100,
        y: m.y / 100,
        z: m.z / 100
      },
      anchorPoint: {
        x: v.x,
        y: v.y,
        z: v.z
      }
    });
  }
  /**
   * Apply transform to the group
   */
  applyTransform(e) {
    const { position: n, rotation: i, scale: r, anchorPoint: o } = e;
    this.group.position.set(
      n.x - o.x,
      -(n.y - o.y),
      // Negate for screen coords
      n.z - o.z
    ), this.group.rotation.set(
      mn.degToRad(i.x),
      mn.degToRad(i.y),
      mn.degToRad(-i.z)
    ), this.group.scale.set(r.x, r.y, r.z), this.group.updateMatrix();
  }
  /**
   * Apply opacity to layer materials
   */
  applyOpacity(e) {
    const n = Math.max(0, Math.min(100, e)) / 100;
    this.group.traverse((i) => {
      if (i instanceof Ze && i.material) {
        const r = i.material;
        "opacity" in r && (r.opacity = n, r.transparent = n < 1, r.needsUpdate = !0);
      }
    });
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Update layer properties
   */
  update(e) {
    e.visible !== void 0 && (this.visible = e.visible, this.group.visible = this.visible), e.locked !== void 0 && (this.locked = e.locked), e.inPoint !== void 0 && (this.inPoint = e.inPoint), e.outPoint !== void 0 && (this.outPoint = e.outPoint), e.opacity !== void 0 && (this.opacity = e.opacity), e.transform !== void 0 && (this.transform = e.transform), e.threeD !== void 0 && (this.threeD = e.threeD), e.blendMode !== void 0 && (this.blendMode = e.blendMode, this.applyBlendMode(this.blendMode)), e.effects !== void 0 && this.setEffects(e.effects), this.onUpdate(e);
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setVisible(e) {
    this.visible = e, this.group.visible = e;
  }
  /**
   * Get layer visibility
   */
  isVisible() {
    return this.visible;
  }
  // ============================================================================
  // DRIVEN VALUES (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values from property drivers
   * These override the base animated values during transform evaluation
   * @param values Map of property path to driven value
   */
  setDrivenValues(e) {
    this.drivenValues = e;
  }
  /**
   * Clear driven values
   */
  clearDrivenValues() {
    this.drivenValues.clear();
  }
  /**
   * Get a driven value if it exists, otherwise return the base value
   */
  getDrivenOrBase(e, n) {
    return this.drivenValues.get(e) ?? n;
  }
  // ============================================================================
  // AUDIO REACTIVE VALUES
  // ============================================================================
  /**
   * Set audio reactive values from audio analysis
   * These are applied additively/multiplicatively to animated properties
   * @param values Map of target parameter to audio-derived value (0-1 range typically)
   */
  setAudioReactiveValues(e) {
    this.audioReactiveValues = e;
  }
  /**
   * Clear audio reactive values
   */
  clearAudioReactiveValues() {
    this.audioReactiveValues.clear();
  }
  /**
   * Get audio reactive modulation for a property
   * Returns 0 if no mapping exists (additive identity)
   */
  getAudioReactiveValue(e) {
    return this.audioReactiveValues.get(e) ?? 0;
  }
  /**
   * Apply audio reactive modulation to a base value
   * Mode determines how the modulation is applied
   */
  applyAudioModulation(e, n, i = "add", r = {}) {
    const o = this.getAudioReactiveValue(n);
    if (o === 0) return e;
    let a;
    switch (i) {
      case "multiply":
        a = e * (0.5 + o);
        break;
      case "replace":
        a = o;
        break;
      case "add":
      default:
        a = e + o * 100;
        break;
    }
    return r.min !== void 0 && (a = Math.max(r.min, a)), r.max !== void 0 && (a = Math.min(r.max, a)), a;
  }
  // ============================================================================
  // EFFECTS
  // ============================================================================
  /**
   * Update the effects stack for this layer
   * @param effects - Array of effect instances
   */
  setEffects(e) {
    this.effects = e, this.effectsDirty = !0;
  }
  /**
   * Get the current effects stack
   */
  getEffects() {
    return this.effects;
  }
  /**
   * Check if this layer has any enabled effects
   */
  hasEnabledEffects() {
    return NE(this.effects);
  }
  /**
   * Process effects on a source canvas
   * Subclasses that support effects should override getSourceCanvas()
   * @param frame - Current frame for animated effect parameters
   * @returns Processed canvas or null if no effects to apply
   */
  processEffects(e) {
    if (!this.hasEnabledEffects())
      return null;
    const n = this.getSourceCanvas();
    if (!n)
      return null;
    try {
      return zE(this.effects, n, e).canvas;
    } catch (i) {
      return Ti.error(`Error processing effects for layer ${this.id}:`, i), null;
    }
  }
  /**
   * Get the source canvas for effect processing
   * Override in subclasses that support effects (ImageLayer, VideoLayer, TextLayer)
   * @returns Canvas with the layer's visual content, or null if not supported
   */
  getSourceCanvas() {
    return null;
  }
  /**
   * Apply processed effects back to the layer
   * Override in subclasses to update their texture from the processed canvas
   * @param processedCanvas - Canvas with effects applied
   */
  applyProcessedEffects(e) {
  }
  /**
   * Called after frame evaluation to apply effects
   * This should be called by subclasses after their content is rendered
   */
  evaluateEffects(e) {
    if (!this.hasEnabledEffects())
      return;
    const n = this.processEffects(e);
    n && this.applyProcessedEffects(n);
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Set parent layer reference
   */
  setParent(e) {
    this.parentLayer && this.parentLayer.getObject().remove(this.group), this.parentLayer = e, e && e.getObject().add(this.group);
  }
  /**
   * Get parent layer reference
   */
  getParent() {
    return this.parentLayer;
  }
  /**
   * Get parent layer ID
   */
  getParentId() {
    return this.parentId;
  }
  /**
   * Check if this layer has a parent
   */
  hasParent() {
    return this.parentId !== null;
  }
  // ============================================================================
  // BLEND MODES
  // ============================================================================
  /**
   * Apply blend mode to layer materials
   * Supports: normal, add, multiply, screen, overlay, soft-light, hard-light,
   * color-dodge, color-burn, difference, exclusion, darken, lighten
   */
  applyBlendMode(e) {
    this.group.traverse((n) => {
      if (n instanceof Ze && n.material) {
        const i = n.material;
        this.setMaterialBlendMode(i, e), i.needsUpdate = !0;
      }
    });
  }
  /**
   * Configure a material's blend mode
   */
  setMaterialBlendMode(e, n) {
    switch (e.blending = Gi, e.blendEquation = Bi, e.blendSrc = Jc, e.blendDst = ll, e.blendEquationAlpha = Bi, e.blendSrcAlpha = bs, e.blendDstAlpha = ll, n) {
      case "normal":
        e.blending = Gi;
        break;
      case "add":
        e.blending = al;
        break;
      case "multiply":
        e.blending = Io;
        break;
      case "screen":
        e.blending = Rr, e.blendEquation = Bi, e.blendSrc = bs, e.blendDst = ch;
        break;
      case "overlay":
        e.blending = Io;
        break;
      case "soft-light":
        e.blending = Gi;
        break;
      case "hard-light":
        e.blending = Io;
        break;
      case "color-dodge":
        e.blending = al;
        break;
      case "color-burn":
        e.blending = lh;
        break;
      case "difference":
        e.blending = Rr, e.blendEquation = D0, e.blendSrc = bs, e.blendDst = bs;
        break;
      case "exclusion":
        e.blending = Rr, e.blendEquation = Bi, e.blendSrc = L0, e.blendDst = ch;
        break;
      case "darken":
        e.blending = Rr, e.blendEquation = k0, e.blendSrc = bs, e.blendDst = bs;
        break;
      case "lighten":
        e.blending = Rr, e.blendEquation = I0, e.blendSrc = bs, e.blendDst = bs;
        break;
      default:
        e.blending = Gi;
        break;
    }
  }
  // ============================================================================
  // BOUNDS
  // ============================================================================
  /**
   * Get the bounding box of this layer
   */
  getBoundingBox() {
    const e = new dr();
    return e.setFromObject(this.group), e;
  }
  /**
   * Get the center point of this layer
   */
  getCenter() {
    const e = this.getBoundingBox(), n = new de();
    return e.getCenter(n), n;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose layer resources
   */
  dispose() {
    this.group.traverse((e) => {
      var n;
      e instanceof Ze && ((n = e.geometry) == null || n.dispose(), Array.isArray(e.material) ? e.material.forEach((i) => i.dispose()) : e.material && e.material.dispose());
    }), this.group.clear(), this.onDispose();
  }
  /**
   * Override in subclasses for type-specific cleanup
   */
  onDispose() {
  }
}
class BE extends Yi {
  constructor(n, i) {
    super(n);
    fe(this, "resources");
    // Video elements
    fe(this, "videoElement", null);
    fe(this, "videoTexture", null);
    fe(this, "mesh", null);
    fe(this, "material", null);
    // Video data
    fe(this, "videoData");
    fe(this, "assetRef", null);
    // Metadata (populated after video loads)
    fe(this, "metadata", null);
    // Animation evaluator
    fe(this, "videoEvaluator");
    // Playback state
    fe(this, "lastEvaluatedFrame", -1);
    fe(this, "isPlaying", !1);
    // Callbacks for composition auto-resize
    fe(this, "onMetadataLoaded");
    // Composition FPS for time calculation
    fe(this, "compositionFPS", 30);
    // Canvas for effect processing
    fe(this, "effectCanvas", null);
    fe(this, "effectCanvasCtx", null);
    this.resources = i, this.videoEvaluator = new Ml(), this.videoData = this.extractVideoData(n), this.createPlaceholderMesh(), this.videoData.assetId && this.loadVideo(this.videoData.assetId), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract video data with defaults
   */
  extractVideoData(n) {
    const i = n.data;
    return {
      assetId: (i == null ? void 0 : i.assetId) ?? null,
      loop: (i == null ? void 0 : i.loop) ?? !1,
      pingPong: (i == null ? void 0 : i.pingPong) ?? !1,
      startTime: (i == null ? void 0 : i.startTime) ?? 0,
      endTime: i == null ? void 0 : i.endTime,
      speed: (i == null ? void 0 : i.speed) ?? 1,
      timeRemapEnabled: (i == null ? void 0 : i.timeRemapEnabled) ?? !1,
      timeRemap: i == null ? void 0 : i.timeRemap,
      frameBlending: (i == null ? void 0 : i.frameBlending) ?? "none",
      audioEnabled: (i == null ? void 0 : i.audioEnabled) ?? !0,
      audioLevel: (i == null ? void 0 : i.audioLevel) ?? 100,
      posterFrame: (i == null ? void 0 : i.posterFrame) ?? 0
    };
  }
  /**
   * Create placeholder mesh before video loads
   */
  createPlaceholderMesh() {
    const n = new un(1, 1);
    this.material = new En({
      color: 3355443,
      transparent: !0,
      side: vn
    }), this.mesh = new Ze(n, this.material), this.mesh.name = `video_${this.id}`, this.group.add(this.mesh);
  }
  // ============================================================================
  // VIDEO LOADING
  // ============================================================================
  /**
   * Load video from asset
   */
  async loadVideo(n) {
    const i = this.resources.getAsset(n);
    if (!i || i.type !== "video") {
      Ti.warn(`VideoLayer: Asset ${n} not found or not a video`);
      return;
    }
    this.assetRef = i, this.videoData.assetId = n, this.videoElement = document.createElement("video"), this.videoElement.crossOrigin = "anonymous", this.videoElement.playsInline = !0, this.videoElement.muted = !this.videoData.audioEnabled, this.videoElement.loop = !1, this.videoElement.preload = "auto", i.data && (this.videoElement.src = i.data), await this.waitForMetadata(), this.createVideoTexture(), this.seekToFrame(this.videoData.posterFrame);
  }
  /**
   * Wait for video metadata to load
   */
  waitForMetadata() {
    return new Promise((n, i) => {
      if (!this.videoElement) {
        i(new Error("No video element"));
        return;
      }
      const r = () => {
        this.extractMetadata(), a(), n();
      }, o = (l) => {
        a(), i(new Error(`Video load error: ${l}`));
      }, a = () => {
        var l, c;
        (l = this.videoElement) == null || l.removeEventListener("loadedmetadata", r), (c = this.videoElement) == null || c.removeEventListener("error", o);
      };
      this.videoElement.addEventListener("loadedmetadata", r), this.videoElement.addEventListener("error", o), this.videoElement.load();
    });
  }
  /**
   * Extract metadata from loaded video
   */
  extractMetadata() {
    var l, c;
    if (!this.videoElement) return;
    const n = this.videoElement.duration, i = this.videoElement.videoWidth, r = this.videoElement.videoHeight, o = ((l = this.assetRef) == null ? void 0 : l.fps) ?? 30, a = Math.ceil(n * o);
    this.metadata = {
      duration: n,
      frameCount: a,
      fps: o,
      width: i,
      height: r,
      hasAudio: this.hasAudioTrack()
    }, this.assetRef && (this.assetRef.duration = n, this.assetRef.frameCount = a, this.assetRef.fps = o, this.assetRef.hasAudio = this.metadata.hasAudio), (c = this.onMetadataLoaded) == null || c.call(this, this.metadata), Ti.debug(`VideoLayer: Loaded: ${i}x${r}, ${a} frames @ ${o}fps, ${n.toFixed(2)}s`);
  }
  /**
   * Check if video has audio track
   */
  hasAudioTrack() {
    if (!this.videoElement) return !1;
    const n = this.videoElement.audioTracks;
    return n ? n.length > 0 : !0;
  }
  /**
   * Create Three.js texture from video element
   */
  createVideoTexture() {
    !this.videoElement || !this.metadata || (this.videoTexture = new O2(this.videoElement), this.videoTexture.minFilter = Bt, this.videoTexture.magFilter = Bt, this.videoTexture.format = Un, this.videoTexture.colorSpace = dn, this.material && (this.material.map = this.videoTexture, this.material.color.setHex(16777215), this.material.needsUpdate = !0), this.resizeMesh(this.metadata.width, this.metadata.height));
  }
  /**
   * Resize mesh to match video dimensions
   */
  resizeMesh(n, i) {
    this.mesh && (this.mesh.geometry.dispose(), this.mesh.geometry = new un(n, i));
  }
  // ============================================================================
  // PLAYBACK CONTROL
  // ============================================================================
  /**
   * Seek to a specific composition frame
   */
  seekToFrame(n) {
    if (!this.videoElement || !this.metadata) return;
    const i = this.calculateVideoTime(n), r = Math.max(0, Math.min(i, this.videoElement.duration));
    this.videoElement.currentTime = r;
  }
  /**
   * Calculate video time from composition frame
   * Handles speed, time remapping, loop, and ping-pong
   */
  calculateVideoTime(n) {
    var l;
    if (!this.metadata) return 0;
    if (this.videoData.timeRemapEnabled && ((l = this.videoData.timeRemap) != null && l.animated))
      return this.videoEvaluator.evaluate(this.videoData.timeRemap, n);
    const i = this.compositionFPS;
    let o = n / i * this.videoData.speed;
    o += this.videoData.startTime;
    const a = this.videoData.endTime ? this.videoData.endTime - this.videoData.startTime : this.metadata.duration - this.videoData.startTime;
    if (this.videoData.loop && a > 0) {
      if (this.videoData.pingPong) {
        const c = Math.floor(o / a), u = o % a;
        o = c % 2 === 0 ? u : a - u;
      } else
        o = o % a;
      o += this.videoData.startTime;
    }
    return o;
  }
  /**
   * Set audio volume
   */
  setAudioLevel(n) {
    this.videoData.audioLevel = n, this.videoElement && (this.videoElement.volume = Math.max(0, Math.min(1, n / 100)));
  }
  /**
   * Enable/disable audio
   */
  setAudioEnabled(n) {
    this.videoData.audioEnabled = n, this.videoElement && (this.videoElement.muted = !n);
  }
  // ============================================================================
  // METADATA CALLBACK
  // ============================================================================
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(n) {
    this.compositionFPS = n;
  }
  /**
   * Register callback for when video metadata is loaded
   * Used by LayerManager to auto-resize composition
   */
  setMetadataCallback(n) {
    this.onMetadataLoaded = n, this.metadata && n(this.metadata);
  }
  /**
   * Get video metadata
   */
  getMetadata() {
    return this.metadata;
  }
  /**
   * Get video data
   */
  getVideoData() {
    return { ...this.videoData };
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setLoop(n) {
    this.videoData.loop = n;
  }
  setPingPong(n) {
    this.videoData.pingPong = n;
  }
  setSpeed(n) {
    this.videoData.speed = n, this.videoElement && (this.videoElement.playbackRate = n);
  }
  setStartTime(n) {
    this.videoData.startTime = n;
  }
  setEndTime(n) {
    this.videoData.endTime = n;
  }
  setFrameBlending(n) {
    this.videoData.frameBlending = n;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the current video frame to a 2D canvas
   */
  getSourceCanvas() {
    if (!this.videoElement || !this.metadata)
      return null;
    const n = this.metadata.width, i = this.metadata.height;
    return (!this.effectCanvas || this.effectCanvas.width !== n || this.effectCanvas.height !== i) && (this.effectCanvas = document.createElement("canvas"), this.effectCanvas.width = n, this.effectCanvas.height = i, this.effectCanvasCtx = this.effectCanvas.getContext("2d")), this.effectCanvasCtx ? (this.effectCanvasCtx.clearRect(0, 0, n, i), this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, n, i), this.effectCanvas) : null;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(n) {
    if (!this.material || !this.metadata) return;
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_effects`,
      {
        minFilter: Bt,
        magFilter: Bt,
        generateMipmaps: !1,
        colorSpace: dn
      }
    );
    this.material.map = i, this.material.needsUpdate = !0;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    n !== this.lastEvaluatedFrame && (this.lastEvaluatedFrame = n, this.seekToFrame(n), this.videoTexture && (this.videoTexture.needsUpdate = !0), this.hasEnabledEffects() ? this.evaluateEffects(n) : this.material && this.videoTexture && (this.material.map = this.videoTexture, this.material.needsUpdate = !0));
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.assetId !== void 0 && i.assetId !== this.videoData.assetId && (i.assetId ? this.loadVideo(i.assetId) : this.clearVideo()), i.loop !== void 0 && this.setLoop(i.loop), i.pingPong !== void 0 && this.setPingPong(i.pingPong), i.speed !== void 0 && this.setSpeed(i.speed), i.startTime !== void 0 && this.setStartTime(i.startTime), i.endTime !== void 0 && this.setEndTime(i.endTime), i.frameBlending !== void 0 && this.setFrameBlending(i.frameBlending), i.audioEnabled !== void 0 && this.setAudioEnabled(i.audioEnabled), i.audioLevel !== void 0 && this.setAudioLevel(i.audioLevel));
  }
  /**
   * Clear current video
   */
  clearVideo() {
    this.videoElement && (this.videoElement.pause(), this.videoElement.src = "", this.videoElement = null), this.videoTexture && (this.videoTexture.dispose(), this.videoTexture = null), this.material && (this.material.map = null, this.material.color.setHex(3355443)), this.metadata = null, this.videoData.assetId = null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.clearVideo(), this.material && this.material.dispose(), this.mesh && (this.mesh.geometry.dispose(), this.group.remove(this.mesh));
  }
}
async function VE(s) {
  return new Promise((e, n) => {
    const i = document.createElement("video");
    i.crossOrigin = "anonymous", i.preload = "metadata";
    const r = () => {
      i.removeEventListener("loadedmetadata", o), i.removeEventListener("error", a), URL.revokeObjectURL(i.src);
    }, o = () => {
      const l = {
        duration: i.duration,
        frameCount: Math.ceil(i.duration * 30),
        // Estimate at 30fps
        fps: 30,
        // Browser doesn't expose this
        width: i.videoWidth,
        height: i.videoHeight,
        hasAudio: !0
        // Assume true
      };
      r(), e(l);
    }, a = () => {
      r(), n(new Error("Failed to load video metadata"));
    };
    i.addEventListener("loadedmetadata", o), i.addEventListener("error", a), typeof s == "string" ? i.src = s : i.src = URL.createObjectURL(s);
  });
}
function GE(s, e = 16) {
  const n = Math.round(s.width / 8) * 8, i = Math.round(s.height / 8) * 8, r = Math.ceil(s.duration * e);
  return { width: n, height: i, frameCount: r };
}
const HE = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function My(s, e, n) {
  const i = e / 2, r = n / 2;
  return {
    id: s,
    name: "Camera 1",
    type: "two-node",
    position: { x: i, y: r, z: -1500 },
    pointOfInterest: { x: i, y: r, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: !1,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: !1
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function Cy() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
function $E() {
  return {
    cameraWireframes: "selected",
    lightWireframes: "selected",
    showMotionPaths: !0,
    showLayerHandles: !0,
    showSafeZones: !1,
    showGrid: !1,
    showRulers: !0,
    show3DReferenceAxes: !0,
    showCompositionBounds: !0,
    showFocalPlane: !1
  };
}
function wt(s, e, n) {
  return { x: s, y: e, z: n };
}
function At(s, e) {
  return { x: s.x + e.x, y: s.y + e.y, z: s.z + e.z };
}
function Yf(s, e) {
  return { x: s.x - e.x, y: s.y - e.y, z: s.z - e.z };
}
function Dt(s, e) {
  return { x: s.x * e, y: s.y * e, z: s.z * e };
}
function WE(s) {
  return Math.sqrt(s.x * s.x + s.y * s.y + s.z * s.z);
}
function Rs(s) {
  const e = WE(s);
  return e === 0 ? { x: 0, y: 0, z: 0 } : { x: s.x / e, y: s.y / e, z: s.z / e };
}
function Xo(s, e) {
  return {
    x: s.y * e.z - s.z * e.y,
    y: s.z * e.x - s.x * e.z,
    z: s.x * e.y - s.y * e.x
  };
}
function Fd(s, e) {
  return s.x * e.x + s.y * e.y + s.z * e.z;
}
function XE(s, e, n, i) {
  const r = new Float32Array(16), o = 1 / Math.tan(s / 2), a = 1 / (n - i);
  return r[0] = o / e, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = (i + n) * a, r[11] = -1, r[12] = 0, r[13] = 0, r[14] = 2 * i * n * a, r[15] = 0, { elements: r };
}
function jE(s, e, n, i, r, o) {
  const a = new Float32Array(16), l = 1 / (e - s), c = 1 / (i - n), u = 1 / (o - r);
  return a[0] = 2 * l, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * c, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = -2 * u, a[11] = 0, a[12] = -(e + s) * l, a[13] = -(i + n) * c, a[14] = -10001 * u, a[15] = 1, { elements: a };
}
function Qi(s, e, n) {
  const i = new Float32Array(16);
  let r = s.x - e.x, o = s.y - e.y, a = s.z - e.z, l = Math.sqrt(r * r + o * o + a * a);
  l === 0 ? a = 1 : (l = 1 / l, r *= l, o *= l, a *= l);
  let c = n.y * a - n.z * o, u = n.z * r - n.x * a, d = n.x * o - n.y * r;
  l = Math.sqrt(c * c + u * u + d * d), l === 0 ? (c = 0, u = 0, d = 0) : (l = 1 / l, c *= l, u *= l, d *= l);
  let h = o * d - a * u, m = a * c - r * d, p = r * u - o * c;
  return l = Math.sqrt(h * h + m * m + p * p), l === 0 ? (h = 0, m = 0, p = 0) : (l = 1 / l, h *= l, m *= l, p *= l), i[0] = c, i[4] = u, i[8] = d, i[12] = -Fd({ x: c, y: u, z: d }, s), i[1] = h, i[5] = m, i[9] = p, i[13] = -Fd({ x: h, y: m, z: p }, s), i[2] = r, i[6] = o, i[10] = a, i[14] = -Fd({ x: r, y: o, z: a }, s), i[3] = 0, i[7] = 0, i[11] = 0, i[15] = 1, { elements: i };
}
function YE(s, e) {
  const n = s.elements, i = n[3] * e.x + n[7] * e.y + n[11] * e.z + n[15];
  return {
    x: (n[0] * e.x + n[4] * e.y + n[8] * e.z + n[12]) / i,
    y: (n[1] * e.x + n[5] * e.y + n[9] * e.z + n[13]) / i,
    z: (n[2] * e.x + n[6] * e.y + n[10] * e.z + n[14]) / i
  };
}
function Cl(s, e) {
  return 2 * Math.atan(e / (2 * s));
}
function qE(s, e) {
  return e / (2 * Math.tan(s / 2));
}
function ml(s, e, n) {
  if (!e || e.length === 0)
    return {
      position: s.position,
      rotation: s.orientation,
      focalLength: s.focalLength,
      zoom: s.zoom,
      focusDistance: s.depthOfField.focusDistance
    };
  let i = null, r = null;
  for (const x of e)
    x.frame <= n && (i = x), x.frame >= n && !r && (r = x);
  if (!i && !r)
    return {
      position: s.position,
      rotation: s.orientation,
      focalLength: s.focalLength,
      zoom: s.zoom,
      focusDistance: s.depthOfField.focusDistance
    };
  i || (i = r), r || (r = i);
  const o = (x) => (x == null ? void 0 : x.position) ?? s.position, a = (x) => (x == null ? void 0 : x.orientation) ?? s.orientation, l = (x) => (x == null ? void 0 : x.focalLength) ?? s.focalLength, c = (x) => (x == null ? void 0 : x.zoom) ?? s.zoom, u = (x) => (x == null ? void 0 : x.focusDistance) ?? s.depthOfField.focusDistance;
  if (i.frame === r.frame)
    return {
      position: o(i),
      rotation: a(i),
      focalLength: l(i),
      zoom: c(i),
      focusDistance: u(i)
    };
  const d = (n - i.frame) / (r.frame - i.frame), h = o(i), m = o(r), p = a(i), v = a(r);
  return {
    position: {
      x: mo(h.x, m.x, d),
      y: mo(h.y, m.y, d),
      z: mo(h.z, m.z, d)
    },
    rotation: {
      x: Ud(p.x, v.x, d),
      y: Ud(p.y, v.y, d),
      z: Ud(p.z, v.z, d)
    },
    focalLength: mo(l(i), l(r), d),
    zoom: mo(c(i), c(r), d),
    focusDistance: mo(u(i), u(r), d)
  };
}
function mo(s, e, n) {
  return s + (e - s) * n;
}
function Ud(s, e, n) {
  let i = e - s;
  return i > 180 && (i -= 360), i < -180 && (i += 360), s + i * n;
}
function Ey(s) {
  const { position: e, rotation: n } = s, i = n.x * Math.PI / 180, r = n.y * Math.PI / 180, o = n.z * Math.PI / 180, a = Math.cos(i), l = Math.sin(i), c = Math.cos(r), u = Math.sin(r), d = Math.cos(o), h = Math.sin(o), m = c * d + u * l * h, p = -c * h + u * l * d, v = u * a, x = a * h, g = a * d, _ = -l, M = -u * d + c * l * h, S = u * h + c * l * d, b = c * a, C = -(m * e.x + x * e.y + M * e.z), E = -(p * e.x + g * e.y + S * e.z), P = -(v * e.x + _ * e.y + b * e.z);
  return [
    [m, p, v, C],
    [x, g, _, E],
    [M, S, b, P],
    [0, 0, 0, 1]
  ];
}
function ZE(s, e, n = 0.1, i = 1e3) {
  const o = Cl(s.focalLength, 36) * Math.PI / 180, l = 1 / Math.tan(o / 2), c = 1 / (n - i);
  return [
    [l / e, 0, 0, 0],
    [0, l, 0, 0],
    [0, 0, (i + n) * c, 2 * i * n * c],
    [0, 0, -1, 0]
  ];
}
function Ty(s, e, n) {
  const i = [];
  for (let r = 0; r < n; r++) {
    const o = ml(s, e, r), a = Ey(o);
    i.push({
      RT: a
    });
  }
  return { camera_poses: i };
}
function KE(s) {
  if (!s || s.length < 2) return "static";
  const e = s[0], n = s[s.length - 1], i = e.position ?? { x: 0, y: 0, z: 0 }, r = n.position ?? { x: 0, y: 0, z: 0 }, o = e.orientation ?? { y: 0 }, a = n.orientation ?? { y: 0 }, l = r.x - i.x, c = r.y - i.y, u = r.z - i.z, d = a.y - o.y, h = 50;
  return Math.abs(u) > h ? u < 0 ? "zoom_in" : "zoom_out" : Math.abs(d) > 15 ? d > 0 ? "rotate_cw" : "rotate_ccw" : Math.abs(l) > h ? l > 0 ? "pan_right" : "pan_left" : Math.abs(c) > h ? c > 0 ? "pan_down" : "pan_up" : "static";
}
function JE(s, e, n) {
  const i = KE(e);
  if (i !== "static" && e.length <= 2)
    return { motion_camera: i };
  const r = Ty(s, e, n);
  return {
    motion_camera: i,
    camera_poses: JSON.stringify(r.camera_poses)
  };
}
function ku(s) {
  if (!s || s.length < 2)
    return {
      hasPan: !1,
      panMagnitude: 0,
      hasZoom: !1,
      zoomMagnitude: 0,
      hasOrbit: !1,
      orbitMagnitude: 0,
      hasRotation: !1,
      rotationMagnitude: 0
    };
  const e = s[0], n = s[s.length - 1], i = e.position ?? { x: 0, y: 0, z: 0 }, r = n.position ?? { x: 0, y: 0, z: 0 }, o = e.orientation ?? { y: 0 }, a = n.orientation ?? { y: 0 }, l = r.x - i.x, c = r.y - i.y, u = r.z - i.z, d = a.y - o.y, h = 30, m = 50, p = 20;
  let v;
  const x = Math.abs(l), g = Math.abs(c);
  (x > h || g > h) && (x > g ? v = l > 0 ? "right" : "left" : v = c > 0 ? "down" : "up");
  let _;
  Math.abs(u) > m && (_ = u < 0 ? "in" : "out");
  let M;
  return Math.abs(d) > p && Math.abs(l) > h && (M = d > 0 ? "right" : "left"), {
    hasPan: !!v,
    panDirection: v,
    panMagnitude: Math.max(x, g),
    hasZoom: !!_,
    zoomDirection: _,
    zoomMagnitude: Math.abs(u),
    hasOrbit: !!M,
    orbitDirection: M,
    orbitMagnitude: Math.abs(d),
    hasRotation: Math.abs(d) > 5,
    rotationMagnitude: Math.abs(d)
  };
}
function QE(s) {
  const e = ku(s);
  let n = "Static";
  if (e.hasOrbit)
    n = e.orbitDirection === "left" ? "Orbital Left" : "Orbital Right";
  else if (e.hasZoom && e.hasPan) {
    const i = bv(e.panDirection || "up"), r = e.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
    n = `Pan ${i} + ${r}`;
  } else e.hasZoom ? n = e.zoomDirection === "in" ? "Zoom In" : "Zoom Out" : e.hasPan && (n = `Pan ${bv(e.panDirection || "up")}`);
  return { camera_motion: n };
}
function bv(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function eT(s) {
  const e = ku(s);
  return e.hasOrbit && e.orbitMagnitude > 45 ? "orbit" : e.hasPan && e.hasZoom ? "custom" : !e.hasPan && !e.hasZoom && !e.hasOrbit ? "free1" : "custom";
}
function tT(s, e, n, i, r) {
  const o = eT(e);
  if (o !== "custom")
    return { traj_type: o };
  const a = [], l = ml(s, e, 0);
  for (let c = 0; c < n; c++) {
    const u = ml(s, e, c);
    a.push({
      zoom: u.zoom / l.zoom,
      x_offset: (u.position.x - l.position.x) / i,
      y_offset: (u.position.y - l.position.y) / r,
      z_offset: (u.position.z - l.position.z) / 1e3,
      pitch: u.rotation.x,
      yaw: u.rotation.y,
      roll: u.rotation.z
    });
  }
  return {
    traj_type: "custom",
    custom_trajectory: a
  };
}
function nT(s) {
  const e = ku(s);
  if (!e.hasPan && !e.hasZoom && !e.hasRotation)
    return "Static";
  if (e.hasZoom)
    return e.zoomDirection === "in" ? "Move Forward" : "Move Backward";
  if (e.hasPan)
    switch (e.panDirection) {
      case "left":
        return "Move Left";
      case "right":
        return "Move Right";
      case "up":
        return "Move Up";
      case "down":
        return "Move Down";
    }
  if (e.hasRotation) {
    const n = s[0], i = s[s.length - 1], r = n.orientation ?? { x: 0, y: 0, z: 0 }, o = i.orientation ?? { x: 0, y: 0, z: 0 }, a = o.x - r.x, l = o.y - r.y, c = o.z - r.z;
    return Math.abs(l) > Math.abs(a) && Math.abs(l) > Math.abs(c) ? l > 0 ? "Rotate Right" : "Rotate Left" : Math.abs(a) > Math.abs(c) ? a > 0 ? "Rotate Down" : "Rotate Up" : c > 0 ? "Roll Right" : "Roll Left";
  }
  return "Static";
}
function iT(s, e) {
  const n = nT(s), i = ku(s);
  let r = 0;
  return i.hasZoom ? r = Math.min(100, i.zoomMagnitude / 5) : i.hasPan ? r = Math.min(100, i.panMagnitude / 3) : i.hasRotation && (r = Math.min(100, i.rotationMagnitude * 2)), {
    motion_type: n,
    speed: Math.round(r),
    frame_length: e
  };
}
function sT(s, e, n) {
  const i = [], r = n.width / n.height;
  for (let o = 0; o < n.frameCount; o++) {
    const a = ml(s, e, o), l = Ey(a), c = ZE(a, r);
    i.push({
      frame: o,
      timestamp: o / n.fps,
      view_matrix: l,
      projection_matrix: c,
      position: [a.position.x, a.position.y, a.position.z],
      rotation: [a.rotation.x, a.rotation.y, a.rotation.z],
      fov: Cl(a.focalLength, s.filmSize),
      focal_length: a.focalLength,
      focus_distance: a.focusDistance
    });
  }
  return {
    frames: i,
    metadata: {
      width: n.width,
      height: n.height,
      fps: n.fps,
      total_frames: n.frameCount,
      camera_type: s.type,
      film_size: s.filmSize
    }
  };
}
function rT(s, e, n, i, r = 1920, o = 1080, a = 24) {
  switch (s) {
    case "motionctrl":
      return Ty(e, n, i);
    case "motionctrl-svd":
      return JE(e, n, i);
    case "wan22-fun-camera":
      return QE(n);
    case "uni3c-camera":
    case "uni3c-motion":
      return tT(e, n, i, r, o);
    case "animatediff-cameractrl":
      return iT(n, i);
    default:
      return sT(e, n, {
        frameCount: i,
        width: r,
        height: o,
        fps: a
      });
  }
}
function vl(s, e, n) {
  var r, o, a, l, c, u, d, h, m, p, v, x, g, _, M, S, b, C, E, P, T, y, w, D, U, R, O, A, G;
  const i = Math.max(0, Math.min(n, s.frameCount - 1));
  switch (e) {
    case "amplitude":
      return s.amplitudeEnvelope[i] ?? 0;
    case "rms":
      return s.rmsEnergy[i] ?? 0;
    case "spectralCentroid":
      return s.spectralCentroid[i] ?? 0;
    case "sub":
      return s.frequencyBands.sub[i] ?? 0;
    case "bass":
      return s.frequencyBands.bass[i] ?? 0;
    case "lowMid":
      return s.frequencyBands.lowMid[i] ?? 0;
    case "mid":
      return s.frequencyBands.mid[i] ?? 0;
    case "highMid":
      return s.frequencyBands.highMid[i] ?? 0;
    case "high":
      return s.frequencyBands.high[i] ?? 0;
    case "onsets":
      return s.onsets.includes(i) ? 1 : 0;
    case "spectralFlux":
      return ((r = s.spectralFlux) == null ? void 0 : r[i]) ?? 0;
    case "zeroCrossingRate":
    case "zcr":
      return ((o = s.zeroCrossingRate) == null ? void 0 : o[i]) ?? 0;
    case "spectralRolloff":
    case "rolloff":
      return ((a = s.spectralRolloff) == null ? void 0 : a[i]) ?? 0;
    case "spectralFlatness":
    case "flatness":
      return ((l = s.spectralFlatness) == null ? void 0 : l[i]) ?? 0;
    case "chromaEnergy":
      return ((c = s.chromaFeatures) == null ? void 0 : c.chromaEnergy[i]) ?? 0;
    case "chromaC":
      return ((d = (u = s.chromaFeatures) == null ? void 0 : u.chroma[i]) == null ? void 0 : d[0]) ?? 0;
    case "chromaCs":
    case "chromaDb":
      return ((m = (h = s.chromaFeatures) == null ? void 0 : h.chroma[i]) == null ? void 0 : m[1]) ?? 0;
    case "chromaD":
      return ((v = (p = s.chromaFeatures) == null ? void 0 : p.chroma[i]) == null ? void 0 : v[2]) ?? 0;
    case "chromaDs":
    case "chromaEb":
      return ((g = (x = s.chromaFeatures) == null ? void 0 : x.chroma[i]) == null ? void 0 : g[3]) ?? 0;
    case "chromaE":
      return ((M = (_ = s.chromaFeatures) == null ? void 0 : _.chroma[i]) == null ? void 0 : M[4]) ?? 0;
    case "chromaF":
      return ((b = (S = s.chromaFeatures) == null ? void 0 : S.chroma[i]) == null ? void 0 : b[5]) ?? 0;
    case "chromaFs":
    case "chromaGb":
      return ((E = (C = s.chromaFeatures) == null ? void 0 : C.chroma[i]) == null ? void 0 : E[6]) ?? 0;
    case "chromaG":
      return ((T = (P = s.chromaFeatures) == null ? void 0 : P.chroma[i]) == null ? void 0 : T[7]) ?? 0;
    case "chromaGs":
    case "chromaAb":
      return ((w = (y = s.chromaFeatures) == null ? void 0 : y.chroma[i]) == null ? void 0 : w[8]) ?? 0;
    case "chromaA":
      return ((U = (D = s.chromaFeatures) == null ? void 0 : D.chroma[i]) == null ? void 0 : U[9]) ?? 0;
    case "chromaAs":
    case "chromaBb":
      return ((O = (R = s.chromaFeatures) == null ? void 0 : R.chroma[i]) == null ? void 0 : O[10]) ?? 0;
    case "chromaB":
      return ((G = (A = s.chromaFeatures) == null ? void 0 : A.chroma[i]) == null ? void 0 : G[11]) ?? 0;
    default:
      return 0;
  }
}
function Ay(s, e) {
  const { threshold: n, minPeaksDistance: i, multiply: r } = e, o = s.map((d) => Math.min(1, d * r)), a = [];
  for (let d = 1; d < o.length - 1; d++) {
    const h = o[d - 1], m = o[d], p = o[d + 1];
    m > h && m > p && m >= n && a.push({ index: d, value: m });
  }
  const l = [];
  for (const d of a) {
    const h = l.findIndex(
      (m) => Math.abs(m.index - d.index) < i
    );
    h === -1 ? l.push(d) : d.value > l[h].value && (l[h] = d);
  }
  l.sort((d, h) => d.index - h.index);
  const c = new Array(s.length).fill(0);
  let u = 0;
  for (let d = 0; d < s.length; d++)
    l.some((m) => m.index === d) && (u = 1 - u), c[d] = u;
  return {
    indices: l.map((d) => d.index),
    values: l.map((d) => d.value),
    count: l.length,
    alternating: c
  };
}
function wv(s, e) {
  return s.onsets.includes(e);
}
function oT(s, e) {
  return s.indices.includes(e);
}
let Ir = null, gl = null, Ao = null, ou = null;
function aT() {
  return Ir || (Ir = new Worker(
    new URL(
      /* @vite-ignore */
      "/assets/audioWorker-DAB3gMSK.js",
      import.meta.url
    ),
    { type: "module" }
  ), Ir.onmessage = (s) => {
    const e = s.data;
    switch (e.type) {
      case "progress":
        ou && ou({
          phase: e.payload.phase,
          progress: e.payload.progress,
          message: e.payload.message
        });
        break;
      case "complete":
        gl && (gl(e.payload), Od());
        break;
      case "error":
        Ao && (Ao(new Error(e.payload.message)), Od());
        break;
    }
  }, Ir.onerror = (s) => {
    console.error("[AudioWorker] Worker error:", s), Ao && (Ao(new Error(`Worker error: ${s.message}`)), Od());
  }), Ir;
}
function Od() {
  gl = null, Ao = null, ou = null;
}
function lT() {
  Ir && Ir.postMessage({ type: "cancel" });
}
async function cT(s, e, n = {}) {
  const i = aT();
  if (gl)
    throw new Error("Analysis already in progress. Cancel it first.");
  const r = s.getChannelData(0), o = new Float32Array(r);
  return new Promise((a, l) => {
    gl = a, Ao = l, ou = n.onProgress || null, i.postMessage(
      {
        type: "analyze",
        payload: {
          channelData: o,
          sampleRate: s.sampleRate,
          fps: e
        }
      },
      [o.buffer]
      // Transfer the buffer for performance
    );
  });
}
async function uT(s, e, n = {}) {
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 0,
    message: "Decoding audio file..."
  });
  const i = await s.arrayBuffer(), r = new AudioContext();
  let o;
  try {
    o = await r.decodeAudioData(i);
  } finally {
    await r.close();
  }
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 1,
    message: "Audio decoded successfully"
  });
  const a = await cT(o, e, n);
  return { buffer: o, analysis: a };
}
function Wt(s, e, n = "number", i) {
  return {
    id: `prop_${s}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
    name: s,
    type: n,
    value: e,
    animated: !1,
    keyframes: [],
    group: i
  };
}
function zd() {
  return {
    position: Wt("position", { x: 0, y: 0 }, "position"),
    anchorPoint: Wt("anchorPoint", { x: 0, y: 0 }, "position"),
    scale: Wt("scale", { x: 100, y: 100 }, "position"),
    rotation: Wt("rotation", 0, "number")
  };
}
function dT(s, e) {
  const n = "main", i = {
    width: s,
    height: e,
    frameCount: 81,
    fps: 16,
    duration: 5.0625,
    backgroundColor: "#000000",
    autoResizeToContent: !0
  };
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    // Multi-composition support
    compositions: {
      [n]: {
        id: n,
        name: "Main Comp",
        settings: i,
        layers: [],
        currentFrame: 0,
        isPrecomp: !1
      }
    },
    mainCompositionId: n,
    // Legacy alias
    composition: i,
    assets: {},
    layers: [],
    currentFrame: 0
  };
}
function hT(s, e = "amplitude", n = "particle.emissionRate") {
  return {
    id: s || `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    feature: e,
    target: n,
    targetLayerId: void 0,
    targetEmitterId: void 0,
    // Core
    sensitivity: 1,
    offset: 0,
    min: 0,
    max: 1,
    smoothing: 0.3,
    invert: !1,
    threshold: 0,
    enabled: !0,
    // ATI style
    amplitudeCurve: 1,
    // Linear by default
    release: 0.5,
    // Medium decay
    beatResponse: "none",
    beatThreshold: 0.5,
    curve: "linear"
  };
}
class fT {
  constructor(e) {
    fe(this, "analysis");
    fe(this, "mappings", /* @__PURE__ */ new Map());
    fe(this, "smoothedValues", /* @__PURE__ */ new Map());
    fe(this, "releaseEnvelopes", /* @__PURE__ */ new Map());
    // ATI-style release tracking
    fe(this, "beatToggleStates", /* @__PURE__ */ new Map());
    // For beat toggle/flip
    fe(this, "peakData", null);
    this.analysis = e;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(e) {
    this.peakData = e;
  }
  /**
   * Add a new mapping
   */
  addMapping(e) {
    this.mappings.set(e.id, e), this.smoothedValues.set(e.id, 0), this.releaseEnvelopes.set(e.id, 0), this.beatToggleStates.set(e.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(e) {
    this.mappings.delete(e), this.smoothedValues.delete(e), this.releaseEnvelopes.delete(e), this.beatToggleStates.delete(e);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(e, n) {
    const i = this.mappings.get(e);
    i && Object.assign(i, n);
  }
  /**
   * Get a specific mapping
   */
  getMapping(e) {
    return this.mappings.get(e);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(e) {
    return Array.from(this.mappings.values()).filter(
      (n) => n.targetLayerId === e || n.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(e) {
    return Array.from(this.mappings.values()).filter((n) => n.target === e);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(e, n) {
    return e === "peaks" ? this.peakData && oT(this.peakData, n) ? 1 : 0 : vl(this.analysis, e, n);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(e, n) {
    const i = this.mappings.get(e);
    if (!i || !i.enabled) return 0;
    let r = this.getFeatureAtFrame(i.feature, n);
    r < i.threshold && (r = 0), i.amplitudeCurve !== 1 && (r = Math.pow(r, i.amplitudeCurve));
    const o = this.releaseEnvelopes.get(e) || 0;
    if (r > o)
      this.releaseEnvelopes.set(e, r);
    else {
      const c = 1 - i.release * 0.98, u = o * c;
      this.releaseEnvelopes.set(e, u), r = Math.max(r, u);
    }
    if (i.beatResponse !== "none") {
      if (this.analysis.onsets.includes(n) && this.getFeatureAtFrame(i.feature, n) > i.beatThreshold) {
        const u = this.beatToggleStates.get(e) || 0;
        switch (i.beatResponse) {
          case "flip":
            this.beatToggleStates.set(e, u === 0 ? 1 : 0);
            break;
          case "pulse":
            r = 1;
            break;
          case "toggle":
            const d = u === 0 ? 1 : 0;
            this.beatToggleStates.set(e, d), r = d;
            break;
        }
      }
      i.beatResponse === "flip" && (this.beatToggleStates.get(e) || 0) === 1 && (r = 1 - r);
    }
    r = this.applyCurve(r, i.curve), i.invert && (r = 1 - r), r *= i.sensitivity, r += i.offset, r = Math.max(i.min, Math.min(i.max, r));
    const l = (this.smoothedValues.get(e) || 0) * i.smoothing + r * (1 - i.smoothing);
    return this.smoothedValues.set(e, l), l;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(e) {
    const n = /* @__PURE__ */ new Map();
    for (const i of this.mappings.values()) {
      if (!i.enabled) continue;
      const r = this.getValueAtFrame(i.id, e), o = n.get(i.target);
      o !== void 0 ? n.set(i.target, o + r) : n.set(i.target, r);
    }
    return n;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(e, n) {
    const i = /* @__PURE__ */ new Map();
    for (const r of this.mappings.values()) {
      if (!r.enabled || r.targetLayerId && r.targetLayerId !== e) continue;
      const o = this.getValueAtFrame(r.id, n), a = i.get(r.target);
      a !== void 0 ? i.set(r.target, a + o) : i.set(r.target, o);
    }
    return i;
  }
  /**
   * Apply curve shaping to a value
   */
  applyCurve(e, n) {
    const i = Math.max(0, Math.min(1, e));
    switch (n) {
      case "exponential":
        return i * i;
      case "logarithmic":
        return Math.sqrt(i);
      case "smoothstep":
        return i * i * (3 - 2 * i);
      case "bounce":
        if (i < 0.5)
          return 2 * i * i;
        {
          const r = i - 0.5;
          return 0.5 + 0.5 * (1 - Math.pow(1 - 2 * r, 2));
        }
      case "linear":
      default:
        return i;
    }
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear(), this.releaseEnvelopes.clear(), this.beatToggleStates.clear();
    for (const e of this.mappings.values())
      this.smoothedValues.set(e.id, 0), this.releaseEnvelopes.set(e.id, 0), this.beatToggleStates.set(e.id, 0);
  }
  /**
   * Update analysis data
   */
  setAnalysis(e) {
    this.analysis = e, this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear(), this.smoothedValues.clear(), this.releaseEnvelopes.clear(), this.beatToggleStates.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addMapping(n);
  }
}
function Nd(s) {
  return {
    // Core
    amplitude: "Amplitude",
    rms: "RMS Energy",
    spectralCentroid: "Brightness",
    // Frequency bands
    sub: "Sub Bass (20-60Hz)",
    bass: "Bass (60-250Hz)",
    lowMid: "Low Mid (250-500Hz)",
    mid: "Mid (500-2kHz)",
    highMid: "High Mid (2-4kHz)",
    high: "High (4-20kHz)",
    // Events
    onsets: "Beat Onsets",
    peaks: "Detected Peaks",
    // Enhanced features
    spectralFlux: "Spectral Flux (Transients)",
    zeroCrossingRate: "Zero Crossing (Percussive)",
    spectralRolloff: "Spectral Rolloff (High Freq)",
    spectralFlatness: "Spectral Flatness (Noise)",
    chromaEnergy: "Chroma Energy (Harmonic)",
    // Pitch classes
    chromaC: "Chroma: C",
    chromaCs: "Chroma: C#/Db",
    chromaD: "Chroma: D",
    chromaDs: "Chroma: D#/Eb",
    chromaE: "Chroma: E",
    chromaF: "Chroma: F",
    chromaFs: "Chroma: F#/Gb",
    chromaG: "Chroma: G",
    chromaGs: "Chroma: G#/Ab",
    chromaA: "Chroma: A",
    chromaAs: "Chroma: A#/Bb",
    chromaB: "Chroma: B"
  }[s] || s;
}
function Sv(s) {
  return {
    "particle.emissionRate": "Particle: Emission Rate",
    "particle.speed": "Particle: Speed",
    "particle.size": "Particle: Size",
    "particle.gravity": "Particle: Gravity",
    "particle.windStrength": "Particle: Wind Strength",
    "particle.windDirection": "Particle: Wind Direction",
    "depthflow.zoom": "Depthflow: Zoom",
    "depthflow.offsetX": "Depthflow: Offset X",
    "depthflow.offsetY": "Depthflow: Offset Y",
    "depthflow.rotation": "Depthflow: Rotation",
    "depthflow.depthScale": "Depthflow: Depth Scale",
    "path.position": "Path: Position",
    "layer.opacity": "Layer: Opacity",
    "layer.scale": "Layer: Scale",
    "layer.rotation": "Layer: Rotation",
    "layer.x": "Layer: X Position",
    "layer.y": "Layer: Y Position"
  }[s] || s;
}
function pT() {
  return [
    // Core
    "amplitude",
    "rms",
    "spectralCentroid",
    // Frequency bands
    "sub",
    "bass",
    "lowMid",
    "mid",
    "highMid",
    "high",
    // Events
    "onsets",
    "peaks",
    // Enhanced
    "spectralFlux",
    "zeroCrossingRate",
    "spectralRolloff",
    "spectralFlatness",
    "chromaEnergy",
    // Pitch classes
    "chromaC",
    "chromaCs",
    "chromaD",
    "chromaDs",
    "chromaE",
    "chromaF",
    "chromaFs",
    "chromaG",
    "chromaGs",
    "chromaA",
    "chromaAs",
    "chromaB"
  ];
}
function mT() {
  return {
    Energy: ["amplitude", "rms"],
    "Frequency Bands": ["sub", "bass", "lowMid", "mid", "highMid", "high"],
    Spectral: ["spectralCentroid", "spectralFlux", "spectralRolloff", "spectralFlatness"],
    Events: ["onsets", "peaks"],
    Harmonic: ["chromaEnergy", "zeroCrossingRate"],
    "Pitch Classes": [
      "chromaC",
      "chromaCs",
      "chromaD",
      "chromaDs",
      "chromaE",
      "chromaF",
      "chromaFs",
      "chromaG",
      "chromaGs",
      "chromaA",
      "chromaAs",
      "chromaB"
    ]
  };
}
function vT() {
  return {
    Particle: [
      "particle.emissionRate",
      "particle.speed",
      "particle.size",
      "particle.gravity",
      "particle.windStrength",
      "particle.windDirection"
    ],
    Depthflow: [
      "depthflow.zoom",
      "depthflow.offsetX",
      "depthflow.offsetY",
      "depthflow.rotation",
      "depthflow.depthScale"
    ],
    Path: ["path.position"],
    Layer: [
      "layer.opacity",
      "layer.scale",
      "layer.rotation",
      "layer.x",
      "layer.y"
    ]
  };
}
const gT = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: !0,
  beatThreshold: 0.05,
  motionBlur: !1,
  motionBlurStrength: 0.5
};
class yT {
  // For amplitude mode release tracking
  constructor(e = {}) {
    fe(this, "config");
    fe(this, "state");
    fe(this, "pathSegments", []);
    fe(this, "totalLength", 0);
    fe(this, "releaseState", 0);
    this.config = { ...gT, ...e }, this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(e) {
    this.pathSegments = this.parsePath(e), this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(e) {
    const n = [], i = e.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let r = 0, o = 0;
    for (const a of i) {
      const l = a[0].toUpperCase(), c = a.slice(1).trim().split(/[\s,]+/).map(Number).filter((u) => !isNaN(u));
      switch (l) {
        case "M":
          r = c[0] || 0, o = c[1] || 0, n.push({
            type: "M",
            points: [r, o],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          n.push({
            type: "L",
            points: [r, o, c[0], c[1]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = c[0], o = c[1];
          break;
        case "C":
          n.push({
            type: "C",
            points: [r, o, c[0], c[1], c[2], c[3], c[4], c[5]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = c[4], o = c[5];
          break;
        case "Q":
          n.push({
            type: "Q",
            points: [r, o, c[0], c[1], c[2], c[3]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = c[2], o = c[3];
          break;
        case "Z":
          const u = n.find((d) => d.type === "M");
          u && n.push({
            type: "L",
            points: [r, o, u.points[0], u.points[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
      }
    }
    return n;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let e = 0;
    for (const n of this.pathSegments) {
      switch (n.type) {
        case "M":
          n.length = 0;
          break;
        case "L":
          n.length = this.lineLength(n.points);
          break;
        case "C":
          n.length = this.bezierLength(n.points, 3);
          break;
        case "Q":
          n.length = this.bezierLength(n.points, 2);
          break;
      }
      n.startT = e, e += n.length, n.endT = e;
    }
    if (this.totalLength = e, this.totalLength > 0)
      for (const n of this.pathSegments)
        n.startT /= this.totalLength, n.endT /= this.totalLength;
  }
  lineLength(e) {
    const n = e[2] - e[0], i = e[3] - e[1];
    return Math.sqrt(n * n + i * i);
  }
  bezierLength(e, n) {
    let r = 0, o = e[0], a = e[1];
    for (let l = 1; l <= 20; l++) {
      const c = l / 20, { x: u, y: d } = this.getBezierPoint(e, c, n), h = u - o, m = d - a;
      r += Math.sqrt(h * h + m * m), o = u, a = d;
    }
    return r;
  }
  getBezierPoint(e, n, i) {
    if (i === 2) {
      const r = 1 - n;
      return {
        x: r * r * e[0] + 2 * r * n * e[2] + n * n * e[4],
        y: r * r * e[1] + 2 * r * n * e[3] + n * n * e[5]
      };
    } else {
      const r = 1 - n, o = r * r, a = n * n;
      return {
        x: o * r * e[0] + 3 * o * n * e[2] + 3 * r * a * e[4] + a * n * e[6],
        y: o * r * e[1] + 3 * o * n * e[3] + 3 * r * a * e[5] + a * n * e[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(e, n) {
    this.state.previousPosition = this.state.position;
    const i = this.state.smoothedValue * this.config.smoothing + e * (1 - this.config.smoothing);
    this.state.smoothedValue = i, this.config.movementMode === "amplitude" ? this.updateAmplitudeMode(i) : this.updateAccumulateMode(i, n);
    const r = this.getPositionOnPath(this.state.position);
    return this.state.x = r.x, this.state.y = r.y, this.state.angle = r.angle, { ...this.state };
  }
  updateAmplitudeMode(e) {
    let n = Math.pow(e, this.config.amplitudeCurve);
    if (n > this.releaseState)
      this.releaseState = n;
    else {
      const r = 1 - this.config.release * 0.95;
      this.releaseState *= r;
    }
    const i = Math.max(n, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, i * this.config.sensitivity));
  }
  updateAccumulateMode(e, n) {
    this.config.flipOnBeat && n && e > this.config.beatThreshold && (this.state.direction *= -1);
    const i = e * this.config.sensitivity * 0.02 * this.state.direction;
    let r = this.state.position + i;
    r > 1 ? (r = 2 - r, this.state.direction = -1) : r < 0 && (r = -r, this.state.direction = 1), this.state.position = Math.max(0, Math.min(1, r));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(e) {
    if (e = Math.max(0, Math.min(1, e)), this.pathSegments.length === 0)
      return { x: 0, y: 0, angle: 0 };
    let n = this.pathSegments[0];
    for (const u of this.pathSegments)
      if (u.type !== "M" && e >= u.startT && e <= u.endT) {
        n = u;
        break;
      }
    if (n.type === "M")
      return { x: n.points[0], y: n.points[1], angle: 0 };
    const i = n.endT > n.startT ? (e - n.startT) / (n.endT - n.startT) : 0;
    let r, o, a, l;
    switch (n.type) {
      case "L":
        r = n.points[0] + (n.points[2] - n.points[0]) * i, o = n.points[1] + (n.points[3] - n.points[1]) * i, a = n.points[2] - n.points[0], l = n.points[3] - n.points[1];
        break;
      case "Q": {
        const u = this.getBezierPoint(n.points, i, 2);
        r = u.x, o = u.y;
        const d = 1 - i;
        a = 2 * d * (n.points[2] - n.points[0]) + 2 * i * (n.points[4] - n.points[2]), l = 2 * d * (n.points[3] - n.points[1]) + 2 * i * (n.points[5] - n.points[3]);
        break;
      }
      case "C": {
        const u = this.getBezierPoint(n.points, i, 3);
        r = u.x, o = u.y;
        const d = 1 - i, h = d * d, m = i * i;
        a = 3 * h * (n.points[2] - n.points[0]) + 6 * d * i * (n.points[4] - n.points[2]) + 3 * m * (n.points[6] - n.points[4]), l = 3 * h * (n.points[3] - n.points[1]) + 6 * d * i * (n.points[5] - n.points[3]) + 3 * m * (n.points[7] - n.points[5]);
        break;
      }
      default:
        r = 0, o = 0, a = 1, l = 0;
    }
    const c = Math.atan2(l, a);
    return { x: r, y: o, angle: c };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(e = 5) {
    if (!this.config.motionBlur) return [];
    const n = [], i = this.state.previousPosition, r = this.state.position;
    for (let o = 0; o <= e; o++) {
      const a = i + (r - i) * (o / e), l = this.getPositionOnPath(a), c = o / e * this.config.motionBlurStrength;
      n.push({ x: l.x, y: l.y, opacity: c });
    }
    return n;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    }, this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(e) {
    Object.assign(this.config, e);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}
function _T(s) {
  switch (s) {
    case "number":
    case "angle":
      return "number";
    case "point":
      return "position";
    case "point3d":
      return "vector3";
    case "color":
      return "color";
    case "checkbox":
    case "dropdown":
    case "layer":
      return "enum";
    default:
      return "number";
  }
}
const au = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: !0 },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: !1 },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: !0 }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: !0 },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: !1 },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: !1 }
    ]
  },
  sharpen: {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: !0 }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: !0 },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: !0 },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: !0 },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Use Legacy", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: !1 },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: !0, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  curves: {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: !1 }
      // Note: Actual curve control would be a custom component
    ]
  },
  levels: {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: !1 },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: !0 },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  tint: {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Distort
  transform: {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: !0 },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  warp: {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: !1 },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: !1 },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 }
    ]
  },
  // Generate
  fill: {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: !0 },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: !0 },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: !1 },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Stylize
  glow: {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: !0 },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: !0 },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: !0 },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: !1 },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: !0 }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: !0 },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: !0 },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: !0 },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: !0 },
      { name: "Shadow Only", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: !1 },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: !1 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: !0 },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: !0 },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: !0 },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: !0 },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: !0 }
    ]
  }
}, Kh = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  distort: { label: "Distort", icon: "D", description: "Distortion effects" },
  generate: { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  keying: { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  matte: { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  perspective: { label: "Perspective", icon: "P", description: "3D perspective effects" },
  stylize: { label: "Stylize", icon: "S", description: "Stylization effects" },
  time: { label: "Time", icon: "T", description: "Time-based effects" },
  transition: { label: "Transition", icon: "Tr", description: "Transition effects" },
  utility: { label: "Utility", icon: "U", description: "Utility effects" }
};
function xT(s) {
  const e = au[s];
  if (!e) return null;
  const n = {};
  return e.parameters.forEach((i, r) => {
    const o = i.name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    n[o] = {
      id: `${s}-${o}-${r}`,
      name: i.name,
      type: _T(i.type),
      value: i.defaultValue,
      animated: !1,
      keyframes: []
    };
  }), {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    effectKey: s,
    name: e.name,
    category: e.category,
    enabled: !0,
    expanded: !0,
    parameters: n
  };
}
const bT = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
];
class wT {
  constructor() {
    fe(this, "drivers", /* @__PURE__ */ new Map());
    fe(this, "smoothedValues", /* @__PURE__ */ new Map());
    fe(this, "audioAnalysis", null);
    fe(this, "propertyGetter", null);
  }
  /**
   * Set the audio analysis data for audio-driven properties
   */
  setAudioAnalysis(e) {
    this.audioAnalysis = e;
  }
  /**
   * Set the property getter function (provided by store/engine)
   */
  setPropertyGetter(e) {
    this.propertyGetter = e;
  }
  /**
   * Add a new driver
   * Returns false if adding would create a circular dependency
   */
  addDriver(e) {
    return e.sourceType === "property" && e.sourceLayerId && e.sourceProperty && this.wouldCreateCycle(e) ? (Jt.warn("PropertyDriverSystem: Cannot add driver: would create circular dependency"), !1) : (this.drivers.set(e.id, e), this.smoothedValues.set(e.id, 0), !0);
  }
  /**
   * Check if adding a driver would create a circular dependency
   */
  wouldCreateCycle(e) {
    if (e.sourceType !== "property" || !e.sourceLayerId || !e.sourceProperty) return !1;
    const n = /* @__PURE__ */ new Set(), i = `${e.targetLayerId}:${e.targetProperty}`, r = (o, a) => {
      const l = `${o}:${a}`;
      if (l === i) return !0;
      if (n.has(l)) return !1;
      n.add(l);
      for (const c of this.drivers.values())
        if (c.sourceType === "property" && !(c.targetLayerId !== o || c.targetProperty !== a) && !(!c.sourceLayerId || !c.sourceProperty) && r(c.sourceLayerId, c.sourceProperty))
          return !0;
      return !1;
    };
    return r(e.sourceLayerId, e.sourceProperty);
  }
  /**
   * Remove a driver
   */
  removeDriver(e) {
    this.drivers.delete(e), this.smoothedValues.delete(e);
  }
  /**
   * Update a driver
   */
  updateDriver(e, n) {
    const i = this.drivers.get(e);
    i && Object.assign(i, n);
  }
  /**
   * Get a driver by ID
   */
  getDriver(e) {
    return this.drivers.get(e);
  }
  /**
   * Get all drivers
   */
  getAllDrivers() {
    return Array.from(this.drivers.values());
  }
  /**
   * Get drivers for a specific target layer
   */
  getDriversForLayer(e) {
    return Array.from(this.drivers.values()).filter((n) => n.targetLayerId === e);
  }
  /**
   * Get drivers for a specific target property
   */
  getDriversForProperty(e, n) {
    return Array.from(this.drivers.values()).filter(
      (i) => i.targetLayerId === e && i.targetProperty === n && i.enabled
    );
  }
  /**
   * Evaluate a driver at a given frame
   */
  evaluateDriver(e, n, i) {
    if (!e.enabled) return i;
    let r = this.getSourceValue(e, n);
    return r === null ? i : (r = this.applyTransforms(e, r), this.blendValue(i, r, e.blendMode, e.blendAmount));
  }
  /**
   * Get the source value for a driver
   */
  getSourceValue(e, n) {
    switch (e.sourceType) {
      case "property":
        return this.getPropertySourceValue(e, n);
      case "audio":
        return this.getAudioSourceValue(e, n);
      case "time":
        return n;
      default:
        return null;
    }
  }
  /**
   * Get value from another property
   */
  getPropertySourceValue(e, n) {
    return !this.propertyGetter || !e.sourceLayerId || !e.sourceProperty ? null : this.propertyGetter(e.sourceLayerId, e.sourceProperty, n);
  }
  /**
   * Get value from audio analysis
   */
  getAudioSourceValue(e, n) {
    if (!this.audioAnalysis || !e.audioFeature)
      return null;
    let i = vl(this.audioAnalysis, e.audioFeature, n);
    return e.audioThreshold !== void 0 && (e.audioAboveThreshold ? i = i > e.audioThreshold ? i : 0 : i = i >= e.audioThreshold ? i : 0), i;
  }
  /**
   * Apply the transform chain to a value
   */
  applyTransforms(e, n) {
    for (const i of e.transforms)
      n = this.applyTransform(e.id, i, n);
    return n;
  }
  /**
   * Apply a single transform
   */
  applyTransform(e, n, i) {
    switch (n.type) {
      case "scale":
        return i * (n.factor ?? 1);
      case "offset":
        return i + (n.amount ?? 0);
      case "clamp":
        return Math.max(n.min ?? -1 / 0, Math.min(n.max ?? 1 / 0, i));
      case "smooth": {
        const r = this.smoothedValues.get(e) ?? i, o = n.smoothing ?? 0.5, a = r * o + i * (1 - o);
        return this.smoothedValues.set(e, a), a;
      }
      case "invert":
        return 1 - i;
      case "remap": {
        const r = n.inMin ?? 0, o = n.inMax ?? 1, a = n.outMin ?? 0, l = n.outMax ?? 1, c = (i - r) / (o - r);
        return a + c * (l - a);
      }
      case "threshold":
        return i > (n.threshold ?? 0.5) ? 1 : 0;
      case "oscillate": {
        const r = n.frequency ?? 1, o = n.amplitude ?? 1, a = n.phase ?? 0;
        return Math.sin((i * r + a) * Math.PI * 2) * o;
      }
      default:
        return i;
    }
  }
  /**
   * Blend driven value with base value
   */
  blendValue(e, n, i, r) {
    let o;
    switch (i) {
      case "replace":
        o = n;
        break;
      case "add":
        o = e + n;
        break;
      case "multiply":
        o = e * n;
        break;
      default:
        o = n;
    }
    return e * (1 - r) + o * r;
  }
  /**
   * Evaluate ALL drivers for a layer at a frame
   * Returns a map of property -> driven value
   */
  evaluateLayerDrivers(e, n, i) {
    const r = /* @__PURE__ */ new Map(), o = this.getDriversForLayer(e);
    for (const a of o) {
      if (!a.enabled) continue;
      const l = i.get(a.targetProperty) ?? 0, c = this.evaluateDriver(a, n, l), u = r.get(a.targetProperty);
      u !== void 0 ? r.set(a.targetProperty, u + c - l) : r.set(a.targetProperty, c);
    }
    return r;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
  }
  /**
   * Clear all drivers
   */
  clear() {
    this.drivers.clear(), this.smoothedValues.clear();
  }
  /**
   * Serialize drivers for storage
   */
  serialize() {
    return Array.from(this.drivers.values());
  }
  /**
   * Load drivers from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addDriver(n);
  }
}
function Py(s, e, n = "property") {
  return {
    id: `driver_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name: "New Driver",
    enabled: !0,
    targetLayerId: s,
    targetProperty: e,
    sourceType: n,
    transforms: [],
    blendMode: "add",
    blendAmount: 1
  };
}
function ST(s, e, n, i = {}) {
  const r = Py(s, e, "audio");
  return r.audioFeature = n, r.audioThreshold = i.threshold ?? 0, r.audioAboveThreshold = i.threshold !== void 0, i.scale !== void 0 && i.scale !== 1 && r.transforms.push({ type: "scale", factor: i.scale }), i.offset !== void 0 && i.offset !== 0 && r.transforms.push({ type: "offset", amount: i.offset }), i.smoothing !== void 0 && i.smoothing > 0 && r.transforms.push({ type: "smooth", smoothing: i.smoothing }), r;
}
function MT(s, e, n, i, r = {}) {
  const o = Py(s, e, "property");
  return o.sourceLayerId = n, o.sourceProperty = i, o.blendMode = r.blendMode ?? "add", r.scale !== void 0 && r.scale !== 1 && o.transforms.push({ type: "scale", factor: r.scale }), r.offset !== void 0 && r.offset !== 0 && o.transforms.push({ type: "offset", amount: r.offset }), o;
}
const CT = {
  enabled: !0,
  snapToGrid: !0,
  snapToKeyframes: !0,
  snapToBeats: !0,
  snapToPeaks: !0,
  snapToLayerBounds: !0,
  snapToPlayhead: !0,
  threshold: 8,
  // 8 pixels snap threshold
  gridInterval: 5
  // Snap to every 5 frames by default
};
function qf(s, e, n, i) {
  var l, c;
  if (!e.enabled)
    return null;
  const r = [], o = e.threshold / n;
  if (e.snapToGrid) {
    const u = Math.round(s / e.gridInterval) * e.gridInterval, d = Math.abs(s - u);
    d <= o && r.push({
      frame: u,
      type: "frame",
      distance: d * n
    });
  }
  if (e.snapToKeyframes && i.layers)
    for (const u of i.layers)
      u.id !== i.selectedLayerId && ET(u, s, o, n, r);
  if (e.snapToBeats && ((l = i.audioAnalysis) != null && l.onsets))
    for (const u of i.audioAnalysis.onsets) {
      const d = Math.abs(s - u);
      d <= o && r.push({
        frame: u,
        type: "beat",
        distance: d * n
      });
    }
  if (e.snapToPeaks && ((c = i.peakData) != null && c.indices))
    for (const u of i.peakData.indices) {
      const d = Math.abs(s - u);
      d <= o && r.push({
        frame: u,
        type: "peak",
        distance: d * n
      });
    }
  if (e.snapToLayerBounds && i.layers)
    for (const u of i.layers) {
      if (u.id === i.selectedLayerId) continue;
      const d = Math.abs(s - u.inPoint), h = Math.abs(s - u.outPoint);
      d <= o && r.push({
        frame: u.inPoint,
        type: "layer-in",
        distance: d * n
      }), h <= o && r.push({
        frame: u.outPoint,
        type: "layer-out",
        distance: h * n
      });
    }
  if (e.snapToPlayhead && i.currentFrame !== void 0) {
    const u = Math.abs(s - i.currentFrame);
    u <= o && u > 0 && r.push({
      frame: i.currentFrame,
      type: "playhead",
      distance: u * n
    });
  }
  if (r.length === 0)
    return null;
  const a = {
    playhead: 5,
    beat: 4,
    peak: 4,
    keyframe: 3,
    "layer-in": 2,
    "layer-out": 2,
    frame: 1
  };
  return r.sort((u, d) => {
    const h = u.distance - d.distance;
    return Math.abs(h) < 0.5 ? a[d.type] - a[u.type] : h;
  }), r[0];
}
function ET(s, e, n, i, r) {
  const o = [
    s.transform.position,
    s.transform.scale,
    s.transform.rotation,
    s.opacity,
    ...s.properties
  ];
  for (const a of o)
    if (!(!a.animated || !a.keyframes))
      for (const l of a.keyframes) {
        const c = Math.abs(e - l.frame);
        c <= n && (r.some((u) => u.frame === l.frame && u.type === "keyframe") || r.push({
          frame: l.frame,
          type: "keyframe",
          distance: c * i
        }));
      }
}
function TT(s) {
  return (s == null ? void 0 : s.onsets) ?? [];
}
function AT(s) {
  return (s == null ? void 0 : s.indices) ?? [];
}
const sn = /* @__PURE__ */ Ux("compositor", {
  state: () => ({
    project: dT(1024, 1024),
    activeCompositionId: "main",
    openCompositionIds: ["main"],
    comfyuiNodeId: null,
    sourceImage: null,
    depthMap: null,
    isPlaying: !1,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    selectedLayerIds: [],
    selectedKeyframeIds: [],
    selectedPropertyPath: null,
    currentTool: "select",
    graphEditorVisible: !1,
    historyStack: [],
    historyIndex: -1,
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    audioLoadingState: "idle",
    audioLoadingProgress: 0,
    audioLoadingPhase: "",
    audioLoadingError: null,
    audioMappings: /* @__PURE__ */ new Map(),
    peakData: null,
    audioReactiveMappings: [],
    audioReactiveMapper: null,
    pathAnimators: /* @__PURE__ */ new Map(),
    // Camera system
    cameras: /* @__PURE__ */ new Map(),
    cameraKeyframes: /* @__PURE__ */ new Map(),
    activeCameraId: null,
    viewportState: Cy(),
    viewOptions: $E(),
    // Property driver system
    propertyDriverSystem: null,
    propertyDrivers: [],
    // Timeline snapping
    snapConfig: { ...CT },
    // Clipboard
    clipboard: {
      layers: [],
      keyframes: []
    }
  }),
  getters: {
    // Active composition helper
    activeComposition: (s) => s.project.compositions[s.activeCompositionId] || null,
    // Project info - now uses active composition
    hasProject: (s) => s.sourceImage !== null,
    width(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.width) || 1024;
    },
    height(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.height) || 1024;
    },
    frameCount(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.frameCount) || 81;
    },
    fps(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.fps) || 16;
    },
    duration(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.duration) || 5;
    },
    // Current frame - per composition
    currentFrame(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.currentFrame) || 0;
    },
    currentTime(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return e ? e.currentFrame / e.settings.fps : 0;
    },
    // Layers - from active composition
    layers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.layers) || [];
    },
    visibleLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => n.visible);
    },
    // Selection
    selectedLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => s.selectedLayerIds.includes(n.id));
    },
    selectedLayer(s) {
      if (s.selectedLayerIds.length !== 1) return null;
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).find((n) => n.id === s.selectedLayerIds[0]) || null;
    },
    // All compositions for tabs
    allCompositions: (s) => Object.values(s.project.compositions),
    openCompositions(s) {
      return s.openCompositionIds.map((e) => s.project.compositions[e]).filter(Boolean);
    },
    // Assets
    assets: (s) => s.project.assets,
    // History
    canUndo: (s) => s.historyIndex > 0,
    canRedo: (s) => s.historyIndex < s.historyStack.length - 1,
    // Camera
    activeCamera: (s) => s.activeCameraId && s.cameras.get(s.activeCameraId) || null,
    allCameras: (s) => Array.from(s.cameras.values()),
    cameraLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => n.type === "camera");
    }
  },
  actions: {
    // ============================================================
    // HELPER METHODS
    // ============================================================
    /**
     * Get the layers array for the active composition (mutable reference)
     */
    getActiveCompLayers() {
      const s = this.project.compositions[this.activeCompositionId];
      return (s == null ? void 0 : s.layers) || [];
    },
    /**
     * Get the active composition (mutable reference)
     */
    getActiveComp() {
      return this.project.compositions[this.activeCompositionId] || null;
    },
    // ============================================================
    // COMPOSITION MANAGEMENT
    // ============================================================
    /**
     * Create a new composition
     */
    createComposition(s, e, n = !1) {
      const i = `comp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, r = this.project.compositions[this.activeCompositionId], o = {
        width: (e == null ? void 0 : e.width) ?? (r == null ? void 0 : r.settings.width) ?? 1024,
        height: (e == null ? void 0 : e.height) ?? (r == null ? void 0 : r.settings.height) ?? 1024,
        frameCount: (e == null ? void 0 : e.frameCount) ?? (r == null ? void 0 : r.settings.frameCount) ?? 81,
        fps: (e == null ? void 0 : e.fps) ?? (r == null ? void 0 : r.settings.fps) ?? 16,
        duration: 0,
        backgroundColor: (e == null ? void 0 : e.backgroundColor) ?? "#000000",
        autoResizeToContent: (e == null ? void 0 : e.autoResizeToContent) ?? !0
      };
      o.duration = o.frameCount / o.fps;
      const a = {
        id: i,
        name: s,
        settings: o,
        layers: [],
        currentFrame: 0,
        isPrecomp: n
      };
      return this.project.compositions[i] = a, this.openCompositionIds.includes(i) || this.openCompositionIds.push(i), this.activeCompositionId = i, Jt.debug("Created composition:", s, i), a;
    },
    /**
     * Delete a composition
     */
    deleteComposition(s) {
      if (s === this.project.mainCompositionId)
        return Jt.warn("Cannot delete main composition"), !1;
      if (!this.project.compositions[s]) return !1;
      delete this.project.compositions[s];
      const n = this.openCompositionIds.indexOf(s);
      return n >= 0 && this.openCompositionIds.splice(n, 1), this.activeCompositionId === s && (this.activeCompositionId = this.openCompositionIds[0] || this.project.mainCompositionId), Jt.debug("Deleted composition:", s), !0;
    },
    /**
     * Switch to a different composition (tab)
     */
    switchComposition(s) {
      if (!this.project.compositions[s]) {
        Jt.warn("Composition not found:", s);
        return;
      }
      this.openCompositionIds.includes(s) || this.openCompositionIds.push(s), this.selectedLayerIds = [], this.selectedKeyframeIds = [], this.activeCompositionId = s, Jt.debug("Switched to composition:", s);
    },
    /**
     * Close a composition tab
     */
    closeCompositionTab(s) {
      if (this.openCompositionIds.length <= 1) {
        Jt.warn("Cannot close the last tab");
        return;
      }
      const e = this.openCompositionIds.indexOf(s);
      e >= 0 && this.openCompositionIds.splice(e, 1), this.activeCompositionId === s && (this.activeCompositionId = this.openCompositionIds[Math.max(0, e - 1)]);
    },
    /**
     * Rename a composition
     */
    renameComposition(s, e) {
      const n = this.project.compositions[s];
      n && (n.name = e);
    },
    /**
     * Update composition settings
     */
    updateCompositionSettings(s, e) {
      const n = this.project.compositions[s];
      if (!n) return;
      const i = n.settings.frameCount;
      if (Object.assign(n.settings, e), n.settings.duration = n.settings.frameCount / n.settings.fps, e.frameCount && e.frameCount > i)
        for (const r of n.layers)
          r.outPoint === i - 1 && (r.outPoint = e.frameCount - 1);
      s === this.project.mainCompositionId && Object.assign(this.project.composition, n.settings);
    },
    /**
     * Get a composition by ID
     */
    getComposition(s) {
      return this.project.compositions[s] || null;
    },
    /**
     * Pre-compose selected layers into a new composition
     */
    precomposeSelectedLayers(s) {
      if (this.selectedLayerIds.length === 0)
        return Jt.warn("No layers selected for pre-compose"), null;
      const e = this.project.compositions[this.activeCompositionId];
      if (!e) return null;
      const n = this.createComposition(
        s || "Pre-comp",
        e.settings,
        !0
      ), i = e.layers.filter(
        (l) => this.selectedLayerIds.includes(l.id)
      ), r = Math.min(...i.map((l) => l.inPoint));
      for (const l of i) {
        l.inPoint -= r, l.outPoint -= r;
        const c = e.layers.indexOf(l);
        c >= 0 && e.layers.splice(c, 1), n.layers.push(l);
      }
      const o = Math.max(...n.layers.map((l) => l.outPoint));
      n.settings.frameCount = o + 1, n.settings.duration = n.settings.frameCount / n.settings.fps;
      const a = {
        id: `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: n.name,
        type: "precomp",
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !1,
        inPoint: r,
        outPoint: r + n.settings.frameCount - 1,
        parentId: null,
        transform: zd(),
        opacity: Wt("opacity", 100, "number"),
        properties: [],
        effects: [],
        blendMode: "normal",
        motionBlur: !1,
        data: {
          compositionId: n.id,
          timeRemapEnabled: !1,
          collapseTransformations: !1
        }
      };
      return e.layers.push(a), this.selectedLayerIds = [], this.activeCompositionId = e.id, Jt.debug("Pre-composed layers into:", n.name), n;
    },
    // ============================================================
    // COMFYUI INTEGRATION
    // ============================================================
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(s) {
      this.comfyuiNodeId = s.node_id, this.sourceImage = s.source_image, this.depthMap = s.depth_map;
      const e = this.project.compositions[this.activeCompositionId];
      if (!e) return;
      const n = e.settings.frameCount;
      if (e.settings.width = s.width, e.settings.height = s.height, e.settings.frameCount = s.frame_count, e.settings.duration = s.frame_count / e.settings.fps, this.project.composition.width = s.width, this.project.composition.height = s.height, this.project.composition.frameCount = s.frame_count, this.project.composition.duration = s.frame_count / this.project.composition.fps, s.frame_count > n)
        for (const i of e.layers)
          i.outPoint === n - 1 && (i.outPoint = s.frame_count - 1);
      s.source_image && (this.project.assets.source_image = {
        id: "source_image",
        type: "image",
        source: "comfyui_node",
        nodeId: s.node_id,
        width: s.width,
        height: s.height,
        data: s.source_image
      }), s.depth_map && (this.project.assets.depth_map = {
        id: "depth_map",
        type: "depth_map",
        source: "comfyui_node",
        nodeId: s.node_id,
        width: s.width,
        height: s.height,
        data: s.depth_map
      }), e && (e.currentFrame = 0), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), Jt.debug("Loaded inputs from ComfyUI:", {
        width: s.width,
        height: s.height,
        frameCount: s.frame_count
      }), this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(s, e) {
      const n = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      let i = null;
      switch (s) {
        case "text":
          i = {
            text: "Text",
            fontFamily: "Arial",
            fontSize: 72,
            fontWeight: "400",
            fontStyle: "normal",
            fill: "#ffffff",
            stroke: "",
            strokeWidth: 0,
            tracking: 0,
            letterSpacing: 0,
            lineHeight: 1.2,
            textAlign: "left",
            pathLayerId: null,
            pathReversed: !1,
            pathPerpendicularToPath: !0,
            pathForceAlignment: !1,
            pathFirstMargin: 0,
            pathLastMargin: 0,
            pathOffset: 0,
            pathAlign: "left"
          };
          break;
        case "solid":
          i = {
            color: "#808080",
            width: this.project.composition.width,
            height: this.project.composition.height
          };
          break;
        case "null":
          i = {
            size: 40
          };
          break;
        case "spline":
          i = {
            pathData: "",
            controlPoints: [],
            closed: !1,
            stroke: "#00ff00",
            strokeWidth: 2,
            fill: ""
          };
          break;
        case "particles":
          i = {
            systemConfig: {
              maxParticles: 1e3,
              gravity: 0,
              windStrength: 0,
              windDirection: 0,
              warmupPeriod: 0,
              respectMaskBoundary: !1,
              boundaryBehavior: "kill",
              friction: 0.01
            },
            emitters: [{
              id: "emitter_1",
              name: "Emitter 1",
              x: this.project.composition.width / 2,
              y: this.project.composition.height / 2,
              direction: -90,
              spread: 30,
              speed: 5,
              speedVariance: 0.2,
              size: 10,
              sizeVariance: 0.3,
              color: [255, 255, 255],
              emissionRate: 10,
              initialBurst: 0,
              particleLifetime: 60,
              lifetimeVariance: 0.2,
              enabled: !0,
              burstOnBeat: !1,
              burstCount: 20
            }],
            gravityWells: [],
            vortices: [],
            modulations: [],
            renderOptions: {
              blendMode: "additive",
              renderTrails: !1,
              trailLength: 10,
              trailOpacityFalloff: 0.9,
              particleShape: "circle",
              glowEnabled: !1,
              glowRadius: 5,
              glowIntensity: 0.5,
              motionBlur: !1,
              motionBlurStrength: 0.5,
              motionBlurSamples: 4,
              connections: {
                enabled: !1,
                maxDistance: 100,
                maxConnections: 3,
                lineWidth: 1,
                lineOpacity: 0.5,
                fadeByDistance: !0
              }
            }
          };
          break;
        case "depthflow":
          i = {
            sourceLayerId: null,
            depthLayerId: null,
            config: {
              preset: "static",
              zoom: 1,
              offsetX: 0,
              offsetY: 0,
              rotation: 0,
              depthScale: 1,
              focusDepth: 0.5,
              dollyZoom: 0,
              orbitRadius: 0,
              orbitSpeed: 1,
              swingAmplitude: 0,
              swingFrequency: 1,
              edgeDilation: 0,
              inpaintEdges: !1
            }
          };
          break;
        case "light":
          i = {
            lightType: "point",
            color: "#ffffff",
            intensity: 100,
            radius: 500,
            falloff: "none",
            falloffDistance: 500,
            castShadows: !1,
            shadowDarkness: 100,
            shadowDiffusion: 0
          };
          break;
        case "camera":
          i = {
            cameraId: null,
            isActiveCamera: !1
          };
          break;
        case "image":
          i = {
            assetId: null,
            fit: "contain"
          };
          break;
        case "video":
          i = {
            assetId: null,
            loop: !1,
            startTime: 0,
            speed: 1
          };
          break;
      }
      let r;
      (s === "video" || s === "audio") && (r = {
        level: Wt("Audio Levels", 0, "number")
        // 0dB default
      });
      const o = this.getActiveComp(), a = this.getActiveCompLayers(), l = {
        id: n,
        name: e || `${s.charAt(0).toUpperCase() + s.slice(1)} ${a.length + 1}`,
        type: s,
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !1,
        motionBlur: !1,
        inPoint: 0,
        outPoint: ((o == null ? void 0 : o.settings.frameCount) || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: Wt("opacity", 100, "number"),
        transform: zd(),
        audio: r,
        properties: [],
        effects: [],
        data: i
      };
      return s === "camera" && Jt.warn("Use createCameraLayer() for camera layers"), a.unshift(l), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), l;
    },
    /**
     * Delete a layer
     */
    deleteLayer(s) {
      const e = this.getActiveCompLayers(), n = e.findIndex((i) => i.id === s);
      n !== -1 && (e.splice(n, 1), this.selectedLayerIds = this.selectedLayerIds.filter((i) => i !== s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Duplicate a layer
     */
    duplicateLayer(s) {
      const e = this.getActiveCompLayers(), n = e.find((o) => o.id === s);
      if (!n) return null;
      const i = JSON.parse(JSON.stringify(n));
      if (i.id = crypto.randomUUID(), i.name = n.name + " Copy", i.transform)
        for (const o of Object.keys(i.transform)) {
          const a = i.transform[o];
          a != null && a.keyframes && (a.keyframes = a.keyframes.map((l) => ({
            ...l,
            id: crypto.randomUUID()
          })));
        }
      if (i.properties)
        for (const o of i.properties)
          o.keyframes && (o.keyframes = o.keyframes.map((a) => ({
            ...a,
            id: crypto.randomUUID()
          })));
      const r = e.findIndex((o) => o.id === s);
      return e.splice(r, 0, i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), i;
    },
    /**
     * Copy selected layers to clipboard
     */
    copySelectedLayers() {
      const e = this.getActiveCompLayers().filter((n) => this.selectedLayerIds.includes(n.id));
      e.length !== 0 && (this.clipboard.layers = e.map((n) => JSON.parse(JSON.stringify(n))), Jt.debug(`Copied ${this.clipboard.layers.length} layer(s) to clipboard`));
    },
    /**
     * Paste layers from clipboard
     */
    pasteLayers() {
      if (this.clipboard.layers.length === 0) return [];
      const s = this.getActiveCompLayers(), e = [];
      for (const n of this.clipboard.layers) {
        const i = JSON.parse(JSON.stringify(n));
        if (i.id = crypto.randomUUID(), i.name = n.name + " Copy", i.transform)
          for (const r of Object.keys(i.transform)) {
            const o = i.transform[r];
            o != null && o.keyframes && (o.keyframes = o.keyframes.map((a) => ({
              ...a,
              id: crypto.randomUUID()
            })));
          }
        if (i.properties)
          for (const r of i.properties)
            r.keyframes && (r.keyframes = r.keyframes.map((o) => ({
              ...o,
              id: crypto.randomUUID()
            })));
        i.parentId = null, s.unshift(i), e.push(i);
      }
      return this.selectedLayerIds = e.map((n) => n.id), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), Jt.debug(`Pasted ${e.length} layer(s)`), e;
    },
    /**
     * Cut selected layers (copy + delete)
     */
    cutSelectedLayers() {
      this.copySelectedLayers();
      const s = [...this.selectedLayerIds];
      for (const e of s)
        this.deleteLayer(e);
    },
    /**
     * Update layer properties
     */
    updateLayer(s, e) {
      const n = this.getActiveCompLayers().find((i) => i.id === s);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Update layer-specific data (e.g., text content, image path, etc.)
     */
    updateLayerData(s, e) {
      const n = this.getActiveCompLayers().find((i) => i.id === s);
      !n || !n.data || (Object.assign(n.data, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Add a control point to a spline layer
     */
    addSplineControlPoint(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "spline" || !n.data) return;
      const i = n.data;
      i.controlPoints || (i.controlPoints = []), i.controlPoints.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update a spline control point
     */
    updateSplineControlPoint(s, e, n) {
      var a;
      const i = this.getActiveCompLayers().find((l) => l.id === s);
      if (!i || i.type !== "spline" || !i.data) return;
      const o = (a = i.data.controlPoints) == null ? void 0 : a.find((l) => l.id === e);
      o && (Object.assign(o, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Delete a spline control point
     */
    deleteSplineControlPoint(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "spline" || !n.data) return;
      const i = n.data;
      if (!i.controlPoints) return;
      const r = i.controlPoints.findIndex((o) => o.id === e);
      r >= 0 && (i.controlPoints.splice(r, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle 3D mode for a layer
     */
    toggleLayer3D(s) {
      const e = this.getActiveCompLayers().find((n) => n.id === s);
      if (e) {
        if (e.threeD = !e.threeD, e.threeD) {
          const n = e.transform, i = n.position.value;
          n.position.value = { x: i.x, y: i.y, z: i.z ?? 0 }, n.position.type = "vector3";
          const r = n.anchorPoint.value;
          n.anchorPoint.value = { x: r.x, y: r.y, z: r.z ?? 0 }, n.anchorPoint.type = "vector3";
          const o = n.scale.value;
          n.scale.value = { x: o.x, y: o.y, z: o.z ?? 100 }, n.scale.type = "vector3", n.orientation || (n.orientation = Wt("orientation", { x: 0, y: 0, z: 0 }, "vector3")), n.rotationX || (n.rotationX = Wt("rotationX", 0, "number")), n.rotationY || (n.rotationY = Wt("rotationY", 0, "number")), n.rotationZ || (n.rotationZ = Wt("rotationZ", 0, "number"), n.rotationZ.value = n.rotation.value);
        } else
          e.transform.rotationZ && (e.transform.rotation.value = e.transform.rotationZ.value);
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Reorder layers
     */
    moveLayer(s, e) {
      const n = this.getActiveCompLayers(), i = n.findIndex((o) => o.id === s);
      if (i === -1) return;
      const [r] = n.splice(i, 1);
      n.splice(e, 0, r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Selection
     */
    selectLayer(s, e = !1) {
      e ? this.selectedLayerIds.includes(s) || this.selectedLayerIds.push(s) : this.selectedLayerIds = [s];
    },
    deselectLayer(s) {
      this.selectedLayerIds = this.selectedLayerIds.filter((e) => e !== s);
    },
    /**
     * Set a layer's parent for parenting/hierarchy
     */
    setLayerParent(s, e) {
      const n = this.getActiveCompLayers(), i = n.find((r) => r.id === s);
      if (i && e !== s) {
        if (e) {
          const r = (a) => {
            const l = n.filter((u) => u.parentId === a);
            let c = l.map((u) => u.id);
            for (const u of l)
              c = c.concat(r(u.id));
            return c;
          };
          if (new Set(r(s)).has(e)) {
            Jt.warn("Cannot set parent: would create circular reference");
            return;
          }
        }
        i.parentId = e, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
      }
    },
    clearSelection() {
      this.selectedLayerIds = [], this.selectedKeyframeIds = [], this.selectedPropertyPath = null;
    },
    /**
     * Select a property path for graph editor focus
     */
    selectProperty(s) {
      this.selectedPropertyPath = s;
    },
    /**
     * Playback controls
     */
    play() {
      if (this.isPlaying) return;
      const s = this.getActiveComp();
      s && (this.isPlaying = !0, this.playbackStartTime = performance.now(), this.playbackStartFrame = s.currentFrame, this.playbackLoop());
    },
    pause() {
      this.isPlaying = !1, this.playbackRequestId !== null && (cancelAnimationFrame(this.playbackRequestId), this.playbackRequestId = null);
    },
    togglePlayback() {
      this.isPlaying ? this.pause() : this.play();
    },
    /**
     * Animation loop for playback
     */
    playbackLoop() {
      if (!this.isPlaying) return;
      const s = this.getActiveComp();
      if (!s) return;
      const e = performance.now() - (this.playbackStartTime || 0), n = s.settings.fps, i = s.settings.frameCount, r = Math.floor(e / 1e3 * n);
      let o = this.playbackStartFrame + r;
      o >= i && (o = 0, this.playbackStartFrame = 0, this.playbackStartTime = performance.now()), s.currentFrame = o, this.playbackRequestId = requestAnimationFrame(() => this.playbackLoop());
    },
    setFrame(s) {
      const e = this.getActiveComp();
      e && (e.currentFrame = Math.max(0, Math.min(s, e.settings.frameCount - 1)));
    },
    nextFrame() {
      const s = this.getActiveComp();
      s && s.currentFrame < s.settings.frameCount - 1 && s.currentFrame++;
    },
    prevFrame() {
      const s = this.getActiveComp();
      s && s.currentFrame > 0 && s.currentFrame--;
    },
    goToStart() {
      const s = this.getActiveComp();
      s && (s.currentFrame = 0);
    },
    goToEnd() {
      const s = this.getActiveComp();
      s && (s.currentFrame = s.settings.frameCount - 1);
    },
    /**
     * Tool selection
     */
    setTool(s) {
      this.currentTool = s;
    },
    /**
     * History management
     */
    pushHistory() {
      this.historyIndex < this.historyStack.length - 1 && (this.historyStack = this.historyStack.slice(0, this.historyIndex + 1));
      const s = JSON.parse(JSON.stringify(this.project));
      this.historyStack.push(s), this.historyIndex = this.historyStack.length - 1;
      const e = 50;
      this.historyStack.length > e && (this.historyStack = this.historyStack.slice(-e), this.historyIndex = this.historyStack.length - 1);
    },
    undo() {
      this.historyIndex <= 0 || (this.historyIndex--, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    redo() {
      this.historyIndex >= this.historyStack.length - 1 || (this.historyIndex++, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    /**
     * Project serialization
     */
    exportProject() {
      return JSON.stringify(this.project, null, 2);
    },
    importProject(s) {
      try {
        const e = JSON.parse(s);
        this.project = e, this.pushHistory();
      } catch (e) {
        Jt.error("Failed to import project:", e);
      }
    },
    /**
     * Toggle graph editor visibility
     */
    toggleGraphEditor() {
      this.graphEditorVisible = !this.graphEditorVisible;
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(s) {
      var e;
      return an(s, ((e = this.getActiveComp()) == null ? void 0 : e.currentFrame) ?? 0);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(s, e, n, i) {
      var u, d, h;
      const r = i ?? ((u = this.getActiveComp()) == null ? void 0 : u.currentFrame) ?? 0;
      Jt.debug("addKeyframe called:", { layerId: s, propertyName: e, value: n, frame: r });
      const o = this.getActiveCompLayers().find((m) => m.id === s);
      if (!o)
        return Jt.debug("addKeyframe: layer not found"), null;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : e === "opacity" ? a = o.opacity : a = o.properties.find((m) => m.name === e), !a)
        return Jt.debug("addKeyframe: property not found:", e), null;
      a.animated = !0;
      const l = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: r,
        value: n,
        interpolation: "linear",
        inHandle: { frame: 0, value: 0, enabled: !1 },
        outHandle: { frame: 0, value: 0, enabled: !1 },
        controlMode: "smooth"
      }, c = a.keyframes.findIndex((m) => m.frame === r);
      return c >= 0 ? (a.keyframes[c] = l, Jt.debug("addKeyframe: replaced existing keyframe at frame", ((d = this.getActiveComp()) == null ? void 0 : d.currentFrame) ?? 0)) : (a.keyframes.push(l), a.keyframes.sort((m, p) => m.frame - p.frame), Jt.debug("addKeyframe: added new keyframe at frame", ((h = this.getActiveComp()) == null ? void 0 : h.currentFrame) ?? 0, "total keyframes:", a.keyframes.length)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), l;
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(s, e, n) {
      const i = this.getActiveCompLayers().find((a) => a.id === s);
      if (!i) return;
      let r;
      if (e === "position" || e === "transform.position" ? r = i.transform.position : e === "scale" || e === "transform.scale" ? r = i.transform.scale : e === "rotation" || e === "transform.rotation" ? r = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = i.transform.anchorPoint : e === "opacity" ? r = i.opacity : r = i.properties.find((a) => a.name === e), !r) return;
      const o = r.keyframes.findIndex((a) => a.id === n);
      o >= 0 && (r.keyframes.splice(o, 1), r.keyframes.length === 0 && (r.animated = !1)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set a property's value (for direct editing in timeline)
     */
    setPropertyValue(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i) return;
      let r;
      if (e === "position" || e === "transform.position" ? r = i.transform.position : e === "scale" || e === "transform.scale" ? r = i.transform.scale : e === "rotation" || e === "transform.rotation" ? r = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = i.transform.anchorPoint : e === "opacity" ? r = i.opacity : r = i.properties.find((o) => o.name === e), !!r) {
        if (r.value = n, r.animated && r.keyframes.length > 0) {
          const o = r.keyframes.find((a) => {
            var l;
            return a.frame === (((l = this.getActiveComp()) == null ? void 0 : l.currentFrame) ?? 0);
          });
          o && (o.value = n);
        }
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Set a property's animated state
     */
    setPropertyAnimated(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i) return;
      let r;
      e === "position" || e === "transform.position" ? r = i.transform.position : e === "scale" || e === "transform.scale" ? r = i.transform.scale : e === "rotation" || e === "transform.rotation" ? r = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = i.transform.anchorPoint : e === "opacity" ? r = i.opacity : r = i.properties.find((o) => o.name === e), r && (r.animated = n, n && r.keyframes.length === 0 && this.addKeyframe(s, e, r.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Move a keyframe to a new frame
     */
    moveKeyframe(s, e, n, i) {
      const r = this.getActiveCompLayers().find((c) => c.id === s);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : e === "opacity" ? o = r.opacity : o = r.properties.find((c) => c.name === e), !o) return;
      const a = o.keyframes.find((c) => c.id === n);
      if (!a) return;
      const l = o.keyframes.find((c) => c.frame === i && c.id !== n);
      l && (o.keyframes = o.keyframes.filter((c) => c.id !== l.id)), a.frame = i, o.keyframes.sort((c, u) => c.frame - u.frame), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set keyframe value (for graph editor numeric input)
     */
    setKeyframeValue(s, e, n, i) {
      const r = this.getActiveCompLayers().find((l) => l.id === s);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : e === "opacity" ? o = r.opacity : o = r.properties.find((l) => l.name === e), !o) return;
      const a = o.keyframes.find((l) => l.id === n);
      a && (typeof a.value == "object" && a.value !== null ? Jt.warn("setKeyframeValue: Cannot directly update vector keyframes from graph editor. Use separate dimension curves.") : a.value = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set keyframe interpolation type
     */
    setKeyframeInterpolation(s, e, n, i) {
      const r = this.getActiveCompLayers().find((l) => l.id === s);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : e === "opacity" ? o = r.opacity : o = r.properties.find((l) => l.name === e), !o) return;
      const a = o.keyframes.find((l) => l.id === n);
      a && (a.interpolation = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Update keyframe frame position and/or value
     */
    updateKeyframe(s, e, n, i) {
      const r = this.getActiveCompLayers().find((l) => l.id === s);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "opacity" ? o = r.opacity : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : o = r.properties.find((l) => l.id === e || l.name === e), !o) return;
      const a = o.keyframes.find((l) => l.id === n);
      a && (i.frame !== void 0 && (a.frame = i.frame, o.keyframes.sort((l, c) => l.frame - c.frame)), i.value !== void 0 && (a.value = i.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set keyframe bezier handle
     */
    setKeyframeHandle(s, e, n, i, r) {
      const o = this.getActiveCompLayers().find((c) => c.id === s);
      if (!o) return;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "opacity" ? a = o.opacity : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : a = o.properties.find((c) => c.id === e || c.name === e), !a) return;
      const l = a.keyframes.find((c) => c.id === n);
      l && (i === "in" ? l.inHandle = { ...r } : l.outHandle = { ...r }, r.enabled && l.interpolation === "linear" && (l.interpolation = "bezier"), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(s = "Text") {
      const e = this.createLayer("text", s.substring(0, 20)), n = {
        text: s,
        fontFamily: "Arial",
        fontSize: 72,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        // Character Properties (AE Animator defaults)
        tracking: 0,
        lineSpacing: 0,
        lineAnchor: 0,
        characterOffset: 0,
        characterValue: 0,
        blur: { x: 0, y: 0 },
        // Paragraph (legacy aliases)
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        // Path Options (Full AE Parity)
        pathLayerId: null,
        pathReversed: !1,
        pathPerpendicularToPath: !0,
        pathForceAlignment: !1,
        pathFirstMargin: 0,
        pathLastMargin: 0,
        pathOffset: 0,
        pathAlign: "left",
        // More Options (AE Advanced)
        anchorPointGrouping: "character",
        groupingAlignment: { x: 0, y: 0 },
        fillAndStroke: "fill-over-stroke",
        interCharacterBlending: "normal",
        // 3D Text
        perCharacter3D: !1
      };
      return e.data = n, e.properties.push(Wt("Font Size", 72, "number", "Text")), e.properties.push(Wt("Fill Color", "#ffffff", "color", "Text")), e.properties.push(Wt("Stroke Color", "#000000", "color", "Text")), e.properties.push(Wt("Stroke Width", 0, "number", "Text")), e.properties.push(Wt("Path Offset", 0, "number", "Path Options")), e.properties.push(Wt("First Margin", 0, "number", "Path Options")), e.properties.push(Wt("Last Margin", 0, "number", "Path Options")), e.properties.push(Wt("Grouping Alignment", { x: 0, y: 0 }, "position", "More Options")), e.properties.push(Wt("Tracking", 0, "number", "Advanced")), e.properties.push(Wt("Line Spacing", 0, "number", "Advanced")), e.properties.push(Wt("Character Offset", 0, "number", "Advanced")), e.properties.push(Wt("Character Value", 0, "number", "Advanced")), e.properties.push(Wt("Blur", { x: 0, y: 0 }, "position", "Advanced")), e;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const s = this.createLayer("spline"), e = {
        pathData: "",
        controlPoints: [],
        closed: !1,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      return s.data = e, s;
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const s = this.createLayer("particles", "Particle System"), e = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: !1,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          x: 0.5,
          y: 0.5,
          direction: 270,
          spread: 30,
          speed: 330,
          speedVariance: 50,
          size: 17,
          sizeVariance: 5,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 10,
          enabled: !0,
          burstOnBeat: !1,
          burstCount: 20
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: !1,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: !1,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: !1,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: !1,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: !0
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      return s.data = e, s;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "particles") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "particles") return;
      n.data.emitters.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(s, e, n) {
      const i = this.getActiveCompLayers().find((a) => a.id === s);
      if (!i || i.type !== "particles") return;
      const o = i.data.emitters.find((a) => a.id === e);
      o && (Object.assign(o, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "particles") return;
      const i = n.data;
      i.emitters = i.emitters.filter((r) => r.id !== e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(s = "", e = "") {
      const n = this.createLayer("depthflow", "Depthflow"), i = {
        sourceLayerId: s,
        depthLayerId: e,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: !0
        },
        animatedZoom: Wt("zoom", 1, "number"),
        animatedOffsetX: Wt("offsetX", 0, "number"),
        animatedOffsetY: Wt("offsetY", 0, "number"),
        animatedRotation: Wt("rotation", 0, "number"),
        animatedDepthScale: Wt("depthScale", 1, "number")
      };
      return n.data = i, n;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "depthflow") return;
      const i = n.data;
      Object.assign(i.config, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // VIDEO LAYER ACTIONS
    // ============================================================
    /**
     * Create a video layer from a file
     * Automatically resizes composition to match video dimensions and duration
     *
     * @param file - Video file to import
     * @param autoResizeComposition - If true, resize composition to match video (default: true for first video)
     * @returns The created layer
     */
    async createVideoLayer(s, e = !0) {
      let n;
      try {
        n = URL.createObjectURL(s);
      } catch {
        throw new Error("Failed to create URL for video file");
      }
      let i;
      try {
        i = await VE(n);
      } catch (c) {
        throw URL.revokeObjectURL(n), new Error(`Failed to load video metadata: ${c.message}`);
      }
      const r = `video_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, o = {
        id: r,
        type: "video",
        source: "file",
        width: i.width,
        height: i.height,
        data: n,
        // Video-specific metadata
        duration: i.duration,
        frameCount: i.frameCount,
        fps: i.fps,
        hasAudio: i.hasAudio
      };
      if (this.project.assets[r] = o, e) {
        const c = GE(i, this.project.composition.fps);
        Jt.debug("Auto-resizing composition for video:", {
          originalWidth: this.project.composition.width,
          originalHeight: this.project.composition.height,
          originalFrameCount: this.project.composition.frameCount,
          newWidth: c.width,
          newHeight: c.height,
          newFrameCount: c.frameCount,
          videoDuration: i.duration
        }), this.project.composition.width = c.width, this.project.composition.height = c.height, this.project.composition.frameCount = c.frameCount, this.project.composition.duration = c.frameCount / this.project.composition.fps;
      }
      const a = this.createLayer("video", s.name.replace(/\.[^.]+$/, "")), l = {
        assetId: r,
        loop: !1,
        pingPong: !1,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        timeRemapEnabled: !1,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: i.hasAudio,
        audioLevel: 100,
        posterFrame: 0
      };
      if (a.data = l, !e) {
        const c = Math.ceil(i.duration * this.project.composition.fps);
        a.outPoint = Math.min(c - 1, this.project.composition.frameCount - 1);
      }
      return this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), Jt.debug("Created video layer:", {
        layerId: a.id,
        assetId: r,
        dimensions: `${i.width}x${i.height}`,
        duration: `${i.duration.toFixed(2)}s`,
        frameCount: i.frameCount,
        hasAudio: i.hasAudio
      }), a;
    },
    /**
     * Update video layer data
     */
    updateVideoLayerData(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "video") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Handle video metadata loaded callback from engine
     * Called by LayerManager when a video finishes loading
     */
    onVideoMetadataLoaded(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "video") return;
      const i = n.data;
      if (!i.assetId) return;
      const r = this.project.assets[i.assetId];
      r && (r.width = e.width, r.height = e.height, r.duration = e.duration, r.frameCount = e.frameCount, r.fps = e.fps, r.hasAudio = e.hasAudio), Jt.debug("Video metadata loaded:", { layerId: s, metadata: e });
    },
    /**
     * Resize composition settings
     * Used for manual resize or when importing video
     */
    resizeComposition(s, e, n) {
      const i = this.getActiveComp();
      if (!i) return;
      const r = i.settings.frameCount;
      if (i.settings.width = s, i.settings.height = e, this.project.composition.width = s, this.project.composition.height = e, n !== void 0 && (i.settings.frameCount = n, i.settings.duration = n / i.settings.fps, this.project.composition.frameCount = n, this.project.composition.duration = n / this.project.composition.fps, n > r))
        for (const o of i.layers)
          o.outPoint === r - 1 && (o.outPoint = n - 1);
      i.currentFrame >= i.settings.frameCount && (i.currentFrame = i.settings.frameCount - 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), Jt.debug("Composition resized:", {
        width: s,
        height: e,
        frameCount: i.settings.frameCount
      });
    },
    // ============================================================
    // PRECOMP LAYER ACTIONS
    // ============================================================
    /**
     * Create a precomp layer referencing another composition
     * (For future multi-composition architecture)
     */
    createPrecompLayer(s, e) {
      const n = this.createLayer("precomp", e || "Precomp"), i = {
        compositionId: s,
        timeRemapEnabled: !1,
        timeRemap: void 0,
        collapseTransformations: !1,
        overrideFrameRate: !1,
        frameRate: void 0
      };
      return n.data = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), n;
    },
    /**
     * Update precomp layer data
     */
    updatePrecompLayerData(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "precomp") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // EFFECT ACTIONS
    // ============================================================
    /**
     * Add effect to layer
     */
    addEffectToLayer(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n) return;
      const i = xT(e);
      i && (n.effects || (n.effects = []), n.effects.push(i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Remove effect from layer
     */
    removeEffectFromLayer(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || !n.effects) return;
      const i = n.effects.findIndex((r) => r.id === e);
      i >= 0 && (n.effects.splice(i, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Update effect parameter value
     */
    updateEffectParameter(s, e, n, i) {
      const r = this.getActiveCompLayers().find((a) => a.id === s);
      if (!r || !r.effects) return;
      const o = r.effects.find((a) => a.id === e);
      !o || !o.parameters[n] || (o.parameters[n].value = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle effect parameter animation state
     */
    setEffectParamAnimated(s, e, n, i) {
      const r = this.getActiveCompLayers().find((l) => l.id === s);
      if (!r || !r.effects) return;
      const o = r.effects.find((l) => l.id === e);
      if (!o || !o.parameters[n]) return;
      const a = o.parameters[n];
      a.animated = i, i && (!a.keyframes || a.keyframes.length === 0) && (a.keyframes = [{
        id: `kf_${Date.now()}`,
        frame: this.currentFrame,
        value: a.value,
        interpolation: "linear",
        inHandle: { frame: -5, value: 0, enabled: !1 },
        outHandle: { frame: 5, value: 0, enabled: !1 },
        controlMode: "smooth"
      }]), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Toggle effect enabled state
     */
    toggleEffect(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || !n.effects) return;
      const i = n.effects.find((r) => r.id === e);
      i && (i.enabled = !i.enabled, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Reorder effects in stack
     */
    reorderEffects(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i || !i.effects || e < 0 || e >= i.effects.length || n < 0 || n >= i.effects.length) return;
      const [r] = i.effects.splice(e, 1);
      i.effects.splice(n, 0, r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Get evaluated effect parameter value at a given frame
     */
    getEffectParameterValue(s, e, n, i) {
      var c;
      const r = this.getActiveCompLayers().find((u) => u.id === s);
      if (!r || !r.effects) return null;
      const o = r.effects.find((u) => u.id === e);
      if (!o || !o.parameters[n]) return null;
      const a = o.parameters[n], l = i ?? ((c = this.getActiveComp()) == null ? void 0 : c.currentFrame) ?? 0;
      return a.animated && a.keyframes.length > 0 ? an(a, l) : a.value;
    },
    // ============================================================
    // CAMERA ACTIONS
    // ============================================================
    /**
     * Create a new camera and corresponding layer
     * Returns both the camera and the layer
     */
    createCameraLayer(s) {
      const e = this.getActiveComp(), n = this.getActiveCompLayers(), i = `camera_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, r = s || `Camera ${this.cameras.size + 1}`, o = My(
        i,
        (e == null ? void 0 : e.settings.width) || 1024,
        (e == null ? void 0 : e.settings.height) || 1024
      );
      o.name = r, this.cameras.set(i, o), this.activeCameraId || (this.activeCameraId = i);
      const a = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, l = {
        id: a,
        name: r,
        type: "camera",
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !0,
        // Cameras are always 3D
        motionBlur: !1,
        inPoint: 0,
        outPoint: ((e == null ? void 0 : e.settings.frameCount) || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: Wt("opacity", 100, "number"),
        transform: zd(),
        properties: [],
        effects: [],
        data: {
          cameraId: i,
          isActiveCamera: !this.activeCameraId || this.activeCameraId === i
        }
      };
      return n.unshift(l), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), this.selectLayer(a), { camera: o, layer: l };
    },
    /**
     * Get a camera by ID
     */
    getCamera(s) {
      return this.cameras.get(s) || null;
    },
    /**
     * Update camera properties
     */
    updateCamera(s, e) {
      const n = this.cameras.get(s);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set the active camera
     */
    setActiveCamera(s) {
      if (!this.cameras.has(s)) return;
      this.activeCameraId = s;
      const e = this.getActiveCompLayers();
      for (const n of e)
        if (n.type === "camera" && n.data) {
          const i = n.data;
          i.isActiveCamera = i.cameraId === s;
        }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Delete a camera (and its layer)
     */
    deleteCamera(s) {
      const e = this.getActiveCompLayers(), n = e.findIndex(
        (i) => {
          var r;
          return i.type === "camera" && ((r = i.data) == null ? void 0 : r.cameraId) === s;
        }
      );
      if (n !== -1) {
        const i = e[n].id;
        e.splice(n, 1), this.selectedLayerIds = this.selectedLayerIds.filter((r) => r !== i);
      }
      if (this.cameras.delete(s), this.activeCameraId === s) {
        const i = Array.from(this.cameras.keys());
        this.activeCameraId = i.length > 0 ? i[0] : null, this.activeCameraId && this.setActiveCamera(this.activeCameraId);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Get camera keyframes for a specific camera
     */
    getCameraKeyframes(s) {
      return this.cameraKeyframes.get(s) || [];
    },
    /**
     * Add a keyframe to a camera
     */
    addCameraKeyframe(s, e) {
      let n = this.cameraKeyframes.get(s);
      n || (n = [], this.cameraKeyframes.set(s, n));
      const i = n.findIndex((r) => r.frame === e.frame);
      i >= 0 ? n[i] = e : (n.push(e), n.sort((r, o) => r.frame - o.frame)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Remove a keyframe from a camera
     */
    removeCameraKeyframe(s, e) {
      const n = this.cameraKeyframes.get(s);
      if (!n) return;
      const i = n.findIndex((r) => r.frame === e);
      i >= 0 && (n.splice(i, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Get camera with keyframe interpolation applied at a specific frame
     * This is the main method for getting animated camera values
     */
    getCameraAtFrame(s, e) {
      const n = this.cameras.get(s);
      if (!n) return null;
      const i = this.cameraKeyframes.get(s);
      if (!i || i.length === 0)
        return n;
      const r = ml(n, i, e);
      return {
        ...n,
        position: r.position,
        orientation: r.rotation,
        focalLength: r.focalLength,
        zoom: r.zoom,
        depthOfField: {
          ...n.depthOfField,
          focusDistance: r.focusDistance
        }
      };
    },
    /**
     * Get the active camera with interpolation at current frame
     */
    getActiveCameraAtFrame(s) {
      return this.activeCameraId ? this.getCameraAtFrame(this.activeCameraId, s ?? this.currentFrame) : null;
    },
    /**
     * Update viewport state
     */
    updateViewportState(s) {
      Object.assign(this.viewportState, s);
    },
    /**
     * Update view options
     */
    updateViewOptions(s) {
      Object.assign(this.viewOptions, s);
    },
    // ============================================================
    // AUDIO ACTIONS
    // ============================================================
    /**
     * Load audio file using Web Worker (non-blocking)
     */
    async loadAudio(s) {
      this.audioFile = s, this.audioBuffer = null, this.audioAnalysis = null, this.audioLoadingState = "decoding", this.audioLoadingProgress = 0, this.audioLoadingPhase = "Preparing...", this.audioLoadingError = null;
      try {
        const e = await uT(
          s,
          this.project.composition.fps,
          {
            onProgress: (n) => {
              n.phase === "decoding" ? this.audioLoadingState = "decoding" : this.audioLoadingState = "analyzing", this.audioLoadingProgress = n.progress, this.audioLoadingPhase = n.message;
            }
          }
        );
        this.audioBuffer = e.buffer, this.audioAnalysis = e.analysis, this.audioLoadingState = "complete", this.audioLoadingProgress = 1, this.audioLoadingPhase = "Complete", this.initializeAudioReactiveMapper(), this.propertyDriverSystem && this.audioAnalysis && this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis), Jt.debug("Audio loaded:", {
          duration: this.audioBuffer.duration,
          bpm: this.audioAnalysis.bpm,
          frameCount: this.audioAnalysis.frameCount
        });
      } catch (e) {
        Jt.error("Failed to load audio:", e), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioReactiveMapper = null, this.audioLoadingState = "error", this.audioLoadingError = e.message;
      }
    },
    /**
     * Cancel ongoing audio analysis
     */
    cancelAudioLoad() {
      lT(), this.audioLoadingState = "idle", this.audioLoadingProgress = 0, this.audioLoadingPhase = "", this.audioLoadingError = null;
    },
    /**
     * Clear loaded audio
     */
    clearAudio() {
      this.cancelAudioLoad(), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioMappings.clear();
    },
    /**
     * Get audio feature value at current frame
     */
    getAudioFeatureAtFrame(s, e) {
      var n;
      return this.audioAnalysis ? vl(this.audioAnalysis, s, e ?? ((n = this.getActiveComp()) == null ? void 0 : n.currentFrame) ?? 0) : 0;
    },
    /**
     * Apply audio reactivity mapping to particle layer
     */
    applyAudioToParticles(s, e) {
      const n = this.audioMappings.get(s) || [];
      n.push(e), this.audioMappings.set(s, n);
    },
    /**
     * Remove audio mapping (legacy)
     */
    removeLegacyAudioMapping(s, e) {
      const n = this.audioMappings.get(s);
      n && (n.splice(e, 1), n.length === 0 && this.audioMappings.delete(s));
    },
    /**
     * Get audio mappings for a layer (legacy)
     */
    getAudioMappingsForLayer(s) {
      return this.audioMappings.get(s) || [];
    },
    // ============================================================
    // NEW AUDIO REACTIVE SYSTEM
    // ============================================================
    /**
     * Set peak data
     */
    setPeakData(s) {
      this.peakData = s, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(s);
    },
    /**
     * Detect peaks with config
     */
    detectAudioPeaks(s) {
      if (!this.audioAnalysis) return null;
      const e = this.audioAnalysis.amplitudeEnvelope, n = Ay(e, s);
      return this.peakData = n, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(n), n;
    },
    /**
     * Add new audio mapping
     */
    addAudioMapping(s) {
      this.audioReactiveMappings.push(s), this.audioReactiveMapper && this.audioReactiveMapper.addMapping(s);
    },
    /**
     * Remove audio mapping by ID
     */
    removeAudioMapping(s) {
      const e = this.audioReactiveMappings.findIndex((n) => n.id === s);
      e >= 0 && this.audioReactiveMappings.splice(e, 1), this.audioReactiveMapper && this.audioReactiveMapper.removeMapping(s);
    },
    /**
     * Update audio mapping
     */
    updateAudioMapping(s, e) {
      const n = this.audioReactiveMappings.find((i) => i.id === s);
      n && Object.assign(n, e), this.audioReactiveMapper && this.audioReactiveMapper.updateMapping(s, e);
    },
    /**
     * Get all audio mappings
     */
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    /**
     * Get mapped value at frame
     */
    getMappedValueAtFrame(s, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValueAtFrame(s, e) : 0;
    },
    /**
     * Get all mapped values at current frame
     */
    getAllMappedValuesAtFrame(s) {
      var e;
      return this.audioReactiveMapper ? this.audioReactiveMapper.getAllValuesAtFrame(s ?? ((e = this.getActiveComp()) == null ? void 0 : e.currentFrame) ?? 0) : /* @__PURE__ */ new Map();
    },
    /**
     * Get active mappings for a specific layer
     */
    getActiveMappingsForLayer(s) {
      return this.audioReactiveMappings.filter(
        (e) => e.enabled && (e.targetLayerId === s || e.targetLayerId === void 0)
      );
    },
    /**
     * Get audio reactive values for a specific layer at a specific frame
     * This is called by the engine during frame evaluation
     */
    getAudioReactiveValuesForLayer(s, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValuesForLayerAtFrame(s, e) : /* @__PURE__ */ new Map();
    },
    /**
     * Check if current frame is a beat
     */
    isBeatAtCurrentFrame() {
      var s;
      return this.audioAnalysis ? wv(this.audioAnalysis, ((s = this.getActiveComp()) == null ? void 0 : s.currentFrame) ?? 0) : !1;
    },
    // ============================================================
    // TIMELINE SNAPPING
    // ============================================================
    /**
     * Find nearest snap point for a given frame
     * @param frame - The frame to snap
     * @param pixelsPerFrame - Current zoom level
     * @param selectedLayerId - Currently selected layer (excluded from keyframe snapping)
     */
    findSnapPoint(s, e, n) {
      var i;
      return qf(s, this.snapConfig, e, {
        layers: this.layers,
        selectedLayerId: n,
        currentFrame: ((i = this.getActiveComp()) == null ? void 0 : i.currentFrame) ?? 0,
        audioAnalysis: this.audioAnalysis,
        peakData: this.peakData
      });
    },
    /**
     * Get all beat frames from audio analysis
     */
    getAudioBeatFrames() {
      return TT(this.audioAnalysis);
    },
    /**
     * Get all peak frames from peak data
     */
    getAudioPeakFrames() {
      return AT(this.peakData);
    },
    /**
     * Update snap configuration
     */
    setSnapConfig(s) {
      this.snapConfig = { ...this.snapConfig, ...s };
    },
    /**
     * Toggle snapping enabled
     */
    toggleSnapping() {
      this.snapConfig.enabled = !this.snapConfig.enabled;
    },
    /**
     * Toggle specific snap type
     */
    toggleSnapType(s) {
      const n = {
        grid: "snapToGrid",
        keyframes: "snapToKeyframes",
        beats: "snapToBeats",
        peaks: "snapToPeaks",
        layerBounds: "snapToLayerBounds",
        playhead: "snapToPlayhead"
      }[s];
      n && typeof this.snapConfig[n] == "boolean" && (this.snapConfig[n] = !this.snapConfig[n]);
    },
    // ============================================================
    // PATH ANIMATOR ACTIONS
    // ============================================================
    /**
     * Create path animator for a layer
     */
    createPathAnimator(s, e = {}) {
      const n = new yT(e);
      this.pathAnimators.set(s, n);
    },
    /**
     * Set path for an animator
     */
    setPathAnimatorPath(s, e) {
      const n = this.pathAnimators.get(s);
      n && n.setPath(e);
    },
    /**
     * Update path animator config
     */
    updatePathAnimatorConfig(s, e) {
      const n = this.pathAnimators.get(s);
      n && n.setConfig(e);
    },
    /**
     * Remove path animator
     */
    removePathAnimator(s) {
      this.pathAnimators.delete(s);
    },
    /**
     * Get path animator for layer
     */
    getPathAnimator(s) {
      return this.pathAnimators.get(s);
    },
    /**
     * Update all path animators for current frame
     */
    updatePathAnimators() {
      var i;
      if (!this.audioAnalysis) return;
      const s = ((i = this.getActiveComp()) == null ? void 0 : i.currentFrame) ?? 0, e = vl(this.audioAnalysis, "amplitude", s), n = wv(this.audioAnalysis, s);
      for (const [r, o] of this.pathAnimators)
        o.update(e, n);
    },
    /**
     * Reset all path animators
     */
    resetPathAnimators() {
      for (const s of this.pathAnimators.values())
        s.reset();
    },
    /**
     * Initialize audio reactive mapper when audio is loaded
     */
    initializeAudioReactiveMapper() {
      if (this.audioAnalysis) {
        this.audioReactiveMapper = new fT(this.audioAnalysis);
        for (const s of this.audioReactiveMappings)
          this.audioReactiveMapper.addMapping(s);
        this.peakData && this.audioReactiveMapper.setPeakData(this.peakData);
      }
    },
    // ============================================================
    // PROPERTY DRIVER SYSTEM (Expressions/Links)
    // ============================================================
    /**
     * Initialize the property driver system
     */
    initializePropertyDriverSystem() {
      this.propertyDriverSystem = new wT(), this.propertyDriverSystem.setPropertyGetter((s, e, n) => this.getPropertyValueAtFrame(s, e, n)), this.audioAnalysis && this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis);
      for (const s of this.propertyDrivers)
        this.propertyDriverSystem.addDriver(s);
    },
    /**
     * Get a property value at a specific frame
     * Used by the driver system to read source properties
     */
    getPropertyValueAtFrame(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i) return null;
      const r = e.split(".");
      if (r[0] === "transform") {
        const o = i.transform;
        if (r[1] === "position") {
          const a = an(o.position, n);
          if (r[2] === "x") return a.x;
          if (r[2] === "y") return a.y;
          if (r[2] === "z") return a.z ?? 0;
        }
        if (r[1] === "anchorPoint") {
          const a = an(o.anchorPoint, n);
          if (r[2] === "x") return a.x;
          if (r[2] === "y") return a.y;
          if (r[2] === "z") return a.z ?? 0;
        }
        if (r[1] === "scale") {
          const a = an(o.scale, n);
          if (r[2] === "x") return a.x;
          if (r[2] === "y") return a.y;
          if (r[2] === "z") return a.z ?? 100;
        }
        if (r[1] === "rotation")
          return an(o.rotation, n);
        if (r[1] === "rotationX" && o.rotationX)
          return an(o.rotationX, n);
        if (r[1] === "rotationY" && o.rotationY)
          return an(o.rotationY, n);
        if (r[1] === "rotationZ" && o.rotationZ)
          return an(o.rotationZ, n);
      }
      return r[0] === "opacity" ? an(i.opacity, n) : null;
    },
    /**
     * Get driven property values for a layer at current frame
     */
    getDrivenValuesForLayer(s) {
      var l;
      if (!this.propertyDriverSystem)
        return /* @__PURE__ */ new Map();
      const e = this.getActiveCompLayers().find((c) => c.id === s);
      if (!e) return /* @__PURE__ */ new Map();
      const n = /* @__PURE__ */ new Map(), i = ((l = this.getActiveComp()) == null ? void 0 : l.currentFrame) ?? 0, r = an(e.transform.position, i);
      n.set("transform.position.x", r.x), n.set("transform.position.y", r.y), n.set("transform.position.z", r.z ?? 0);
      const o = an(e.transform.anchorPoint, i);
      n.set("transform.anchorPoint.x", o.x), n.set("transform.anchorPoint.y", o.y), n.set("transform.anchorPoint.z", o.z ?? 0);
      const a = an(e.transform.scale, i);
      return n.set("transform.scale.x", a.x), n.set("transform.scale.y", a.y), n.set("transform.scale.z", a.z ?? 100), n.set("transform.rotation", an(e.transform.rotation, i)), e.transform.rotationX && n.set("transform.rotationX", an(e.transform.rotationX, i)), e.transform.rotationY && n.set("transform.rotationY", an(e.transform.rotationY, i)), e.transform.rotationZ && n.set("transform.rotationZ", an(e.transform.rotationZ, i)), n.set("opacity", an(e.opacity, i)), this.propertyDriverSystem.evaluateLayerDrivers(s, i, n);
    },
    /**
     * Add a property driver
     * Returns false if adding would create a circular dependency
     */
    addPropertyDriver(s) {
      return this.propertyDriverSystem && !this.propertyDriverSystem.addDriver(s) ? (Jt.warn("Cannot add property driver: would create circular dependency"), !1) : (this.propertyDrivers.push(s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), !0);
    },
    /**
     * Create and add an audio-driven property driver
     */
    createAudioPropertyDriver(s, e, n, i = {}) {
      const r = ST(s, e, n, i);
      return this.addPropertyDriver(r), r;
    },
    /**
     * Create and add a property-to-property link
     * Returns null if creating would cause a circular dependency
     */
    createPropertyLink(s, e, n, i, r = {}) {
      const o = MT(
        s,
        e,
        n,
        i,
        r
      );
      return this.addPropertyDriver(o) ? o : null;
    },
    /**
     * Remove a property driver
     */
    removePropertyDriver(s) {
      const e = this.propertyDrivers.findIndex((n) => n.id === s);
      e >= 0 && this.propertyDrivers.splice(e, 1), this.propertyDriverSystem && this.propertyDriverSystem.removeDriver(s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Update a property driver
     */
    updatePropertyDriver(s, e) {
      const n = this.propertyDrivers.find((i) => i.id === s);
      n && Object.assign(n, e), this.propertyDriverSystem && this.propertyDriverSystem.updateDriver(s, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Get all drivers for a layer
     */
    getDriversForLayer(s) {
      return this.propertyDrivers.filter((e) => e.targetLayerId === s);
    },
    /**
     * Toggle driver enabled state
     */
    togglePropertyDriver(s) {
      const e = this.propertyDrivers.find((n) => n.id === s);
      e && (e.enabled = !e.enabled, this.propertyDriverSystem && this.propertyDriverSystem.updateDriver(s, { enabled: e.enabled }), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    }
  }
});
async function Mv(s) {
  try {
    const e = await s.requestDevice(), n = e.limits.maxBufferSize;
    return e.destroy(), Math.round(n * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function PT() {
  if ("gpu" in navigator)
    try {
      const i = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (i) {
        let r = "";
        if ("info" in i) {
          const o = i.info;
          r = (o == null ? void 0 : o.device) || (o == null ? void 0 : o.description) || "";
        }
        return r.includes("RTX 50") || r.toLowerCase().includes("blackwell") || r.includes("B100") || r.includes("B200") ? {
          tier: "blackwell",
          vram: await Mv(i),
          features: ["fp4_tensor", "webgpu", "cuda_12"]
        } : {
          tier: "webgpu",
          vram: await Mv(i),
          features: ["webgpu"]
        };
      }
    } catch (n) {
      ts.warn("WebGPU detection failed:", n);
    }
  const e = document.createElement("canvas").getContext("webgl2");
  if (e) {
    const n = e.getExtension("WEBGL_debug_renderer_info"), i = n ? e.getParameter(n.UNMASKED_RENDERER_WEBGL) : "Unknown";
    return ts.debug("WebGL renderer:", i), {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}
const RT = { class: "project-panel" }, DT = { class: "panel-header" }, kT = { class: "header-actions" }, IT = { class: "dropdown-container" }, LT = {
  key: 0,
  class: "dropdown-menu"
}, FT = {
  key: 0,
  class: "search-bar"
}, UT = { class: "panel-content" }, OT = { class: "folder-tree" }, zT = ["onClick", "onDblclick"], NT = ["onClick"], BT = { class: "folder-name" }, VT = { class: "item-count" }, GT = {
  key: 0,
  class: "folder-contents"
}, HT = ["onClick", "onDblclick", "onDragstart"], $T = { class: "item-icon" }, WT = { class: "item-name" }, XT = { class: "item-info" }, jT = ["onClick", "onDblclick", "onDragstart"], YT = { class: "item-icon" }, qT = { class: "item-name" }, ZT = { class: "item-info" }, KT = {
  key: 0,
  class: "empty-state"
}, JT = {
  key: 1,
  class: "panel-footer"
}, QT = { class: "item-details" }, eA = { class: "detail-label" }, tA = { class: "detail-info" }, nA = /* @__PURE__ */ Ot({
  __name: "ProjectPanel",
  emits: ["openCompositionSettings"],
  setup(s, { emit: e }) {
    const n = e, i = sn(), r = we(null), o = we(!1), a = we(!1), l = we(""), c = we(null), u = we(["compositions", "footage"]), d = we([
      {
        id: "compositions",
        name: "Compositions",
        items: [
          { id: "comp-1", name: "Main Comp", type: "composition", width: 1920, height: 1080, fps: 30, duration: 300 }
        ]
      },
      {
        id: "footage",
        name: "Footage",
        items: []
      },
      {
        id: "solids",
        name: "Solids",
        items: []
      }
    ]), h = we([]), m = Ie(() => {
      if (!l.value) return d.value;
      const R = l.value.toLowerCase();
      return d.value.map((O) => ({
        ...O,
        items: O.items.filter(
          (A) => A.name.toLowerCase().includes(R)
        )
      })).filter((O) => O.items.length > 0 || O.name.toLowerCase().includes(R));
    }), p = Ie(() => {
      if (!l.value) return h.value;
      const R = l.value.toLowerCase();
      return h.value.filter(
        (O) => O.name.toLowerCase().includes(R)
      );
    }), v = Ie(() => {
      if (!c.value) return null;
      for (const O of d.value) {
        const A = O.items.find((G) => G.id === c.value);
        if (A)
          return {
            name: A.name,
            info: D(A)
          };
      }
      const R = h.value.find((O) => O.id === c.value);
      return R ? {
        name: R.name,
        info: D(R)
      } : null;
    });
    function x(R) {
      const O = u.value.indexOf(R);
      O >= 0 ? u.value.splice(O, 1) : u.value.push(R);
    }
    function g(R) {
      c.value = R;
    }
    function _(R) {
      R.type === "composition" && console.log("Opening composition:", R.name);
    }
    function M() {
      a.value = !1, n("openCompositionSettings");
    }
    function S() {
      a.value = !1;
      const R = i.createLayer("solid", "Solid");
      console.log("[ProjectPanel] Created solid layer:", R.id);
    }
    function b() {
      a.value = !1;
      const R = i.createTextLayer("Text");
      console.log("[ProjectPanel] Created text layer:", R.id);
    }
    function C() {
      a.value = !1;
      const R = i.createLayer("null", "Null");
      console.log("[ProjectPanel] Created null layer:", R.id);
    }
    function E() {
      a.value = !1;
      const R = i.createSplineLayer();
      console.log("[ProjectPanel] Created spline layer:", R.id);
    }
    function P() {
      var R;
      (R = r.value) == null || R.click();
    }
    async function T(R) {
      const O = R.target, A = O.files;
      if (!(!A || A.length === 0)) {
        for (const G of Array.from(A)) {
          const ue = y(G), Q = {
            id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            name: G.name,
            type: ue
          };
          if (ue === "audio")
            i.loadAudio(G);
          else if (G.type.startsWith("video/"))
            try {
              const re = await i.createVideoLayer(G, !0);
              Q.id = re.id, Q.width = i.width, Q.height = i.height, Q.duration = i.frameCount, Q.fps = i.fps, console.log("[ProjectPanel] Video layer created:", re.id, re.name);
            } catch (re) {
              console.error("[ProjectPanel] Failed to import video:", re);
              continue;
            }
          else if (G.type.startsWith("image/")) {
            const re = URL.createObjectURL(G), j = `image_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            i.project.assets[j] = {
              id: j,
              type: "image",
              source: "file",
              width: 0,
              // Will be updated when image loads
              height: 0,
              data: re
            };
            const $ = i.createLayer("image", G.name.replace(/\.[^.]+$/, ""));
            $.data = { assetId: j }, Q.id = $.id;
          }
          const le = d.value.find((re) => re.id === "footage");
          le ? le.items.push(Q) : h.value.push(Q), console.log("[ProjectPanel] Imported:", G.name, ue);
        }
        O.value = "";
      }
    }
    function y(R) {
      const O = R.type;
      return O.startsWith("audio/") ? "audio" : (O.startsWith("video/") || O.startsWith("image/"), "footage");
    }
    function w(R) {
      return {
        composition: "",
        footage: "",
        solid: "",
        audio: "",
        folder: ""
      }[R] || "";
    }
    function D(R) {
      if (R.type === "composition" || R.type === "footage") {
        const O = [];
        if (R.width && R.height && O.push(`${R.width}${R.height}`), R.fps && O.push(`${R.fps}fps`), R.duration) {
          const A = R.duration / (R.fps || 30);
          O.push(`${A.toFixed(1)}s`);
        }
        return O.join("  ");
      }
      return "";
    }
    function U(R, O) {
      var A;
      (A = O.dataTransfer) == null || A.setData("application/project-item", JSON.stringify(R));
    }
    return (R, O) => (te(), ae("div", RT, [
      f("div", DT, [
        O[3] || (O[3] = f("span", { class: "panel-title" }, "Project", -1)),
        f("div", kT, [
          f("button", {
            onClick: P,
            title: "Import File (Ctrl+I)"
          }, ""),
          f("div", IT, [
            f("button", {
              onClick: O[0] || (O[0] = (A) => a.value = !a.value),
              title: "New Item"
            }, "+"),
            a.value ? (te(), ae("div", LT, [
              f("button", { onClick: M }, " New Composition"),
              f("button", { onClick: S }, " New Solid"),
              f("button", { onClick: b }, "T New Text"),
              f("button", { onClick: C }, " New Null"),
              f("button", { onClick: E }, " New Spline")
            ])) : Pe("", !0)
          ]),
          f("button", {
            onClick: O[1] || (O[1] = (A) => o.value = !o.value),
            title: "Search"
          }, "")
        ])
      ]),
      f("input", {
        ref_key: "fileInputRef",
        ref: r,
        type: "file",
        multiple: "",
        accept: "image/*,video/*,audio/*,.json",
        style: { display: "none" },
        onChange: T
      }, null, 544),
      o.value ? (te(), ae("div", FT, [
        st(f("input", {
          type: "text",
          "onUpdate:modelValue": O[2] || (O[2] = (A) => l.value = A),
          placeholder: "Search project...",
          class: "search-input"
        }, null, 512), [
          [Ut, l.value]
        ])
      ])) : Pe("", !0),
      f("div", UT, [
        f("div", OT, [
          (te(!0), ae(qe, null, ot(m.value, (A) => (te(), ae("div", {
            key: A.id,
            class: "folder-item"
          }, [
            f("div", {
              class: Fe(["folder-header", { selected: c.value === A.id }]),
              onClick: (G) => g(A.id),
              onDblclick: (G) => x(A.id)
            }, [
              f("span", {
                class: "expand-icon",
                onClick: _t((G) => x(A.id), ["stop"])
              }, xe(u.value.includes(A.id) ? "" : ""), 9, NT),
              O[4] || (O[4] = f("span", { class: "folder-icon" }, "", -1)),
              f("span", BT, xe(A.name), 1),
              f("span", VT, xe(A.items.length), 1)
            ], 42, zT),
            u.value.includes(A.id) ? (te(), ae("div", GT, [
              (te(!0), ae(qe, null, ot(A.items, (G) => (te(), ae("div", {
                key: G.id,
                class: Fe(["project-item", { selected: c.value === G.id }]),
                onClick: (ue) => g(G.id),
                onDblclick: (ue) => _(G),
                draggable: "true",
                onDragstart: (ue) => U(G, ue)
              }, [
                f("span", $T, xe(w(G.type)), 1),
                f("span", WT, xe(G.name), 1),
                f("span", XT, xe(D(G)), 1)
              ], 42, HT))), 128))
            ])) : Pe("", !0)
          ]))), 128)),
          (te(!0), ae(qe, null, ot(p.value, (A) => (te(), ae("div", {
            key: A.id,
            class: Fe(["project-item", { selected: c.value === A.id }]),
            onClick: (G) => g(A.id),
            onDblclick: (G) => _(A),
            draggable: "true",
            onDragstart: (G) => U(A, G)
          }, [
            f("span", YT, xe(w(A.type)), 1),
            f("span", qT, xe(A.name), 1),
            f("span", ZT, xe(D(A)), 1)
          ], 42, jT))), 128))
        ]),
        h.value.length === 0 ? (te(), ae("div", KT, [...O[5] || (O[5] = [
          f("p", null, "No items in project", -1),
          f("p", { class: "hint" }, "Import footage or create compositions", -1)
        ])])) : Pe("", !0)
      ]),
      v.value ? (te(), ae("div", JT, [
        f("div", QT, [
          f("span", eA, xe(v.value.name), 1),
          f("span", tA, xe(v.value.info), 1)
        ])
      ])) : Pe("", !0)
    ]));
  }
}), Gt = (s, e) => {
  const n = s.__vccOpts || s;
  for (const [i, r] of e)
    n[i] = r;
  return n;
}, iA = /* @__PURE__ */ Gt(nA, [["__scopeId", "data-v-8f208c83"]]), sA = { class: "effects-panel" }, rA = { class: "panel-header" }, oA = { class: "header-actions" }, aA = { class: "panel-content" }, lA = { class: "tabs" }, cA = {
  key: 0,
  class: "effects-list"
}, uA = ["onClick"], dA = { class: "expand-icon" }, hA = { class: "category-icon" }, fA = { class: "category-name" }, pA = { class: "effect-count" }, mA = {
  key: 0,
  class: "category-effects"
}, vA = ["onDblclick", "onDragstart"], gA = { class: "effect-name" }, yA = ["onClick", "title"], _A = {
  key: 1,
  class: "presets-list"
}, xA = ["onClick"], bA = { class: "expand-icon" }, wA = { class: "category-name" }, SA = { class: "preset-count" }, MA = {
  key: 0,
  class: "category-presets"
}, CA = ["onDblclick", "onDragstart"], EA = { class: "preset-info" }, TA = { class: "preset-name" }, AA = { class: "preset-description" }, PA = {
  key: 2,
  class: "favorites-list"
}, RA = {
  key: 0,
  class: "empty-favorites"
}, DA = ["onDblclick", "onDragstart"], kA = { class: "category-badge" }, IA = { class: "effect-name" }, LA = ["onClick"], FA = /* @__PURE__ */ Ot({
  __name: "EffectsPanel",
  setup(s) {
    const e = sn(), n = we("effects"), i = we(""), r = we(["blur-sharpen", "color-correction"]), o = we(["Fade", "Scale"]), a = we([]);
    _n(() => {
      const b = localStorage.getItem("effect-favorites");
      if (b)
        try {
          a.value = JSON.parse(b);
        } catch {
          a.value = [];
        }
    });
    function l() {
      localStorage.setItem("effect-favorites", JSON.stringify(a.value));
    }
    const c = Ie(() => Object.entries(au).map(([b, C]) => ({
      key: b,
      name: C.name,
      category: C.category,
      description: C.description
    }))), u = Ie(() => {
      const b = i.value.toLowerCase();
      return Object.entries(Kh).map(([C, E]) => {
        const P = c.value.filter((T) => !(T.category !== C || b && !T.name.toLowerCase().includes(b)));
        return {
          key: C,
          label: E.label,
          icon: E.icon,
          effects: P
        };
      }).filter((C) => C.effects.length > 0);
    }), d = Ie(() => {
      const b = i.value.toLowerCase(), C = {};
      for (const E of bT)
        b && !E.name.toLowerCase().includes(b) || (C[E.category] || (C[E.category] = []), C[E.category].push(E));
      return Object.entries(C).map(([E, P]) => ({
        category: E,
        presets: P
      }));
    }), h = Ie(() => c.value.filter((b) => a.value.includes(b.key)));
    function m(b) {
      const C = r.value.indexOf(b);
      C >= 0 ? r.value.splice(C, 1) : r.value.push(b);
    }
    function p(b) {
      const C = o.value.indexOf(b);
      C >= 0 ? o.value.splice(C, 1) : o.value.push(b);
    }
    function v(b) {
      const C = a.value.indexOf(b);
      C >= 0 ? a.value.splice(C, 1) : a.value.push(b), l();
    }
    function x(b) {
      var C;
      return ((C = Kh[b]) == null ? void 0 : C.icon) || "?";
    }
    function g(b) {
      const C = e.selectedLayer;
      if (!C) {
        console.warn("No layer selected to apply effect");
        return;
      }
      e.addEffectToLayer(C.id, b);
    }
    function _(b) {
      const C = e.selectedLayer;
      if (!C || !e.getActiveComp()) return;
      const P = C.inPoint, y = C.outPoint - P;
      for (const w of b.keyframes)
        for (const D of w.keyframes) {
          const U = Math.round(P + D.time * y);
          e.addKeyframe(C.id, w.property, D.value, U);
        }
    }
    function M(b, C) {
      var E;
      (E = C.dataTransfer) == null || E.setData("application/effect", b);
    }
    function S(b, C) {
      var E;
      (E = C.dataTransfer) == null || E.setData("application/preset", JSON.stringify(b));
    }
    return (b, C) => (te(), ae("div", sA, [
      f("div", rA, [
        C[4] || (C[4] = f("span", { class: "panel-title" }, "Effects & Presets", -1)),
        f("div", oA, [
          st(f("input", {
            type: "text",
            "onUpdate:modelValue": C[0] || (C[0] = (E) => i.value = E),
            placeholder: "Search...",
            class: "search-input"
          }, null, 512), [
            [Ut, i.value]
          ])
        ])
      ]),
      f("div", aA, [
        f("div", lA, [
          f("button", {
            class: Fe({ active: n.value === "effects" }),
            onClick: C[1] || (C[1] = (E) => n.value = "effects")
          }, " Effects ", 2),
          f("button", {
            class: Fe({ active: n.value === "presets" }),
            onClick: C[2] || (C[2] = (E) => n.value = "presets")
          }, " Presets ", 2),
          f("button", {
            class: Fe({ active: n.value === "favorites" }),
            onClick: C[3] || (C[3] = (E) => n.value = "favorites")
          }, " Favorites ", 2)
        ]),
        n.value === "effects" ? (te(), ae("div", cA, [
          (te(!0), ae(qe, null, ot(u.value, (E) => (te(), ae("div", {
            key: E.key,
            class: "effect-category"
          }, [
            f("div", {
              class: "category-header",
              onClick: (P) => m(E.key)
            }, [
              f("span", dA, xe(r.value.includes(E.key) ? "" : ""), 1),
              f("span", hA, xe(E.icon), 1),
              f("span", fA, xe(E.label), 1),
              f("span", pA, xe(E.effects.length), 1)
            ], 8, uA),
            r.value.includes(E.key) ? (te(), ae("div", mA, [
              (te(!0), ae(qe, null, ot(E.effects, (P) => (te(), ae("div", {
                key: P.key,
                class: Fe(["effect-item", { favorite: a.value.includes(P.key) }]),
                onDblclick: (T) => g(P.key),
                onDragstart: (T) => M(P.key, T),
                draggable: "true"
              }, [
                f("span", gA, xe(P.name), 1),
                f("button", {
                  class: "favorite-btn",
                  onClick: _t((T) => v(P.key), ["stop"]),
                  title: a.value.includes(P.key) ? "Remove from favorites" : "Add to favorites"
                }, xe(a.value.includes(P.key) ? "" : ""), 9, yA)
              ], 42, vA))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : n.value === "presets" ? (te(), ae("div", _A, [
          (te(!0), ae(qe, null, ot(d.value, (E) => (te(), ae("div", {
            key: E.category,
            class: "preset-category"
          }, [
            f("div", {
              class: "category-header",
              onClick: (P) => p(E.category)
            }, [
              f("span", bA, xe(o.value.includes(E.category) ? "" : ""), 1),
              f("span", wA, xe(E.category), 1),
              f("span", SA, xe(E.presets.length), 1)
            ], 8, xA),
            o.value.includes(E.category) ? (te(), ae("div", MA, [
              (te(!0), ae(qe, null, ot(E.presets, (P) => (te(), ae("div", {
                key: P.id,
                class: "preset-item",
                onDblclick: (T) => _(P),
                onDragstart: (T) => S(P, T),
                draggable: "true"
              }, [
                C[5] || (C[5] = f("div", { class: "preset-preview" }, [
                  f("span", { class: "preview-icon" }, "")
                ], -1)),
                f("div", EA, [
                  f("span", TA, xe(P.name), 1),
                  f("span", AA, xe(P.description), 1)
                ])
              ], 40, CA))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : n.value === "favorites" ? (te(), ae("div", PA, [
          h.value.length === 0 ? (te(), ae("div", RA, [...C[6] || (C[6] = [
            f("p", null, "No favorites yet", -1),
            f("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
          ])])) : Pe("", !0),
          (te(!0), ae(qe, null, ot(h.value, (E) => (te(), ae("div", {
            key: E.key,
            class: "effect-item",
            onDblclick: (P) => g(E.key),
            onDragstart: (P) => M(E.key, P),
            draggable: "true"
          }, [
            f("span", kA, xe(x(E.category)), 1),
            f("span", IA, xe(E.name), 1),
            f("button", {
              class: "favorite-btn active",
              onClick: _t((P) => v(E.key), ["stop"])
            }, "  ", 8, LA)
          ], 40, DA))), 128))
        ])) : Pe("", !0)
      ]),
      C[7] || (C[7] = f("div", { class: "panel-footer" }, [
        f("span", { class: "info-text" }, "Double-click or drag to apply")
      ], -1))
    ]));
  }
}), UA = /* @__PURE__ */ Gt(FA, [["__scopeId", "data-v-5e081b38"]]), OA = ["value", "min", "max", "step", "disabled"], zA = {
  key: 1,
  class: "scrub-unit"
}, NA = /* @__PURE__ */ Ot({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -1 / 0 },
    max: { default: 1 / 0 },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we(!1), o = we(0), a = we(0), l = Ie(() => n.default ?? n.modelValue), c = Ie(() => n.default !== void 0), u = Ie(() => Number.isInteger(n.modelValue) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function d(S) {
      return Math.max(n.min, Math.min(n.max, S));
    }
    function h(S) {
      const b = Math.pow(10, n.precision);
      return Math.round(S * b) / b;
    }
    function m(S) {
      n.disabled || (r.value = !0, o.value = S.clientX, a.value = n.modelValue, document.addEventListener("mousemove", p), document.addEventListener("mouseup", v), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function p(S) {
      const b = S.clientX - o.value;
      let C = n.sensitivity;
      S.shiftKey && (C *= 10), (S.ctrlKey || S.metaKey) && (C *= 0.1);
      const E = b * n.step * C * 0.5, P = h(d(a.value + E));
      P !== n.modelValue && i("update:modelValue", P);
    }
    function v() {
      r.value = !1, document.removeEventListener("mousemove", p), document.removeEventListener("mouseup", v), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function x(S) {
      const b = S.target, C = parseFloat(b.value);
      isNaN(C) || i("update:modelValue", h(d(C)));
    }
    function g(S) {
      if (n.disabled) return;
      let b = 0;
      S.key === "ArrowUp" ? b = n.step : S.key === "ArrowDown" && (b = -n.step), b !== 0 && (S.preventDefault(), S.shiftKey && (b *= 10), (S.ctrlKey || S.metaKey) && (b *= 0.1), i("update:modelValue", h(d(n.modelValue + b))));
    }
    function _(S) {
      const b = S.target, C = parseFloat(b.value);
      isNaN(C) && (b.value = u.value.toString());
    }
    function M() {
      n.default !== void 0 && i("update:modelValue", n.default);
    }
    return (S, b) => (te(), ae("div", {
      class: Fe(["scrubable-number", { disabled: s.disabled }])
    }, [
      s.label ? (te(), ae("label", {
        key: 0,
        class: Fe(["scrub-label", { scrubbing: r.value }]),
        onMousedown: m
      }, xe(s.label), 35)) : Pe("", !0),
      f("input", {
        type: "number",
        class: "scrub-input",
        value: u.value,
        min: s.min,
        max: s.max,
        step: s.step,
        disabled: s.disabled,
        onInput: x,
        onKeydown: g,
        onBlur: _
      }, null, 40, OA),
      s.unit ? (te(), ae("span", zA, xe(s.unit), 1)) : Pe("", !0),
      c.value && s.modelValue !== l.value ? (te(), ae("button", {
        key: 2,
        class: "reset-btn",
        onClick: M,
        title: "Reset to default"
      }, [...b[0] || (b[0] = [
        f("i", { class: "pi pi-refresh" }, null, -1)
      ])])) : Pe("", !0)
    ], 2));
  }
}), et = /* @__PURE__ */ Gt(NA, [["__scopeId", "data-v-dcc786e6"]]), BA = ["value", "min", "max", "step", "disabled"], VA = {
  key: 2,
  class: "slider-unit"
}, GA = /* @__PURE__ */ Ot({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: !0 },
    gradient: {},
    disabled: { type: Boolean, default: !1 },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we(null), o = we(!1), a = we(!1), l = we(0), c = we(0), u = Ie(() => {
      const E = n.max - n.min;
      return E === 0 ? 0 : (n.modelValue - n.min) / E * 100;
    }), d = Ie(() => Number.isInteger(n.step) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function h(E) {
      return Math.max(n.min, Math.min(n.max, E));
    }
    function m(E) {
      const P = Math.pow(10, n.precision);
      return Math.round(E * P) / P;
    }
    function p(E) {
      n.disabled || (o.value = !0, l.value = E.clientX, c.value = n.modelValue, document.addEventListener("mousemove", v), document.addEventListener("mouseup", x), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function v(E) {
      const P = E.clientX - l.value, T = n.max - n.min;
      let y = 1;
      E.shiftKey && (y *= 10), (E.ctrlKey || E.metaKey) && (y *= 0.1);
      const w = P / 200 * T * y, D = m(h(c.value + w));
      D !== n.modelValue && i("update:modelValue", D);
    }
    function x() {
      o.value = !1, document.removeEventListener("mousemove", v), document.removeEventListener("mouseup", x), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function g(E) {
      if (n.disabled || !r.value) return;
      const P = r.value.getBoundingClientRect(), T = (E.clientX - P.left) / P.width, y = n.min + T * (n.max - n.min);
      i("update:modelValue", m(h(y)));
    }
    function _(E) {
      n.disabled || (a.value = !0, document.addEventListener("mousemove", M), document.addEventListener("mouseup", S), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function M(E) {
      if (!r.value) return;
      const P = r.value.getBoundingClientRect(), T = (E.clientX - P.left) / P.width, y = n.min + Math.max(0, Math.min(1, T)) * (n.max - n.min);
      i("update:modelValue", m(h(y)));
    }
    function S() {
      a.value = !1, document.removeEventListener("mousemove", M), document.removeEventListener("mouseup", S), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function b(E) {
      const P = E.target, T = parseFloat(P.value);
      isNaN(T) || i("update:modelValue", m(h(T)));
    }
    function C(E) {
      const P = E.target, T = parseFloat(P.value);
      isNaN(T) && (P.value = d.value.toString());
    }
    return (E, P) => (te(), ae("div", {
      class: Fe(["slider-input", { disabled: s.disabled }])
    }, [
      s.label ? (te(), ae("label", {
        key: 0,
        class: Fe(["slider-label", { scrubbing: o.value }]),
        onMousedown: p
      }, xe(s.label), 35)) : Pe("", !0),
      f("div", {
        class: "slider-track",
        ref_key: "trackRef",
        ref: r,
        onMousedown: g
      }, [
        f("div", {
          class: "slider-fill",
          style: yt({ width: u.value + "%", background: s.gradient || void 0 })
        }, null, 4),
        f("div", {
          class: "slider-thumb",
          style: yt({ left: u.value + "%" }),
          onMousedown: _t(_, ["stop"])
        }, null, 36)
      ], 544),
      s.showValue ? (te(), ae("input", {
        key: 1,
        type: "number",
        class: "slider-value",
        value: d.value,
        min: s.min,
        max: s.max,
        step: s.step,
        disabled: s.disabled,
        onInput: b,
        onBlur: C
      }, null, 40, BA)) : Pe("", !0),
      s.unit ? (te(), ae("span", VA, xe(s.unit), 1)) : Pe("", !0)
    ], 2));
  }
}), jn = /* @__PURE__ */ Gt(GA, [["__scopeId", "data-v-9dd40416"]]), HA = { class: "dial-marks" }, $A = {
  key: 0,
  class: "angle-value"
}, WA = ["value", "disabled"], XA = /* @__PURE__ */ Ot({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we(null), o = we(!1), a = Ie(() => Math.round(n.modelValue * 10) / 10);
    function l(v) {
      return (v % 360 + 360) % 360;
    }
    function c(v) {
      n.disabled || (o.value = !0, d(v), document.addEventListener("mousemove", u), document.addEventListener("mouseup", h), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function u(v) {
      o.value && d(v);
    }
    function d(v) {
      if (!r.value) return;
      const x = r.value.getBoundingClientRect(), g = x.left + x.width / 2, _ = x.top + x.height / 2, M = v.clientX - g, S = v.clientY - _;
      let b = Math.atan2(M, -S) * (180 / Math.PI);
      b = l(b), v.shiftKey && (b = Math.round(b / 45) * 45), i("update:modelValue", b);
    }
    function h() {
      o.value = !1, document.removeEventListener("mousemove", u), document.removeEventListener("mouseup", h), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function m(v) {
      const x = v.target, g = parseFloat(x.value);
      isNaN(g) || i("update:modelValue", l(g));
    }
    function p(v) {
      const x = v.target, g = parseFloat(x.value);
      isNaN(g) && (x.value = a.value.toString());
    }
    return (v, x) => (te(), ae("div", {
      class: Fe(["angle-dial", { disabled: s.disabled }])
    }, [
      f("div", {
        class: "dial",
        ref_key: "dialRef",
        ref: r,
        style: yt({ width: s.size + "px", height: s.size + "px" }),
        onMousedown: c
      }, [
        x[0] || (x[0] = f("div", { class: "dial-ring" }, null, -1)),
        x[1] || (x[1] = f("div", { class: "dial-center" }, null, -1)),
        f("div", {
          class: "dial-indicator",
          style: yt({ transform: `rotate(${s.modelValue}deg)` })
        }, null, 4),
        f("div", HA, [
          (te(), ae(qe, null, ot(8, (g) => f("div", {
            class: "dial-mark",
            key: g,
            style: yt({ transform: `rotate(${g * 45}deg)` })
          }, null, 4)), 64))
        ])
      ], 36),
      s.showValue ? (te(), ae("div", $A, [
        f("input", {
          type: "number",
          class: "angle-input",
          value: a.value,
          disabled: s.disabled,
          onInput: m,
          onBlur: p
        }, null, 40, WA),
        x[2] || (x[2] = f("span", { class: "angle-unit" }, "", -1))
      ])) : Pe("", !0)
    ], 2));
  }
}), Zf = /* @__PURE__ */ Gt(XA, [["__scopeId", "data-v-04a5caf6"]]);
function Cv(s, e, n) {
  s = (s % 360 + 360) % 360;
  const i = n * e, r = i * (1 - Math.abs(s / 60 % 2 - 1)), o = n - i;
  let a = 0, l = 0, c = 0;
  return s < 60 ? (a = i, l = r, c = 0) : s < 120 ? (a = r, l = i, c = 0) : s < 180 ? (a = 0, l = i, c = r) : s < 240 ? (a = 0, l = r, c = i) : s < 300 ? (a = r, l = 0, c = i) : (a = i, l = 0, c = r), [
    Math.round((a + o) * 255),
    Math.round((l + o) * 255),
    Math.round((c + o) * 255)
  ];
}
function gs(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), r = Math.min(s, e, n), o = i - r;
  let a = 0;
  const l = i === 0 ? 0 : o / i, c = i;
  if (o !== 0)
    switch (i) {
      case s:
        a = ((e - n) / o + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        a = ((n - s) / o + 2) * 60;
        break;
      case n:
        a = ((s - e) / o + 4) * 60;
        break;
    }
  return [a, l, c];
}
function fc(s, e, n) {
  s = (s % 360 + 360) % 360;
  const i = (1 - Math.abs(2 * n - 1)) * e, r = i * (1 - Math.abs(s / 60 % 2 - 1)), o = n - i / 2;
  let a = 0, l = 0, c = 0;
  return s < 60 ? (a = i, l = r, c = 0) : s < 120 ? (a = r, l = i, c = 0) : s < 180 ? (a = 0, l = i, c = r) : s < 240 ? (a = 0, l = r, c = i) : s < 300 ? (a = r, l = 0, c = i) : (a = i, l = 0, c = r), [
    Math.round((a + o) * 255),
    Math.round((l + o) * 255),
    Math.round((c + o) * 255)
  ];
}
function br(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), r = Math.min(s, e, n), o = (i + r) / 2;
  let a = 0, l = 0;
  if (i !== r) {
    const c = i - r;
    switch (l = o > 0.5 ? c / (2 - i - r) : c / (i + r), i) {
      case s:
        a = ((e - n) / c + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        a = ((n - s) / c + 2) * 60;
        break;
      case n:
        a = ((s - e) / c + 4) * 60;
        break;
    }
  }
  return [a, l, o];
}
function jA(s) {
  if (s = s.replace(/^#/, ""), s.length === 3 && (s = s[0] + s[0] + s[1] + s[1] + s[2] + s[2]), s.length === 6 || s.length === 8) {
    const e = parseInt(s.slice(0, 2), 16), n = parseInt(s.slice(2, 4), 16), i = parseInt(s.slice(4, 6), 16);
    if (!isNaN(e) && !isNaN(n) && !isNaN(i))
      return [e, n, i];
  }
  return null;
}
function YA(s) {
  if (s = s.replace(/^#/, ""), s.length === 3 && (s = s[0] + s[0] + s[1] + s[1] + s[2] + s[2] + "ff"), s.length === 6 && (s = s + "ff"), s.length === 8) {
    const e = parseInt(s.slice(0, 2), 16), n = parseInt(s.slice(2, 4), 16), i = parseInt(s.slice(4, 6), 16), r = parseInt(s.slice(6, 8), 16) / 255;
    if (!isNaN(e) && !isNaN(n) && !isNaN(i) && !isNaN(r))
      return [e, n, i, r];
  }
  return null;
}
function qA(s, e, n) {
  const i = (r) => Math.max(0, Math.min(255, Math.round(r))).toString(16).padStart(2, "0");
  return `#${i(s)}${i(e)}${i(n)}`;
}
function ZA(s, e, n, i) {
  const r = (o) => Math.max(0, Math.min(255, Math.round(o))).toString(16).padStart(2, "0");
  return `#${r(s)}${r(e)}${r(n)}${r(i * 255)}`;
}
const KA = [
  "#ff0000",
  "#ff8000",
  "#ffff00",
  "#80ff00",
  "#00ff00",
  "#00ff80",
  "#00ffff",
  "#0080ff",
  "#0000ff",
  "#8000ff",
  "#ff00ff",
  "#ff0080",
  "#ffffff",
  "#c0c0c0",
  "#808080",
  "#404040",
  "#000000"
], JA = {
  key: 0,
  class: "checkerboard"
}, QA = ["value"], e3 = { class: "mode-tabs" }, t3 = ["onClick"], n3 = {
  key: 1,
  class: "rgb-sliders"
}, i3 = { class: "color-slider" }, s3 = ["value"], r3 = { class: "color-slider" }, o3 = ["value"], a3 = { class: "color-slider" }, l3 = ["value"], c3 = {
  key: 2,
  class: "hsl-sliders"
}, u3 = { class: "color-slider" }, d3 = ["value"], h3 = { class: "color-slider" }, f3 = ["value"], p3 = { class: "color-slider" }, m3 = ["value"], v3 = {
  key: 3,
  class: "alpha-slider"
}, g3 = ["value"], y3 = { class: "swatches-section" }, _3 = { class: "swatches-grid" }, x3 = ["onClick"], b3 = {
  key: 4,
  class: "recent-section"
}, w3 = { class: "swatches-grid" }, S3 = ["onClick"], M3 = /* @__PURE__ */ Ot({
  __name: "ColorPicker",
  props: {
    modelValue: {},
    alpha: { type: Boolean, default: !1 },
    swatches: {},
    recentCount: { default: 8 },
    teleport: { type: Boolean, default: !0 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = ["hsv", "rgb", "hsl"], o = we(null), a = we(null), l = we(null), c = we(null), u = we(null), d = we(!1), h = we("hsv"), m = we(1), p = we([]), v = we([255, 255, 255]), x = we([0, 0, 1]), g = we([0, 0, 1]), _ = Ie(() => n.swatches || KA), M = Ie(() => {
      if (!o.value || !n.teleport) return {};
      const ne = o.value.getBoundingClientRect();
      return {
        top: `${ne.bottom + 4}px`,
        left: `${ne.left}px`
      };
    });
    function S(ne) {
      const J = jA(ne);
      J && (v.value = J, x.value = gs(J[0], J[1], J[2]), g.value = br(J[0], J[1], J[2]));
    }
    function b() {
      const ne = qA(v.value[0], v.value[1], v.value[2]);
      i("update:modelValue", ne);
    }
    function C() {
      d.value = !d.value;
    }
    function E() {
      d.value && (d.value = !1, P(n.modelValue));
    }
    function P(ne) {
      const J = p.value.indexOf(ne);
      J !== -1 && p.value.splice(J, 1), p.value.unshift(ne), p.value.length > n.recentCount && p.value.pop();
    }
    function T(ne) {
      i("update:modelValue", ne);
    }
    let y = !1;
    function w(ne) {
      y = !0, U(ne), document.addEventListener("mousemove", D), document.addEventListener("mouseup", R);
    }
    function D(ne) {
      y && U(ne);
    }
    function U(ne) {
      if (!l.value) return;
      const J = l.value.getBoundingClientRect(), B = Math.max(0, Math.min(1, (ne.clientX - J.left) / J.width)), X = Math.max(0, Math.min(1, 1 - (ne.clientY - J.top) / J.height));
      x.value = [x.value[0], B, X], v.value = Cv(x.value[0], x.value[1], x.value[2]), g.value = br(v.value[0], v.value[1], v.value[2]), b();
    }
    function R() {
      y = !1, document.removeEventListener("mousemove", D), document.removeEventListener("mouseup", R);
    }
    let O = !1;
    function A(ne) {
      O = !0, ue(ne), document.addEventListener("mousemove", G), document.addEventListener("mouseup", Q);
    }
    function G(ne) {
      O && ue(ne);
    }
    function ue(ne) {
      if (!c.value) return;
      const J = c.value.getBoundingClientRect(), B = Math.max(0, Math.min(360, (ne.clientX - J.left) / J.width * 360));
      x.value = [B, x.value[1], x.value[2]], v.value = Cv(x.value[0], x.value[1], x.value[2]), g.value = br(v.value[0], v.value[1], v.value[2]), b();
    }
    function Q() {
      O = !1, document.removeEventListener("mousemove", G), document.removeEventListener("mouseup", Q);
    }
    let le = null, re = null;
    function j(ne, J) {
      le = ne;
      const B = J.target.closest(".slider-track");
      B && (re = B.getBoundingClientRect(), q(J), document.addEventListener("mousemove", $), document.addEventListener("mouseup", oe));
    }
    function $(ne) {
      le && q(ne);
    }
    function q(ne) {
      if (!re || !le) return;
      const J = Math.max(0, Math.min(1, (ne.clientX - re.left) / re.width));
      switch (le) {
        case "r":
          v.value = [Math.round(J * 255), v.value[1], v.value[2]], x.value = gs(v.value[0], v.value[1], v.value[2]), g.value = br(v.value[0], v.value[1], v.value[2]);
          break;
        case "g":
          v.value = [v.value[0], Math.round(J * 255), v.value[2]], x.value = gs(v.value[0], v.value[1], v.value[2]), g.value = br(v.value[0], v.value[1], v.value[2]);
          break;
        case "b":
          v.value = [v.value[0], v.value[1], Math.round(J * 255)], x.value = gs(v.value[0], v.value[1], v.value[2]), g.value = br(v.value[0], v.value[1], v.value[2]);
          break;
        case "h":
          g.value = [J * 360, g.value[1], g.value[2]], v.value = fc(g.value[0], g.value[1], g.value[2]), x.value = gs(v.value[0], v.value[1], v.value[2]);
          break;
        case "s":
          g.value = [g.value[0], J, g.value[2]], v.value = fc(g.value[0], g.value[1], g.value[2]), x.value = gs(v.value[0], v.value[1], v.value[2]);
          break;
        case "l":
          g.value = [g.value[0], g.value[1], J], v.value = fc(g.value[0], g.value[1], g.value[2]), x.value = gs(v.value[0], v.value[1], v.value[2]);
          break;
      }
      b();
    }
    function oe() {
      le = null, re = null, document.removeEventListener("mousemove", $), document.removeEventListener("mouseup", oe);
    }
    let ie = !1;
    function ce(ne) {
      ie = !0, Y(ne), document.addEventListener("mousemove", V), document.addEventListener("mouseup", H);
    }
    function V(ne) {
      ie && Y(ne);
    }
    function Y(ne) {
      if (!u.value) return;
      const J = u.value.getBoundingClientRect();
      m.value = Math.max(0, Math.min(1, (ne.clientX - J.left) / J.width));
    }
    function H() {
      ie = !1, document.removeEventListener("mousemove", V), document.removeEventListener("mouseup", H);
    }
    function I(ne) {
      let B = ne.target.value.trim();
      B.startsWith("#") || (B = "#" + B), /^#[0-9a-f]{6}$/i.test(B) && i("update:modelValue", B.toLowerCase());
    }
    function F(ne) {
      const J = ne.target;
      J.value = n.modelValue;
    }
    function L(ne, J) {
      const B = J.target, X = Math.max(0, Math.min(255, parseInt(B.value) || 0)), se = [...v.value];
      se[ne] = X, v.value = se, x.value = gs(v.value[0], v.value[1], v.value[2]), g.value = br(v.value[0], v.value[1], v.value[2]), b();
    }
    function ee(ne, J) {
      const B = J.target;
      let X = parseFloat(B.value) || 0;
      ne === 0 ? (X = Math.max(0, Math.min(360, X)), g.value = [X, g.value[1], g.value[2]]) : (X = Math.max(0, Math.min(100, X)) / 100, ne === 1 ? g.value = [g.value[0], X, g.value[2]] : g.value = [g.value[0], g.value[1], X]), v.value = fc(g.value[0], g.value[1], g.value[2]), x.value = gs(v.value[0], v.value[1], v.value[2]), b();
    }
    function Z(ne) {
      const J = ne.target;
      m.value = Math.max(0, Math.min(100, parseInt(J.value) || 0)) / 100;
    }
    function k(ne) {
      o.value && !o.value.contains(ne.target) && a.value && !a.value.contains(ne.target) && E();
    }
    return Ft(() => n.modelValue, (ne) => {
      S(ne);
    }, { immediate: !0 }), _n(() => {
      document.addEventListener("mousedown", k);
    }), Nn(() => {
      document.removeEventListener("mousedown", k);
    }), (ne, J) => (te(), ae("div", {
      class: "color-picker",
      ref_key: "containerRef",
      ref: o
    }, [
      f("button", {
        class: "color-swatch",
        style: yt({ backgroundColor: s.modelValue }),
        onClick: C
      }, [
        s.alpha ? (te(), ae("span", JA)) : Pe("", !0)
      ], 4),
      f("input", {
        type: "text",
        class: "hex-input",
        value: s.modelValue,
        onInput: I,
        onBlur: F,
        onKeydown: J[0] || (J[0] = rl((B) => B.target.blur(), ["enter"]))
      }, null, 40, QA),
      (te(), St(Uo, {
        to: "body",
        disabled: !s.teleport
      }, [
        d.value ? (te(), ae("div", {
          key: 0,
          class: "picker-panel",
          style: yt(M.value),
          ref_key: "panelRef",
          ref: a
        }, [
          f("div", e3, [
            (te(), ae(qe, null, ot(r, (B) => f("button", {
              key: B,
              class: Fe({ active: h.value === B }),
              onClick: (X) => h.value = B
            }, xe(B.toUpperCase()), 11, t3)), 64))
          ]),
          h.value === "hsv" ? (te(), ae(qe, { key: 0 }, [
            f("div", {
              class: "sv-square",
              style: yt({ backgroundColor: `hsl(${x.value[0]}, 100%, 50%)` }),
              onMousedown: w,
              ref_key: "svSquareRef",
              ref: l
            }, [
              J[13] || (J[13] = f("div", { class: "sv-white" }, null, -1)),
              J[14] || (J[14] = f("div", { class: "sv-black" }, null, -1)),
              f("div", {
                class: "sv-cursor",
                style: yt({ left: x.value[1] * 100 + "%", top: (1 - x.value[2]) * 100 + "%" })
              }, null, 4)
            ], 36),
            f("div", {
              class: "hue-slider",
              onMousedown: A,
              ref_key: "hueSliderRef",
              ref: c
            }, [
              f("div", {
                class: "hue-cursor",
                style: yt({ left: x.value[0] / 360 * 100 + "%" })
              }, null, 4)
            ], 544)
          ], 64)) : h.value === "rgb" ? (te(), ae("div", n3, [
            f("div", i3, [
              J[15] || (J[15] = f("label", null, "R", -1)),
              f("div", {
                class: "slider-track r-track",
                onMousedown: J[1] || (J[1] = (B) => j("r", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: v.value[0] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: v.value[0],
                min: "0",
                max: "255",
                onInput: J[2] || (J[2] = (B) => L(0, B))
              }, null, 40, s3)
            ]),
            f("div", r3, [
              J[16] || (J[16] = f("label", null, "G", -1)),
              f("div", {
                class: "slider-track g-track",
                onMousedown: J[3] || (J[3] = (B) => j("g", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: v.value[1] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: v.value[1],
                min: "0",
                max: "255",
                onInput: J[4] || (J[4] = (B) => L(1, B))
              }, null, 40, o3)
            ]),
            f("div", a3, [
              J[17] || (J[17] = f("label", null, "B", -1)),
              f("div", {
                class: "slider-track b-track",
                onMousedown: J[5] || (J[5] = (B) => j("b", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: v.value[2] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: v.value[2],
                min: "0",
                max: "255",
                onInput: J[6] || (J[6] = (B) => L(2, B))
              }, null, 40, l3)
            ])
          ])) : h.value === "hsl" ? (te(), ae("div", c3, [
            f("div", u3, [
              J[18] || (J[18] = f("label", null, "H", -1)),
              f("div", {
                class: "slider-track hue-track",
                onMousedown: J[7] || (J[7] = (B) => j("h", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: g.value[0] / 360 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: Math.round(g.value[0]),
                min: "0",
                max: "360",
                onInput: J[8] || (J[8] = (B) => ee(0, B))
              }, null, 40, d3)
            ]),
            f("div", h3, [
              J[19] || (J[19] = f("label", null, "S", -1)),
              f("div", {
                class: "slider-track sat-track",
                style: yt({ "--hue": g.value[0] }),
                onMousedown: J[9] || (J[9] = (B) => j("s", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: g.value[1] * 100 + "%" })
                }, null, 4)
              ], 36),
              f("input", {
                type: "number",
                value: Math.round(g.value[1] * 100),
                min: "0",
                max: "100",
                onInput: J[10] || (J[10] = (B) => ee(1, B))
              }, null, 40, f3)
            ]),
            f("div", p3, [
              J[20] || (J[20] = f("label", null, "L", -1)),
              f("div", {
                class: "slider-track light-track",
                style: yt({ "--hue": g.value[0] }),
                onMousedown: J[11] || (J[11] = (B) => j("l", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: g.value[2] * 100 + "%" })
                }, null, 4)
              ], 36),
              f("input", {
                type: "number",
                value: Math.round(g.value[2] * 100),
                min: "0",
                max: "100",
                onInput: J[12] || (J[12] = (B) => ee(2, B))
              }, null, 40, m3)
            ])
          ])) : Pe("", !0),
          s.alpha ? (te(), ae("div", v3, [
            J[21] || (J[21] = f("label", null, "A", -1)),
            f("div", {
              class: "slider-track alpha-track",
              style: yt({ "--color": s.modelValue }),
              onMousedown: ce,
              ref_key: "alphaSliderRef",
              ref: u
            }, [
              f("div", {
                class: "slider-cursor",
                style: yt({ left: m.value * 100 + "%" })
              }, null, 4)
            ], 36),
            f("input", {
              type: "number",
              value: Math.round(m.value * 100),
              min: "0",
              max: "100",
              onInput: Z
            }, null, 40, g3)
          ])) : Pe("", !0),
          f("div", y3, [
            J[22] || (J[22] = f("div", { class: "swatches-label" }, "Swatches", -1)),
            f("div", _3, [
              (te(!0), ae(qe, null, ot(_.value, (B) => (te(), ae("button", {
                key: B,
                class: "swatch",
                style: yt({ backgroundColor: B }),
                onClick: (X) => T(B)
              }, null, 12, x3))), 128))
            ])
          ]),
          p.value.length > 0 ? (te(), ae("div", b3, [
            J[23] || (J[23] = f("div", { class: "swatches-label" }, "Recent", -1)),
            f("div", w3, [
              (te(!0), ae(qe, null, ot(p.value, (B) => (te(), ae("button", {
                key: B,
                class: "swatch",
                style: yt({ backgroundColor: B }),
                onClick: (X) => T(B)
              }, null, 12, S3))), 128))
            ])
          ])) : Pe("", !0)
        ], 4)) : Pe("", !0)
      ], 8, ["disabled"]))
    ], 512));
  }
}), lu = /* @__PURE__ */ Gt(M3, [["__scopeId", "data-v-05165efb"]]), C3 = { class: "effect-controls" }, E3 = { class: "panel-header" }, T3 = { class: "header-row" }, A3 = {
  key: 0,
  class: "layer-badge"
}, P3 = { class: "layer-type-icon" }, R3 = ["disabled"], D3 = {
  key: 0,
  class: "effect-menu"
}, k3 = { class: "category-label" }, I3 = { class: "cat-icon" }, L3 = { class: "category-items" }, F3 = ["onClick"], U3 = { class: "panel-content" }, O3 = {
  key: 0,
  class: "empty-state"
}, z3 = {
  key: 1,
  class: "empty-state"
}, N3 = {
  key: 2,
  class: "effects-list"
}, B3 = ["onClick"], V3 = { class: "header-left" }, G3 = { class: "arrow" }, H3 = ["onClick"], $3 = { class: "effect-name" }, W3 = { class: "header-right" }, X3 = ["onClick"], j3 = {
  key: 0,
  class: "effect-params"
}, Y3 = { class: "param-header" }, q3 = ["title"], Z3 = ["onClick"], K3 = { class: "param-control" }, J3 = {
  key: 0,
  class: "control-group"
}, Q3 = {
  key: 1,
  class: "control-group"
}, eP = {
  key: 2,
  class: "control-group point-group"
}, tP = ["checked", "onChange"], nP = ["value", "onChange"], iP = ["value"], sP = /* @__PURE__ */ Ot({
  __name: "EffectControlsPanel",
  setup(s) {
    const e = sn(), n = we(!1), i = we(null), r = Ie(() => e.selectedLayer), o = Kh;
    function a(T) {
      return Object.entries(au).filter(([y, w]) => w.category === T).map(([y, w]) => ({ key: y, ...w }));
    }
    function l(T, y) {
      const w = au[T];
      return w == null ? void 0 : w.parameters.find((D) => c(D.name) === y);
    }
    function c(T) {
      return T.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    }
    function u(T, y) {
      const w = l(T, y);
      return w && (w.min !== void 0 || w.max !== void 0);
    }
    function d(T, y) {
      const w = l(T, y);
      return (w == null ? void 0 : w.type) === "checkbox";
    }
    function h(T, y) {
      const w = l(T, y);
      return (w == null ? void 0 : w.type) === "angle";
    }
    function m(T, y) {
      const w = l(T, y);
      return (w == null ? void 0 : w.options) || [];
    }
    function p(T) {
      return {
        solid: "",
        text: "T",
        spline: "~",
        null: "",
        camera: "",
        light: "",
        particles: "",
        image: ""
      }[T] || "";
    }
    function v(T) {
      r.value && (e.addEffectToLayer(r.value.id, T), n.value = !1);
    }
    function x(T) {
      r.value && e.removeEffectFromLayer(r.value.id, T.id);
    }
    function g(T) {
      r.value && e.toggleEffect(r.value.id, T.id);
    }
    function _(T) {
      T.expanded = !T.expanded;
    }
    function M(T, y, w) {
      r.value && e.updateEffectParameter(r.value.id, T, y, w);
    }
    function S(T, y, w, D) {
      if (!r.value) return;
      const U = r.value.effects.find((A) => A.id === T);
      if (!U) return;
      const O = { ...U.parameters[y].value, [w]: D };
      e.updateEffectParameter(r.value.id, T, y, O);
    }
    function b(T) {
      return typeof T == "string" ? T : ZA(T.r, T.g, T.b, T.a ?? 1);
    }
    function C(T, y, w) {
      const D = YA(w);
      if (D && r.value) {
        const U = { r: D[0], g: D[1], b: D[2], a: D[3] };
        e.updateEffectParameter(r.value.id, T, y, U);
      }
    }
    function E(T, y) {
      if (!r.value) return;
      const w = r.value.effects.find((U) => U.id === T), D = w == null ? void 0 : w.parameters[y];
      D && e.setEffectParamAnimated(r.value.id, T, y, !D.animated);
    }
    function P(T) {
      i.value && !i.value.contains(T.target) && (n.value = !1);
    }
    return _n(() => window.addEventListener("mousedown", P)), Nn(() => window.removeEventListener("mousedown", P)), (T, y) => (te(), ae("div", C3, [
      f("div", E3, [
        f("div", T3, [
          y[1] || (y[1] = f("h3", null, "Effect Controls", -1)),
          r.value ? (te(), ae("div", A3, [
            f("span", P3, xe(p(r.value.type)), 1),
            ct(" " + xe(r.value.name), 1)
          ])) : Pe("", !0)
        ]),
        f("div", {
          class: "add-effect-wrapper",
          ref_key: "menuRef",
          ref: i
        }, [
          f("button", {
            class: "add-btn",
            onClick: y[0] || (y[0] = (w) => n.value = !n.value),
            disabled: !r.value
          }, [...y[2] || (y[2] = [
            f("span", { class: "icon" }, "+", -1),
            ct(" Add Effect ", -1)
          ])], 8, R3),
          n.value ? (te(), ae("div", D3, [
            (te(!0), ae(qe, null, ot(Ve(o), (w, D) => (te(), ae("div", {
              key: D,
              class: "effect-category"
            }, [
              f("div", k3, [
                f("span", I3, xe(w.icon), 1),
                ct(" " + xe(w.label), 1)
              ]),
              f("div", L3, [
                (te(!0), ae(qe, null, ot(a(D), (U) => (te(), ae("button", {
                  key: U.key,
                  onClick: (R) => v(U.key)
                }, xe(U.name), 9, F3))), 128))
              ])
            ]))), 128))
          ])) : Pe("", !0)
        ], 512)
      ]),
      f("div", U3, [
        r.value ? !r.value.effects || r.value.effects.length === 0 ? (te(), ae("div", z3, " No effects applied ")) : (te(), ae("div", N3, [
          (te(!0), ae(qe, null, ot(r.value.effects, (w, D) => (te(), ae("div", {
            key: w.id,
            class: Fe(["effect-item", { collapsed: !w.expanded }])
          }, [
            f("div", {
              class: "effect-header",
              onClick: (U) => _(w)
            }, [
              f("div", V3, [
                f("span", G3, xe(w.expanded ? "" : ""), 1),
                f("button", {
                  class: "icon-btn",
                  onClick: _t((U) => g(w), ["stop"])
                }, [
                  f("span", {
                    class: Fe(["fx-icon", { disabled: !w.enabled }])
                  }, "fx", 2)
                ], 8, H3),
                f("span", $3, xe(w.name), 1)
              ]),
              f("div", W3, [
                f("button", {
                  class: "icon-btn delete",
                  onClick: _t((U) => x(w), ["stop"]),
                  title: "Remove Effect"
                }, "", 8, X3)
              ])
            ], 8, B3),
            w.expanded ? (te(), ae("div", j3, [
              (te(!0), ae(qe, null, ot(w.parameters, (U, R) => {
                var O, A, G, ue;
                return te(), ae("div", {
                  key: R,
                  class: "param-row"
                }, [
                  f("div", Y3, [
                    f("span", {
                      class: "param-name",
                      title: String(R)
                    }, xe(U.name), 9, q3),
                    f("button", {
                      class: Fe(["stopwatch", { active: U.animated }]),
                      onClick: (Q) => E(w.id, String(R)),
                      title: "Toggle Animation"
                    }, "", 10, Z3)
                  ]),
                  f("div", K3, [
                    U.type === "number" && h(w.effectKey, String(R)) ? (te(), ae("div", J3, [
                      ze(Zf, {
                        modelValue: U.value,
                        "onUpdate:modelValue": (Q) => M(w.id, String(R), Q),
                        size: 32,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      ze(et, {
                        modelValue: U.value,
                        "onUpdate:modelValue": (Q) => M(w.id, String(R), Q),
                        unit: ""
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : U.type === "number" ? (te(), ae("div", Q3, [
                      u(w.effectKey, String(R)) ? (te(), St(jn, {
                        key: 0,
                        modelValue: U.value,
                        "onUpdate:modelValue": (Q) => M(w.id, String(R), Q),
                        min: ((O = l(w.effectKey, String(R))) == null ? void 0 : O.min) ?? 0,
                        max: ((A = l(w.effectKey, String(R))) == null ? void 0 : A.max) ?? 100,
                        step: ((G = l(w.effectKey, String(R))) == null ? void 0 : G.step) ?? 1,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "min", "max", "step"])) : Pe("", !0),
                      ze(et, {
                        modelValue: U.value,
                        "onUpdate:modelValue": (Q) => M(w.id, String(R), Q),
                        step: ((ue = l(w.effectKey, String(R))) == null ? void 0 : ue.step) ?? 0.1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "step"])
                    ])) : U.type === "position" ? (te(), ae("div", eP, [
                      ze(et, {
                        modelValue: U.value.x,
                        "onUpdate:modelValue": (Q) => S(w.id, String(R), "x", Q),
                        label: "X"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      ze(et, {
                        modelValue: U.value.y,
                        "onUpdate:modelValue": (Q) => S(w.id, String(R), "y", Q),
                        label: "Y"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : U.type === "color" ? (te(), St(lu, {
                      key: 3,
                      modelValue: b(U.value),
                      "onUpdate:modelValue": (Q) => C(w.id, String(R), Q),
                      alpha: !0
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : U.type === "enum" && d(w.effectKey, String(R)) ? (te(), ae("input", {
                      key: 4,
                      type: "checkbox",
                      checked: U.value,
                      onChange: (Q) => M(w.id, String(R), Q.target.checked)
                    }, null, 40, tP)) : U.type === "enum" ? (te(), ae("select", {
                      key: 5,
                      value: U.value,
                      onChange: (Q) => M(w.id, String(R), Q.target.value),
                      class: "param-select"
                    }, [
                      (te(!0), ae(qe, null, ot(m(w.effectKey, String(R)), (Q) => (te(), ae("option", {
                        key: Q.value,
                        value: Q.value
                      }, xe(Q.label), 9, iP))), 128))
                    ], 40, nP)) : Pe("", !0)
                  ])
                ]);
              }), 128))
            ])) : Pe("", !0)
          ], 2))), 128))
        ])) : (te(), ae("div", O3, " Select a layer to edit effects "))
      ])
    ]));
  }
}), rP = /* @__PURE__ */ Gt(sP, [["__scopeId", "data-v-8ac57c6b"]]), vo = qo("Font"), pc = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
], mc = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class oP {
  constructor() {
    fe(this, "systemFonts", []);
    fe(this, "loadedGoogleFonts", /* @__PURE__ */ new Set());
    fe(this, "initialized", !1);
  }
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    this.initialized || ("queryLocalFonts" in window && await this.loadSystemFonts(), this.initialized = !0);
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const e = await window.queryLocalFonts(), n = /* @__PURE__ */ new Map();
      for (const i of e)
        (!n.has(i.family) || i.style === "Regular") && n.set(i.family, {
          family: i.family,
          fullName: i.fullName,
          style: i.style,
          source: "system"
        });
      this.systemFonts = Array.from(n.values()).sort((i, r) => i.family.localeCompare(r.family)), vo.debug(`Loaded ${this.systemFonts.length} system fonts`);
    } catch (e) {
      e.name === "NotAllowedError" ? vo.info("User denied font access permission") : vo.error("Error loading system fonts:", e);
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const e = [];
    return this.systemFonts.length > 0 && e.push({
      name: "System Fonts",
      fonts: this.systemFonts
    }), e.push({
      name: "Web Safe",
      fonts: pc
    }), e.push({
      name: "Google Fonts",
      fonts: mc.map((n) => ({
        family: n,
        fullName: n,
        style: "normal",
        source: "google"
      }))
    }), e;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const e = /* @__PURE__ */ new Set();
    return pc.forEach((n) => e.add(n.family)), mc.forEach((n) => e.add(n)), this.systemFonts.forEach((n) => e.add(n.family)), Array.from(e).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(e, n = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(e)) return;
    const i = n.join(";"), r = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(e)}:wght@${i}&display=swap`, o = document.createElement("link");
    o.rel = "stylesheet", o.href = r, document.head.appendChild(o);
    try {
      await document.fonts.load(`400 16px "${e}"`), this.loadedGoogleFonts.add(e), vo.debug(`Loaded Google Font: ${e}`);
    } catch (a) {
      vo.error(`Failed to load Google Font: ${e}`, a);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(e) {
    return pc.some((n) => n.family === e) ? !0 : mc.includes(e) ? (await this.loadGoogleFont(e), !0) : this.systemFonts.some((n) => n.family === e) ? !0 : this.isFontAvailable(e);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(e) {
    const n = "mmmmmmmmmmlli", r = document.createElement("canvas").getContext("2d");
    r.font = "72px monospace";
    const o = r.measureText(n).width;
    r.font = `72px "${e}", monospace`;
    const a = r.measureText(n).width;
    return o !== a;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return pc;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return mc;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    return "queryLocalFonts" in window ? (await this.loadSystemFonts(), this.systemFonts.length > 0) : (vo.info("Local Font Access API not available"), !1);
  }
}
const go = new oP(), aP = { class: "text-properties" }, lP = { class: "prop-section" }, cP = ["value"], uP = { class: "prop-section" }, dP = { class: "row font-row" }, hP = ["value"], fP = ["label"], pP = ["value"], mP = { class: "style-toggles" }, vP = {
  key: 0,
  class: "row"
}, gP = ["disabled"], yP = { class: "row" }, _P = { class: "row color-row" }, xP = { class: "color-item" }, bP = ["value"], wP = { class: "color-item" }, SP = ["value"], MP = { class: "row" }, CP = { class: "row" }, EP = { class: "align-buttons" }, TP = { class: "prop-section" }, AP = { class: "row" }, PP = { class: "vec2" }, RP = { class: "row" }, DP = { class: "vec2" }, kP = { class: "row" }, IP = { class: "vec2" }, LP = { class: "row" }, FP = { class: "row" }, UP = { class: "prop-section" }, OP = { class: "row" }, zP = ["value"], NP = ["value"], BP = { class: "row" }, VP = { class: "row" }, GP = { class: "row" }, HP = { class: "row checkbox-row" }, $P = ["checked"], WP = { class: "row checkbox-row" }, XP = ["checked"], jP = { class: "row checkbox-row" }, YP = ["checked"], qP = { class: "prop-section" }, ZP = { class: "row" }, KP = { class: "row" }, JP = { class: "row" }, QP = { class: "prop-section checkbox" }, eR = ["checked"], tR = /* @__PURE__ */ Ot({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = we([]), a = we(!1), l = we(!1);
    _n(async () => {
      await go.initialize(), o.value = go.getFontCategories(), a.value = go.hasSystemFonts();
    });
    async function c() {
      l.value = !0;
      try {
        await go.requestSystemFontAccess() && (o.value = go.getFontCategories(), a.value = !0);
      } finally {
        l.value = !1;
      }
    }
    const u = Ie(() => n.layer.data), d = Ie(() => n.layer.transform), h = Ie(() => r.layers.filter((T) => T.type === "spline"));
    function m(T) {
      var y;
      return (y = n.layer.properties) == null ? void 0 : y.find((w) => w.name === T);
    }
    function p(T) {
      const y = m(T);
      return y ? y.value : null;
    }
    function v(T) {
      r.setPropertyValue(n.layer.id, "Source Text", T), r.updateLayerData(n.layer.id, { text: T }), i("update");
    }
    function x(T, y) {
      r.updateLayerData(n.layer.id, { [T]: y });
      const w = {
        fill: "Fill Color",
        stroke: "Stroke Color",
        fontSize: "Font Size",
        strokeWidth: "Stroke Width"
      };
      w[T] && r.setPropertyValue(n.layer.id, w[T], y), i("update");
    }
    function g(T, y) {
      r.setPropertyValue(n.layer.id, T, y);
      const w = {
        "Font Size": "fontSize",
        "Stroke Width": "strokeWidth",
        Tracking: "tracking",
        "Line Spacing": "lineSpacing",
        "Character Offset": "characterOffset",
        "Path Offset": "pathOffset",
        "First Margin": "pathFirstMargin",
        "Last Margin": "pathLastMargin"
      };
      w[T] && r.updateLayerData(n.layer.id, { [w[T]]: y }), i("update");
    }
    function _(T) {
      const y = m(T);
      return (y == null ? void 0 : y.animated) ?? !1;
    }
    function M(T) {
      var U;
      const y = m(T);
      if (!y) return;
      const w = r.currentFrame, D = (U = y.keyframes) == null ? void 0 : U.find((R) => R.frame === w);
      D ? r.removeKeyframe(n.layer.id, T, D.id) : r.addKeyframe(n.layer.id, T, y.value, w), i("update");
    }
    function S(T, y, w) {
      const D = d.value[T];
      let U;
      y ? U = { ...D.value, [y]: w } : U = w, r.setPropertyValue(n.layer.id, `transform.${T}`, U), i("update");
    }
    function b(T) {
      r.setPropertyValue(n.layer.id, "opacity", T), i("update");
    }
    function C() {
      x("fontWeight", u.value.fontWeight === "bold" ? "400" : "bold");
    }
    function E() {
      x("fontStyle", u.value.fontStyle === "italic" ? "normal" : "italic");
    }
    async function P(T) {
      await go.ensureFont(T), x("fontFamily", T);
    }
    return (T, y) => {
      var w;
      return te(), ae("div", aP, [
        f("div", lP, [
          y[29] || (y[29] = f("div", { class: "section-title" }, "Source Text", -1)),
          f("textarea", {
            value: u.value.text,
            onInput: y[0] || (y[0] = (D) => v(D.target.value)),
            class: "text-area",
            rows: "3"
          }, null, 40, cP)
        ]),
        f("div", uP, [
          y[35] || (y[35] = f("div", { class: "section-title" }, "Character", -1)),
          f("div", dP, [
            f("select", {
              value: u.value.fontFamily,
              onChange: y[1] || (y[1] = (D) => P(D.target.value)),
              class: "font-select"
            }, [
              (te(!0), ae(qe, null, ot(o.value, (D) => (te(), ae("optgroup", {
                key: D.name,
                label: D.name
              }, [
                (te(!0), ae(qe, null, ot(D.fonts, (U) => (te(), ae("option", {
                  key: U.family,
                  value: U.family
                }, xe(U.family), 9, pP))), 128))
              ], 8, fP))), 128))
            ], 40, hP),
            f("div", mP, [
              f("button", {
                class: Fe({ active: u.value.fontWeight === "bold" }),
                onClick: C
              }, "B", 2),
              f("button", {
                class: Fe({ active: u.value.fontStyle === "italic" }),
                onClick: E
              }, "I", 2)
            ])
          ]),
          a.value ? Pe("", !0) : (te(), ae("div", vP, [
            f("button", {
              class: "font-access-btn",
              onClick: c,
              disabled: l.value
            }, xe(l.value ? "Loading..." : "+ Load System Fonts"), 9, gP)
          ])),
          f("div", yP, [
            y[30] || (y[30] = f("label", null, "Size", -1)),
            ze(Ve(et), {
              modelValue: p("Font Size") || u.value.fontSize,
              "onUpdate:modelValue": y[2] || (y[2] = (D) => g("Font Size", D))
            }, null, 8, ["modelValue"])
          ]),
          f("div", _P, [
            f("div", xP, [
              f("input", {
                type: "color",
                value: u.value.fill,
                onInput: y[3] || (y[3] = (D) => x("fill", D.target.value))
              }, null, 40, bP),
              y[31] || (y[31] = f("span", null, "Fill", -1))
            ]),
            f("div", wP, [
              f("input", {
                type: "color",
                value: u.value.stroke || "#000000",
                onInput: y[4] || (y[4] = (D) => x("stroke", D.target.value))
              }, null, 40, SP),
              y[32] || (y[32] = f("span", null, "Stroke", -1))
            ])
          ]),
          f("div", MP, [
            y[33] || (y[33] = f("label", null, "Stroke Width", -1)),
            ze(Ve(et), {
              modelValue: p("Stroke Width") || u.value.strokeWidth || 0,
              "onUpdate:modelValue": y[5] || (y[5] = (D) => g("Stroke Width", D)),
              min: 0,
              max: 50
            }, null, 8, ["modelValue"])
          ]),
          f("div", CP, [
            y[34] || (y[34] = f("label", null, "Alignment", -1)),
            f("div", EP, [
              f("button", {
                class: Fe({ active: u.value.textAlign === "left" }),
                onClick: y[6] || (y[6] = (D) => x("textAlign", "left"))
              }, "", 2),
              f("button", {
                class: Fe({ active: u.value.textAlign === "center" }),
                onClick: y[7] || (y[7] = (D) => x("textAlign", "center"))
              }, "", 2),
              f("button", {
                class: Fe({ active: u.value.textAlign === "right" }),
                onClick: y[8] || (y[8] = (D) => x("textAlign", "right"))
              }, "", 2)
            ])
          ])
        ]),
        f("div", TP, [
          y[41] || (y[41] = f("div", { class: "section-title" }, "Transform", -1)),
          f("div", AP, [
            y[36] || (y[36] = f("label", null, "Position", -1)),
            f("div", PP, [
              ze(Ve(et), {
                modelValue: d.value.position.value.x,
                "onUpdate:modelValue": y[9] || (y[9] = (D) => S("position", "x", D))
              }, null, 8, ["modelValue"]),
              ze(Ve(et), {
                modelValue: d.value.position.value.y,
                "onUpdate:modelValue": y[10] || (y[10] = (D) => S("position", "y", D))
              }, null, 8, ["modelValue"])
            ])
          ]),
          f("div", RP, [
            y[37] || (y[37] = f("label", null, "Anchor Pt", -1)),
            f("div", DP, [
              ze(Ve(et), {
                modelValue: d.value.anchorPoint.value.x,
                "onUpdate:modelValue": y[11] || (y[11] = (D) => S("anchorPoint", "x", D))
              }, null, 8, ["modelValue"]),
              ze(Ve(et), {
                modelValue: d.value.anchorPoint.value.y,
                "onUpdate:modelValue": y[12] || (y[12] = (D) => S("anchorPoint", "y", D))
              }, null, 8, ["modelValue"])
            ])
          ]),
          f("div", kP, [
            y[38] || (y[38] = f("label", null, "Scale %", -1)),
            f("div", IP, [
              ze(Ve(et), {
                modelValue: d.value.scale.value.x,
                "onUpdate:modelValue": y[13] || (y[13] = (D) => S("scale", "x", D))
              }, null, 8, ["modelValue"]),
              ze(Ve(et), {
                modelValue: d.value.scale.value.y,
                "onUpdate:modelValue": y[14] || (y[14] = (D) => S("scale", "y", D))
              }, null, 8, ["modelValue"])
            ])
          ]),
          f("div", LP, [
            y[39] || (y[39] = f("label", null, "Rotation", -1)),
            ze(Ve(et), {
              modelValue: d.value.rotation.value,
              "onUpdate:modelValue": y[15] || (y[15] = (D) => S("rotation", null, D))
            }, null, 8, ["modelValue"])
          ]),
          f("div", FP, [
            y[40] || (y[40] = f("label", null, "Opacity", -1)),
            ze(Ve(et), {
              modelValue: ((w = s.layer.opacity) == null ? void 0 : w.value) ?? 100,
              "onUpdate:modelValue": y[16] || (y[16] = (D) => b(D)),
              min: 0,
              max: 100
            }, null, 8, ["modelValue"])
          ])
        ]),
        f("div", UP, [
          y[50] || (y[50] = f("div", { class: "section-title" }, "Path Options", -1)),
          f("div", OP, [
            y[43] || (y[43] = f("label", null, "Path", -1)),
            f("select", {
              value: u.value.pathLayerId || "",
              onChange: y[17] || (y[17] = (D) => x("pathLayerId", D.target.value || null)),
              class: "full-select"
            }, [
              y[42] || (y[42] = f("option", { value: "" }, "None", -1)),
              (te(!0), ae(qe, null, ot(h.value, (D) => (te(), ae("option", {
                key: D.id,
                value: D.id
              }, xe(D.name), 9, NP))), 128))
            ], 40, zP)
          ]),
          u.value.pathLayerId ? (te(), ae(qe, { key: 0 }, [
            f("div", BP, [
              y[44] || (y[44] = f("label", null, "Path Offset %", -1)),
              ze(Ve(et), {
                modelValue: p("Path Offset") ?? u.value.pathOffset ?? 0,
                "onUpdate:modelValue": y[18] || (y[18] = (D) => g("Path Offset", D)),
                min: -100,
                max: 200,
                precision: 1
              }, null, 8, ["modelValue"]),
              f("button", {
                class: Fe(["keyframe-btn", { active: _("Path Offset") }]),
                onClick: y[19] || (y[19] = (D) => M("Path Offset")),
                title: "Add keyframe"
              }, "", 2)
            ]),
            f("div", VP, [
              y[45] || (y[45] = f("label", null, "First Margin", -1)),
              ze(Ve(et), {
                modelValue: p("First Margin") ?? u.value.pathFirstMargin ?? 0,
                "onUpdate:modelValue": y[20] || (y[20] = (D) => g("First Margin", D)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            f("div", GP, [
              y[46] || (y[46] = f("label", null, "Last Margin", -1)),
              ze(Ve(et), {
                modelValue: p("Last Margin") ?? u.value.pathLastMargin ?? 0,
                "onUpdate:modelValue": y[21] || (y[21] = (D) => g("Last Margin", D)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            f("div", HP, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: u.value.pathReversed,
                  onChange: y[22] || (y[22] = (D) => x("pathReversed", !u.value.pathReversed))
                }, null, 40, $P),
                y[47] || (y[47] = ct(" Reverse Path ", -1))
              ])
            ]),
            f("div", WP, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: u.value.pathPerpendicularToPath ?? !0,
                  onChange: y[23] || (y[23] = (D) => x("pathPerpendicularToPath", !u.value.pathPerpendicularToPath))
                }, null, 40, XP),
                y[48] || (y[48] = ct(" Perpendicular to Path ", -1))
              ])
            ]),
            f("div", jP, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: u.value.pathForceAlignment,
                  onChange: y[24] || (y[24] = (D) => x("pathForceAlignment", !u.value.pathForceAlignment))
                }, null, 40, YP),
                y[49] || (y[49] = ct(" Force Alignment ", -1))
              ])
            ])
          ], 64)) : Pe("", !0)
        ]),
        f("div", qP, [
          y[54] || (y[54] = f("div", { class: "section-title" }, "Advanced", -1)),
          f("div", ZP, [
            y[51] || (y[51] = f("label", null, "Tracking", -1)),
            ze(Ve(et), {
              modelValue: p("Tracking") || u.value.tracking || 0,
              "onUpdate:modelValue": y[25] || (y[25] = (D) => g("Tracking", D))
            }, null, 8, ["modelValue"])
          ]),
          f("div", KP, [
            y[52] || (y[52] = f("label", null, "Line Spacing", -1)),
            ze(Ve(et), {
              modelValue: p("Line Spacing") || u.value.lineSpacing || 0,
              "onUpdate:modelValue": y[26] || (y[26] = (D) => g("Line Spacing", D))
            }, null, 8, ["modelValue"])
          ]),
          f("div", JP, [
            y[53] || (y[53] = f("label", null, "Char Offset", -1)),
            ze(Ve(et), {
              modelValue: p("Character Offset") || u.value.characterOffset || 0,
              "onUpdate:modelValue": y[27] || (y[27] = (D) => g("Character Offset", D)),
              precision: 0
            }, null, 8, ["modelValue"])
          ])
        ]),
        f("div", QP, [
          f("label", null, [
            f("input", {
              type: "checkbox",
              checked: u.value.perCharacter3D,
              onChange: y[28] || (y[28] = (D) => x("perCharacter3D", !u.value.perCharacter3D))
            }, null, 40, eR),
            y[55] || (y[55] = ct(" Enable Per-Character 3D ", -1))
          ])
        ])
      ]);
    };
  }
}), nR = /* @__PURE__ */ Gt(tR, [["__scopeId", "data-v-947c42b2"]]), iR = { class: "particle-properties" }, sR = { class: "property-section" }, rR = {
  key: 0,
  class: "section-content"
}, oR = { class: "property-row" }, aR = ["value"], lR = { class: "value-display" }, cR = { class: "property-row" }, uR = ["value"], dR = { class: "value-display" }, hR = { class: "property-row" }, fR = ["value"], pR = { class: "value-display" }, mR = { class: "property-row" }, vR = ["value"], gR = { class: "value-display" }, yR = { class: "property-row" }, _R = ["value"], xR = { class: "value-display" }, bR = { class: "property-row" }, wR = ["value"], SR = { class: "property-section" }, MR = {
  key: 0,
  class: "section-content"
}, CR = ["onClick"], ER = ["value", "onInput"], TR = { class: "enabled-toggle" }, AR = ["checked", "onChange"], PR = ["onClick"], RR = {
  key: 0,
  class: "emitter-content"
}, DR = { class: "property-row" }, kR = ["value", "onInput"], IR = { class: "value-display" }, LR = { class: "property-row" }, FR = ["value", "onInput"], UR = { class: "value-display" }, OR = { class: "property-row" }, zR = ["value", "onInput"], NR = { class: "value-display" }, BR = { class: "property-row" }, VR = ["value", "onInput"], GR = { class: "value-display" }, HR = { class: "property-row" }, $R = ["value", "onInput"], WR = { class: "value-display" }, XR = { class: "property-row" }, jR = ["value", "onInput"], YR = { class: "value-display" }, qR = { class: "property-row" }, ZR = ["value", "onInput"], KR = { class: "value-display" }, JR = { class: "property-row" }, QR = ["value", "onInput"], eD = { class: "value-display" }, tD = { class: "property-row" }, nD = ["value", "onInput"], iD = { class: "property-row" }, sD = ["value", "onInput"], rD = { class: "value-display" }, oD = { class: "property-row" }, aD = ["value", "onInput"], lD = { class: "value-display" }, cD = { class: "property-row" }, uD = ["value", "onInput"], dD = { class: "value-display" }, hD = { class: "property-row checkbox-row" }, fD = ["checked", "onChange"], pD = {
  key: 0,
  class: "property-row"
}, mD = ["value", "onInput"], vD = { class: "value-display" }, gD = {
  key: 0,
  class: "empty-message"
}, yD = { class: "property-section" }, _D = {
  key: 0,
  class: "section-content"
}, xD = { class: "force-tabs" }, bD = {
  key: 0,
  class: "force-list"
}, wD = { class: "force-header" }, SD = ["value", "onInput"], MD = { class: "enabled-toggle" }, CD = ["checked", "onChange"], ED = ["onClick"], TD = { class: "property-row" }, AD = ["value", "onInput"], PD = { class: "value-display" }, RD = { class: "property-row" }, DD = ["value", "onInput"], kD = { class: "value-display" }, ID = { class: "property-row" }, LD = ["value", "onInput"], FD = { class: "value-display" }, UD = { class: "property-row" }, OD = ["value", "onInput"], zD = { class: "value-display" }, ND = { class: "property-row" }, BD = ["value", "onChange"], VD = {
  key: 1,
  class: "force-list"
}, GD = { class: "force-header" }, HD = ["value", "onInput"], $D = { class: "enabled-toggle" }, WD = ["checked", "onChange"], XD = ["onClick"], jD = { class: "property-row" }, YD = ["value", "onInput"], qD = { class: "value-display" }, ZD = { class: "property-row" }, KD = ["value", "onInput"], JD = { class: "value-display" }, QD = { class: "property-row" }, ek = ["value", "onInput"], tk = { class: "value-display" }, nk = { class: "property-row" }, ik = ["value", "onInput"], sk = { class: "value-display" }, rk = { class: "property-row" }, ok = ["value", "onInput"], ak = { class: "value-display" }, lk = { class: "property-row" }, ck = ["value", "onInput"], uk = { class: "value-display" }, dk = { class: "property-section" }, hk = {
  key: 0,
  class: "section-content"
}, fk = { class: "force-header" }, pk = { class: "enabled-toggle" }, mk = ["checked", "onChange"], vk = ["onClick"], gk = { class: "property-row" }, yk = ["value", "onInput"], _k = { class: "value-display" }, xk = { class: "property-row" }, bk = ["value", "onInput"], wk = { class: "value-display" }, Sk = { class: "property-row" }, Mk = ["value", "onInput"], Ck = { class: "value-display" }, Ek = {
  key: 0,
  class: "empty-message"
}, Tk = { class: "property-section" }, Ak = {
  key: 0,
  class: "section-content"
}, Pk = { class: "force-header" }, Rk = ["value", "onChange"], Dk = ["value"], kk = { class: "enabled-toggle" }, Ik = ["checked", "onChange"], Lk = ["onClick"], Fk = { class: "property-row" }, Uk = ["value", "onChange"], Ok = { class: "property-row" }, zk = ["value", "onInput"], Nk = { class: "value-display" }, Bk = { class: "property-row" }, Vk = ["value", "onInput"], Gk = { class: "value-display" }, Hk = { class: "property-row" }, $k = ["value", "onInput"], Wk = { class: "value-display" }, Xk = { class: "property-row" }, jk = ["value", "onInput"], Yk = { class: "value-display" }, qk = { class: "property-row" }, Zk = ["value", "onInput"], Kk = { class: "value-display" }, Jk = { class: "property-row" }, Qk = ["value", "onInput"], eI = { class: "value-display" }, tI = { class: "property-row" }, nI = ["value", "onInput"], iI = {
  key: 0,
  class: "empty-message"
}, sI = { class: "property-section" }, rI = {
  key: 0,
  class: "section-content"
}, oI = { class: "modulation-header" }, aI = ["value", "onChange"], lI = ["value"], cI = ["onClick"], uI = { class: "property-row" }, dI = ["value", "onChange"], hI = { class: "property-row" }, fI = ["value", "onInput"], pI = { class: "property-row" }, mI = ["value", "onInput"], vI = { class: "property-row" }, gI = ["value", "onChange"], yI = {
  key: 0,
  class: "empty-message"
}, _I = { class: "property-section" }, xI = {
  key: 0,
  class: "section-content"
}, bI = { class: "property-row" }, wI = ["value"], SI = { class: "property-row" }, MI = ["value"], CI = { class: "property-row checkbox-row" }, EI = ["checked"], TI = {
  key: 0,
  class: "property-row"
}, AI = ["value"], PI = { class: "value-display" }, RI = { class: "property-row checkbox-row" }, DI = ["checked"], kI = {
  key: 1,
  class: "property-row"
}, II = ["value"], LI = { class: "value-display" }, FI = {
  key: 2,
  class: "property-row"
}, UI = ["value"], OI = { class: "value-display" }, zI = { class: "property-row checkbox-row" }, NI = ["checked"], BI = {
  key: 3,
  class: "property-row"
}, VI = ["value"], GI = { class: "value-display" }, HI = {
  key: 4,
  class: "property-row"
}, $I = ["value"], WI = { class: "value-display" }, XI = {
  key: 5,
  class: "property-row"
}, jI = ["value"], YI = { class: "value-display" }, qI = {
  key: 6,
  class: "property-row"
}, ZI = ["value"], KI = { class: "value-display" }, JI = {
  key: 7,
  class: "property-row checkbox-row"
}, QI = ["checked"], eL = { class: "particle-count" }, tL = /* @__PURE__ */ Ot({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we(/* @__PURE__ */ new Set(["system", "emitters"])), o = we(/* @__PURE__ */ new Set()), a = we("wells"), l = Ie(() => n.layer.data || {
      systemConfig: {
        maxParticles: 1e4,
        gravity: 0,
        windStrength: 0,
        windDirection: 0,
        warmupPeriod: 0,
        respectMaskBoundary: !1,
        boundaryBehavior: "kill",
        friction: 0.01
      },
      emitters: [],
      gravityWells: [],
      vortices: [],
      modulations: [],
      renderOptions: {
        blendMode: "additive",
        renderTrails: !1,
        trailLength: 5,
        trailOpacityFalloff: 0.7,
        particleShape: "circle",
        glowEnabled: !1,
        glowRadius: 10,
        glowIntensity: 0.5,
        motionBlur: !1,
        motionBlurStrength: 0.5,
        motionBlurSamples: 8,
        connections: {
          enabled: !1,
          maxDistance: 100,
          maxConnections: 3,
          lineWidth: 1,
          lineOpacity: 0.5,
          fadeByDistance: !0
        }
      },
      turbulenceFields: [],
      subEmitters: []
    }), c = Ie(() => l.value.systemConfig), u = Ie(() => l.value.emitters), d = Ie(() => l.value.gravityWells), h = Ie(() => l.value.vortices), m = Ie(() => l.value.modulations), p = Ie(() => l.value.renderOptions), v = Ie(() => l.value.turbulenceFields || []), x = Ie(() => l.value.subEmitters || []), g = Ie(() => p.value.connections || {
      enabled: !1,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: !0
    }), _ = Ie(() => n.particleCount);
    function M(H) {
      r.value.has(H) ? r.value.delete(H) : r.value.add(H);
    }
    function S(H) {
      o.value.has(H) ? o.value.delete(H) : o.value.add(H);
    }
    function b(H, I) {
      i("update", {
        systemConfig: { ...c.value, [H]: I }
      });
    }
    function C(H, I, F) {
      const L = u.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { emitters: L });
    }
    function E(H, I) {
      const F = Y(I);
      C(H, "color", F);
    }
    function P() {
      const H = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${u.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: !0,
        burstOnBeat: !1,
        burstCount: 20
      };
      i("update", { emitters: [...u.value, H] }), o.value.add(H.id);
    }
    function T(H) {
      i("update", { emitters: u.value.filter((I) => I.id !== H) });
    }
    function y(H, I, F) {
      const L = d.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { gravityWells: L });
    }
    function w() {
      const H = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${d.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: !0
      };
      i("update", { gravityWells: [...d.value, H] });
    }
    function D(H) {
      i("update", { gravityWells: d.value.filter((I) => I.id !== H) });
    }
    function U(H, I, F) {
      const L = h.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { vortices: L });
    }
    function R() {
      const H = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${h.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: !0
      };
      i("update", { vortices: [...h.value, H] });
    }
    function O(H) {
      i("update", { vortices: h.value.filter((I) => I.id !== H) });
    }
    function A(H, I, F) {
      const L = m.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { modulations: L });
    }
    function G() {
      const H = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      i("update", { modulations: [...m.value, H] });
    }
    function ue(H) {
      i("update", { modulations: m.value.filter((I) => I.id !== H) });
    }
    function Q(H, I) {
      i("update", {
        renderOptions: { ...p.value, [H]: I }
      });
    }
    function le(H, I) {
      i("update", {
        renderOptions: {
          ...p.value,
          connections: { ...g.value, [H]: I }
        }
      });
    }
    function re(H, I, F) {
      const L = v.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { turbulenceFields: L });
    }
    function j() {
      const H = {
        id: `turb_${Date.now()}`,
        enabled: !0,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      i("update", { turbulenceFields: [...v.value, H] });
    }
    function $(H) {
      i("update", { turbulenceFields: v.value.filter((I) => I.id !== H) });
    }
    function q(H, I, F) {
      const L = x.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { subEmitters: L });
    }
    function oe(H, I) {
      const F = Y(I);
      q(H, "color", F);
    }
    function ie() {
      const H = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: !0
      };
      i("update", { subEmitters: [...x.value, H] });
    }
    function ce(H) {
      i("update", { subEmitters: x.value.filter((I) => I.id !== H) });
    }
    function V(H) {
      return "#" + H.map((I) => I.toString(16).padStart(2, "0")).join("");
    }
    function Y(H) {
      const I = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(H);
      return I ? [parseInt(I[1], 16), parseInt(I[2], 16), parseInt(I[3], 16)] : [255, 255, 255];
    }
    return (H, I) => (te(), ae("div", iR, [
      f("div", sR, [
        f("div", {
          class: "section-header",
          onClick: I[0] || (I[0] = (F) => M("system"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[30] || (I[30] = f("span", null, "System Settings", -1))
        ]),
        r.value.has("system") ? (te(), ae("div", rR, [
          f("div", oR, [
            I[31] || (I[31] = f("label", null, "Max Particles", -1)),
            f("input", {
              type: "range",
              value: c.value.maxParticles,
              min: "100",
              max: "50000",
              step: "100",
              onInput: I[1] || (I[1] = (F) => b("maxParticles", Number(F.target.value)))
            }, null, 40, aR),
            f("span", lR, xe(c.value.maxParticles), 1)
          ]),
          f("div", cR, [
            I[32] || (I[32] = f("label", null, "Gravity", -1)),
            f("input", {
              type: "range",
              value: c.value.gravity,
              min: "-1000",
              max: "1000",
              step: "10",
              onInput: I[2] || (I[2] = (F) => b("gravity", Number(F.target.value)))
            }, null, 40, uR),
            f("span", dR, xe(c.value.gravity), 1)
          ]),
          f("div", hR, [
            I[33] || (I[33] = f("label", null, "Wind Strength", -1)),
            f("input", {
              type: "range",
              value: c.value.windStrength,
              min: "0",
              max: "1000",
              step: "10",
              onInput: I[3] || (I[3] = (F) => b("windStrength", Number(F.target.value)))
            }, null, 40, fR),
            f("span", pR, xe(c.value.windStrength), 1)
          ]),
          f("div", mR, [
            I[34] || (I[34] = f("label", null, "Wind Direction", -1)),
            f("input", {
              type: "range",
              value: c.value.windDirection,
              min: "0",
              max: "360",
              step: "5",
              onInput: I[4] || (I[4] = (F) => b("windDirection", Number(F.target.value)))
            }, null, 40, vR),
            f("span", gR, xe(c.value.windDirection) + "", 1)
          ]),
          f("div", yR, [
            I[35] || (I[35] = f("label", null, "Friction", -1)),
            f("input", {
              type: "range",
              value: c.value.friction,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: I[5] || (I[5] = (F) => b("friction", Number(F.target.value)))
            }, null, 40, _R),
            f("span", xR, xe(c.value.friction.toFixed(2)), 1)
          ]),
          f("div", bR, [
            I[37] || (I[37] = f("label", null, "Boundary", -1)),
            f("select", {
              value: c.value.boundaryBehavior,
              onChange: I[6] || (I[6] = (F) => b("boundaryBehavior", F.target.value))
            }, [...I[36] || (I[36] = [
              f("option", { value: "kill" }, "Kill", -1),
              f("option", { value: "bounce" }, "Bounce", -1),
              f("option", { value: "wrap" }, "Wrap", -1)
            ])], 40, wR)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", SR, [
        f("div", {
          class: "section-header",
          onClick: I[7] || (I[7] = (F) => M("emitters"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[39] || (I[39] = f("span", null, "Emitters", -1)),
          f("button", {
            class: "add-btn",
            onClick: _t(P, ["stop"]),
            title: "Add Emitter"
          }, [...I[38] || (I[38] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("emitters") ? (te(), ae("div", MR, [
          (te(!0), ae(qe, null, ot(u.value, (F) => (te(), ae("div", {
            key: F.id,
            class: "emitter-item"
          }, [
            f("div", {
              class: "emitter-header",
              onClick: (L) => S(F.id)
            }, [
              f("i", {
                class: Fe(["pi", o.value.has(F.id) ? "pi-chevron-down" : "pi-chevron-right"])
              }, null, 2),
              f("input", {
                type: "text",
                value: F.name,
                onInput: (L) => C(F.id, "name", L.target.value),
                onClick: I[8] || (I[8] = _t(() => {
                }, ["stop"])),
                class: "emitter-name"
              }, null, 40, ER),
              f("label", TR, [
                f("input", {
                  type: "checkbox",
                  checked: F.enabled,
                  onChange: (L) => C(F.id, "enabled", L.target.checked),
                  onClick: I[9] || (I[9] = _t(() => {
                  }, ["stop"]))
                }, null, 40, AR)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: _t((L) => T(F.id), ["stop"]),
                title: "Remove"
              }, [...I[40] || (I[40] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, PR)
            ], 8, CR),
            o.value.has(F.id) ? (te(), ae("div", RR, [
              f("div", DR, [
                I[41] || (I[41] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: F.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => C(F.id, "x", Number(L.target.value))
                }, null, 40, kR),
                f("span", IR, xe(F.x.toFixed(2)), 1)
              ]),
              f("div", LR, [
                I[42] || (I[42] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: F.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => C(F.id, "y", Number(L.target.value))
                }, null, 40, FR),
                f("span", UR, xe(F.y.toFixed(2)), 1)
              ]),
              f("div", OR, [
                I[43] || (I[43] = f("label", null, "Direction", -1)),
                f("input", {
                  type: "range",
                  value: F.direction,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (L) => C(F.id, "direction", Number(L.target.value))
                }, null, 40, zR),
                f("span", NR, xe(F.direction) + "", 1)
              ]),
              f("div", BR, [
                I[44] || (I[44] = f("label", null, "Spread", -1)),
                f("input", {
                  type: "range",
                  value: F.spread,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (L) => C(F.id, "spread", Number(L.target.value))
                }, null, 40, VR),
                f("span", GR, xe(F.spread) + "", 1)
              ]),
              f("div", HR, [
                I[45] || (I[45] = f("label", null, "Speed", -1)),
                f("input", {
                  type: "range",
                  value: F.speed,
                  min: "1",
                  max: "1000",
                  step: "10",
                  onInput: (L) => C(F.id, "speed", Number(L.target.value))
                }, null, 40, $R),
                f("span", WR, xe(F.speed), 1)
              ]),
              f("div", XR, [
                I[46] || (I[46] = f("label", null, "Speed Variance", -1)),
                f("input", {
                  type: "range",
                  value: F.speedVariance,
                  min: "0",
                  max: "500",
                  step: "10",
                  onInput: (L) => C(F.id, "speedVariance", Number(L.target.value))
                }, null, 40, jR),
                f("span", YR, xe(F.speedVariance), 1)
              ]),
              f("div", qR, [
                I[47] || (I[47] = f("label", null, "Size", -1)),
                f("input", {
                  type: "range",
                  value: F.size,
                  min: "1",
                  max: "400",
                  step: "1",
                  onInput: (L) => C(F.id, "size", Number(L.target.value))
                }, null, 40, ZR),
                f("span", KR, xe(F.size) + "px", 1)
              ]),
              f("div", JR, [
                I[48] || (I[48] = f("label", null, "Size Variance", -1)),
                f("input", {
                  type: "range",
                  value: F.sizeVariance,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (L) => C(F.id, "sizeVariance", Number(L.target.value))
                }, null, 40, QR),
                f("span", eD, xe(F.sizeVariance), 1)
              ]),
              f("div", tD, [
                I[49] || (I[49] = f("label", null, "Color", -1)),
                f("input", {
                  type: "color",
                  value: V(F.color),
                  onInput: (L) => E(F.id, L.target.value)
                }, null, 40, nD)
              ]),
              f("div", iD, [
                I[50] || (I[50] = f("label", null, "Emission Rate", -1)),
                f("input", {
                  type: "range",
                  value: F.emissionRate,
                  min: "0.1",
                  max: "100",
                  step: "0.1",
                  onInput: (L) => C(F.id, "emissionRate", Number(L.target.value))
                }, null, 40, sD),
                f("span", rD, xe(F.emissionRate.toFixed(1)) + "/s", 1)
              ]),
              f("div", oD, [
                I[51] || (I[51] = f("label", null, "Lifetime", -1)),
                f("input", {
                  type: "range",
                  value: F.particleLifetime,
                  min: "1",
                  max: "300",
                  step: "1",
                  onInput: (L) => C(F.id, "particleLifetime", Number(L.target.value))
                }, null, 40, aD),
                f("span", lD, xe(F.particleLifetime) + "f", 1)
              ]),
              f("div", cD, [
                I[52] || (I[52] = f("label", null, "Initial Burst", -1)),
                f("input", {
                  type: "range",
                  value: F.initialBurst,
                  min: "0",
                  max: "1",
                  step: "0.1",
                  onInput: (L) => C(F.id, "initialBurst", Number(L.target.value))
                }, null, 40, uD),
                f("span", dD, xe((F.initialBurst * 100).toFixed(0)) + "%", 1)
              ]),
              f("div", hD, [
                f("label", null, [
                  f("input", {
                    type: "checkbox",
                    checked: F.burstOnBeat,
                    onChange: (L) => C(F.id, "burstOnBeat", L.target.checked)
                  }, null, 40, fD),
                  I[53] || (I[53] = ct(" Burst on Beat ", -1))
                ])
              ]),
              F.burstOnBeat ? (te(), ae("div", pD, [
                I[54] || (I[54] = f("label", null, "Burst Count", -1)),
                f("input", {
                  type: "range",
                  value: F.burstCount,
                  min: "1",
                  max: "100",
                  step: "1",
                  onInput: (L) => C(F.id, "burstCount", Number(L.target.value))
                }, null, 40, mD),
                f("span", vD, xe(F.burstCount), 1)
              ])) : Pe("", !0)
            ])) : Pe("", !0)
          ]))), 128)),
          u.value.length === 0 ? (te(), ae("div", gD, " No emitters. Click + to add one. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", yD, [
        f("div", {
          class: "section-header",
          onClick: I[10] || (I[10] = (F) => M("forces"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[55] || (I[55] = f("span", null, "Force Fields", -1))
        ]),
        r.value.has("forces") ? (te(), ae("div", _D, [
          f("div", xD, [
            f("button", {
              class: Fe({ active: a.value === "wells" }),
              onClick: I[11] || (I[11] = (F) => a.value = "wells")
            }, " Gravity Wells ", 2),
            f("button", {
              class: Fe({ active: a.value === "vortices" }),
              onClick: I[12] || (I[12] = (F) => a.value = "vortices")
            }, " Vortices ", 2)
          ]),
          a.value === "wells" ? (te(), ae("div", bD, [
            f("button", {
              class: "add-btn full-width",
              onClick: w
            }, [...I[56] || (I[56] = [
              f("i", { class: "pi pi-plus" }, null, -1),
              ct(" Add Gravity Well ", -1)
            ])]),
            (te(!0), ae(qe, null, ot(d.value, (F) => (te(), ae("div", {
              key: F.id,
              class: "force-item"
            }, [
              f("div", wD, [
                f("input", {
                  type: "text",
                  value: F.name,
                  onInput: (L) => y(F.id, "name", L.target.value),
                  class: "force-name"
                }, null, 40, SD),
                f("label", MD, [
                  f("input", {
                    type: "checkbox",
                    checked: F.enabled,
                    onChange: (L) => y(F.id, "enabled", L.target.checked)
                  }, null, 40, CD)
                ]),
                f("button", {
                  class: "remove-btn",
                  onClick: (L) => D(F.id)
                }, [...I[57] || (I[57] = [
                  f("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, ED)
              ]),
              f("div", TD, [
                I[58] || (I[58] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: F.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => y(F.id, "x", Number(L.target.value))
                }, null, 40, AD),
                f("span", PD, xe(F.x.toFixed(2)), 1)
              ]),
              f("div", RD, [
                I[59] || (I[59] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: F.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => y(F.id, "y", Number(L.target.value))
                }, null, 40, DD),
                f("span", kD, xe(F.y.toFixed(2)), 1)
              ]),
              f("div", ID, [
                I[60] || (I[60] = f("label", null, "Strength", -1)),
                f("input", {
                  type: "range",
                  value: F.strength,
                  min: "-1000",
                  max: "1000",
                  step: "10",
                  onInput: (L) => y(F.id, "strength", Number(L.target.value))
                }, null, 40, LD),
                f("span", FD, xe(F.strength), 1)
              ]),
              f("div", UD, [
                I[61] || (I[61] = f("label", null, "Radius", -1)),
                f("input", {
                  type: "range",
                  value: F.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => y(F.id, "radius", Number(L.target.value))
                }, null, 40, OD),
                f("span", zD, xe(F.radius.toFixed(2)), 1)
              ]),
              f("div", ND, [
                I[63] || (I[63] = f("label", null, "Falloff", -1)),
                f("select", {
                  value: F.falloff,
                  onChange: (L) => y(F.id, "falloff", L.target.value)
                }, [...I[62] || (I[62] = [
                  f("option", { value: "linear" }, "Linear", -1),
                  f("option", { value: "quadratic" }, "Quadratic", -1),
                  f("option", { value: "constant" }, "Constant", -1)
                ])], 40, BD)
              ])
            ]))), 128))
          ])) : Pe("", !0),
          a.value === "vortices" ? (te(), ae("div", VD, [
            f("button", {
              class: "add-btn full-width",
              onClick: R
            }, [...I[64] || (I[64] = [
              f("i", { class: "pi pi-plus" }, null, -1),
              ct(" Add Vortex ", -1)
            ])]),
            (te(!0), ae(qe, null, ot(h.value, (F) => (te(), ae("div", {
              key: F.id,
              class: "force-item"
            }, [
              f("div", GD, [
                f("input", {
                  type: "text",
                  value: F.name,
                  onInput: (L) => U(F.id, "name", L.target.value),
                  class: "force-name"
                }, null, 40, HD),
                f("label", $D, [
                  f("input", {
                    type: "checkbox",
                    checked: F.enabled,
                    onChange: (L) => U(F.id, "enabled", L.target.checked)
                  }, null, 40, WD)
                ]),
                f("button", {
                  class: "remove-btn",
                  onClick: (L) => O(F.id)
                }, [...I[65] || (I[65] = [
                  f("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, XD)
              ]),
              f("div", jD, [
                I[66] || (I[66] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: F.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => U(F.id, "x", Number(L.target.value))
                }, null, 40, YD),
                f("span", qD, xe(F.x.toFixed(2)), 1)
              ]),
              f("div", ZD, [
                I[67] || (I[67] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: F.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => U(F.id, "y", Number(L.target.value))
                }, null, 40, KD),
                f("span", JD, xe(F.y.toFixed(2)), 1)
              ]),
              f("div", QD, [
                I[68] || (I[68] = f("label", null, "Strength", -1)),
                f("input", {
                  type: "range",
                  value: F.strength,
                  min: "0",
                  max: "1000",
                  step: "10",
                  onInput: (L) => U(F.id, "strength", Number(L.target.value))
                }, null, 40, ek),
                f("span", tk, xe(F.strength), 1)
              ]),
              f("div", nk, [
                I[69] || (I[69] = f("label", null, "Radius", -1)),
                f("input", {
                  type: "range",
                  value: F.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => U(F.id, "radius", Number(L.target.value))
                }, null, 40, ik),
                f("span", sk, xe(F.radius.toFixed(2)), 1)
              ]),
              f("div", rk, [
                I[70] || (I[70] = f("label", null, "Rotation Speed", -1)),
                f("input", {
                  type: "range",
                  value: F.rotationSpeed,
                  min: "0",
                  max: "50",
                  step: "1",
                  onInput: (L) => U(F.id, "rotationSpeed", Number(L.target.value))
                }, null, 40, ok),
                f("span", ak, xe(F.rotationSpeed) + "/f", 1)
              ]),
              f("div", lk, [
                I[71] || (I[71] = f("label", null, "Inward Pull", -1)),
                f("input", {
                  type: "range",
                  value: F.inwardPull,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (L) => U(F.id, "inwardPull", Number(L.target.value))
                }, null, 40, ck),
                f("span", uk, xe(F.inwardPull), 1)
              ])
            ]))), 128))
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", dk, [
        f("div", {
          class: "section-header",
          onClick: I[13] || (I[13] = (F) => M("turbulence"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[73] || (I[73] = f("span", null, "Turbulence", -1)),
          f("button", {
            class: "add-btn",
            onClick: _t(j, ["stop"]),
            title: "Add Turbulence Field"
          }, [...I[72] || (I[72] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("turbulence") ? (te(), ae("div", hk, [
          (te(!0), ae(qe, null, ot(v.value, (F) => (te(), ae("div", {
            key: F.id,
            class: "force-item"
          }, [
            f("div", fk, [
              I[75] || (I[75] = f("span", { class: "force-label" }, "Turbulence Field", -1)),
              f("label", pk, [
                f("input", {
                  type: "checkbox",
                  checked: F.enabled,
                  onChange: (L) => re(F.id, "enabled", L.target.checked)
                }, null, 40, mk)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: (L) => $(F.id)
              }, [...I[74] || (I[74] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, vk)
            ]),
            f("div", gk, [
              I[76] || (I[76] = f("label", null, "Scale", -1)),
              f("input", {
                type: "range",
                value: F.scale,
                min: "0.001",
                max: "0.02",
                step: "0.001",
                onInput: (L) => re(F.id, "scale", Number(L.target.value))
              }, null, 40, yk),
              f("span", _k, xe(F.scale.toFixed(3)), 1)
            ]),
            f("div", xk, [
              I[77] || (I[77] = f("label", null, "Strength", -1)),
              f("input", {
                type: "range",
                value: F.strength,
                min: "0",
                max: "500",
                step: "10",
                onInput: (L) => re(F.id, "strength", Number(L.target.value))
              }, null, 40, bk),
              f("span", wk, xe(F.strength), 1)
            ]),
            f("div", Sk, [
              I[78] || (I[78] = f("label", null, "Evolution", -1)),
              f("input", {
                type: "range",
                value: F.evolutionSpeed,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: (L) => re(F.id, "evolutionSpeed", Number(L.target.value))
              }, null, 40, Mk),
              f("span", Ck, xe(F.evolutionSpeed.toFixed(2)), 1)
            ])
          ]))), 128)),
          v.value.length === 0 ? (te(), ae("div", Ek, " No turbulence fields. Add one for organic particle motion. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", Tk, [
        f("div", {
          class: "section-header",
          onClick: I[14] || (I[14] = (F) => M("subEmitters"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[80] || (I[80] = f("span", null, "Sub-Emitters", -1)),
          f("button", {
            class: "add-btn",
            onClick: _t(ie, ["stop"]),
            title: "Add Sub-Emitter"
          }, [...I[79] || (I[79] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("subEmitters") ? (te(), ae("div", Ak, [
          (te(!0), ae(qe, null, ot(x.value, (F) => (te(), ae("div", {
            key: F.id,
            class: "force-item"
          }, [
            f("div", Pk, [
              f("select", {
                value: F.parentEmitterId,
                onChange: (L) => q(F.id, "parentEmitterId", L.target.value),
                class: "sub-emitter-parent"
              }, [
                I[81] || (I[81] = f("option", { value: "*" }, "All Emitters", -1)),
                (te(!0), ae(qe, null, ot(u.value, (L) => (te(), ae("option", {
                  key: L.id,
                  value: L.id
                }, xe(L.name), 9, Dk))), 128))
              ], 40, Rk),
              f("label", kk, [
                f("input", {
                  type: "checkbox",
                  checked: F.enabled,
                  onChange: (L) => q(F.id, "enabled", L.target.checked)
                }, null, 40, Ik)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: (L) => ce(F.id)
              }, [...I[82] || (I[82] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, Lk)
            ]),
            f("div", Fk, [
              I[84] || (I[84] = f("label", null, "Trigger", -1)),
              f("select", {
                value: F.trigger,
                onChange: (L) => q(F.id, "trigger", L.target.value)
              }, [...I[83] || (I[83] = [
                f("option", { value: "death" }, "On Death", -1)
              ])], 40, Uk)
            ]),
            f("div", Ok, [
              I[85] || (I[85] = f("label", null, "Spawn Count", -1)),
              f("input", {
                type: "range",
                value: F.spawnCount,
                min: "1",
                max: "10",
                step: "1",
                onInput: (L) => q(F.id, "spawnCount", Number(L.target.value))
              }, null, 40, zk),
              f("span", Nk, xe(F.spawnCount), 1)
            ]),
            f("div", Bk, [
              I[86] || (I[86] = f("label", null, "Inherit Velocity", -1)),
              f("input", {
                type: "range",
                value: F.inheritVelocity,
                min: "0",
                max: "1",
                step: "0.1",
                onInput: (L) => q(F.id, "inheritVelocity", Number(L.target.value))
              }, null, 40, Vk),
              f("span", Gk, xe((F.inheritVelocity * 100).toFixed(0)) + "%", 1)
            ]),
            f("div", Hk, [
              I[87] || (I[87] = f("label", null, "Size", -1)),
              f("input", {
                type: "range",
                value: F.size,
                min: "1",
                max: "100",
                step: "1",
                onInput: (L) => q(F.id, "size", Number(L.target.value))
              }, null, 40, $k),
              f("span", Wk, xe(F.size) + "px", 1)
            ]),
            f("div", Xk, [
              I[88] || (I[88] = f("label", null, "Lifetime", -1)),
              f("input", {
                type: "range",
                value: F.lifetime,
                min: "1",
                max: "120",
                step: "1",
                onInput: (L) => q(F.id, "lifetime", Number(L.target.value))
              }, null, 40, jk),
              f("span", Yk, xe(F.lifetime) + "f", 1)
            ]),
            f("div", qk, [
              I[89] || (I[89] = f("label", null, "Speed", -1)),
              f("input", {
                type: "range",
                value: F.speed,
                min: "1",
                max: "500",
                step: "10",
                onInput: (L) => q(F.id, "speed", Number(L.target.value))
              }, null, 40, Zk),
              f("span", Kk, xe(F.speed), 1)
            ]),
            f("div", Jk, [
              I[90] || (I[90] = f("label", null, "Spread", -1)),
              f("input", {
                type: "range",
                value: F.spread,
                min: "0",
                max: "360",
                step: "5",
                onInput: (L) => q(F.id, "spread", Number(L.target.value))
              }, null, 40, Qk),
              f("span", eI, xe(F.spread) + "", 1)
            ]),
            f("div", tI, [
              I[91] || (I[91] = f("label", null, "Color", -1)),
              f("input", {
                type: "color",
                value: V(F.color),
                onInput: (L) => oe(F.id, L.target.value)
              }, null, 40, nI)
            ])
          ]))), 128)),
          x.value.length === 0 ? (te(), ae("div", iI, " No sub-emitters. Add one for particle death effects. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", sI, [
        f("div", {
          class: "section-header",
          onClick: I[15] || (I[15] = (F) => M("modulations"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[93] || (I[93] = f("span", null, "Modulations", -1)),
          f("button", {
            class: "add-btn",
            onClick: _t(G, ["stop"]),
            title: "Add Modulation"
          }, [...I[92] || (I[92] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("modulations") ? (te(), ae("div", rI, [
          (te(!0), ae(qe, null, ot(m.value, (F) => (te(), ae("div", {
            key: F.id,
            class: "modulation-item"
          }, [
            f("div", oI, [
              f("select", {
                value: F.emitterId,
                onChange: (L) => A(F.id, "emitterId", L.target.value)
              }, [
                I[94] || (I[94] = f("option", { value: "*" }, "All Emitters", -1)),
                (te(!0), ae(qe, null, ot(u.value, (L) => (te(), ae("option", {
                  key: L.id,
                  value: L.id
                }, xe(L.name), 9, lI))), 128))
              ], 40, aI),
              f("button", {
                class: "remove-btn",
                onClick: (L) => ue(F.id)
              }, [...I[95] || (I[95] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, cI)
            ]),
            f("div", uI, [
              I[97] || (I[97] = f("label", null, "Property", -1)),
              f("select", {
                value: F.property,
                onChange: (L) => A(F.id, "property", L.target.value)
              }, [...I[96] || (I[96] = [
                as('<option value="size" data-v-60b9bdc8>Size</option><option value="speed" data-v-60b9bdc8>Speed</option><option value="opacity" data-v-60b9bdc8>Opacity</option><option value="colorR" data-v-60b9bdc8>Color R</option><option value="colorG" data-v-60b9bdc8>Color G</option><option value="colorB" data-v-60b9bdc8>Color B</option>', 6)
              ])], 40, dI)
            ]),
            f("div", hI, [
              I[98] || (I[98] = f("label", null, "Start Value", -1)),
              f("input", {
                type: "number",
                value: F.startValue,
                step: "0.1",
                onInput: (L) => A(F.id, "startValue", Number(L.target.value))
              }, null, 40, fI)
            ]),
            f("div", pI, [
              I[99] || (I[99] = f("label", null, "End Value", -1)),
              f("input", {
                type: "number",
                value: F.endValue,
                step: "0.1",
                onInput: (L) => A(F.id, "endValue", Number(L.target.value))
              }, null, 40, mI)
            ]),
            f("div", vI, [
              I[101] || (I[101] = f("label", null, "Easing", -1)),
              f("select", {
                value: F.easing,
                onChange: (L) => A(F.id, "easing", L.target.value)
              }, [...I[100] || (I[100] = [
                as('<option value="linear" data-v-60b9bdc8>Linear</option><option value="easeIn" data-v-60b9bdc8>Ease In</option><option value="easeOut" data-v-60b9bdc8>Ease Out</option><option value="easeInOut" data-v-60b9bdc8>Ease In Out</option><option value="bounce" data-v-60b9bdc8>Bounce</option><option value="elastic" data-v-60b9bdc8>Elastic</option>', 6)
              ])], 40, gI)
            ])
          ]))), 128)),
          m.value.length === 0 ? (te(), ae("div", yI, " No modulations. Add one to animate particle properties over lifetime. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", _I, [
        f("div", {
          class: "section-header",
          onClick: I[16] || (I[16] = (F) => M("render"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[102] || (I[102] = f("span", null, "Render Options", -1))
        ]),
        r.value.has("render") ? (te(), ae("div", xI, [
          f("div", bI, [
            I[104] || (I[104] = f("label", null, "Blend Mode", -1)),
            f("select", {
              value: p.value.blendMode,
              onChange: I[17] || (I[17] = (F) => Q("blendMode", F.target.value))
            }, [...I[103] || (I[103] = [
              f("option", { value: "normal" }, "Normal", -1),
              f("option", { value: "additive" }, "Additive", -1),
              f("option", { value: "multiply" }, "Multiply", -1),
              f("option", { value: "screen" }, "Screen", -1)
            ])], 40, wI)
          ]),
          f("div", SI, [
            I[106] || (I[106] = f("label", null, "Shape", -1)),
            f("select", {
              value: p.value.particleShape,
              onChange: I[18] || (I[18] = (F) => Q("particleShape", F.target.value))
            }, [...I[105] || (I[105] = [
              f("option", { value: "circle" }, "Circle", -1),
              f("option", { value: "square" }, "Square", -1),
              f("option", { value: "triangle" }, "Triangle", -1),
              f("option", { value: "star" }, "Star", -1)
            ])], 40, MI)
          ]),
          f("div", CI, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: p.value.renderTrails,
                onChange: I[19] || (I[19] = (F) => Q("renderTrails", F.target.checked))
              }, null, 40, EI),
              I[107] || (I[107] = ct(" Render Trails ", -1))
            ])
          ]),
          p.value.renderTrails ? (te(), ae("div", TI, [
            I[108] || (I[108] = f("label", null, "Trail Length", -1)),
            f("input", {
              type: "range",
              value: p.value.trailLength,
              min: "1",
              max: "20",
              step: "1",
              onInput: I[20] || (I[20] = (F) => Q("trailLength", Number(F.target.value)))
            }, null, 40, AI),
            f("span", PI, xe(p.value.trailLength), 1)
          ])) : Pe("", !0),
          f("div", RI, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: p.value.glowEnabled,
                onChange: I[21] || (I[21] = (F) => Q("glowEnabled", F.target.checked))
              }, null, 40, DI),
              I[109] || (I[109] = ct(" Enable Glow ", -1))
            ])
          ]),
          p.value.glowEnabled ? (te(), ae("div", kI, [
            I[110] || (I[110] = f("label", null, "Glow Radius", -1)),
            f("input", {
              type: "range",
              value: p.value.glowRadius,
              min: "1",
              max: "50",
              step: "1",
              onInput: I[22] || (I[22] = (F) => Q("glowRadius", Number(F.target.value)))
            }, null, 40, II),
            f("span", LI, xe(p.value.glowRadius) + "px", 1)
          ])) : Pe("", !0),
          p.value.glowEnabled ? (te(), ae("div", FI, [
            I[111] || (I[111] = f("label", null, "Glow Intensity", -1)),
            f("input", {
              type: "range",
              value: p.value.glowIntensity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: I[23] || (I[23] = (F) => Q("glowIntensity", Number(F.target.value)))
            }, null, 40, UI),
            f("span", OI, xe(p.value.glowIntensity.toFixed(2)), 1)
          ])) : Pe("", !0),
          I[118] || (I[118] = f("div", { class: "subsection-divider" }, "Particle Connections", -1)),
          f("div", zI, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: g.value.enabled,
                onChange: I[24] || (I[24] = (F) => le("enabled", F.target.checked))
              }, null, 40, NI),
              I[112] || (I[112] = ct(" Enable Connections ", -1))
            ])
          ]),
          g.value.enabled ? (te(), ae("div", BI, [
            I[113] || (I[113] = f("label", null, "Max Distance", -1)),
            f("input", {
              type: "range",
              value: g.value.maxDistance,
              min: "10",
              max: "300",
              step: "10",
              onInput: I[25] || (I[25] = (F) => le("maxDistance", Number(F.target.value)))
            }, null, 40, VI),
            f("span", GI, xe(g.value.maxDistance) + "px", 1)
          ])) : Pe("", !0),
          g.value.enabled ? (te(), ae("div", HI, [
            I[114] || (I[114] = f("label", null, "Max Connections", -1)),
            f("input", {
              type: "range",
              value: g.value.maxConnections,
              min: "1",
              max: "5",
              step: "1",
              onInput: I[26] || (I[26] = (F) => le("maxConnections", Number(F.target.value)))
            }, null, 40, $I),
            f("span", WI, xe(g.value.maxConnections), 1)
          ])) : Pe("", !0),
          g.value.enabled ? (te(), ae("div", XI, [
            I[115] || (I[115] = f("label", null, "Line Width", -1)),
            f("input", {
              type: "range",
              value: g.value.lineWidth,
              min: "0.5",
              max: "3",
              step: "0.1",
              onInput: I[27] || (I[27] = (F) => le("lineWidth", Number(F.target.value)))
            }, null, 40, jI),
            f("span", YI, xe(g.value.lineWidth.toFixed(1)), 1)
          ])) : Pe("", !0),
          g.value.enabled ? (te(), ae("div", qI, [
            I[116] || (I[116] = f("label", null, "Line Opacity", -1)),
            f("input", {
              type: "range",
              value: g.value.lineOpacity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: I[28] || (I[28] = (F) => le("lineOpacity", Number(F.target.value)))
            }, null, 40, ZI),
            f("span", KI, xe(g.value.lineOpacity.toFixed(2)), 1)
          ])) : Pe("", !0),
          g.value.enabled ? (te(), ae("div", JI, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: g.value.fadeByDistance,
                onChange: I[29] || (I[29] = (F) => le("fadeByDistance", F.target.checked))
              }, null, 40, QI),
              I[117] || (I[117] = ct(" Fade by Distance ", -1))
            ])
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", eL, [
        I[119] || (I[119] = f("i", { class: "pi pi-circle-fill" }, null, -1)),
        f("span", null, xe(_.value) + " particles", 1)
      ])
    ]));
  }
}), nL = /* @__PURE__ */ Gt(tL, [["__scopeId", "data-v-60b9bdc8"]]), iL = ["title"], sL = /* @__PURE__ */ Ot({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = Ie(() => n.property.animated ? n.property.keyframes.some((m) => m.frame === r.currentFrame) : !1), a = Ie(() => n.property.animated && n.property.keyframes.find((m) => m.frame === r.currentFrame) || null), l = Ie(() => o.value ? "pi-circle-fill" : n.property.animated ? "pi-circle" : "pi-stopwatch"), c = Ie(() => o.value ? "Remove keyframe at current frame" : n.property.animated ? "Add keyframe at current frame" : "Enable animation (add keyframe)");
    function u() {
      o.value ? h() : d();
    }
    function d() {
      const m = { frame: 0, value: 0, enabled: !1 }, p = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: r.currentFrame,
        value: n.property.value,
        interpolation: "linear",
        inHandle: { ...m },
        outHandle: { ...m },
        controlMode: "smooth"
      };
      n.property.animated || (n.property.animated = !0, i("animationToggled", !0)), n.property.keyframes.push(p), n.property.keyframes.sort((v, x) => v.frame - x.frame), i("keyframeAdded", p);
    }
    function h() {
      const m = a.value;
      if (!m) return;
      const p = n.property.keyframes.findIndex((v) => v.id === m.id);
      p >= 0 && (n.property.keyframes.splice(p, 1), i("keyframeRemoved", m.id)), n.property.keyframes.length === 0 && (n.property.animated = !1, i("animationToggled", !1));
    }
    return (m, p) => (te(), ae("button", {
      class: Fe(["keyframe-toggle", {
        animated: s.property.animated,
        "has-keyframe": o.value
      }]),
      onClick: u,
      title: c.value
    }, [
      f("i", {
        class: Fe(["pi", l.value])
      }, null, 2)
    ], 10, iL));
  }
}), Lr = /* @__PURE__ */ Gt(sL, [["__scopeId", "data-v-b9271c8f"]]), rL = { class: "depthflow-properties" }, oL = { class: "property-section" }, aL = {
  key: 0,
  class: "section-content"
}, lL = { class: "property-row" }, cL = ["value"], uL = ["value"], dL = { class: "property-row" }, hL = ["value"], fL = ["value"], pL = { class: "property-section" }, mL = {
  key: 0,
  class: "section-content"
}, vL = { class: "preset-grid" }, gL = ["onClick"], yL = {
  key: 0,
  class: "property-row"
}, _L = ["value"], xL = { class: "value-display" }, bL = { class: "property-section" }, wL = {
  key: 0,
  class: "section-content"
}, SL = { class: "property-row" }, ML = ["value"], CL = { class: "value-display" }, EL = { class: "property-row" }, TL = ["value"], AL = { class: "value-display" }, PL = { class: "property-row" }, RL = ["value"], DL = { class: "value-display" }, kL = { class: "property-row" }, IL = ["value"], LL = { class: "value-display" }, FL = { class: "property-section" }, UL = {
  key: 0,
  class: "section-content"
}, OL = { class: "property-row" }, zL = ["value"], NL = { class: "value-display" }, BL = { class: "property-row" }, VL = ["value"], GL = { class: "value-display" }, HL = {
  key: 0,
  class: "property-section"
}, $L = {
  key: 0,
  class: "section-content"
}, WL = { class: "property-row" }, XL = ["value"], jL = { class: "value-display" }, YL = { class: "property-row" }, qL = ["value"], ZL = { class: "value-display" }, KL = { class: "property-row" }, JL = ["value"], QL = { class: "value-display" }, e5 = { class: "property-row" }, t5 = ["value"], n5 = { class: "value-display" }, i5 = {
  key: 2,
  class: "property-row"
}, s5 = ["value"], r5 = { class: "value-display" }, o5 = { class: "property-section" }, a5 = {
  key: 0,
  class: "section-content"
}, l5 = { class: "property-row" }, c5 = ["value"], u5 = { class: "value-display" }, d5 = { class: "property-row checkbox-row" }, h5 = ["checked"], f5 = { class: "property-section" }, p5 = {
  key: 0,
  class: "section-content"
}, m5 = { class: "preview-container" }, v5 = { class: "preview-controls" }, g5 = { class: "frame-indicator" }, Ki = 200, y5 = /* @__PURE__ */ Ot({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = we(null), a = we(!1), l = we(0), c = we(null), u = we(/* @__PURE__ */ new Set(["source", "preset", "camera"])), d = we(1), h = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ], m = Ie(() => n.layer.data || {
      sourceLayerId: "",
      depthLayerId: "",
      config: {
        preset: "static",
        zoom: 1,
        offsetX: 0,
        offsetY: 0,
        rotation: 0,
        depthScale: 1,
        focusDepth: 0.5,
        dollyZoom: 0,
        orbitRadius: 0.1,
        orbitSpeed: 360,
        swingAmplitude: 0.1,
        swingFrequency: 1,
        edgeDilation: 5,
        inpaintEdges: !0
      }
    }), p = Ie(() => m.value.config), v = Ie(() => r.frameCount), x = Ie(
      () => r.layers.filter((O) => O.type === "image" || O.type === "generated")
    ), g = Ie(
      () => r.layers.filter((O) => O.type === "depth" || O.type === "generated")
    ), _ = Ie(
      () => ["circle_cw", "circle_ccw"].includes(p.value.preset)
    ), M = Ie(
      () => ["horizontal_swing", "vertical_swing"].includes(p.value.preset)
    ), S = Ie(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(p.value.preset)
    ), b = Ie(
      () => _.value || M.value || S.value
    ), C = Ie(() => _.value ? "Orbit Settings" : M.value ? "Swing Settings" : S.value ? "Dolly Zoom Settings" : "Preset Settings");
    function E(O) {
      u.value.has(O) ? u.value.delete(O) : u.value.add(O);
    }
    function P(O, A) {
      i("update", { [O]: A });
    }
    function T(O, A) {
      i("update", {
        config: { ...p.value, [O]: A }
      });
    }
    function y(O) {
      T("preset", O);
    }
    function w(O) {
      d.value = O, _.value ? T("orbitRadius", 0.1 * O) : M.value ? T("swingAmplitude", 0.1 * O) : T("depthScale", 1 * O);
    }
    function D() {
      a.value = !a.value, a.value ? U() : c.value !== null && (cancelAnimationFrame(c.value), c.value = null);
    }
    function U() {
      a.value && (l.value = (l.value + 1) % v.value, R(), c.value = requestAnimationFrame(() => {
        setTimeout(U, 1e3 / r.fps);
      }));
    }
    function R() {
      const O = o.value;
      if (!O) return;
      const A = O.getContext("2d");
      A && (A.fillStyle = "#1e1e1e", A.fillRect(0, 0, Ki, Ki), A.fillStyle = "#333", A.fillRect(10, 10, Ki - 20, Ki - 20), A.fillStyle = "#666", A.font = "12px sans-serif", A.textAlign = "center", A.fillText("Depthflow Preview", Ki / 2, Ki / 2), A.fillText(`Frame ${l.value}`, Ki / 2, Ki / 2 + 16));
    }
    return _n(() => {
      R();
    }), Nn(() => {
      c.value !== null && cancelAnimationFrame(c.value);
    }), (O, A) => (te(), ae("div", rL, [
      f("div", oL, [
        f("div", {
          class: "section-header",
          onClick: A[0] || (A[0] = (G) => E("source"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[23] || (A[23] = f("span", null, "Source Selection", -1))
        ]),
        u.value.has("source") ? (te(), ae("div", aL, [
          f("div", lL, [
            A[25] || (A[25] = f("label", null, "Source Layer", -1)),
            f("select", {
              value: m.value.sourceLayerId,
              onChange: A[1] || (A[1] = (G) => P("sourceLayerId", G.target.value))
            }, [
              A[24] || (A[24] = f("option", { value: "" }, "Select source...", -1)),
              (te(!0), ae(qe, null, ot(x.value, (G) => (te(), ae("option", {
                key: G.id,
                value: G.id
              }, xe(G.name), 9, uL))), 128))
            ], 40, cL)
          ]),
          f("div", dL, [
            A[27] || (A[27] = f("label", null, "Depth Layer", -1)),
            f("select", {
              value: m.value.depthLayerId,
              onChange: A[2] || (A[2] = (G) => P("depthLayerId", G.target.value))
            }, [
              A[26] || (A[26] = f("option", { value: "" }, "Select depth map...", -1)),
              (te(!0), ae(qe, null, ot(g.value, (G) => (te(), ae("option", {
                key: G.id,
                value: G.id
              }, xe(G.name), 9, fL))), 128))
            ], 40, hL)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", pL, [
        f("div", {
          class: "section-header",
          onClick: A[3] || (A[3] = (G) => E("preset"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[28] || (A[28] = f("span", null, "Motion Preset", -1))
        ]),
        u.value.has("preset") ? (te(), ae("div", mL, [
          f("div", vL, [
            (te(), ae(qe, null, ot(h, (G) => f("button", {
              key: G.value,
              class: Fe(["preset-btn", { active: p.value.preset === G.value }]),
              onClick: (ue) => y(G.value)
            }, [
              f("i", {
                class: Fe(G.icon)
              }, null, 2),
              f("span", null, xe(G.label), 1)
            ], 10, gL)), 64))
          ]),
          p.value.preset !== "static" ? (te(), ae("div", yL, [
            A[29] || (A[29] = f("label", null, "Intensity", -1)),
            f("input", {
              type: "range",
              value: d.value,
              min: "0.1",
              max: "2",
              step: "0.1",
              onInput: A[4] || (A[4] = (G) => w(Number(G.target.value)))
            }, null, 40, _L),
            f("span", xL, xe(d.value.toFixed(1)) + "x", 1)
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", bL, [
        f("div", {
          class: "section-header",
          onClick: A[5] || (A[5] = (G) => E("camera"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[30] || (A[30] = f("span", null, "Camera Controls", -1))
        ]),
        u.value.has("camera") ? (te(), ae("div", wL, [
          f("div", SL, [
            A[31] || (A[31] = f("label", null, "Zoom", -1)),
            m.value.animatedZoom ? (te(), St(Lr, {
              key: 0,
              property: m.value.animatedZoom,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.zoom,
              min: "0.5",
              max: "2",
              step: "0.01",
              onInput: A[6] || (A[6] = (G) => T("zoom", Number(G.target.value)))
            }, null, 40, ML),
            f("span", CL, xe(p.value.zoom.toFixed(2)), 1)
          ]),
          f("div", EL, [
            A[32] || (A[32] = f("label", null, "Offset X", -1)),
            m.value.animatedOffsetX ? (te(), St(Lr, {
              key: 0,
              property: m.value.animatedOffsetX,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.offsetX,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: A[7] || (A[7] = (G) => T("offsetX", Number(G.target.value)))
            }, null, 40, TL),
            f("span", AL, xe(p.value.offsetX.toFixed(2)), 1)
          ]),
          f("div", PL, [
            A[33] || (A[33] = f("label", null, "Offset Y", -1)),
            m.value.animatedOffsetY ? (te(), St(Lr, {
              key: 0,
              property: m.value.animatedOffsetY,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.offsetY,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: A[8] || (A[8] = (G) => T("offsetY", Number(G.target.value)))
            }, null, 40, RL),
            f("span", DL, xe(p.value.offsetY.toFixed(2)), 1)
          ]),
          f("div", kL, [
            A[34] || (A[34] = f("label", null, "Rotation", -1)),
            m.value.animatedRotation ? (te(), St(Lr, {
              key: 0,
              property: m.value.animatedRotation,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.rotation,
              min: "-180",
              max: "180",
              step: "1",
              onInput: A[9] || (A[9] = (G) => T("rotation", Number(G.target.value)))
            }, null, 40, IL),
            f("span", LL, xe(p.value.rotation) + "", 1)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", FL, [
        f("div", {
          class: "section-header",
          onClick: A[10] || (A[10] = (G) => E("depth"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[35] || (A[35] = f("span", null, "Depth Settings", -1))
        ]),
        u.value.has("depth") ? (te(), ae("div", UL, [
          f("div", OL, [
            A[36] || (A[36] = f("label", null, "Depth Scale", -1)),
            m.value.animatedDepthScale ? (te(), St(Lr, {
              key: 0,
              property: m.value.animatedDepthScale,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.depthScale,
              min: "0",
              max: "2",
              step: "0.05",
              onInput: A[11] || (A[11] = (G) => T("depthScale", Number(G.target.value)))
            }, null, 40, zL),
            f("span", NL, xe(p.value.depthScale.toFixed(2)), 1)
          ]),
          f("div", BL, [
            A[37] || (A[37] = f("label", null, "Focus Depth", -1)),
            f("input", {
              type: "range",
              value: p.value.focusDepth,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: A[12] || (A[12] = (G) => T("focusDepth", Number(G.target.value)))
            }, null, 40, VL),
            f("span", GL, xe(p.value.focusDepth.toFixed(2)), 1)
          ]),
          A[38] || (A[38] = f("div", { class: "depth-hint" }, [
            ct(" Objects at focus depth stay stationary."),
            f("br"),
            ct(" Closer objects move more, distant objects move less. ")
          ], -1))
        ])) : Pe("", !0)
      ]),
      b.value ? (te(), ae("div", HL, [
        f("div", {
          class: "section-header",
          onClick: A[13] || (A[13] = (G) => E("presetSettings"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          f("span", null, xe(C.value), 1)
        ]),
        u.value.has("presetSettings") ? (te(), ae("div", $L, [
          _.value ? (te(), ae(qe, { key: 0 }, [
            f("div", WL, [
              A[39] || (A[39] = f("label", null, "Orbit Radius", -1)),
              f("input", {
                type: "range",
                value: p.value.orbitRadius,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: A[14] || (A[14] = (G) => T("orbitRadius", Number(G.target.value)))
              }, null, 40, XL),
              f("span", jL, xe(p.value.orbitRadius.toFixed(2)), 1)
            ]),
            f("div", YL, [
              A[40] || (A[40] = f("label", null, "Orbit Speed", -1)),
              f("input", {
                type: "range",
                value: p.value.orbitSpeed,
                min: "1",
                max: "720",
                step: "1",
                onInput: A[15] || (A[15] = (G) => T("orbitSpeed", Number(G.target.value)))
              }, null, 40, qL),
              f("span", ZL, xe(p.value.orbitSpeed) + "", 1)
            ])
          ], 64)) : Pe("", !0),
          M.value ? (te(), ae(qe, { key: 1 }, [
            f("div", KL, [
              A[41] || (A[41] = f("label", null, "Amplitude", -1)),
              f("input", {
                type: "range",
                value: p.value.swingAmplitude,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: A[16] || (A[16] = (G) => T("swingAmplitude", Number(G.target.value)))
              }, null, 40, JL),
              f("span", QL, xe(p.value.swingAmplitude.toFixed(2)), 1)
            ]),
            f("div", e5, [
              A[42] || (A[42] = f("label", null, "Frequency", -1)),
              f("input", {
                type: "range",
                value: p.value.swingFrequency,
                min: "0.1",
                max: "5",
                step: "0.1",
                onInput: A[17] || (A[17] = (G) => T("swingFrequency", Number(G.target.value)))
              }, null, 40, t5),
              f("span", n5, xe(p.value.swingFrequency.toFixed(1)) + " Hz", 1)
            ])
          ], 64)) : Pe("", !0),
          S.value ? (te(), ae("div", i5, [
            A[43] || (A[43] = f("label", null, "Dolly Rate", -1)),
            f("input", {
              type: "range",
              value: p.value.dollyZoom,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: A[18] || (A[18] = (G) => T("dollyZoom", Number(G.target.value)))
            }, null, 40, s5),
            f("span", r5, xe(p.value.dollyZoom.toFixed(2)), 1)
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ])) : Pe("", !0),
      f("div", o5, [
        f("div", {
          class: "section-header",
          onClick: A[19] || (A[19] = (G) => E("quality"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[44] || (A[44] = f("span", null, "Quality", -1))
        ]),
        u.value.has("quality") ? (te(), ae("div", a5, [
          f("div", l5, [
            A[45] || (A[45] = f("label", null, "Edge Dilation", -1)),
            f("input", {
              type: "range",
              value: p.value.edgeDilation,
              min: "0",
              max: "50",
              step: "1",
              onInput: A[20] || (A[20] = (G) => T("edgeDilation", Number(G.target.value)))
            }, null, 40, c5),
            f("span", u5, xe(p.value.edgeDilation) + "px", 1)
          ]),
          f("div", d5, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: p.value.inpaintEdges,
                onChange: A[21] || (A[21] = (G) => T("inpaintEdges", G.target.checked))
              }, null, 40, h5),
              A[46] || (A[46] = ct(" Inpaint Edges ", -1))
            ])
          ])
        ])) : Pe("", !0)
      ]),
      f("div", f5, [
        f("div", {
          class: "section-header",
          onClick: A[22] || (A[22] = (G) => E("preview"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[47] || (A[47] = f("span", null, "Preview", -1))
        ]),
        u.value.has("preview") ? (te(), ae("div", p5, [
          f("div", m5, [
            f("canvas", {
              ref_key: "previewCanvas",
              ref: o,
              class: "preview-canvas",
              width: Ki,
              height: Ki
            }, null, 512)
          ]),
          f("div", v5, [
            f("button", {
              class: Fe(["preview-btn", { active: a.value }]),
              onClick: D
            }, [
              f("i", {
                class: Fe(a.value ? "pi pi-pause" : "pi pi-play")
              }, null, 2),
              ct(" " + xe(a.value ? "Pause" : "Play"), 1)
            ], 2),
            f("span", g5, " Frame " + xe(l.value) + " / " + xe(v.value - 1), 1)
          ])
        ])) : Pe("", !0)
      ])
    ]));
  }
}), _5 = /* @__PURE__ */ Gt(y5, [["__scopeId", "data-v-ffaf4c8a"]]), x5 = { class: "light-properties" }, b5 = { class: "property-section" }, w5 = { class: "section-content" }, S5 = { class: "property-row" }, M5 = ["value"], C5 = { class: "property-group" }, E5 = { class: "property-group" }, T5 = { class: "control-row" }, A5 = { class: "property-group" }, P5 = { class: "control-row" }, R5 = { class: "property-group" }, D5 = {
  key: 1,
  class: "property-row"
}, k5 = ["value"], I5 = {
  key: 2,
  class: "property-group"
}, L5 = {
  key: 3,
  class: "property-group"
}, F5 = { class: "property-group checkbox-row" }, U5 = ["checked"], O5 = { class: "property-group" }, z5 = { class: "property-group" }, N5 = {
  key: 5,
  class: "note"
}, B5 = /* @__PURE__ */ Ot({
  __name: "LightProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = Ie(() => n.layer.data || {
      lightType: "spot",
      color: "#ffffff",
      intensity: 100,
      radius: 500,
      falloff: "none",
      falloffDistance: 500,
      castShadows: !1,
      shadowDarkness: 100,
      shadowDiffusion: 0,
      coneAngle: 90,
      coneFeather: 50
    });
    function a(l, c) {
      r.updateLayer(n.layer.id, {
        data: { ...o.value, [l]: c }
      }), i("update");
    }
    return (l, c) => (te(), ae("div", x5, [
      f("div", b5, [
        c[25] || (c[25] = f("div", { class: "section-header" }, "Light Settings", -1)),
        f("div", w5, [
          f("div", S5, [
            c[13] || (c[13] = f("label", null, "Type", -1)),
            f("select", {
              value: o.value.lightType,
              onChange: c[0] || (c[0] = (u) => a("lightType", u.target.value)),
              class: "type-select"
            }, [...c[12] || (c[12] = [
              f("option", { value: "parallel" }, "Parallel", -1),
              f("option", { value: "spot" }, "Spot", -1),
              f("option", { value: "point" }, "Point", -1),
              f("option", { value: "ambient" }, "Ambient", -1)
            ])], 40, M5)
          ]),
          f("div", C5, [
            c[14] || (c[14] = f("label", null, "Color", -1)),
            ze(Ve(lu), {
              modelValue: o.value.color,
              "onUpdate:modelValue": c[1] || (c[1] = (u) => a("color", u))
            }, null, 8, ["modelValue"])
          ]),
          f("div", E5, [
            c[15] || (c[15] = f("label", null, "Intensity", -1)),
            f("div", T5, [
              ze(Ve(jn), {
                modelValue: o.value.intensity,
                "onUpdate:modelValue": c[2] || (c[2] = (u) => a("intensity", u)),
                min: 0,
                max: 500,
                step: 1,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ]),
          o.value.lightType === "spot" ? (te(), ae(qe, { key: 0 }, [
            f("div", A5, [
              c[16] || (c[16] = f("label", null, "Cone Angle", -1)),
              f("div", P5, [
                ze(Ve(Zf), {
                  modelValue: o.value.coneAngle ?? 90,
                  "onUpdate:modelValue": c[3] || (c[3] = (u) => a("coneAngle", u)),
                  size: 32
                }, null, 8, ["modelValue"]),
                ze(Ve(et), {
                  modelValue: o.value.coneAngle ?? 90,
                  "onUpdate:modelValue": c[4] || (c[4] = (u) => a("coneAngle", u)),
                  unit: ""
                }, null, 8, ["modelValue"])
              ])
            ]),
            f("div", R5, [
              c[17] || (c[17] = f("label", null, "Cone Feather", -1)),
              ze(Ve(jn), {
                modelValue: o.value.coneFeather ?? 50,
                "onUpdate:modelValue": c[5] || (c[5] = (u) => a("coneFeather", u)),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : Pe("", !0),
          o.value.lightType !== "ambient" ? (te(), ae("div", D5, [
            c[19] || (c[19] = f("label", null, "Falloff", -1)),
            f("select", {
              value: o.value.falloff,
              onChange: c[6] || (c[6] = (u) => a("falloff", u.target.value)),
              class: "type-select"
            }, [...c[18] || (c[18] = [
              f("option", { value: "none" }, "None", -1),
              f("option", { value: "smooth" }, "Smooth", -1),
              f("option", { value: "inverseSquareClamped" }, "Inverse Square Clamped", -1)
            ])], 40, k5)
          ])) : Pe("", !0),
          o.value.lightType !== "ambient" && o.value.lightType !== "parallel" ? (te(), ae("div", I5, [
            c[20] || (c[20] = f("label", null, "Radius", -1)),
            ze(Ve(et), {
              modelValue: o.value.radius,
              "onUpdate:modelValue": c[7] || (c[7] = (u) => a("radius", u)),
              min: 0,
              unit: "px"
            }, null, 8, ["modelValue"])
          ])) : Pe("", !0),
          o.value.lightType !== "ambient" ? (te(), ae("div", L5, [
            c[21] || (c[21] = f("label", null, "Falloff Distance", -1)),
            ze(Ve(et), {
              modelValue: o.value.falloffDistance ?? 500,
              "onUpdate:modelValue": c[8] || (c[8] = (u) => a("falloffDistance", u)),
              min: 0,
              unit: "px"
            }, null, 8, ["modelValue"])
          ])) : Pe("", !0),
          f("div", F5, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: o.value.castShadows,
                onChange: c[9] || (c[9] = (u) => a("castShadows", u.target.checked))
              }, null, 40, U5),
              c[22] || (c[22] = ct(" Casts Shadows ", -1))
            ])
          ]),
          o.value.castShadows ? (te(), ae(qe, { key: 4 }, [
            f("div", O5, [
              c[23] || (c[23] = f("label", null, "Shadow Darkness", -1)),
              ze(Ve(jn), {
                modelValue: o.value.shadowDarkness ?? 100,
                "onUpdate:modelValue": c[10] || (c[10] = (u) => a("shadowDarkness", u)),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"])
            ]),
            f("div", z5, [
              c[24] || (c[24] = f("label", null, "Shadow Diffusion", -1)),
              ze(Ve(et), {
                modelValue: o.value.shadowDiffusion ?? 0,
                "onUpdate:modelValue": c[11] || (c[11] = (u) => a("shadowDiffusion", u)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : Pe("", !0),
          o.value.castShadows ? (te(), ae("div", N5, " Note: Shadows are only cast from layers with 'Cast Shadows' enabled to layers with 'Accepts Shadows' enabled. ")) : Pe("", !0)
        ])
      ])
    ]));
  }
}), V5 = /* @__PURE__ */ Gt(B5, [["__scopeId", "data-v-7bf0f1bf"]]), G5 = { class: "shape-properties" }, H5 = { class: "property-section" }, $5 = { class: "section-content" }, W5 = { class: "property-group" }, X5 = { class: "group-header" }, j5 = ["checked"], Y5 = {
  key: 0,
  class: "control-row"
}, q5 = { class: "property-group" }, Z5 = { class: "group-header" }, K5 = ["checked"], J5 = {
  key: 0,
  class: "stroke-controls"
}, Q5 = { class: "control-row" }, e4 = { class: "property-row" }, t4 = { class: "property-row" }, n4 = { class: "icon-toggle-group" }, i4 = { class: "property-group" }, s4 = { class: "control-row checkbox-row" }, r4 = ["checked"], o4 = /* @__PURE__ */ Ot({
  __name: "ShapeProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = Ie(() => n.layer.data || {
      pathData: "",
      controlPoints: [],
      closed: !1,
      stroke: "#ffffff",
      strokeWidth: 2,
      fill: ""
    }), a = Ie(() => !!o.value.fill && o.value.fill !== "transparent"), l = Ie(() => !!o.value.stroke && o.value.strokeWidth > 0), c = Ie(() => o.value.strokeLineCap || "round");
    function u(m, p) {
      r.updateLayer(n.layer.id, {
        data: { ...o.value, [m]: p }
      }), i("update");
    }
    function d(m) {
      const p = m.target.checked;
      u("fill", p ? "#ffffff" : "");
    }
    function h(m) {
      m.target.checked ? (u("stroke", "#ffffff"), u("strokeWidth", 2)) : u("strokeWidth", 0);
    }
    return (m, p) => (te(), ae("div", G5, [
      f("div", H5, [
        p[13] || (p[13] = f("div", { class: "section-header" }, "Shape Appearance", -1)),
        f("div", $5, [
          f("div", W5, [
            f("div", X5, [
              p[7] || (p[7] = f("label", null, "Fill", -1)),
              f("input", {
                type: "checkbox",
                checked: a.value,
                onChange: d
              }, null, 40, j5)
            ]),
            a.value ? (te(), ae("div", Y5, [
              ze(Ve(lu), {
                modelValue: o.value.fill || "#ffffff",
                "onUpdate:modelValue": p[0] || (p[0] = (v) => u("fill", v)),
                alpha: !0
              }, null, 8, ["modelValue"])
            ])) : Pe("", !0)
          ]),
          f("div", q5, [
            f("div", Z5, [
              p[8] || (p[8] = f("label", null, "Stroke", -1)),
              f("input", {
                type: "checkbox",
                checked: l.value,
                onChange: h
              }, null, 40, K5)
            ]),
            l.value ? (te(), ae("div", J5, [
              f("div", Q5, [
                ze(Ve(lu), {
                  modelValue: o.value.stroke || "#ffffff",
                  "onUpdate:modelValue": p[1] || (p[1] = (v) => u("stroke", v)),
                  alpha: !0
                }, null, 8, ["modelValue"])
              ]),
              f("div", e4, [
                p[9] || (p[9] = f("label", { class: "sub-label" }, "Width", -1)),
                ze(Ve(et), {
                  modelValue: o.value.strokeWidth || 0,
                  "onUpdate:modelValue": p[2] || (p[2] = (v) => u("strokeWidth", v)),
                  min: 0,
                  max: 500,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ]),
              f("div", t4, [
                p[10] || (p[10] = f("label", { class: "sub-label" }, "Cap", -1)),
                f("div", n4, [
                  f("button", {
                    class: Fe({ active: c.value === "butt" }),
                    onClick: p[3] || (p[3] = (v) => u("strokeLineCap", "butt")),
                    title: "Butt Cap"
                  }, "I", 2),
                  f("button", {
                    class: Fe({ active: c.value === "round" }),
                    onClick: p[4] || (p[4] = (v) => u("strokeLineCap", "round")),
                    title: "Round Cap"
                  }, "C", 2),
                  f("button", {
                    class: Fe({ active: c.value === "square" }),
                    onClick: p[5] || (p[5] = (v) => u("strokeLineCap", "square")),
                    title: "Square Cap"
                  }, "H", 2)
                ])
              ])
            ])) : Pe("", !0)
          ]),
          f("div", i4, [
            p[12] || (p[12] = f("label", null, "Path", -1)),
            f("div", s4, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.closed,
                  onChange: p[6] || (p[6] = (v) => u("closed", v.target.checked))
                }, null, 40, r4),
                p[11] || (p[11] = ct(" Closed Path ", -1))
              ])
            ])
          ])
        ])
      ])
    ]));
  }
}), a4 = /* @__PURE__ */ Gt(o4, [["__scopeId", "data-v-e2af8c92"]]), l4 = { class: "video-properties" }, c4 = {
  key: 0,
  class: "property-section"
}, u4 = { class: "section-content info-grid" }, d4 = { class: "info-row" }, h4 = { class: "info-value" }, f4 = { class: "info-row" }, p4 = { class: "info-value" }, m4 = { class: "info-row" }, v4 = { class: "info-value" }, g4 = { class: "info-row" }, y4 = { class: "info-value" }, _4 = { class: "property-section" }, x4 = { class: "section-content" }, b4 = { class: "property-row" }, w4 = { class: "property-row" }, S4 = { class: "property-row" }, M4 = { class: "checkbox-group" }, C4 = { class: "checkbox-row" }, E4 = ["checked"], T4 = { class: "checkbox-row" }, A4 = ["checked"], P4 = { class: "property-section" }, R4 = { class: "section-header" }, D4 = { class: "header-toggle" }, k4 = ["checked"], I4 = {
  key: 0,
  class: "section-content"
}, L4 = { class: "property-row" }, F4 = { class: "control-with-keyframe" }, U4 = { class: "property-section" }, O4 = { class: "section-content" }, z4 = { class: "property-row" }, N4 = ["value"], B4 = {
  key: 1,
  class: "property-section"
}, V4 = { class: "section-content" }, G4 = { class: "checkbox-group" }, H4 = { class: "checkbox-row" }, $4 = ["checked"], W4 = {
  key: 0,
  class: "property-row"
}, X4 = { class: "control-with-keyframe" }, j4 = {
  key: 1,
  class: "property-row"
}, Y4 = {
  key: 2,
  class: "waveform-container"
}, q4 = /* @__PURE__ */ Ot({
  __name: "VideoProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = Ie(() => n.layer.data || {
      assetId: null,
      loop: !1,
      pingPong: !1,
      startTime: 0,
      endTime: void 0,
      speed: 1,
      timeRemapEnabled: !1,
      timeRemap: void 0,
      frameBlending: "none",
      audioEnabled: !0,
      audioLevel: 100,
      posterFrame: 0
    }), a = Ie(() => {
      const C = o.value.assetId;
      return C && r.assets[C] || null;
    }), l = Ie(() => {
      var C;
      return (C = n.layer.audio) == null ? void 0 : C.level;
    }), c = Ie(() => o.value.timeRemap ? o.value.timeRemap.value : 0);
    function u(C) {
      var y;
      if (!C) return "0:00";
      const E = Math.floor(C / 60), P = Math.floor(C % 60), T = Math.floor(C % 1 * (((y = a.value) == null ? void 0 : y.fps) || 30));
      return `${E}:${P.toString().padStart(2, "0")}:${T.toString().padStart(2, "0")}`;
    }
    function d(C) {
      r.updateVideoLayerData(n.layer.id, { speed: C }), i("update");
    }
    function h(C) {
      r.updateVideoLayerData(n.layer.id, { startTime: C }), i("update");
    }
    function m(C) {
      r.updateVideoLayerData(n.layer.id, { endTime: C }), i("update");
    }
    function p(C) {
      const E = C.target;
      r.updateVideoLayerData(n.layer.id, { loop: E.checked }), i("update");
    }
    function v(C) {
      const E = C.target;
      r.updateVideoLayerData(n.layer.id, { pingPong: E.checked }), i("update");
    }
    function x(C) {
      const E = C.target;
      r.updateVideoLayerData(n.layer.id, { timeRemapEnabled: E.checked }), i("update");
    }
    function g(C) {
      const E = n.layer.data;
      E.timeRemap && (E.timeRemap.value = C), i("update");
    }
    function _(C) {
      const E = C.target;
      r.updateVideoLayerData(n.layer.id, { frameBlending: E.value }), i("update");
    }
    function M(C) {
      const E = C.target;
      r.updateVideoLayerData(n.layer.id, { audioEnabled: E.checked }), i("update");
    }
    function S(C) {
      r.updateVideoLayerData(n.layer.id, { audioLevel: C }), i("update");
    }
    function b(C) {
      var E;
      (E = n.layer.audio) != null && E.level && (n.layer.audio.level.value = C, i("update"));
    }
    return (C, E) => {
      var P, T, y;
      return te(), ae("div", l4, [
        a.value ? (te(), ae("div", c4, [
          E[4] || (E[4] = f("div", { class: "section-header" }, "Video Info", -1)),
          f("div", u4, [
            f("div", d4, [
              E[0] || (E[0] = f("span", { class: "info-label" }, "Dimensions", -1)),
              f("span", h4, xe(a.value.width) + "  " + xe(a.value.height), 1)
            ]),
            f("div", f4, [
              E[1] || (E[1] = f("span", { class: "info-label" }, "Duration", -1)),
              f("span", p4, xe(u(a.value.duration)), 1)
            ]),
            f("div", m4, [
              E[2] || (E[2] = f("span", { class: "info-label" }, "Frame Rate", -1)),
              f("span", v4, xe(((P = a.value.fps) == null ? void 0 : P.toFixed(2)) || "?") + " fps", 1)
            ]),
            f("div", g4, [
              E[3] || (E[3] = f("span", { class: "info-label" }, "Has Audio", -1)),
              f("span", y4, xe(a.value.hasAudio ? "Yes" : "No"), 1)
            ])
          ])
        ])) : Pe("", !0),
        f("div", _4, [
          E[10] || (E[10] = f("div", { class: "section-header" }, "Playback", -1)),
          f("div", x4, [
            f("div", b4, [
              E[5] || (E[5] = f("label", null, "Speed", -1)),
              ze(Ve(et), {
                modelValue: o.value.speed,
                "onUpdate:modelValue": d,
                min: 0.1,
                max: 10,
                step: 0.1,
                precision: 2,
                unit: "x"
              }, null, 8, ["modelValue"])
            ]),
            f("div", w4, [
              E[6] || (E[6] = f("label", null, "Start Time", -1)),
              ze(Ve(et), {
                modelValue: o.value.startTime,
                "onUpdate:modelValue": h,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            f("div", S4, [
              E[7] || (E[7] = f("label", null, "End Time", -1)),
              ze(Ve(et), {
                modelValue: o.value.endTime || ((T = a.value) == null ? void 0 : T.duration) || 0,
                "onUpdate:modelValue": m,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            f("div", M4, [
              f("label", C4, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.loop,
                  onChange: p
                }, null, 40, E4),
                E[8] || (E[8] = f("span", null, "Loop", -1))
              ]),
              f("label", T4, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.pingPong,
                  onChange: v
                }, null, 40, A4),
                E[9] || (E[9] = f("span", null, "Ping-Pong", -1))
              ])
            ])
          ])
        ]),
        f("div", P4, [
          f("div", R4, [
            E[11] || (E[11] = f("span", null, "Time Remap", -1)),
            f("label", D4, [
              f("input", {
                type: "checkbox",
                checked: o.value.timeRemapEnabled,
                onChange: x
              }, null, 40, k4)
            ])
          ]),
          o.value.timeRemapEnabled ? (te(), ae("div", I4, [
            f("div", L4, [
              E[12] || (E[12] = f("label", null, "Remap Time", -1)),
              f("div", F4, [
                ze(Ve(et), {
                  modelValue: c.value,
                  "onUpdate:modelValue": g,
                  min: 0,
                  step: 0.01,
                  precision: 3,
                  unit: "s"
                }, null, 8, ["modelValue"]),
                o.value.timeRemap ? (te(), St(Lr, {
                  key: 0,
                  property: o.value.timeRemap,
                  layerId: s.layer.id,
                  propertyPath: "data.timeRemap"
                }, null, 8, ["property", "layerId"])) : Pe("", !0)
              ])
            ]),
            E[13] || (E[13] = f("p", { class: "hint" }, "Animate time remap to control video playback independently of composition time.", -1))
          ])) : Pe("", !0)
        ]),
        f("div", U4, [
          E[16] || (E[16] = f("div", { class: "section-header" }, "Frame Blending", -1)),
          f("div", O4, [
            f("div", z4, [
              E[15] || (E[15] = f("label", null, "Mode", -1)),
              f("select", {
                value: o.value.frameBlending,
                onChange: _,
                class: "select-input"
              }, [...E[14] || (E[14] = [
                f("option", { value: "none" }, "None", -1),
                f("option", { value: "frame-mix" }, "Frame Mix", -1),
                f("option", { value: "pixel-motion" }, "Pixel Motion", -1)
              ])], 40, N4)
            ])
          ])
        ]),
        ((y = a.value) == null ? void 0 : y.hasAudio) !== !1 ? (te(), ae("div", B4, [
          E[21] || (E[21] = f("div", { class: "section-header" }, "Audio", -1)),
          f("div", V4, [
            f("div", G4, [
              f("label", H4, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.audioEnabled,
                  onChange: M
                }, null, 40, $4),
                E[17] || (E[17] = f("span", null, "Audio Enabled", -1))
              ])
            ]),
            o.value.audioEnabled ? (te(), ae("div", W4, [
              E[18] || (E[18] = f("label", null, "Level", -1)),
              f("div", X4, [
                l.value ? (te(), St(Ve(et), {
                  key: 0,
                  modelValue: l.value.value,
                  "onUpdate:modelValue": b,
                  unit: "dB",
                  min: -48,
                  max: 12,
                  precision: 1
                }, null, 8, ["modelValue"])) : Pe("", !0),
                l.value ? (te(), St(Lr, {
                  key: 1,
                  property: l.value,
                  layerId: s.layer.id
                }, null, 8, ["property", "layerId"])) : Pe("", !0)
              ])
            ])) : Pe("", !0),
            o.value.audioEnabled ? (te(), ae("div", j4, [
              E[19] || (E[19] = f("label", null, "Volume", -1)),
              ze(Ve(et), {
                modelValue: o.value.audioLevel,
                "onUpdate:modelValue": S,
                min: 0,
                max: 200,
                step: 1,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])) : Pe("", !0),
            o.value.audioEnabled ? (te(), ae("div", Y4, [...E[20] || (E[20] = [
              f("div", { class: "waveform-placeholder" }, "Audio Waveform", -1)
            ])])) : Pe("", !0)
          ])
        ])) : Pe("", !0)
      ]);
    };
  }
}), Z4 = /* @__PURE__ */ Gt(q4, [["__scopeId", "data-v-5f46759a"]]), K4 = ["title"], J4 = {
  viewBox: "0 0 16 16",
  class: "pickwhip-icon"
}, Q4 = {
  key: 0,
  d: "M8 5 L8 2 M8 11 L8 14 M5 8 L2 8 M11 8 L14 8",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
}, eF = {
  key: 1,
  d: "M11 5 L14 2 M11 11 L14 14",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
}, tF = ["x1", "y1", "x2", "y2"], nF = ["cx", "cy"], iF = { class: "drop-label" }, sF = /* @__PURE__ */ Ot({
  __name: "Pickwhip",
  props: {
    layerId: {},
    property: {},
    linkedTo: {}
  },
  emits: ["link", "unlink"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we(null), o = we(!1), a = we({ x: 0, y: 0 }), l = we({ x: 0, y: 0 }), c = we(null), u = Ie(() => !!n.linkedTo), d = Ie(() => n.linkedTo ? `${n.linkedTo.layerId}.${n.linkedTo.property}` : ""), h = Ie(() => ({
      position: "fixed",
      top: 0,
      left: 0,
      width: "100vw",
      height: "100vh",
      pointerEvents: "none",
      zIndex: 1e4
    })), m = Ie(() => {
      if (!c.value) return {};
      const b = c.value.rect;
      return {
        position: "fixed",
        top: `${b.top}px`,
        left: `${b.left}px`,
        width: `${b.width}px`,
        height: `${b.height}px`,
        zIndex: 9999
      };
    });
    function p() {
      const b = [];
      return document.querySelectorAll("[data-pickwhip-target]").forEach((E) => {
        const P = E, T = P.dataset.pickwhipLayerId, y = P.dataset.pickwhipTarget, w = P.dataset.pickwhipLabel || y;
        T === n.layerId && y === n.property || T && y && b.push({
          layerId: T,
          property: y,
          label: w,
          element: P,
          rect: P.getBoundingClientRect()
        });
      }), b;
    }
    function v(b, C, E) {
      for (const P of E) {
        const T = P.rect;
        if (b >= T.left && b <= T.right && C >= T.top && C <= T.bottom)
          return P;
      }
      return null;
    }
    let x = [];
    function g(b) {
      var T;
      b.preventDefault(), b.stopPropagation();
      const C = "touches" in b ? b.touches[0].clientX : b.clientX, E = "touches" in b ? b.touches[0].clientY : b.clientY, P = (T = r.value) == null ? void 0 : T.getBoundingClientRect();
      P ? a.value = { x: P.left + P.width / 2, y: P.top + P.height / 2 } : a.value = { x: C, y: E }, l.value = { x: C, y: E }, o.value = !0, x = p(), window.addEventListener("mousemove", _), window.addEventListener("mouseup", M), window.addEventListener("touchmove", _), window.addEventListener("touchend", M);
    }
    function _(b) {
      if (!o.value) return;
      const C = "touches" in b ? b.touches[0].clientX : b.clientX, E = "touches" in b ? b.touches[0].clientY : b.clientY;
      l.value = { x: C, y: E }, x.forEach((P) => {
        P.rect = P.element.getBoundingClientRect();
      }), c.value = v(C, E, x);
    }
    function M(b) {
      if (!o.value) return;
      const C = "changedTouches" in b ? b.changedTouches[0].clientX : b.clientX, E = "changedTouches" in b ? b.changedTouches[0].clientY : b.clientY, P = v(C, E, x);
      P && i("link", { layerId: P.layerId, property: P.property }), o.value = !1, c.value = null, x = [], window.removeEventListener("mousemove", _), window.removeEventListener("mouseup", M), window.removeEventListener("touchmove", _), window.removeEventListener("touchend", M);
    }
    function S() {
      i("unlink");
    }
    return Nn(() => {
      window.removeEventListener("mousemove", _), window.removeEventListener("mouseup", M), window.removeEventListener("touchmove", _), window.removeEventListener("touchend", M);
    }), (b, C) => (te(), ae("div", {
      class: "pickwhip-container",
      ref_key: "containerRef",
      ref: r
    }, [
      f("div", {
        class: Fe(["pickwhip-handle", { dragging: o.value, linked: u.value }]),
        onMousedown: g,
        onTouchstart: _t(g, ["prevent"]),
        title: u.value ? `Linked to: ${d.value}` : "Drag to link property"
      }, [
        (te(), ae("svg", J4, [
          C[0] || (C[0] = f("circle", {
            cx: "8",
            cy: "8",
            r: "3",
            fill: "currentColor"
          }, null, -1)),
          u.value ? (te(), ae("path", eF)) : (te(), ae("path", Q4))
        ]))
      ], 42, K4),
      u.value ? (te(), ae("button", {
        key: 0,
        class: "clear-link-btn",
        onClick: S,
        title: "Remove link"
      }, "  ")) : Pe("", !0),
      (te(), St(Uo, { to: "body" }, [
        o.value ? (te(), ae("svg", {
          key: 0,
          class: "pickwhip-line",
          style: yt(h.value)
        }, [
          f("line", {
            x1: a.value.x,
            y1: a.value.y,
            x2: l.value.x,
            y2: l.value.y,
            stroke: "#4a90d9",
            "stroke-width": "2",
            "stroke-dasharray": "4 2"
          }, null, 8, tF),
          f("circle", {
            cx: l.value.x,
            cy: l.value.y,
            r: "6",
            fill: "#4a90d9",
            stroke: "#fff",
            "stroke-width": "1"
          }, null, 8, nF)
        ], 4)) : Pe("", !0)
      ])),
      (te(), St(Uo, { to: "body" }, [
        o.value && c.value ? (te(), ae("div", {
          key: 0,
          class: "drop-target-highlight",
          style: yt(m.value)
        }, [
          f("span", iF, xe(c.value.label), 1)
        ], 4)) : Pe("", !0)
      ]))
    ], 512));
  }
}), vc = /* @__PURE__ */ Gt(sF, [["__scopeId", "data-v-da1938e3"]]), rF = {
  key: 0,
  class: "driver-list"
}, oF = { class: "expand-icon" }, aF = { class: "count" }, lF = {
  key: 0,
  class: "driver-items"
}, cF = { class: "driver-header" }, uF = ["onClick"], dF = { class: "driver-info" }, hF = { class: "target" }, fF = {
  key: 0,
  class: "source"
}, pF = {
  key: 1,
  class: "source audio"
}, mF = {
  key: 2,
  class: "source time"
}, vF = ["onClick"], gF = {
  key: 0,
  class: "driver-transforms"
}, yF = ["title"], _F = {
  key: 1,
  class: "add-driver-section"
}, xF = {
  key: 0,
  class: "add-menu"
}, bF = { class: "menu-section" }, wF = { class: "menu-section" }, SF = { class: "menu-section" }, MF = { class: "menu-section" }, CF = { class: "menu-actions" }, EF = /* @__PURE__ */ Ot({
  __name: "DriverList",
  props: {
    layerId: {}
  },
  setup(s) {
    const e = s, n = sn(), i = we(!0), r = we(!1), o = we({
      audioFeature: "amplitude",
      targetProperty: "transform.position.y",
      scale: 100,
      threshold: 0
    }), a = Ie(() => n.getDriversForLayer(e.layerId));
    function l(p) {
      return p ? {
        "transform.position.x": "Pos X",
        "transform.position.y": "Pos Y",
        "transform.position.z": "Pos Z",
        "transform.scale.x": "Scale X",
        "transform.scale.y": "Scale Y",
        "transform.rotation": "Rotation",
        "transform.rotationX": "Rot X",
        "transform.rotationY": "Rot Y",
        "transform.rotationZ": "Rot Z",
        opacity: "Opacity"
      }[p] || p : "?";
    }
    function c(p) {
      if (!p) return "?";
      const v = n.layers.find((x) => x.id === p);
      return (v == null ? void 0 : v.name) || p.slice(0, 8);
    }
    function u(p) {
      switch (p.type) {
        case "scale":
          return `Scale: ${p.factor}`;
        case "offset":
          return `Offset: ${p.amount}`;
        case "clamp":
          return `Clamp: ${p.min}-${p.max}`;
        case "smooth":
          return `Smooth: ${p.smoothing}`;
        case "threshold":
          return `Threshold: ${p.threshold}`;
        default:
          return p.type;
      }
    }
    function d(p) {
      n.togglePropertyDriver(p);
    }
    function h(p) {
      n.removePropertyDriver(p);
    }
    function m() {
      n.createAudioPropertyDriver(
        e.layerId,
        o.value.targetProperty,
        o.value.audioFeature,
        {
          scale: o.value.scale,
          threshold: o.value.threshold > 0 ? o.value.threshold : void 0
        }
      ), r.value = !1;
    }
    return (p, v) => a.value.length > 0 ? (te(), ae("div", rF, [
      f("div", {
        class: "driver-list-header",
        onClick: v[0] || (v[0] = (x) => i.value = !i.value)
      }, [
        f("span", oF, xe(i.value ? "" : ""), 1),
        v[7] || (v[7] = f("span", { class: "title" }, "Property Drivers", -1)),
        f("span", aF, "(" + xe(a.value.length) + ")", 1)
      ]),
      i.value ? (te(), ae("div", lF, [
        (te(!0), ae(qe, null, ot(a.value, (x) => (te(), ae("div", {
          key: x.id,
          class: Fe(["driver-item", { disabled: !x.enabled }])
        }, [
          f("div", cF, [
            f("button", {
              class: Fe(["toggle-btn", { active: x.enabled }]),
              onClick: (g) => d(x.id),
              title: "Toggle driver"
            }, "  ", 10, uF),
            f("div", dF, [
              f("span", hF, xe(l(x.targetProperty)), 1),
              v[8] || (v[8] = f("span", { class: "arrow" }, "", -1)),
              x.sourceType === "property" ? (te(), ae("span", fF, xe(c(x.sourceLayerId)) + "." + xe(l(x.sourceProperty)), 1)) : x.sourceType === "audio" ? (te(), ae("span", pF, "  " + xe(x.audioFeature), 1)) : x.sourceType === "time" ? (te(), ae("span", mF, "  Time ")) : Pe("", !0)
            ]),
            f("button", {
              class: "remove-btn",
              onClick: (g) => h(x.id),
              title: "Remove driver"
            }, "  ", 8, vF)
          ]),
          x.transforms.length > 0 ? (te(), ae("div", gF, [
            (te(!0), ae(qe, null, ot(x.transforms, (g, _) => (te(), ae("span", {
              key: _,
              class: "transform-chip",
              title: u(g)
            }, xe(g.type), 9, yF))), 128))
          ])) : Pe("", !0)
        ], 2))), 128))
      ])) : Pe("", !0),
      i.value ? (te(), ae("div", _F, [
        f("button", {
          class: "add-driver-btn",
          onClick: v[1] || (v[1] = (x) => r.value = !r.value)
        }, " + Add Audio Driver "),
        r.value ? (te(), ae("div", xF, [
          f("div", bF, [
            v[10] || (v[10] = f("label", null, "Audio Feature:", -1)),
            st(f("select", {
              "onUpdate:modelValue": v[2] || (v[2] = (x) => o.value.audioFeature = x)
            }, [...v[9] || (v[9] = [
              as('<option value="amplitude" data-v-d3107912>Amplitude</option><option value="bass" data-v-d3107912>Bass</option><option value="mid" data-v-d3107912>Mid</option><option value="high" data-v-d3107912>High</option><option value="rms" data-v-d3107912>RMS</option>', 5)
            ])], 512), [
              [Cn, o.value.audioFeature]
            ])
          ]),
          f("div", wF, [
            v[12] || (v[12] = f("label", null, "Target Property:", -1)),
            st(f("select", {
              "onUpdate:modelValue": v[3] || (v[3] = (x) => o.value.targetProperty = x)
            }, [...v[11] || (v[11] = [
              as('<option value="transform.position.x" data-v-d3107912>Position X</option><option value="transform.position.y" data-v-d3107912>Position Y</option><option value="transform.scale.x" data-v-d3107912>Scale X</option><option value="transform.scale.y" data-v-d3107912>Scale Y</option><option value="transform.rotation" data-v-d3107912>Rotation</option><option value="opacity" data-v-d3107912>Opacity</option>', 6)
            ])], 512), [
              [Cn, o.value.targetProperty]
            ])
          ]),
          f("div", SF, [
            v[13] || (v[13] = f("label", null, "Scale:", -1)),
            st(f("input", {
              type: "number",
              "onUpdate:modelValue": v[4] || (v[4] = (x) => o.value.scale = x),
              step: "10"
            }, null, 512), [
              [
                Ut,
                o.value.scale,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          f("div", MF, [
            v[14] || (v[14] = f("label", null, "Threshold:", -1)),
            st(f("input", {
              type: "number",
              "onUpdate:modelValue": v[5] || (v[5] = (x) => o.value.threshold = x),
              min: "0",
              max: "1",
              step: "0.1"
            }, null, 512), [
              [
                Ut,
                o.value.threshold,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          f("div", CF, [
            f("button", { onClick: m }, "Create"),
            f("button", {
              onClick: v[6] || (v[6] = (x) => r.value = !1)
            }, "Cancel")
          ])
        ])) : Pe("", !0)
      ])) : Pe("", !0)
    ])) : Pe("", !0);
  }
}), TF = /* @__PURE__ */ Gt(EF, [["__scopeId", "data-v-d3107912"]]), AF = { class: "properties-panel" }, PF = {
  key: 0,
  class: "panel-content"
}, RF = { class: "property-section" }, DF = { class: "property-row" }, kF = { class: "property-section" }, IF = { class: "property-row" }, LF = ["value"], FF = ["value"], UF = { class: "property-section" }, OF = { class: "expand-icon" }, zF = {
  key: 0,
  class: "section-content"
}, NF = ["data-pickwhip-layer-id"], BF = { class: "multi-value" }, VF = { class: "multi-value" }, GF = { class: "property-row" }, HF = { class: "multi-value orientation-row" }, $F = { class: "property-row" }, WF = { class: "single-value" }, XF = { class: "property-row" }, jF = { class: "single-value" }, YF = { class: "property-row" }, qF = { class: "single-value" }, ZF = { class: "single-value" }, KF = { class: "property-row" }, JF = { class: "multi-value" }, QF = { class: "single-value" }, eU = { class: "property-section" }, tU = { class: "property-row" }, nU = ["value"], iU = {
  key: 1,
  class: "empty-state"
}, sU = /* @__PURE__ */ Ot({
  __name: "PropertiesPanel",
  setup(s) {
    const e = sn(), n = we(["transform"]), i = we(!0), r = we(""), o = we({
      position: { x: 0, y: 0, z: 0 },
      scale: { x: 100, y: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0 },
      opacity: 100,
      // 3D properties
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0
    }), a = we("normal"), l = we([]), c = [
      { label: "Normal", value: "normal" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
      { label: "Add", value: "add" }
    ], u = Ie(() => e.selectedLayer), d = Ie(() => {
      if (!u.value) return [];
      const T = u.value.id, y = (D) => {
        const U = e.layers.filter((O) => O.parentId === D);
        let R = U.map((O) => O.id);
        for (const O of U)
          R = R.concat(y(O.id));
        return R;
      }, w = new Set(y(T));
      return e.layers.filter(
        (D) => D.id !== T && !w.has(D.id) && D.type !== "camera"
        // Camera layers shouldn't be parents
      );
    }), h = Ie(() => {
      if (!u.value) return null;
      switch (u.value.type) {
        case "text":
          return Ss(nR);
        case "particles":
          return Ss(nL);
        case "depthflow":
          return Ss(_5);
        case "light":
          return Ss(V5);
        case "spline":
          return Ss(a4);
        case "video":
          return Ss(Z4);
        default:
          return null;
      }
    });
    Ft(u, (T) => {
      var y, w, D, U, R, O, A, G, ue, Q, le, re, j, $, q, oe, ie, ce, V, Y, H, I, F, L, ee;
      if (T) {
        r.value = T.name;
        const Z = T.transform;
        o.value = {
          position: {
            x: ((w = (y = Z == null ? void 0 : Z.position) == null ? void 0 : y.value) == null ? void 0 : w.x) || 0,
            y: ((U = (D = Z == null ? void 0 : Z.position) == null ? void 0 : D.value) == null ? void 0 : U.y) || 0,
            z: ((O = (R = Z == null ? void 0 : Z.position) == null ? void 0 : R.value) == null ? void 0 : O.z) || 0
          },
          scale: { x: ((G = (A = Z == null ? void 0 : Z.scale) == null ? void 0 : A.value) == null ? void 0 : G.x) || 100, y: ((Q = (ue = Z == null ? void 0 : Z.scale) == null ? void 0 : ue.value) == null ? void 0 : Q.y) || 100 },
          rotation: ((le = Z == null ? void 0 : Z.rotation) == null ? void 0 : le.value) || 0,
          anchorPoint: { x: ((j = (re = Z == null ? void 0 : Z.anchorPoint) == null ? void 0 : re.value) == null ? void 0 : j.x) || 0, y: ((q = ($ = Z == null ? void 0 : Z.anchorPoint) == null ? void 0 : $.value) == null ? void 0 : q.y) || 0 },
          opacity: ((oe = T.opacity) == null ? void 0 : oe.value) || 100,
          // 3D properties
          orientationX: ((ce = (ie = Z == null ? void 0 : Z.orientation) == null ? void 0 : ie.value) == null ? void 0 : ce.x) || 0,
          orientationY: ((Y = (V = Z == null ? void 0 : Z.orientation) == null ? void 0 : V.value) == null ? void 0 : Y.y) || 0,
          orientationZ: ((I = (H = Z == null ? void 0 : Z.orientation) == null ? void 0 : H.value) == null ? void 0 : I.z) || 0,
          rotationX: ((F = Z == null ? void 0 : Z.rotationX) == null ? void 0 : F.value) || 0,
          rotationY: ((L = Z == null ? void 0 : Z.rotationY) == null ? void 0 : L.value) || 0,
          rotationZ: ((ee = Z == null ? void 0 : Z.rotationZ) == null ? void 0 : ee.value) || 0
        }, a.value = T.blendMode || "normal";
      }
    }, { immediate: !0 }), Ft(() => o.value.scale.x, (T, y) => {
      if (i.value && T !== y) {
        const w = T / y;
        o.value.scale.y = Math.round(o.value.scale.y * w * 10) / 10;
      }
    });
    function m(T) {
      const y = n.value.indexOf(T);
      y >= 0 ? n.value.splice(y, 1) : n.value.push(T);
    }
    function p() {
      u.value && r.value && (u.value.name = r.value);
    }
    function v() {
      if (!u.value) return;
      const T = u.value.transform, y = o.value;
      T != null && T.position && (T.position.value = { x: y.position.x, y: y.position.y, z: y.position.z }), T != null && T.scale && (T.scale.value = { x: y.scale.x, y: y.scale.y }), T != null && T.rotation && (T.rotation.value = y.rotation), T != null && T.anchorPoint && (T.anchorPoint.value = { x: y.anchorPoint.x, y: y.anchorPoint.y }), u.value.opacity && (u.value.opacity.value = y.opacity), u.value.threeD && (T != null && T.orientation && (T.orientation.value = { x: y.orientationX, y: y.orientationY, z: y.orientationZ }), T != null && T.rotationX && (T.rotationX.value = y.rotationX), T != null && T.rotationY && (T.rotationY.value = y.rotationY), T != null && T.rotationZ && (T.rotationZ.value = y.rotationZ)), M();
    }
    function x() {
      u.value && (u.value.blendMode = a.value);
    }
    function g(T) {
      return l.value.includes(T);
    }
    function _(T) {
      const y = l.value.indexOf(T);
      y >= 0 ? l.value.splice(y, 1) : (l.value.push(T), console.log(`Added keyframe for ${T} at frame ${e.currentFrame}`));
    }
    function M(T) {
      u.value && (T && Object.keys(T).length > 0 ? e.updateLayerData(u.value.id, T) : e.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    }
    function S(T) {
      if (!u.value) return;
      const y = T.target.value || null;
      e.setLayerParent(u.value.id, y);
    }
    function b(T) {
      if (!u.value) return null;
      const w = e.getDriversForLayer(u.value.id).find((D) => D.targetProperty === T && D.sourceType === "property");
      return w && w.sourceLayerId && w.sourceProperty ? {
        layerId: w.sourceLayerId,
        property: w.sourceProperty
      } : null;
    }
    function C(T, y) {
      u.value && (e.createPropertyLink(
        u.value.id,
        T,
        y.layerId,
        y.property,
        { blendMode: "add" }
      ), console.log(`[PropertiesPanel] Linked ${u.value.id}.${T} <- ${y.layerId}.${y.property}`));
    }
    function E(T) {
      if (!u.value) return;
      const w = e.getDriversForLayer(u.value.id).find((D) => D.targetProperty === T && D.sourceType === "property");
      w && (e.removePropertyDriver(w.id), console.log(`[PropertiesPanel] Unlinked ${u.value.id}.${T}`));
    }
    function P(T) {
      return u.value ? e.getDriversForLayer(u.value.id).some((w) => w.targetProperty === T && w.enabled) : !1;
    }
    return (T, y) => {
      var w, D, U, R, O, A, G, ue, Q, le, re;
      return te(), ae("div", AF, [
        y[49] || (y[49] = f("div", { class: "panel-header" }, [
          f("span", { class: "panel-title" }, "Layer Properties")
        ], -1)),
        u.value ? (te(), ae("div", PF, [
          f("div", RF, [
            f("div", DF, [
              st(f("input", {
                type: "text",
                "onUpdate:modelValue": y[0] || (y[0] = (j) => r.value = j),
                class: "layer-name-input",
                onBlur: p,
                onKeydown: y[1] || (y[1] = rl((j) => j.target.blur(), ["enter"]))
              }, null, 544), [
                [Ut, r.value]
              ])
            ])
          ]),
          f("div", kF, [
            f("div", IF, [
              y[37] || (y[37] = f("label", null, "Parent", -1)),
              f("select", {
                class: "parent-select",
                value: ((w = u.value) == null ? void 0 : w.parentId) || "",
                onChange: S
              }, [
                y[36] || (y[36] = f("option", { value: "" }, "None", -1)),
                (te(!0), ae(qe, null, ot(d.value, (j) => (te(), ae("option", {
                  key: j.id,
                  value: j.id
                }, xe(j.name), 9, FF))), 128))
              ], 40, LF)
            ])
          ]),
          f("div", UF, [
            f("div", {
              class: "section-header",
              onClick: y[2] || (y[2] = (j) => m("transform"))
            }, [
              f("span", OF, xe(n.value.includes("transform") ? "" : ""), 1),
              y[38] || (y[38] = f("span", { class: "section-title" }, "Transform", -1))
            ]),
            n.value.includes("transform") ? (te(), ae("div", zF, [
              f("div", {
                class: Fe(["property-row", { "has-driver": P("transform.position.x") }])
              }, [
                u.value ? (te(), St(vc, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.position.x",
                  linkedTo: b("transform.position.x"),
                  onLink: y[3] || (y[3] = (j) => C("transform.position.x", j)),
                  onUnlink: y[4] || (y[4] = () => E("transform.position.x"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                f("label", {
                  "data-pickwhip-target": "transform.position.x",
                  "data-pickwhip-layer-id": (D = u.value) == null ? void 0 : D.id,
                  "data-pickwhip-label": "Position X"
                }, "Position", 8, NF),
                f("div", BF, [
                  ze(Ve(et), {
                    modelValue: o.value.position.x,
                    "onUpdate:modelValue": [
                      y[5] || (y[5] = (j) => o.value.position.x = j),
                      v
                    ],
                    precision: 1,
                    unit: "X",
                    "data-pickwhip-target": "transform.position.x",
                    "data-pickwhip-layer-id": (U = u.value) == null ? void 0 : U.id,
                    "data-pickwhip-label": "Position X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  ze(Ve(et), {
                    modelValue: o.value.position.y,
                    "onUpdate:modelValue": [
                      y[6] || (y[6] = (j) => o.value.position.y = j),
                      v
                    ],
                    precision: 1,
                    unit: "Y",
                    "data-pickwhip-target": "transform.position.y",
                    "data-pickwhip-layer-id": (R = u.value) == null ? void 0 : R.id,
                    "data-pickwhip-label": "Position Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  (O = u.value) != null && O.threeD ? (te(), St(Ve(et), {
                    key: 0,
                    modelValue: o.value.position.z,
                    "onUpdate:modelValue": [
                      y[7] || (y[7] = (j) => o.value.position.z = j),
                      v
                    ],
                    precision: 1,
                    unit: "Z",
                    "data-pickwhip-target": "transform.position.z",
                    "data-pickwhip-layer-id": (A = u.value) == null ? void 0 : A.id,
                    "data-pickwhip-label": "Position Z"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])) : Pe("", !0)
                ]),
                f("button", {
                  class: Fe(["keyframe-btn", { active: g("position") }]),
                  onClick: y[8] || (y[8] = (j) => _("position"))
                }, "", 2)
              ], 2),
              f("div", {
                class: Fe(["property-row", { "has-driver": P("transform.scale.x") || P("transform.scale.y") }])
              }, [
                u.value ? (te(), St(vc, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.scale.x",
                  linkedTo: b("transform.scale.x"),
                  onLink: y[9] || (y[9] = (j) => C("transform.scale.x", j)),
                  onUnlink: y[10] || (y[10] = () => E("transform.scale.x"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                y[39] || (y[39] = f("label", null, "Scale", -1)),
                f("div", VF, [
                  ze(Ve(et), {
                    modelValue: o.value.scale.x,
                    "onUpdate:modelValue": [
                      y[11] || (y[11] = (j) => o.value.scale.x = j),
                      v
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.x",
                    "data-pickwhip-layer-id": (G = u.value) == null ? void 0 : G.id,
                    "data-pickwhip-label": "Scale X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  f("button", {
                    class: Fe(["link-btn", { active: i.value }]),
                    onClick: y[12] || (y[12] = (j) => i.value = !i.value),
                    title: "Link scale values"
                  }, "  ", 2),
                  ze(Ve(et), {
                    modelValue: o.value.scale.y,
                    "onUpdate:modelValue": [
                      y[13] || (y[13] = (j) => o.value.scale.y = j),
                      v
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.y",
                    "data-pickwhip-layer-id": (ue = u.value) == null ? void 0 : ue.id,
                    "data-pickwhip-label": "Scale Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                f("button", {
                  class: Fe(["keyframe-btn", { active: g("scale") }]),
                  onClick: y[14] || (y[14] = (j) => _("scale"))
                }, "", 2)
              ], 2),
              (Q = u.value) != null && Q.threeD ? (te(), ae(qe, { key: 0 }, [
                f("div", GF, [
                  y[40] || (y[40] = f("label", null, "Orientation", -1)),
                  f("div", HF, [
                    ze(Ve(et), {
                      modelValue: o.value.orientationX,
                      "onUpdate:modelValue": [
                        y[15] || (y[15] = (j) => o.value.orientationX = j),
                        v
                      ],
                      unit: "X"
                    }, null, 8, ["modelValue"]),
                    ze(Ve(et), {
                      modelValue: o.value.orientationY,
                      "onUpdate:modelValue": [
                        y[16] || (y[16] = (j) => o.value.orientationY = j),
                        v
                      ],
                      unit: "Y"
                    }, null, 8, ["modelValue"]),
                    ze(Ve(et), {
                      modelValue: o.value.orientationZ,
                      "onUpdate:modelValue": [
                        y[17] || (y[17] = (j) => o.value.orientationZ = j),
                        v
                      ],
                      unit: "Z"
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                f("div", $F, [
                  y[41] || (y[41] = f("label", null, "X Rotation", -1)),
                  f("div", WF, [
                    ze(Ve(et), {
                      modelValue: o.value.rotationX,
                      "onUpdate:modelValue": [
                        y[18] || (y[18] = (j) => o.value.rotationX = j),
                        v
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  f("button", {
                    class: Fe(["keyframe-btn", { active: g("rotationX") }]),
                    onClick: y[19] || (y[19] = (j) => _("rotationX"))
                  }, "", 2)
                ]),
                f("div", XF, [
                  y[42] || (y[42] = f("label", null, "Y Rotation", -1)),
                  f("div", jF, [
                    ze(Ve(et), {
                      modelValue: o.value.rotationY,
                      "onUpdate:modelValue": [
                        y[20] || (y[20] = (j) => o.value.rotationY = j),
                        v
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  f("button", {
                    class: Fe(["keyframe-btn", { active: g("rotationY") }]),
                    onClick: y[21] || (y[21] = (j) => _("rotationY"))
                  }, "", 2)
                ]),
                f("div", YF, [
                  y[43] || (y[43] = f("label", null, "Z Rotation", -1)),
                  f("div", qF, [
                    ze(Ve(et), {
                      modelValue: o.value.rotationZ,
                      "onUpdate:modelValue": [
                        y[22] || (y[22] = (j) => o.value.rotationZ = j),
                        v
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  f("button", {
                    class: Fe(["keyframe-btn", { active: g("rotationZ") }]),
                    onClick: y[23] || (y[23] = (j) => _("rotationZ"))
                  }, "", 2)
                ])
              ], 64)) : (te(), ae("div", {
                key: 1,
                class: Fe(["property-row", { "has-driver": P("transform.rotation") }])
              }, [
                u.value ? (te(), St(vc, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.rotation",
                  linkedTo: b("transform.rotation"),
                  onLink: y[24] || (y[24] = (j) => C("transform.rotation", j)),
                  onUnlink: y[25] || (y[25] = () => E("transform.rotation"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                y[44] || (y[44] = f("label", null, "Rotation", -1)),
                f("div", ZF, [
                  ze(Ve(et), {
                    modelValue: o.value.rotation,
                    "onUpdate:modelValue": [
                      y[26] || (y[26] = (j) => o.value.rotation = j),
                      v
                    ],
                    min: -360,
                    max: 360,
                    unit: "",
                    "data-pickwhip-target": "transform.rotation",
                    "data-pickwhip-layer-id": (le = u.value) == null ? void 0 : le.id,
                    "data-pickwhip-label": "Rotation"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                f("button", {
                  class: Fe(["keyframe-btn", { active: g("rotation") }]),
                  onClick: y[27] || (y[27] = (j) => _("rotation"))
                }, "", 2)
              ], 2)),
              f("div", KF, [
                y[45] || (y[45] = f("label", null, "Anchor Point", -1)),
                f("div", JF, [
                  ze(Ve(et), {
                    modelValue: o.value.anchorPoint.x,
                    "onUpdate:modelValue": [
                      y[28] || (y[28] = (j) => o.value.anchorPoint.x = j),
                      v
                    ],
                    precision: 1,
                    unit: "X"
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: o.value.anchorPoint.y,
                    "onUpdate:modelValue": [
                      y[29] || (y[29] = (j) => o.value.anchorPoint.y = j),
                      v
                    ],
                    precision: 1,
                    unit: "Y"
                  }, null, 8, ["modelValue"])
                ]),
                f("button", {
                  class: Fe(["keyframe-btn", { active: g("anchorPoint") }]),
                  onClick: y[30] || (y[30] = (j) => _("anchorPoint"))
                }, "", 2)
              ]),
              f("div", {
                class: Fe(["property-row", { "has-driver": P("opacity") }])
              }, [
                u.value ? (te(), St(vc, {
                  key: 0,
                  layerId: u.value.id,
                  property: "opacity",
                  linkedTo: b("opacity"),
                  onLink: y[31] || (y[31] = (j) => C("opacity", j)),
                  onUnlink: y[32] || (y[32] = () => E("opacity"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                y[46] || (y[46] = f("label", null, "Opacity", -1)),
                f("div", QF, [
                  ze(Ve(jn), {
                    modelValue: o.value.opacity,
                    "onUpdate:modelValue": [
                      y[33] || (y[33] = (j) => o.value.opacity = j),
                      v
                    ],
                    min: 0,
                    max: 100,
                    unit: "%",
                    "data-pickwhip-target": "opacity",
                    "data-pickwhip-layer-id": (re = u.value) == null ? void 0 : re.id,
                    "data-pickwhip-label": "Opacity"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                f("button", {
                  class: Fe(["keyframe-btn", { active: g("opacity") }]),
                  onClick: y[34] || (y[34] = (j) => _("opacity"))
                }, "", 2)
              ], 2)
            ])) : Pe("", !0)
          ]),
          f("div", eU, [
            f("div", tU, [
              y[47] || (y[47] = f("label", null, "Blend Mode", -1)),
              st(f("select", {
                "onUpdate:modelValue": y[35] || (y[35] = (j) => a.value = j),
                class: "blend-select",
                onChange: x
              }, [
                (te(), ae(qe, null, ot(c, (j) => f("option", {
                  key: j.value,
                  value: j.value
                }, xe(j.label), 9, nU)), 64))
              ], 544), [
                [Cn, a.value]
              ])
            ])
          ]),
          h.value ? (te(), St(Qg(h.value), {
            key: 0,
            layer: u.value,
            onUpdate: M
          }, null, 40, ["layer"])) : Pe("", !0),
          u.value ? (te(), St(TF, {
            key: 1,
            layerId: u.value.id
          }, null, 8, ["layerId"])) : Pe("", !0)
        ])) : (te(), ae("div", iU, [...y[48] || (y[48] = [
          f("p", null, "No layer selected", -1),
          f("p", { class: "hint" }, "Select a layer to edit its properties", -1)
        ])]))
      ]);
    };
  }
}), rU = /* @__PURE__ */ Gt(sU, [["__scopeId", "data-v-a5a9c7d6"]]), oU = {
  type: "custom",
  baseDistance: 1500,
  center: { x: 960, y: 540, z: 0 },
  duration: 150,
  // 5 seconds at 30fps
  startPhase: 0,
  loops: 1,
  amplitude: 1,
  easing: "ease-in-out",
  audioReactive: !1
}, aU = {
  custom: {},
  orbit: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  orbit_reverse: {
    loops: 1,
    amplitude: -1,
    // Negative for reverse
    easing: "linear"
  },
  swing1: {
    amplitude: 0.25,
    // Smaller arc
    easing: "ease-in-out"
  },
  swing2: {
    amplitude: 0.5,
    // Larger arc
    easing: "ease-in-out"
  },
  dolly_in: {
    amplitude: 0.5,
    // Move 50% closer
    easing: "ease-out"
  },
  dolly_out: {
    amplitude: -0.5,
    // Move 50% away
    easing: "ease-in"
  },
  pan_left: {
    amplitude: 30,
    // 30 degree pan
    easing: "ease-in-out"
  },
  pan_right: {
    amplitude: -30,
    easing: "ease-in-out"
  },
  tilt_up: {
    amplitude: 20,
    // 20 degree tilt
    easing: "ease-in-out"
  },
  tilt_down: {
    amplitude: -20,
    easing: "ease-in-out"
  },
  zoom_in: {
    amplitude: 0.5,
    // 50% zoom increase
    easing: "ease-out"
  },
  zoom_out: {
    amplitude: -0.3,
    // 30% zoom decrease
    easing: "ease-in"
  },
  circle: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  figure8: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  spiral_in: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-out"
  },
  spiral_out: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-in"
  },
  crane_up: {
    amplitude: 500,
    // Pixels to move up
    easing: "ease-in-out"
  },
  crane_down: {
    amplitude: -500,
    easing: "ease-in-out"
  },
  truck_left: {
    amplitude: 300,
    // Pixels to move left
    easing: "ease-in-out"
  },
  truck_right: {
    amplitude: -300,
    easing: "ease-in-out"
  },
  arc_left: {
    amplitude: 0.25,
    // Quarter circle left
    easing: "ease-in-out"
  },
  arc_right: {
    amplitude: -0.25,
    easing: "ease-in-out"
  }
};
function Ry(s, e) {
  switch (e) {
    case "linear":
      return s;
    case "ease-in":
      return s * s;
    case "ease-out":
      return 1 - (1 - s) * (1 - s);
    case "ease-in-out":
      return s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2;
    case "bounce":
      if (s < 0.5)
        return 8 * s * s * s * s;
      const n = s - 1;
      return 1 - 8 * n * n * n * n;
    default:
      return s;
  }
}
function Dy(s, e) {
  const n = Ry(e, s.easing), { center: i, baseDistance: r, amplitude: o, loops: a, startPhase: l, type: c } = s;
  let u = { x: i.x, y: i.y, z: i.z - r }, d = { ...i };
  switch (c) {
    case "orbit":
    case "orbit_reverse": {
      const h = (l + n * a) * 2 * Math.PI * Math.sign(o);
      u = {
        x: i.x + Math.sin(h) * r,
        y: i.y,
        z: i.z - Math.cos(h) * r
      };
      break;
    }
    case "swing1":
    case "swing2": {
      const h = Math.abs(o) * Math.PI, m = Math.sin(n * Math.PI) * h;
      u = {
        x: i.x + Math.sin(m) * r,
        y: i.y,
        z: i.z - Math.cos(m) * r
      };
      break;
    }
    case "dolly_in": {
      const h = r * (1 - n * Math.abs(o));
      u = {
        x: i.x,
        y: i.y,
        z: i.z - h
      };
      break;
    }
    case "dolly_out": {
      const h = r * (1 + n * Math.abs(o));
      u = {
        x: i.x,
        y: i.y,
        z: i.z - h
      };
      break;
    }
    case "pan_left":
    case "pan_right": {
      const h = n * o * (Math.PI / 180);
      d = {
        x: i.x + Math.sin(h) * r,
        y: i.y,
        z: i.z + Math.cos(h) * r - r
      };
      break;
    }
    case "tilt_up":
    case "tilt_down": {
      const h = n * o * (Math.PI / 180);
      d = {
        x: i.x,
        y: i.y + Math.sin(h) * r,
        z: i.z
      };
      break;
    }
    case "circle": {
      const h = (l + n * a) * 2 * Math.PI, m = r * 0.3 * Math.abs(o);
      u = {
        x: i.x + Math.sin(h) * m,
        y: i.y + Math.cos(h) * m * 0.5,
        // Elliptical
        z: i.z - r + Math.cos(h) * m * 0.3
      };
      break;
    }
    case "figure8": {
      const h = (l + n * a) * 2 * Math.PI, m = r * 0.3 * Math.abs(o);
      u = {
        x: i.x + Math.sin(h) * m,
        y: i.y + Math.sin(h * 2) * m * 0.3,
        z: i.z - r
      };
      break;
    }
    case "spiral_in": {
      const h = (l + n * a) * 2 * Math.PI, m = r * (1 - n * Math.abs(o));
      u = {
        x: i.x + Math.sin(h) * m * 0.3,
        y: i.y,
        z: i.z - m
      };
      break;
    }
    case "spiral_out": {
      const h = (l + n * a) * 2 * Math.PI, m = r * (1 + n * Math.abs(o));
      u = {
        x: i.x + Math.sin(h) * m * 0.3,
        y: i.y,
        z: i.z - m
      };
      break;
    }
    case "crane_up":
    case "crane_down": {
      u = {
        x: i.x,
        y: i.y + n * o,
        z: i.z - r
      }, d = {
        x: i.x,
        y: i.y + n * o * 0.5,
        // Target moves less
        z: i.z
      };
      break;
    }
    case "truck_left":
    case "truck_right": {
      u = {
        x: i.x + n * o,
        y: i.y,
        z: i.z - r
      }, d = {
        x: i.x + n * o,
        y: i.y,
        z: i.z
      };
      break;
    }
    case "arc_left":
    case "arc_right": {
      const h = n * o * 2 * Math.PI;
      u = {
        x: i.x + Math.sin(h) * r,
        y: i.y,
        z: i.z - Math.cos(h) * r
      };
      break;
    }
  }
  return { position: u, target: d };
}
function lU(s, e = 0, n = 5) {
  const i = [], r = [], o = [], a = Math.ceil(s.duration / n) + 1;
  for (let l = 0; l < a; l++) {
    const c = e + Math.min(l * n, s.duration), u = Math.min(l * n, s.duration) / s.duration, { position: d, target: h } = Dy(s, u);
    if (i.push({
      frame: c,
      position: d,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    }), r.push({
      frame: c,
      pointOfInterest: h,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    }), s.type === "zoom_in" || s.type === "zoom_out") {
      const m = Ry(u, s.easing), p = s.type === "zoom_in" ? 1 + m * Math.abs(s.amplitude) : 1 - m * Math.abs(s.amplitude);
      o.push({
        frame: c,
        zoom: 1778 * p,
        // Base 50mm zoom
        temporalInterpolation: "linear"
      });
    }
  }
  return {
    position: i,
    pointOfInterest: r,
    zoom: o.length > 0 ? o : void 0
  };
}
function cU(s) {
  return {
    custom: "Custom trajectory with manual keyframes",
    orbit: "360 horizontal orbit around target",
    orbit_reverse: "360 reverse orbit around target",
    swing1: "Gentle pendulum swing (45)",
    swing2: "Wide pendulum swing (90)",
    dolly_in: "Move camera toward target",
    dolly_out: "Move camera away from target",
    pan_left: "Rotate camera left while stationary",
    pan_right: "Rotate camera right while stationary",
    tilt_up: "Tilt camera up while stationary",
    tilt_down: "Tilt camera down while stationary",
    zoom_in: "Zoom lens in (narrower FOV)",
    zoom_out: "Zoom lens out (wider FOV)",
    circle: "Elliptical circling motion",
    figure8: "Figure-8 weaving pattern",
    spiral_in: "Spiral toward target",
    spiral_out: "Spiral away from target",
    crane_up: "Vertical lift (crane shot up)",
    crane_down: "Vertical descent (crane shot down)",
    truck_left: "Horizontal slide left",
    truck_right: "Horizontal slide right",
    arc_left: "Curved arc movement left",
    arc_right: "Curved arc movement right"
  }[s] || "Unknown trajectory";
}
function uU(s) {
  return {
    custom: "Custom",
    orbit: "Orbital",
    orbit_reverse: "Orbital",
    swing1: "Orbital",
    swing2: "Orbital",
    circle: "Orbital",
    figure8: "Orbital",
    arc_left: "Orbital",
    arc_right: "Orbital",
    dolly_in: "Dolly",
    dolly_out: "Dolly",
    spiral_in: "Dolly",
    spiral_out: "Dolly",
    pan_left: "Pan/Tilt",
    pan_right: "Pan/Tilt",
    tilt_up: "Pan/Tilt",
    tilt_down: "Pan/Tilt",
    crane_up: "Crane",
    crane_down: "Crane",
    truck_left: "Truck",
    truck_right: "Truck",
    zoom_in: "Zoom",
    zoom_out: "Zoom"
  }[s] || "Other";
}
function dU() {
  const s = Object.keys(aU), e = {};
  for (const n of s) {
    const i = uU(n);
    e[i] || (e[i] = []), e[i].push(n);
  }
  return e;
}
const hU = { class: "camera-properties" }, fU = { class: "panel-header" }, pU = { class: "camera-name" }, mU = {
  key: 0,
  class: "properties-content"
}, vU = { class: "property-section" }, gU = { class: "property-row" }, yU = ["value"], _U = { class: "property-section" }, xU = { class: "toggle-icon" }, bU = { class: "section-content" }, wU = { class: "property-group" }, SU = { class: "xyz-inputs" }, MU = {
  key: 0,
  class: "property-group"
}, CU = { class: "xyz-inputs" }, EU = { class: "property-group" }, TU = { class: "xyz-inputs" }, AU = { class: "property-group" }, PU = { class: "property-group" }, RU = { class: "property-group" }, DU = { class: "property-section" }, kU = { class: "toggle-icon" }, IU = { class: "section-content" }, LU = { class: "preset-row" }, FU = ["onClick"], UU = { class: "property-group" }, OU = { class: "property-group" }, zU = { class: "property-group" }, NU = { class: "property-group" }, BU = ["value"], VU = { class: "property-section" }, GU = { class: "toggle-icon" }, HU = { class: "section-content" }, $U = { class: "property-group checkbox-group" }, WU = ["checked"], XU = { class: "property-group" }, jU = { class: "property-group" }, YU = { class: "property-group" }, qU = { class: "property-group checkbox-group" }, ZU = ["checked"], KU = { class: "property-section" }, JU = { class: "toggle-icon" }, QU = { class: "section-content" }, eO = { class: "property-group" }, tO = { class: "property-group" }, nO = { class: "property-group" }, iO = { class: "property-group" }, sO = { class: "property-group" }, rO = { class: "property-section" }, oO = { class: "toggle-icon" }, aO = { class: "section-content" }, lO = { class: "property-group" }, cO = { class: "property-group" }, uO = { class: "property-group" }, dO = { class: "property-section" }, hO = { class: "toggle-icon" }, fO = { class: "section-content" }, pO = { class: "property-group" }, mO = ["value"], vO = { class: "property-section" }, gO = { class: "toggle-icon" }, yO = { class: "section-content" }, _O = { class: "property-group" }, xO = { class: "property-group" }, bO = { class: "property-section" }, wO = { class: "toggle-icon" }, SO = { class: "section-content" }, MO = { class: "property-group" }, CO = ["label"], EO = ["value"], TO = { class: "trajectory-description" }, AO = { class: "property-group" }, PO = { class: "property-group" }, RO = {
  key: 0,
  class: "property-group"
}, DO = { class: "property-group" }, kO = { class: "property-group checkbox-group" }, IO = { class: "property-group" }, LO = { class: "property-group" }, FO = {
  key: 1,
  class: "no-camera"
}, UO = /* @__PURE__ */ Ot({
  __name: "CameraProperties",
  setup(s) {
    const e = sn(), n = Ie(() => {
      const T = e.selectedLayer;
      if ((T == null ? void 0 : T.type) === "camera" && T.data) {
        const y = T.data;
        return e.getCamera(y.cameraId);
      }
      return e.activeCamera;
    }), i = Gr({
      transform: !0,
      lens: !0,
      dof: !1,
      iris: !1,
      highlight: !1,
      autoOrient: !1,
      clipping: !1,
      trajectory: !1
    }), r = Gr({
      ...oU
    }), o = Ie(() => dU()), a = Ie(() => cU(r.type)), l = Ie(() => ["orbit", "orbit_reverse", "circle", "figure8", "spiral_in", "spiral_out"].includes(r.type));
    function c(T) {
      return T.split("_").map((y) => y.charAt(0).toUpperCase() + y.slice(1)).join(" ");
    }
    const u = we(null);
    function d() {
      if (!n.value) return;
      u.value !== null && cancelAnimationFrame(u.value);
      const T = performance.now(), y = r.duration / 30 * 1e3, w = {
        ...r,
        center: { ...n.value.pointOfInterest },
        baseDistance: Math.sqrt(
          Math.pow(n.value.position.x - n.value.pointOfInterest.x, 2) + Math.pow(n.value.position.y - n.value.pointOfInterest.y, 2) + Math.pow(n.value.position.z - n.value.pointOfInterest.z, 2)
        )
      };
      function D() {
        const U = performance.now() - T, R = Math.min(U / y, 1), { position: O, target: A } = Dy(w, R);
        e.updateCamera(n.value.id, {
          position: O,
          pointOfInterest: A
        }), R < 1 ? u.value = requestAnimationFrame(D) : u.value = null;
      }
      D();
    }
    function h() {
      if (!n.value) return;
      const T = Math.sqrt(
        Math.pow(n.value.position.x - n.value.pointOfInterest.x, 2) + Math.pow(n.value.position.y - n.value.pointOfInterest.y, 2) + Math.pow(n.value.position.z - n.value.pointOfInterest.z, 2)
      ), y = {
        ...r,
        center: { ...n.value.pointOfInterest },
        baseDistance: T
      }, w = lU(y, e.currentFrame);
      console.log("Generated trajectory keyframes:", w), alert(`Generated ${w.position.length} keyframes for camera trajectory.
Keyframe application will be added in a future update.`);
    }
    function m(T) {
      i[T] = !i[T];
    }
    function p(T, y) {
      n.value && e.updateCamera(n.value.id, { [T]: y });
    }
    function v(T, y) {
      n.value && e.updateCamera(n.value.id, {
        position: { ...n.value.position, [T]: y }
      });
    }
    function x(T, y) {
      n.value && e.updateCamera(n.value.id, {
        pointOfInterest: { ...n.value.pointOfInterest, [T]: y }
      });
    }
    function g(T, y) {
      n.value && e.updateCamera(n.value.id, {
        orientation: { ...n.value.orientation, [T]: y }
      });
    }
    function _(T) {
      if (!n.value) return;
      const y = Cl(T, n.value.filmSize);
      e.updateCamera(n.value.id, {
        focalLength: T,
        angleOfView: y
      });
    }
    function M(T) {
      if (!n.value) return;
      const y = qE(T, n.value.filmSize);
      e.updateCamera(n.value.id, {
        angleOfView: T,
        focalLength: y
      });
    }
    function S(T, y) {
      n.value && e.updateCamera(n.value.id, {
        depthOfField: { ...n.value.depthOfField, [T]: y }
      });
    }
    function b(T, y) {
      n.value && e.updateCamera(n.value.id, {
        iris: { ...n.value.iris, [T]: y }
      });
    }
    function C(T, y) {
      n.value && e.updateCamera(n.value.id, {
        highlight: { ...n.value.highlight, [T]: y }
      });
    }
    function E(T) {
      n.value && e.updateCamera(n.value.id, {
        focalLength: T.focalLength,
        angleOfView: T.angleOfView,
        zoom: T.zoom
      });
    }
    function P() {
      e.createCameraLayer();
    }
    return (T, y) => {
      var w;
      return te(), ae("div", hU, [
        f("div", fU, [
          y[47] || (y[47] = f("span", { class: "panel-title" }, "Camera", -1)),
          f("span", pU, xe(((w = n.value) == null ? void 0 : w.name) ?? "No Camera"), 1)
        ]),
        n.value ? (te(), ae("div", mU, [
          f("div", vU, [
            y[49] || (y[49] = f("div", { class: "section-header" }, "Type", -1)),
            f("div", gU, [
              f("select", {
                value: n.value.type,
                onChange: y[0] || (y[0] = (D) => p("type", D.target.value)),
                class: "type-select"
              }, [...y[48] || (y[48] = [
                f("option", { value: "one-node" }, "One-Node Camera", -1),
                f("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, yU)
            ])
          ]),
          f("div", _U, [
            f("div", {
              class: "section-header",
              onClick: y[1] || (y[1] = (D) => m("transform"))
            }, [
              f("span", xU, xe(i.transform ? "" : ""), 1),
              y[50] || (y[50] = ct(" Transform ", -1))
            ]),
            st(f("div", bU, [
              f("div", wU, [
                y[51] || (y[51] = f("label", null, "Position", -1)),
                f("div", SU, [
                  ze(Ve(et), {
                    modelValue: n.value.position.x,
                    "onUpdate:modelValue": y[2] || (y[2] = (D) => v("x", D)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.position.y,
                    "onUpdate:modelValue": y[3] || (y[3] = (D) => v("y", D)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.position.z,
                    "onUpdate:modelValue": y[4] || (y[4] = (D) => v("z", D)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              n.value.type === "two-node" ? (te(), ae("div", MU, [
                y[52] || (y[52] = f("label", null, "Point of Interest", -1)),
                f("div", CU, [
                  ze(Ve(et), {
                    modelValue: n.value.pointOfInterest.x,
                    "onUpdate:modelValue": y[5] || (y[5] = (D) => x("x", D)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.pointOfInterest.y,
                    "onUpdate:modelValue": y[6] || (y[6] = (D) => x("y", D)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.pointOfInterest.z,
                    "onUpdate:modelValue": y[7] || (y[7] = (D) => x("z", D)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : Pe("", !0),
              f("div", EU, [
                y[53] || (y[53] = f("label", null, "Orientation", -1)),
                f("div", TU, [
                  ze(Ve(et), {
                    modelValue: n.value.orientation.x,
                    "onUpdate:modelValue": y[8] || (y[8] = (D) => g("x", D)),
                    label: "X",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.orientation.y,
                    "onUpdate:modelValue": y[9] || (y[9] = (D) => g("y", D)),
                    label: "Y",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.orientation.z,
                    "onUpdate:modelValue": y[10] || (y[10] = (D) => g("z", D)),
                    label: "Z",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              f("div", AU, [
                y[54] || (y[54] = f("label", null, "X Rotation", -1)),
                ze(Ve(et), {
                  modelValue: n.value.xRotation,
                  "onUpdate:modelValue": y[11] || (y[11] = (D) => p("xRotation", D)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", PU, [
                y[55] || (y[55] = f("label", null, "Y Rotation", -1)),
                ze(Ve(et), {
                  modelValue: n.value.yRotation,
                  "onUpdate:modelValue": y[12] || (y[12] = (D) => p("yRotation", D)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", RU, [
                y[56] || (y[56] = f("label", null, "Z Rotation", -1)),
                ze(Ve(et), {
                  modelValue: n.value.zRotation,
                  "onUpdate:modelValue": y[13] || (y[13] = (D) => p("zRotation", D)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Bs, i.transform]
            ])
          ]),
          f("div", DU, [
            f("div", {
              class: "section-header",
              onClick: y[14] || (y[14] = (D) => m("lens"))
            }, [
              f("span", kU, xe(i.lens ? "" : ""), 1),
              y[57] || (y[57] = ct(" Lens ", -1))
            ]),
            st(f("div", IU, [
              f("div", LU, [
                (te(!0), ae(qe, null, ot(Ve(HE), (D) => (te(), ae("button", {
                  key: D.name,
                  class: Fe({ active: Math.abs(n.value.focalLength - D.focalLength) < 0.5 }),
                  onClick: (U) => E(D)
                }, xe(D.name), 11, FU))), 128))
              ]),
              f("div", UU, [
                y[58] || (y[58] = f("label", null, "Focal Length", -1)),
                ze(Ve(et), {
                  modelValue: n.value.focalLength,
                  "onUpdate:modelValue": _,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", OU, [
                y[59] || (y[59] = f("label", null, "Angle of View", -1)),
                ze(Ve(et), {
                  modelValue: n.value.angleOfView,
                  "onUpdate:modelValue": M,
                  min: 1,
                  max: 170,
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", zU, [
                y[60] || (y[60] = f("label", null, "Film Size", -1)),
                ze(Ve(et), {
                  modelValue: n.value.filmSize,
                  "onUpdate:modelValue": y[15] || (y[15] = (D) => p("filmSize", D)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", NU, [
                y[62] || (y[62] = f("label", null, "Measure Film Size", -1)),
                f("select", {
                  value: n.value.measureFilmSize,
                  onChange: y[16] || (y[16] = (D) => p("measureFilmSize", D.target.value))
                }, [...y[61] || (y[61] = [
                  f("option", { value: "horizontal" }, "Horizontal", -1),
                  f("option", { value: "vertical" }, "Vertical", -1),
                  f("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, BU)
              ])
            ], 512), [
              [Bs, i.lens]
            ])
          ]),
          f("div", VU, [
            f("div", {
              class: "section-header",
              onClick: y[17] || (y[17] = (D) => m("dof"))
            }, [
              f("span", GU, xe(i.dof ? "" : ""), 1),
              y[63] || (y[63] = ct(" Depth of Field ", -1))
            ]),
            st(f("div", HU, [
              f("div", $U, [
                f("label", null, [
                  f("input", {
                    type: "checkbox",
                    checked: n.value.depthOfField.enabled,
                    onChange: y[18] || (y[18] = (D) => S("enabled", D.target.checked))
                  }, null, 40, WU),
                  y[64] || (y[64] = ct(" Enable DOF ", -1))
                ])
              ]),
              n.value.depthOfField.enabled ? (te(), ae(qe, { key: 0 }, [
                f("div", XU, [
                  y[65] || (y[65] = f("label", null, "Focus Distance", -1)),
                  ze(Ve(et), {
                    modelValue: n.value.depthOfField.focusDistance,
                    "onUpdate:modelValue": y[19] || (y[19] = (D) => S("focusDistance", D)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                f("div", jU, [
                  y[66] || (y[66] = f("label", null, "f-Stop", -1)),
                  ze(Ve(et), {
                    modelValue: n.value.depthOfField.fStop,
                    "onUpdate:modelValue": y[20] || (y[20] = (D) => S("fStop", D)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                f("div", YU, [
                  y[67] || (y[67] = f("label", null, "Blur Level", -1)),
                  ze(Ve(jn), {
                    modelValue: n.value.depthOfField.blurLevel,
                    "onUpdate:modelValue": y[21] || (y[21] = (D) => S("blurLevel", D)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                f("div", qU, [
                  f("label", null, [
                    f("input", {
                      type: "checkbox",
                      checked: n.value.depthOfField.lockToZoom,
                      onChange: y[22] || (y[22] = (D) => S("lockToZoom", D.target.checked))
                    }, null, 40, ZU),
                    y[68] || (y[68] = ct(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : Pe("", !0)
            ], 512), [
              [Bs, i.dof]
            ])
          ]),
          f("div", KU, [
            f("div", {
              class: "section-header",
              onClick: y[23] || (y[23] = (D) => m("iris"))
            }, [
              f("span", JU, xe(i.iris ? "" : ""), 1),
              y[69] || (y[69] = ct(" Iris ", -1))
            ]),
            st(f("div", QU, [
              f("div", eO, [
                f("label", null, "Shape (" + xe(Math.round(n.value.iris.shape)) + "-gon)", 1),
                ze(Ve(jn), {
                  modelValue: n.value.iris.shape,
                  "onUpdate:modelValue": y[24] || (y[24] = (D) => b("shape", D)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", tO, [
                y[70] || (y[70] = f("label", null, "Rotation", -1)),
                ze(Ve(Zf), {
                  modelValue: n.value.iris.rotation,
                  "onUpdate:modelValue": y[25] || (y[25] = (D) => b("rotation", D)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              f("div", nO, [
                y[71] || (y[71] = f("label", null, "Roundness", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.iris.roundness,
                  "onUpdate:modelValue": y[26] || (y[26] = (D) => b("roundness", D)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", iO, [
                y[72] || (y[72] = f("label", null, "Aspect Ratio", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.iris.aspectRatio,
                  "onUpdate:modelValue": y[27] || (y[27] = (D) => b("aspectRatio", D)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", sO, [
                y[73] || (y[73] = f("label", null, "Diffraction Fringe", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.iris.diffractionFringe,
                  "onUpdate:modelValue": y[28] || (y[28] = (D) => b("diffractionFringe", D)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Bs, i.iris]
            ])
          ]),
          f("div", rO, [
            f("div", {
              class: "section-header",
              onClick: y[29] || (y[29] = (D) => m("highlight"))
            }, [
              f("span", oO, xe(i.highlight ? "" : ""), 1),
              y[74] || (y[74] = ct(" Highlight ", -1))
            ]),
            st(f("div", aO, [
              f("div", lO, [
                y[75] || (y[75] = f("label", null, "Gain", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.highlight.gain,
                  "onUpdate:modelValue": y[30] || (y[30] = (D) => C("gain", D)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", cO, [
                y[76] || (y[76] = f("label", null, "Threshold", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.highlight.threshold,
                  "onUpdate:modelValue": y[31] || (y[31] = (D) => C("threshold", D)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", uO, [
                y[77] || (y[77] = f("label", null, "Saturation", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.highlight.saturation,
                  "onUpdate:modelValue": y[32] || (y[32] = (D) => C("saturation", D)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Bs, i.highlight]
            ])
          ]),
          f("div", dO, [
            f("div", {
              class: "section-header",
              onClick: y[33] || (y[33] = (D) => m("autoOrient"))
            }, [
              f("span", hO, xe(i.autoOrient ? "" : ""), 1),
              y[78] || (y[78] = ct(" Auto-Orient ", -1))
            ]),
            st(f("div", fO, [
              f("div", pO, [
                f("select", {
                  value: n.value.autoOrient,
                  onChange: y[34] || (y[34] = (D) => p("autoOrient", D.target.value))
                }, [...y[79] || (y[79] = [
                  f("option", { value: "off" }, "Off", -1),
                  f("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  f("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, mO)
              ])
            ], 512), [
              [Bs, i.autoOrient]
            ])
          ]),
          f("div", vO, [
            f("div", {
              class: "section-header",
              onClick: y[35] || (y[35] = (D) => m("clipping"))
            }, [
              f("span", gO, xe(i.clipping ? "" : ""), 1),
              y[80] || (y[80] = ct(" Clipping ", -1))
            ]),
            st(f("div", yO, [
              f("div", _O, [
                y[81] || (y[81] = f("label", null, "Near Clip", -1)),
                ze(Ve(et), {
                  modelValue: n.value.nearClip,
                  "onUpdate:modelValue": y[36] || (y[36] = (D) => p("nearClip", D)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", xO, [
                y[82] || (y[82] = f("label", null, "Far Clip", -1)),
                ze(Ve(et), {
                  modelValue: n.value.farClip,
                  "onUpdate:modelValue": y[37] || (y[37] = (D) => p("farClip", D)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Bs, i.clipping]
            ])
          ]),
          f("div", bO, [
            f("div", {
              class: "section-header",
              onClick: y[38] || (y[38] = (D) => m("trajectory"))
            }, [
              f("span", wO, xe(i.trajectory ? "" : ""), 1),
              y[83] || (y[83] = ct(" Trajectory ", -1))
            ]),
            st(f("div", SO, [
              f("div", MO, [
                y[84] || (y[84] = f("label", null, "Motion Preset", -1)),
                st(f("select", {
                  "onUpdate:modelValue": y[39] || (y[39] = (D) => r.type = D),
                  class: "trajectory-select"
                }, [
                  (te(!0), ae(qe, null, ot(o.value, (D, U) => (te(), ae("optgroup", {
                    key: U,
                    label: U
                  }, [
                    (te(!0), ae(qe, null, ot(D, (R) => (te(), ae("option", {
                      key: R,
                      value: R
                    }, xe(c(R)), 9, EO))), 128))
                  ], 8, CO))), 128))
                ], 512), [
                  [Cn, r.type]
                ])
              ]),
              f("div", TO, xe(a.value), 1),
              f("div", AO, [
                y[85] || (y[85] = f("label", null, "Duration (frames)", -1)),
                ze(Ve(et), {
                  modelValue: r.duration,
                  "onUpdate:modelValue": y[40] || (y[40] = (D) => r.duration = D),
                  min: 1,
                  max: 600,
                  precision: 0
                }, null, 8, ["modelValue"])
              ]),
              f("div", PO, [
                y[86] || (y[86] = f("label", null, "Amplitude", -1)),
                ze(Ve(jn), {
                  modelValue: Math.abs(r.amplitude),
                  "onUpdate:modelValue": y[41] || (y[41] = (D) => r.amplitude = D * Math.sign(r.amplitude || 1)),
                  min: 0.1,
                  max: 2,
                  step: 0.1
                }, null, 8, ["modelValue"])
              ]),
              l.value ? (te(), ae("div", RO, [
                y[87] || (y[87] = f("label", null, "Loops", -1)),
                ze(Ve(et), {
                  modelValue: r.loops,
                  "onUpdate:modelValue": y[42] || (y[42] = (D) => r.loops = D),
                  min: 0.25,
                  max: 5,
                  precision: 2
                }, null, 8, ["modelValue"])
              ])) : Pe("", !0),
              f("div", DO, [
                y[89] || (y[89] = f("label", null, "Easing", -1)),
                st(f("select", {
                  "onUpdate:modelValue": y[43] || (y[43] = (D) => r.easing = D)
                }, [...y[88] || (y[88] = [
                  as('<option value="linear" data-v-5af5ddc6>Linear</option><option value="ease-in" data-v-5af5ddc6>Ease In</option><option value="ease-out" data-v-5af5ddc6>Ease Out</option><option value="ease-in-out" data-v-5af5ddc6>Ease In-Out</option><option value="bounce" data-v-5af5ddc6>Bounce</option>', 5)
                ])], 512), [
                  [Cn, r.easing]
                ])
              ]),
              f("div", kO, [
                f("label", null, [
                  st(f("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": y[44] || (y[44] = (D) => r.audioReactive = D)
                  }, null, 512), [
                    [xi, r.audioReactive]
                  ]),
                  y[90] || (y[90] = ct(" Audio Reactive ", -1))
                ])
              ]),
              r.audioReactive ? (te(), ae(qe, { key: 1 }, [
                f("div", IO, [
                  y[92] || (y[92] = f("label", null, "Audio Feature", -1)),
                  st(f("select", {
                    "onUpdate:modelValue": y[45] || (y[45] = (D) => r.audioFeature = D)
                  }, [...y[91] || (y[91] = [
                    as('<option value="amplitude" data-v-5af5ddc6>Amplitude</option><option value="bass" data-v-5af5ddc6>Bass</option><option value="mid" data-v-5af5ddc6>Mid</option><option value="high" data-v-5af5ddc6>High</option><option value="onsets" data-v-5af5ddc6>Onsets</option>', 5)
                  ])], 512), [
                    [Cn, r.audioFeature]
                  ])
                ]),
                f("div", LO, [
                  y[93] || (y[93] = f("label", null, "Sensitivity", -1)),
                  ze(Ve(jn), {
                    modelValue: r.audioSensitivity ?? 1,
                    "onUpdate:modelValue": y[46] || (y[46] = (D) => r.audioSensitivity = D),
                    min: 0.1,
                    max: 3,
                    step: 0.1
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : Pe("", !0),
              f("div", { class: "trajectory-actions" }, [
                f("button", {
                  class: "action-btn preview",
                  onClick: d
                }, " Preview "),
                f("button", {
                  class: "action-btn apply",
                  onClick: h
                }, " Apply Keyframes ")
              ])
            ], 512), [
              [Bs, i.trajectory]
            ])
          ])
        ])) : (te(), ae("div", FO, [
          y[94] || (y[94] = f("p", null, "No camera selected", -1)),
          f("button", { onClick: P }, "Create Camera")
        ]))
      ]);
    };
  }
}), OO = /* @__PURE__ */ Gt(UO, [["__scopeId", "data-v-5af5ddc6"]]), zO = { class: "audio-properties" }, NO = { class: "property-section" }, BO = {
  key: 0,
  class: "section-content"
}, VO = { class: "property-row" }, GO = { class: "value-display" }, HO = { class: "property-row" }, $O = { class: "value-display" }, WO = { class: "property-row" }, XO = { class: "value-display" }, jO = { class: "property-row" }, YO = {
  key: 0,
  class: "peak-count"
}, qO = { class: "property-section" }, ZO = { class: "mapping-count" }, KO = {
  key: 0,
  class: "section-content"
}, JO = { class: "mapping-header" }, QO = { class: "mapping-enabled" }, ez = ["onUpdate:modelValue"], tz = { class: "mapping-name" }, nz = ["onClick"], iz = {
  key: 0,
  class: "mapping-details"
}, sz = { class: "property-row" }, rz = ["onUpdate:modelValue"], oz = ["label"], az = ["value"], lz = { class: "property-row" }, cz = ["onUpdate:modelValue"], uz = ["label"], dz = ["value"], hz = { class: "property-row" }, fz = ["onUpdate:modelValue"], pz = { class: "value-display" }, mz = { class: "property-row" }, vz = ["onUpdate:modelValue"], gz = { class: "value-display" }, yz = { class: "property-row" }, _z = ["onUpdate:modelValue"], xz = { class: "value-display" }, bz = { class: "property-row" }, wz = ["onUpdate:modelValue"], Sz = ["onUpdate:modelValue"], Mz = { class: "property-row" }, Cz = ["onUpdate:modelValue"], Ez = { class: "value-display" }, Tz = { class: "property-row" }, Az = ["onUpdate:modelValue"], Pz = { class: "value-display" }, Rz = { class: "property-row" }, Dz = ["onUpdate:modelValue"], kz = { class: "property-row" }, Iz = ["onUpdate:modelValue"], Lz = {
  key: 0,
  class: "property-row"
}, Fz = ["onUpdate:modelValue"], Uz = { class: "value-display" }, Oz = { class: "property-row checkbox-row" }, zz = ["onUpdate:modelValue"], Nz = ["onClick"], Bz = { class: "property-section" }, Vz = {
  key: 0,
  class: "section-content"
}, Gz = { class: "property-row" }, Hz = ["value"], $z = { class: "visualizer-canvas-container" }, Wz = { class: "visualizer-value" }, Xz = /* @__PURE__ */ Ot({
  __name: "AudioProperties",
  setup(s) {
    const e = sn(), n = we(/* @__PURE__ */ new Set(["peaks", "mappings"])), i = we(/* @__PURE__ */ new Set()), r = we({
      threshold: 0.3,
      minPeaksDistance: 10,
      multiply: 1
    }), o = we(null), a = we([]), l = we("amplitude"), c = we(null), u = Ie(() => pT()), d = Ie(() => mT()), h = Ie(() => vT()), m = Ie(
      () => e.currentFrame / e.frameCount * 100
    ), p = Ie(() => e.audioAnalysis ? vl(e.audioAnalysis, l.value, e.currentFrame) : 0);
    function v(b) {
      n.value.has(b) ? n.value.delete(b) : n.value.add(b);
    }
    function x(b) {
      i.value.has(b) ? i.value.delete(b) : i.value.add(b);
    }
    function g() {
      if (!e.audioAnalysis) return;
      const b = e.audioAnalysis.amplitudeEnvelope;
      o.value = Ay(b, r.value), e.setPeakData(o.value);
    }
    function _() {
      const b = hT();
      a.value.push(b), i.value.add(b.id), e.addAudioMapping(b);
    }
    function M(b) {
      const C = a.value.findIndex((E) => E.id === b);
      C >= 0 && (a.value.splice(C, 1), i.value.delete(b), e.removeAudioMapping(b));
    }
    function S() {
      var w, D;
      const b = c.value;
      if (!b || !e.audioAnalysis) return;
      const C = b.getContext("2d");
      if (!C) return;
      const E = b.width, P = b.height;
      C.fillStyle = "#1e1e1e", C.fillRect(0, 0, E, P);
      let T = [];
      const y = e.audioAnalysis;
      switch (l.value) {
        case "amplitude":
          T = y.amplitudeEnvelope;
          break;
        case "rms":
          T = y.rmsEnergy;
          break;
        case "spectralCentroid":
          T = y.spectralCentroid;
          break;
        case "bass":
          T = y.frequencyBands.bass;
          break;
        case "mid":
          T = y.frequencyBands.mid;
          break;
        case "high":
          T = y.frequencyBands.high;
          break;
        case "sub":
          T = y.frequencyBands.sub;
          break;
        case "lowMid":
          T = y.frequencyBands.lowMid;
          break;
        case "highMid":
          T = y.frequencyBands.highMid;
          break;
        case "spectralFlux":
          T = y.spectralFlux || [];
          break;
        case "zeroCrossingRate":
          T = y.zeroCrossingRate || [];
          break;
        case "spectralRolloff":
          T = y.spectralRolloff || [];
          break;
        case "spectralFlatness":
          T = y.spectralFlatness || [];
          break;
        case "chromaEnergy":
          T = ((w = y.chromaFeatures) == null ? void 0 : w.chromaEnergy) || [];
          break;
        case "chromaC":
        case "chromaCs":
        case "chromaD":
        case "chromaDs":
        case "chromaE":
        case "chromaF":
        case "chromaFs":
        case "chromaG":
        case "chromaGs":
        case "chromaA":
        case "chromaAs":
        case "chromaB":
          if ((D = y.chromaFeatures) != null && D.chroma) {
            const U = [
              "chromaC",
              "chromaCs",
              "chromaD",
              "chromaDs",
              "chromaE",
              "chromaF",
              "chromaFs",
              "chromaG",
              "chromaGs",
              "chromaA",
              "chromaAs",
              "chromaB"
            ].indexOf(l.value);
            T = y.chromaFeatures.chroma.map((R) => R[U] || 0);
          }
          break;
        case "onsets":
          T = new Array(y.frameCount).fill(0);
          for (const U of y.onsets)
            U < T.length && (T[U] = 1);
          break;
        case "peaks":
          if (o.value) {
            T = new Array(y.frameCount).fill(0);
            for (const U of o.value.indices)
              U < T.length && (T[U] = 1);
          }
          break;
      }
      if (T.length !== 0) {
        C.strokeStyle = "#4a90d9", C.lineWidth = 1.5, C.beginPath();
        for (let U = 0; U < T.length; U++) {
          const R = U / T.length * E, O = P - T[U] * P * 0.9 - 5;
          U === 0 ? C.moveTo(R, O) : C.lineTo(R, O);
        }
        if (C.stroke(), o.value && l.value !== "peaks") {
          C.fillStyle = "#ff6b6b";
          for (const U of o.value.indices) {
            const R = U / T.length * E;
            C.beginPath(), C.moveTo(R, 0), C.lineTo(R, P), C.strokeStyle = "rgba(255, 107, 107, 0.3)", C.stroke();
          }
        }
      }
    }
    return Ft(
      () => [e.audioAnalysis, l.value, o.value],
      () => {
        S();
      }
    ), Ft(
      a,
      (b) => {
        for (const C of b)
          e.updateAudioMapping(C.id, C);
      },
      { deep: !0 }
    ), _n(() => {
      S();
      const b = e.getAudioMappings();
      b.length > 0 && (a.value = [...b]);
    }), (b, C) => (te(), ae("div", zO, [
      f("div", NO, [
        f("div", {
          class: "section-header",
          onClick: C[0] || (C[0] = (E) => v("peaks"))
        }, [
          f("i", {
            class: Fe(["pi", n.value.has("peaks") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          C[7] || (C[7] = f("span", null, "Peak Detection", -1))
        ]),
        n.value.has("peaks") ? (te(), ae("div", BO, [
          f("div", VO, [
            C[8] || (C[8] = f("label", null, "Threshold", -1)),
            st(f("input", {
              type: "range",
              "onUpdate:modelValue": C[1] || (C[1] = (E) => r.value.threshold = E),
              min: "0",
              max: "1",
              step: "0.01"
            }, null, 512), [
              [
                Ut,
                r.value.threshold,
                void 0,
                { number: !0 }
              ]
            ]),
            f("span", GO, xe(r.value.threshold.toFixed(2)), 1)
          ]),
          f("div", HO, [
            C[9] || (C[9] = f("label", null, "Min Peak Distance", -1)),
            st(f("input", {
              type: "range",
              "onUpdate:modelValue": C[2] || (C[2] = (E) => r.value.minPeaksDistance = E),
              min: "1",
              max: "60",
              step: "1"
            }, null, 512), [
              [
                Ut,
                r.value.minPeaksDistance,
                void 0,
                { number: !0 }
              ]
            ]),
            f("span", $O, xe(r.value.minPeaksDistance) + " frames", 1)
          ]),
          f("div", WO, [
            C[10] || (C[10] = f("label", null, "Multiply", -1)),
            st(f("input", {
              type: "range",
              "onUpdate:modelValue": C[3] || (C[3] = (E) => r.value.multiply = E),
              min: "0.1",
              max: "5",
              step: "0.1"
            }, null, 512), [
              [
                Ut,
                r.value.multiply,
                void 0,
                { number: !0 }
              ]
            ]),
            f("span", XO, xe(r.value.multiply.toFixed(1)) + "x", 1)
          ]),
          f("div", jO, [
            f("button", {
              class: "action-btn",
              onClick: g
            }, [...C[11] || (C[11] = [
              f("i", { class: "pi pi-bolt" }, null, -1),
              ct(" Detect Peaks ", -1)
            ])]),
            o.value ? (te(), ae("span", YO, xe(o.value.count) + " peaks found ", 1)) : Pe("", !0)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", qO, [
        f("div", {
          class: "section-header",
          onClick: C[4] || (C[4] = (E) => v("mappings"))
        }, [
          f("i", {
            class: Fe(["pi", n.value.has("mappings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          C[12] || (C[12] = f("span", null, "Audio Mappings", -1)),
          f("span", ZO, xe(a.value.length), 1)
        ]),
        n.value.has("mappings") ? (te(), ae("div", KO, [
          f("button", {
            class: "action-btn add-mapping-btn",
            onClick: _
          }, [...C[13] || (C[13] = [
            f("i", { class: "pi pi-plus" }, null, -1),
            ct(" Add Mapping ", -1)
          ])]),
          (te(!0), ae(qe, null, ot(a.value, (E) => {
            var P, T, y;
            return te(), ae("div", {
              key: E.id,
              class: "mapping-item"
            }, [
              f("div", JO, [
                f("label", QO, [
                  st(f("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": (w) => E.enabled = w
                  }, null, 8, ez), [
                    [xi, E.enabled]
                  ])
                ]),
                f("span", tz, xe(Ve(Nd)(E.feature)) + "  " + xe(Ve(Sv)(E.target)), 1),
                f("button", {
                  class: "delete-btn",
                  onClick: (w) => M(E.id)
                }, [...C[14] || (C[14] = [
                  f("i", { class: "pi pi-times" }, null, -1)
                ])], 8, nz)
              ]),
              i.value.has(E.id) ? (te(), ae("div", iz, [
                f("div", sz, [
                  C[15] || (C[15] = f("label", null, "Feature", -1)),
                  st(f("select", {
                    "onUpdate:modelValue": (w) => E.feature = w
                  }, [
                    (te(!0), ae(qe, null, ot(d.value, (w, D) => (te(), ae("optgroup", {
                      key: D,
                      label: D
                    }, [
                      (te(!0), ae(qe, null, ot(w, (U) => (te(), ae("option", {
                        key: U,
                        value: U
                      }, xe(Ve(Nd)(U)), 9, az))), 128))
                    ], 8, oz))), 128))
                  ], 8, rz), [
                    [Cn, E.feature]
                  ])
                ]),
                f("div", lz, [
                  C[16] || (C[16] = f("label", null, "Target", -1)),
                  st(f("select", {
                    "onUpdate:modelValue": (w) => E.target = w
                  }, [
                    (te(!0), ae(qe, null, ot(h.value, (w, D) => (te(), ae("optgroup", {
                      key: D,
                      label: D
                    }, [
                      (te(!0), ae(qe, null, ot(w, (U) => (te(), ae("option", {
                        key: U,
                        value: U
                      }, xe(Ve(Sv)(U)), 9, dz))), 128))
                    ], 8, uz))), 128))
                  ], 8, cz), [
                    [Cn, E.target]
                  ])
                ]),
                C[30] || (C[30] = f("div", { class: "subsection-header" }, "Basic Controls", -1)),
                f("div", hz, [
                  C[17] || (C[17] = f("label", null, "Sensitivity", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => E.sensitivity = w,
                    min: "0.1",
                    max: "5",
                    step: "0.1"
                  }, null, 8, fz), [
                    [
                      Ut,
                      E.sensitivity,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", pz, xe(E.sensitivity.toFixed(1)) + "x", 1)
                ]),
                f("div", mz, [
                  C[18] || (C[18] = f("label", null, "Threshold", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => E.threshold = w,
                    min: "0",
                    max: "1",
                    step: "0.01"
                  }, null, 8, vz), [
                    [
                      Ut,
                      E.threshold,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", gz, xe(E.threshold.toFixed(2)), 1)
                ]),
                f("div", yz, [
                  C[19] || (C[19] = f("label", null, "Smoothing", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => E.smoothing = w,
                    min: "0",
                    max: "0.99",
                    step: "0.01"
                  }, null, 8, _z), [
                    [
                      Ut,
                      E.smoothing,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", xz, xe(E.smoothing.toFixed(2)), 1)
                ]),
                f("div", bz, [
                  C[20] || (C[20] = f("label", null, "Min/Max", -1)),
                  st(f("input", {
                    type: "number",
                    "onUpdate:modelValue": (w) => E.min = w,
                    step: "0.1",
                    class: "small-input"
                  }, null, 8, wz), [
                    [
                      Ut,
                      E.min,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  C[21] || (C[21] = f("span", { class: "separator" }, "-", -1)),
                  st(f("input", {
                    type: "number",
                    "onUpdate:modelValue": (w) => E.max = w,
                    step: "0.1",
                    class: "small-input"
                  }, null, 8, Sz), [
                    [
                      Ut,
                      E.max,
                      void 0,
                      { number: !0 }
                    ]
                  ])
                ]),
                C[31] || (C[31] = f("div", { class: "subsection-header" }, "ATI-Style Effects", -1)),
                f("div", Mz, [
                  C[22] || (C[22] = f("label", { title: ">1 = expander (emphasize loud), <1 = compressor (boost quiet)" }, "Amp Curve", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => E.amplitudeCurve = w,
                    min: "0.1",
                    max: "4",
                    step: "0.1"
                  }, null, 8, Cz), [
                    [
                      Ut,
                      E.amplitudeCurve,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", Ez, xe(((P = E.amplitudeCurve) == null ? void 0 : P.toFixed(1)) || "1.0"), 1)
                ]),
                f("div", Tz, [
                  C[23] || (C[23] = f("label", { title: "How slowly the value decays after a peak (0=instant, 1=slow)" }, "Release", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => E.release = w,
                    min: "0",
                    max: "1",
                    step: "0.01"
                  }, null, 8, Az), [
                    [
                      Ut,
                      E.release,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", Pz, xe(((T = E.release) == null ? void 0 : T.toFixed(2)) || "0.50"), 1)
                ]),
                f("div", Rz, [
                  C[25] || (C[25] = f("label", null, "Curve", -1)),
                  st(f("select", {
                    "onUpdate:modelValue": (w) => E.curve = w,
                    class: "curve-select"
                  }, [...C[24] || (C[24] = [
                    as('<option value="linear" data-v-0611c34c>Linear</option><option value="exponential" data-v-0611c34c>Exponential</option><option value="logarithmic" data-v-0611c34c>Logarithmic</option><option value="smoothstep" data-v-0611c34c>Smoothstep</option><option value="bounce" data-v-0611c34c>Bounce</option>', 5)
                  ])], 8, Dz), [
                    [Cn, E.curve]
                  ])
                ]),
                C[32] || (C[32] = f("div", { class: "subsection-header" }, "Beat Response", -1)),
                f("div", kz, [
                  C[27] || (C[27] = f("label", null, "On Beat", -1)),
                  st(f("select", {
                    "onUpdate:modelValue": (w) => E.beatResponse = w,
                    class: "beat-select"
                  }, [...C[26] || (C[26] = [
                    f("option", { value: "none" }, "None", -1),
                    f("option", { value: "flip" }, "Flip (reverse direction)", -1),
                    f("option", { value: "pulse" }, "Pulse (spike to max)", -1),
                    f("option", { value: "toggle" }, "Toggle (0/1 switch)", -1)
                  ])], 8, Iz), [
                    [Cn, E.beatResponse]
                  ])
                ]),
                E.beatResponse !== "none" ? (te(), ae("div", Lz, [
                  C[28] || (C[28] = f("label", { title: "Lower = more sensitive to quieter beats" }, "Beat Sens.", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => E.beatThreshold = w,
                    min: "0.01",
                    max: "1",
                    step: "0.01"
                  }, null, 8, Fz), [
                    [
                      Ut,
                      E.beatThreshold,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", Uz, xe(((y = E.beatThreshold) == null ? void 0 : y.toFixed(2)) || "0.50"), 1)
                ])) : Pe("", !0),
                f("div", Oz, [
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": (w) => E.invert = w
                    }, null, 8, zz), [
                      [xi, E.invert]
                    ]),
                    C[29] || (C[29] = ct(" Invert Output ", -1))
                  ])
                ])
              ])) : Pe("", !0),
              f("button", {
                class: "expand-btn",
                onClick: (w) => x(E.id)
              }, [
                f("i", {
                  class: Fe(["pi", i.value.has(E.id) ? "pi-chevron-up" : "pi-chevron-down"])
                }, null, 2)
              ], 8, Nz)
            ]);
          }), 128))
        ])) : Pe("", !0)
      ]),
      f("div", Bz, [
        f("div", {
          class: "section-header",
          onClick: C[5] || (C[5] = (E) => v("visualizer"))
        }, [
          f("i", {
            class: Fe(["pi", n.value.has("visualizer") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          C[33] || (C[33] = f("span", null, "Feature Visualizer", -1))
        ]),
        n.value.has("visualizer") ? (te(), ae("div", Vz, [
          f("div", Gz, [
            C[34] || (C[34] = f("label", null, "Feature", -1)),
            st(f("select", {
              "onUpdate:modelValue": C[6] || (C[6] = (E) => l.value = E)
            }, [
              (te(!0), ae(qe, null, ot(u.value, (E) => (te(), ae("option", {
                key: E,
                value: E
              }, xe(Ve(Nd)(E)), 9, Hz))), 128))
            ], 512), [
              [Cn, l.value]
            ])
          ]),
          f("div", $z, [
            f("canvas", {
              ref_key: "visualizerCanvas",
              ref: c,
              class: "visualizer-canvas",
              width: "240",
              height: "60"
            }, null, 512),
            f("div", {
              class: "visualizer-playhead",
              style: yt({ left: `${m.value}%` })
            }, null, 4)
          ]),
          f("div", Wz, " Current: " + xe(p.value.toFixed(3)), 1)
        ])) : Pe("", !0)
      ])
    ]));
  }
}), jz = /* @__PURE__ */ Gt(Xz, [["__scopeId", "data-v-0611c34c"]]), Yz = { class: "audio-panel" }, qz = {
  key: 0,
  class: "panel-content"
}, Zz = { class: "audio-info" }, Kz = { class: "file-info" }, Jz = { class: "file-details" }, Qz = { class: "file-name" }, e6 = { class: "file-meta" }, t6 = { class: "control-section" }, n6 = { class: "control-row" }, i6 = { class: "waveform-section" }, s6 = { class: "waveform-display" }, r6 = { class: "linker-section" }, o6 = {
  key: 1,
  class: "empty-state"
}, a6 = /* @__PURE__ */ Ot({
  __name: "AudioPanel",
  setup(s) {
    const e = sn(), n = we(null), i = we(null), r = we(100), o = we(!1), a = Ie(() => !!e.audioBuffer), l = Ie(() => {
      var x;
      return ((x = e.audioFile) == null ? void 0 : x.name) || "Unknown";
    }), c = Ie(() => e.audioBuffer ? `${(e.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : ""), u = Ie(() => {
      if (!e.audioBuffer) return "0:00";
      const x = Math.floor(e.audioBuffer.duration / 60), g = Math.floor(e.audioBuffer.duration % 60);
      return `${x}:${g.toString().padStart(2, "0")}`;
    });
    function d() {
      var x;
      (x = n.value) == null || x.click();
    }
    async function h(x) {
      var _;
      const g = x.target;
      (_ = g.files) != null && _.length && await e.loadAudio(g.files[0]), g.value = "";
    }
    function m() {
      e.clearAudio();
    }
    function p() {
      o.value = !o.value;
    }
    function v() {
      if (!i.value || !e.audioBuffer) return;
      const x = i.value, g = x.getContext("2d");
      if (!g) return;
      const _ = x.getBoundingClientRect();
      x.width = _.width * window.devicePixelRatio, x.height = 60 * window.devicePixelRatio, g.scale(window.devicePixelRatio, window.devicePixelRatio);
      const M = e.audioBuffer.getChannelData(0), S = Math.ceil(M.length / _.width), b = 30;
      g.fillStyle = "#1a1a1a", g.fillRect(0, 0, _.width, 60), g.beginPath(), g.strokeStyle = "#4a90d9", g.lineWidth = 1;
      for (let E = 0; E < _.width; E++) {
        let P = 1, T = -1;
        for (let y = 0; y < S; y++) {
          const w = M[E * S + y];
          w < P && (P = w), w > T && (T = w);
        }
        g.moveTo(E, (1 + P) * b), g.lineTo(E, (1 + T) * b);
      }
      g.stroke();
      const C = e.currentFrame / e.frameCount * _.width;
      g.fillStyle = "#fff", g.fillRect(C, 0, 1, 60);
    }
    return Ft(() => [e.audioBuffer, e.currentFrame], v), _n(() => {
      a.value && setTimeout(v, 100);
    }), (x, g) => (te(), ae("div", Yz, [
      f("div", { class: "panel-header" }, [
        g[2] || (g[2] = f("span", { class: "panel-title" }, "Audio Source", -1)),
        f("div", { class: "header-actions" }, [
          f("button", {
            onClick: d,
            title: "Load Audio"
          }, [...g[1] || (g[1] = [
            f("span", { class: "icon" }, "", -1)
          ])])
        ])
      ]),
      a.value ? (te(), ae("div", qz, [
        f("div", Zz, [
          f("div", Kz, [
            g[3] || (g[3] = f("span", { class: "file-icon" }, "", -1)),
            f("div", Jz, [
              f("span", Qz, xe(l.value), 1),
              f("span", e6, xe(u.value) + "  " + xe(c.value), 1)
            ]),
            f("button", {
              class: "remove-btn",
              onClick: m,
              title: "Remove Audio"
            }, "")
          ])
        ]),
        f("div", t6, [
          f("div", n6, [
            g[4] || (g[4] = f("label", null, "Master Vol", -1)),
            ze(Ve(jn), {
              modelValue: r.value,
              "onUpdate:modelValue": g[0] || (g[0] = (_) => r.value = _),
              min: 0,
              max: 100,
              unit: "%"
            }, null, 8, ["modelValue"]),
            f("button", {
              class: Fe(["mute-btn", { active: o.value }]),
              onClick: p,
              title: "Mute"
            }, xe(o.value ? "" : ""), 3)
          ])
        ]),
        f("div", i6, [
          g[5] || (g[5] = f("div", { class: "section-header" }, [
            f("span", { class: "section-title" }, "Waveform")
          ], -1)),
          f("div", s6, [
            f("canvas", {
              ref_key: "waveformCanvas",
              ref: i,
              class: "waveform-canvas"
            }, null, 512)
          ])
        ]),
        f("div", r6, [
          g[6] || (g[6] = f("div", { class: "linker-header" }, "Audio Linker", -1)),
          ze(jz)
        ])
      ])) : (te(), ae("div", o6, [
        g[7] || (g[7] = f("div", { class: "empty-icon" }, "", -1)),
        g[8] || (g[8] = f("p", null, "No audio loaded", -1)),
        f("button", {
          class: "load-btn",
          onClick: d
        }, "Load Audio File"),
        g[9] || (g[9] = f("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
      ])),
      f("input", {
        ref_key: "audioFileInput",
        ref: n,
        type: "file",
        accept: "audio/*",
        style: { display: "none" },
        onChange: h
      }, null, 544)
    ]));
  }
}), l6 = /* @__PURE__ */ Gt(a6, [["__scopeId", "data-v-66384e06"]]), Ev = 40, c6 = 30;
function u6(s) {
  const e = [], n = "#ffcc00", i = s.position;
  let r;
  if (s.type === "two-node")
    r = Rs(Yf(s.pointOfInterest, i));
  else {
    const p = s.orientation.x * Math.PI / 180, v = s.orientation.y * Math.PI / 180;
    r = wt(
      Math.sin(v) * Math.cos(p),
      -Math.sin(p),
      Math.cos(v) * Math.cos(p)
    );
  }
  const o = wt(0, -1, 0);
  let a = Rs(Xo(r, o));
  isNaN(a.x) && (a = wt(1, 0, 0));
  const l = Rs(Xo(a, r)), c = Ev / 2, u = At(i, Dt(r, -Ev)), d = [];
  for (let p = 0; p < 2; p++) {
    const v = p === 0 ? i : u;
    for (let x = -1; x <= 1; x += 2)
      for (let g = -1; g <= 1; g += 2)
        d.push(At(
          At(v, Dt(a, x * c)),
          Dt(l, g * c)
        ));
  }
  e.push({ start: d[0], end: d[1], color: n }), e.push({ start: d[1], end: d[3], color: n }), e.push({ start: d[3], end: d[2], color: n }), e.push({ start: d[2], end: d[0], color: n }), e.push({ start: d[4], end: d[5], color: n }), e.push({ start: d[5], end: d[7], color: n }), e.push({ start: d[7], end: d[6], color: n }), e.push({ start: d[6], end: d[4], color: n }), e.push({ start: d[0], end: d[4], color: n }), e.push({ start: d[1], end: d[5], color: n }), e.push({ start: d[2], end: d[6], color: n }), e.push({ start: d[3], end: d[7], color: n });
  const h = At(i, Dt(r, c6)), m = 8;
  for (let p = 0; p < m; p++) {
    const v = p / m * Math.PI * 2, x = (p + 1) / m * Math.PI * 2, g = At(
      At(i, Dt(a, Math.cos(v) * c * 0.5)),
      Dt(l, Math.sin(v) * c * 0.5)
    ), _ = At(
      At(i, Dt(a, Math.cos(x) * c * 0.5)),
      Dt(l, Math.sin(x) * c * 0.5)
    );
    e.push({ start: g, end: _, color: n }), e.push({ start: g, end: h, color: n });
  }
  return e;
}
function d6(s, e, n, i = 2e3) {
  const r = [], o = "#7c9cff", a = Cl(s.focalLength, s.filmSize), l = e / n, c = s.position;
  let u;
  if (s.type === "two-node")
    u = Rs(Yf(s.pointOfInterest, c));
  else {
    const P = s.orientation.x * Math.PI / 180, T = s.orientation.y * Math.PI / 180;
    u = wt(
      Math.sin(T) * Math.cos(P),
      -Math.sin(P),
      Math.cos(T) * Math.cos(P)
    );
  }
  const d = wt(0, -1, 0);
  let h = Rs(Xo(u, d));
  isNaN(h.x) && (h = wt(1, 0, 0));
  const m = Rs(Xo(h, u)), p = s.nearClip, v = Math.min(s.farClip, i), x = p * Math.tan(a * Math.PI / 360), g = x * l, _ = v * Math.tan(a * Math.PI / 360), M = _ * l, S = At(c, Dt(u, p)), b = [
    At(At(S, Dt(h, -g)), Dt(m, x)),
    At(At(S, Dt(h, g)), Dt(m, x)),
    At(At(S, Dt(h, g)), Dt(m, -x)),
    At(At(S, Dt(h, -g)), Dt(m, -x))
  ], C = At(c, Dt(u, v)), E = [
    At(At(C, Dt(h, -M)), Dt(m, _)),
    At(At(C, Dt(h, M)), Dt(m, _)),
    At(At(C, Dt(h, M)), Dt(m, -_)),
    At(At(C, Dt(h, -M)), Dt(m, -_))
  ];
  for (let P = 0; P < 4; P++)
    r.push({ start: b[P], end: b[(P + 1) % 4], color: o });
  for (let P = 0; P < 4; P++)
    r.push({ start: E[P], end: E[(P + 1) % 4], color: o });
  for (let P = 0; P < 4; P++)
    r.push({ start: b[P], end: E[P], color: o });
  return r;
}
function h6(s, e) {
  const n = "#00ff88", i = [
    wt(0, 0, 0),
    wt(s, 0, 0),
    wt(s, e, 0),
    wt(0, e, 0)
  ], r = [];
  for (let o = 0; o < 4; o++)
    r.push({ start: i[o], end: i[(o + 1) % 4], color: n });
  return r.push({ start: i[0], end: i[2], color: "#005533" }), r.push({ start: i[1], end: i[3], color: "#005533" }), r;
}
function f6(s) {
  return s.type !== "two-node" ? null : {
    start: s.position,
    end: s.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function p6(s, e, n) {
  if (!s.depthOfField.enabled)
    return [];
  const i = "#ff00ff", r = [], o = s.position, a = s.depthOfField.focusDistance;
  let l;
  if (s.type === "two-node")
    l = Rs(Yf(s.pointOfInterest, o));
  else {
    const x = s.orientation.x * Math.PI / 180, g = s.orientation.y * Math.PI / 180;
    l = wt(
      Math.sin(g) * Math.cos(x),
      -Math.sin(x),
      Math.cos(g) * Math.cos(x)
    );
  }
  const c = wt(0, -1, 0);
  let u = Rs(Xo(l, c));
  isNaN(u.x) && (u = wt(1, 0, 0));
  const d = Rs(Xo(u, l)), h = At(o, Dt(l, a)), m = e / 4, p = n / 4, v = [
    At(At(h, Dt(u, -m)), Dt(d, p)),
    At(At(h, Dt(u, m)), Dt(d, p)),
    At(At(h, Dt(u, m)), Dt(d, -p)),
    At(At(h, Dt(u, -m)), Dt(d, -p))
  ];
  for (let x = 0; x < 4; x++)
    r.push({ start: v[x], end: v[(x + 1) % 4], color: i });
  return r;
}
function Tv(s, e, n, i = !0, r = !0, o = !1) {
  return {
    body: u6(s),
    frustum: i ? d6(s, e, n) : [],
    compositionBounds: r ? h6(e, n) : [],
    poiLine: f6(s),
    focalPlane: o ? p6(s, e, n) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function m6(s, e, n) {
  const i = e / n, r = Cl(s.focalLength, s.filmSize);
  let o;
  if (s.type === "two-node")
    o = s.pointOfInterest;
  else {
    const u = s.orientation.x * Math.PI / 180, d = s.orientation.y * Math.PI / 180, h = wt(
      Math.sin(d) * Math.cos(u),
      -Math.sin(u),
      Math.cos(d) * Math.cos(u)
    );
    o = At(s.position, Dt(h, 1e3));
  }
  const a = Qi(s.position, o, wt(0, -1, 0)), l = XE(r, i, s.nearClip, s.farClip), c = ky(l, a);
  return { view: a, projection: l, viewProjection: c };
}
function Av(s, e, n, i) {
  const r = e / n;
  let o, a = 1e3;
  const l = e / 2, c = n / 2;
  switch (s) {
    case "front":
      o = Qi(
        wt(l, c, -2e3),
        wt(l, c, 0),
        wt(0, -1, 0)
      );
      break;
    case "back":
      o = Qi(
        wt(l, c, 2e3),
        wt(l, c, 0),
        wt(0, -1, 0)
      );
      break;
    case "left":
      o = Qi(
        wt(-2e3, c, 0),
        wt(l, c, 0),
        wt(0, -1, 0)
      );
      break;
    case "right":
      o = Qi(
        wt(l + 2e3, c, 0),
        wt(l, c, 0),
        wt(0, -1, 0)
      );
      break;
    case "top":
      o = Qi(
        wt(l, -2e3, 0),
        wt(l, c, 0),
        wt(0, 0, 1)
      );
      break;
    case "bottom":
      o = Qi(
        wt(l, c + 2e3, 0),
        wt(l, c, 0),
        wt(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (i) {
        const h = i.orbitPhi * Math.PI / 180, m = i.orbitTheta * Math.PI / 180, p = i.orbitDistance, v = wt(
          i.orbitCenter.x + p * Math.sin(h) * Math.sin(m),
          i.orbitCenter.y + p * Math.cos(h),
          i.orbitCenter.z + p * Math.sin(h) * Math.cos(m)
        );
        o = Qi(
          v,
          i.orbitCenter,
          wt(0, -1, 0)
        ), a = 1e3 / i.orthoZoom;
      } else
        o = Qi(
          wt(l, c, -2e3),
          wt(l, c, 0),
          wt(0, -1, 0)
        );
      break;
    default:
      o = Qi(
        wt(l, c, -2e3),
        wt(l, c, 0),
        wt(0, -1, 0)
      );
  }
  const u = jE(
    -a * r,
    a * r,
    -a,
    a,
    1,
    1e4
  ), d = ky(u, o);
  return { view: o, projection: u, viewProjection: d };
}
function ky(s, e) {
  const n = s.elements, i = e.elements, r = new Float32Array(16);
  for (let o = 0; o < 4; o++)
    for (let a = 0; a < 4; a++) {
      let l = 0;
      for (let c = 0; c < 4; c++)
        l += n[o + c * 4] * i[c + a * 4];
      r[o + a * 4] = l;
    }
  return { elements: r };
}
function Bd(s, e, n, i) {
  const r = YE(e, s), o = e.elements, a = s.x * o[3] + s.y * o[7] + s.z * o[11] + o[15];
  if (a <= 0)
    return { x: 0, y: 0, z: r.z, visible: !1 };
  const l = (r.x / a * 0.5 + 0.5) * n, c = (-r.y / a * 0.5 + 0.5) * i;
  return {
    x: l,
    y: c,
    z: r.z / a,
    visible: !0
  };
}
function v6(s, e = 100) {
  return [
    { start: s, end: At(s, wt(e, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: s, end: At(s, wt(0, e, 0)), color: "#00ff00" },
    // Y - Green
    { start: s, end: At(s, wt(0, 0, e)), color: "#0000ff" }
    // Z - Blue
  ];
}
function g6(s, e, n = 100) {
  const i = [], r = "#333333", o = "#444444", a = s / 2, l = e / 2, c = Math.max(s, e);
  for (let u = -c; u <= c + s; u += n) {
    const d = Math.abs(u - a) < n / 2;
    i.push({
      start: wt(u, -c, 0),
      end: wt(u, c + e, 0),
      color: d ? o : r
    });
  }
  for (let u = -c; u <= c + e; u += n) {
    const d = Math.abs(u - l) < n / 2;
    i.push({
      start: wt(-c, u, 0),
      end: wt(c + s, u, 0),
      color: d ? o : r
    });
  }
  return i;
}
const y6 = ["onClick"], _6 = { class: "view-header" }, x6 = ["value", "onChange"], b6 = { class: "view-tools" }, w6 = ["onClick"], S6 = ["onMousedown", "onWheel"], M6 = { class: "view-info" }, C6 = { class: "view-name" }, E6 = {
  key: 0,
  class: "view-coords"
}, T6 = { class: "layout-controls" }, A6 = ["onClick", "title"], P6 = /* @__PURE__ */ Ot({
  __name: "ViewportRenderer",
  setup(s) {
    const e = sn(), n = Ie(() => e.activeCamera), i = Ie(() => e.width), r = Ie(() => e.height), o = Ie(() => e.viewportState), a = Ie(() => e.viewOptions), l = Ie(() => e.layers.filter((le) => le.type !== "camera").map((le) => ({
      id: le.id,
      name: le.name,
      position: {
        x: le.transform.position.value.x,
        y: le.transform.position.value.y,
        z: 0
        // 2D layers at z=0
      },
      selected: e.selectedLayerIds.includes(le.id)
    }))), c = we([null, null, null, null]), u = we([null, null, null, null]), d = we(!1), h = we({ x: 0, y: 0 }), m = we(0), p = we(0), v = [
      { value: "1-view", label: "1 View", icon: "" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "" },
      { value: "4-view", label: "4 Views", icon: "" }
    ], x = Ie(() => o.value.layout), g = Ie(() => o.value.activeViewIndex), _ = Ie(() => o.value.customViews), M = Ie(() => {
      switch (o.value.layout) {
        case "1-view":
          return [o.value.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return o.value.views.slice(0, 2);
        case "4-view":
          return o.value.views.slice(0, 4);
        default:
          return [o.value.views[0]];
      }
    });
    function S(le, re) {
      c.value[re] = le, le && (u.value[re] = le.getContext("2d"));
    }
    function b(le) {
      return le.startsWith("custom-");
    }
    function C(le) {
      return {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        front: "Front",
        back: "Back",
        left: "Left",
        right: "Right",
        top: "Top",
        bottom: "Bottom"
      }[le];
    }
    function E(le) {
      e.updateViewportState({
        activeViewIndex: le
      });
    }
    function P(le, re) {
      const j = [...o.value.views];
      j[le] = re, e.updateViewportState({
        views: j
      });
    }
    function T(le) {
      const re = ["active-camera", "top", "front", "right"];
      let j = [...o.value.views];
      for (; j.length < 4; )
        j.push(re[j.length] || "front");
      e.updateViewportState({
        layout: le,
        views: j,
        activeViewIndex: Math.min(o.value.activeViewIndex, y(le) - 1)
      });
    }
    function y(le) {
      switch (le) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function w(le) {
      const re = {
        orbitCenter: { x: i.value / 2, y: r.value / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      e.updateViewportState({
        customViews: {
          ...o.value.customViews,
          [le]: re
        }
      });
    }
    function D(le, re) {
      d.value = !0, h.value = { x: le.clientX, y: le.clientY }, m.value = re, p.value = le.button, document.addEventListener("mousemove", U), document.addEventListener("mouseup", R);
    }
    function U(le) {
      if (!d.value) return;
      const re = le.clientX - h.value.x, j = le.clientY - h.value.y;
      h.value = { x: le.clientX, y: le.clientY };
      const $ = M.value[m.value];
      if (b($)) {
        const q = _.value[$];
        if (p.value === 0) {
          const oe = q.orbitTheta + re * 0.5, ie = Math.max(1, Math.min(179, q.orbitPhi + j * 0.5));
          e.updateViewportState({
            customViews: {
              ...o.value.customViews,
              [$]: {
                ...q,
                orbitTheta: oe,
                orbitPhi: ie
              }
            }
          });
        } else (p.value === 1 || p.value === 2) && e.updateViewportState({
          customViews: {
            ...o.value.customViews,
            [$]: {
              ...q,
              orthoOffset: {
                x: q.orthoOffset.x + re,
                y: q.orthoOffset.y + j
              }
            }
          }
        });
      }
    }
    function R() {
      d.value = !1, document.removeEventListener("mousemove", U), document.removeEventListener("mouseup", R);
    }
    function O(le, re) {
      le.preventDefault();
      const j = M.value[re];
      if (b(j)) {
        const $ = _.value[j], q = le.deltaY > 0 ? 1.1 : 0.9;
        e.updateViewportState({
          customViews: {
            ...o.value.customViews,
            [j]: {
              ...$,
              orbitDistance: $.orbitDistance * q
            }
          }
        });
      }
    }
    function A() {
      M.value.forEach((le, re) => {
        const j = c.value[re], $ = u.value[re];
        if (!j || !$) return;
        const q = j.getBoundingClientRect(), oe = window.devicePixelRatio || 1;
        j.width = q.width * oe, j.height = q.height * oe, $.scale(oe, oe), $.fillStyle = "#1a1a1a", $.fillRect(0, 0, q.width, q.height);
        let ie;
        le === "active-camera" && n.value ? ie = m6(n.value, i.value, r.value) : b(le) ? ie = Av(le, i.value, r.value, _.value[le]) : ie = Av(le, i.value, r.value);
        const ce = [];
        if (a.value.showGrid && ce.push(...g6(i.value, r.value)), a.value.show3DReferenceAxes && ce.push(...v6(wt(i.value / 2, r.value / 2, 0))), a.value.showCompositionBounds) {
          const V = Tv(
            n.value ?? G(),
            i.value,
            r.value,
            !1,
            !0,
            !1
          );
          ce.push(...V.compositionBounds);
        }
        if (le !== "active-camera" && n.value && (a.value.cameraWireframes === "always" || a.value.cameraWireframes === "selected")) {
          const Y = Tv(
            n.value,
            i.value,
            r.value,
            !0,
            !1,
            a.value.showFocalPlane
          );
          ce.push(...Y.body), ce.push(...Y.frustum), ce.push(...Y.focalPlane), Y.poiLine && ce.push(Y.poiLine);
        }
        for (const V of ce) {
          const Y = Bd(V.start, ie.viewProjection, q.width, q.height), H = Bd(V.end, ie.viewProjection, q.width, q.height);
          !Y.visible && !H.visible || ($.beginPath(), $.strokeStyle = V.color, $.lineWidth = 1, $.moveTo(Y.x, Y.y), $.lineTo(H.x, H.y), $.stroke());
        }
        if (a.value.showLayerHandles)
          for (const V of l.value) {
            const Y = Bd(V.position, ie.viewProjection, q.width, q.height);
            Y.visible && ($.beginPath(), $.fillStyle = V.selected ? "#ffcc00" : "#888888", $.arc(Y.x, Y.y, V.selected ? 6 : 4, 0, Math.PI * 2), $.fill(), $.fillStyle = "#ffffff", $.font = "10px sans-serif", $.fillText(V.name, Y.x + 8, Y.y + 4));
          }
      });
    }
    function G() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: i.value / 2, y: r.value / 2, z: -1500 },
        pointOfInterest: { x: i.value / 2, y: r.value / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: !1,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let ue;
    function Q() {
      A(), ue = requestAnimationFrame(Q);
    }
    return _n(() => {
      Q();
    }), Nn(() => {
      cancelAnimationFrame(ue);
    }), Ft([n, o, a, l], () => {
    }, { deep: !0 }), (le, re) => (te(), ae("div", {
      class: Fe(["viewport-renderer", [`layout-${x.value}`]])
    }, [
      (te(!0), ae(qe, null, ot(M.value, (j, $) => {
        var q, oe;
        return te(), ae("div", {
          key: $,
          class: Fe(["view-panel", { active: $ === g.value }]),
          onClick: (ie) => E($)
        }, [
          f("div", _6, [
            f("select", {
              value: j,
              onChange: (ie) => P($, ie.target.value),
              class: "view-select"
            }, [...re[1] || (re[1] = [
              as('<option value="active-camera" data-v-cdf0e094>Active Camera</option><option value="custom-1" data-v-cdf0e094>Custom View 1</option><option value="custom-2" data-v-cdf0e094>Custom View 2</option><option value="custom-3" data-v-cdf0e094>Custom View 3</option><option value="front" data-v-cdf0e094>Front</option><option value="back" data-v-cdf0e094>Back</option><option value="left" data-v-cdf0e094>Left</option><option value="right" data-v-cdf0e094>Right</option><option value="top" data-v-cdf0e094>Top</option><option value="bottom" data-v-cdf0e094>Bottom</option>', 10)
            ])], 40, x6),
            f("div", b6, [
              b(j) ? (te(), ae("button", {
                key: 0,
                onClick: _t((ie) => w(j), ["stop"]),
                title: "Reset View"
              }, [...re[2] || (re[2] = [
                f("span", { class: "icon" }, "", -1)
              ])], 8, w6)) : Pe("", !0)
            ])
          ]),
          f("canvas", {
            ref_for: !0,
            ref: (ie) => S(ie, $),
            class: "view-canvas",
            onMousedown: (ie) => D(ie, $),
            onWheel: (ie) => O(ie, $),
            onContextmenu: re[0] || (re[0] = _t(() => {
            }, ["prevent"]))
          }, null, 40, S6),
          f("div", M6, [
            f("span", C6, xe(C(j)), 1),
            b(j) ? (te(), ae("span", E6, " : " + xe(Math.round(((q = _.value[j]) == null ? void 0 : q.orbitTheta) ?? 0)) + " : " + xe(Math.round(((oe = _.value[j]) == null ? void 0 : oe.orbitPhi) ?? 0)) + " ", 1)) : Pe("", !0)
          ])
        ], 10, y6);
      }), 128)),
      f("div", T6, [
        (te(), ae(qe, null, ot(v, (j) => f("button", {
          key: j.value,
          class: Fe({ active: x.value === j.value }),
          onClick: ($) => T(j.value),
          title: j.label
        }, xe(j.icon), 11, A6)), 64))
      ])
    ], 2));
  }
}), R6 = /* @__PURE__ */ Gt(P6, [["__scopeId", "data-v-cdf0e094"]]), wr = new jf(), Wn = new de(), Ys = new de(), on = new ni(), Pv = {
  X: new de(1, 0, 0),
  Y: new de(0, 1, 0),
  Z: new de(0, 0, 1)
}, Vd = { type: "change" }, Rv = { type: "mouseDown", mode: null }, Dv = { type: "mouseUp", mode: null }, kv = { type: "objectChange" };
class D6 extends EE {
  constructor(e, n = null) {
    super(void 0, n);
    const i = new O6(this);
    this._root = i;
    const r = new z6();
    this._gizmo = r, i.add(r);
    const o = new N6();
    this._plane = o, i.add(o);
    const a = this;
    function l(S, b) {
      let C = b;
      Object.defineProperty(a, S, {
        get: function() {
          return C !== void 0 ? C : b;
        },
        set: function(E) {
          C !== E && (C = E, o[S] = E, r[S] = E, a.dispatchEvent({ type: S + "-changed", value: E }), a.dispatchEvent(Vd));
        }
      }), a[S] = b, o[S] = b, r[S] = b;
    }
    l("camera", e), l("object", void 0), l("enabled", !0), l("axis", null), l("mode", "translate"), l("translationSnap", null), l("rotationSnap", null), l("scaleSnap", null), l("space", "world"), l("size", 1), l("dragging", !1), l("showX", !0), l("showY", !0), l("showZ", !0), l("minX", -1 / 0), l("maxX", 1 / 0), l("minY", -1 / 0), l("maxY", 1 / 0), l("minZ", -1 / 0), l("maxZ", 1 / 0);
    const c = new de(), u = new de(), d = new ni(), h = new ni(), m = new de(), p = new ni(), v = new de(), x = new de(), g = new de(), _ = 0, M = new de();
    l("worldPosition", c), l("worldPositionStart", u), l("worldQuaternion", d), l("worldQuaternionStart", h), l("cameraPosition", m), l("cameraQuaternion", p), l("pointStart", v), l("pointEnd", x), l("rotationAxis", g), l("rotationAngle", _), l("eye", M), this._offset = new de(), this._startNorm = new de(), this._endNorm = new de(), this._cameraScale = new de(), this._parentPosition = new de(), this._parentQuaternion = new ni(), this._parentQuaternionInv = new ni(), this._parentScale = new de(), this._worldScaleStart = new de(), this._worldQuaternionInv = new ni(), this._worldScale = new de(), this._positionStart = new de(), this._quaternionStart = new ni(), this._scaleStart = new de(), this._getPointer = k6.bind(this), this._onPointerDown = L6.bind(this), this._onPointerHover = I6.bind(this), this._onPointerMove = F6.bind(this), this._onPointerUp = U6.bind(this), n !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "auto";
  }
  getHelper() {
    return this._root;
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0) return;
    e !== null && wr.setFromCamera(e, this.camera);
    const n = Gd(this._gizmo.picker[this.mode], wr);
    n ? this.axis = n.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e != null && e.button !== 0) && this.axis !== null) {
      e !== null && wr.setFromCamera(e, this.camera);
      const n = Gd(this._plane, wr, !0);
      n && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(n.point).sub(this.worldPositionStart)), this.dragging = !0, Rv.mode = this.mode, this.dispatchEvent(Rv);
    }
  }
  pointerMove(e) {
    const n = this.axis, i = this.mode, r = this.object;
    let o = this.space;
    if (i === "scale" ? o = "local" : (n === "E" || n === "XYZE" || n === "XYZ") && (o = "world"), r === void 0 || n === null || this.dragging === !1 || e !== null && e.button !== -1) return;
    e !== null && wr.setFromCamera(e, this.camera);
    const a = Gd(this._plane, wr, !0);
    if (a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), i === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), o === "local" && n !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), n.indexOf("X") === -1 && (this._offset.x = 0), n.indexOf("Y") === -1 && (this._offset.y = 0), n.indexOf("Z") === -1 && (this._offset.z = 0), o === "local" && n !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), r.position.copy(this._offset).add(this._positionStart), this.translationSnap && (o === "local" && (r.position.applyQuaternion(on.copy(this._quaternionStart).invert()), n.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), n.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), n.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this._quaternionStart)), o === "world" && (r.parent && r.position.add(Wn.setFromMatrixPosition(r.parent.matrixWorld)), n.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), n.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), n.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(Wn.setFromMatrixPosition(r.parent.matrixWorld)))), r.position.x = Math.max(this.minX, Math.min(this.maxX, r.position.x)), r.position.y = Math.max(this.minY, Math.min(this.maxY, r.position.y)), r.position.z = Math.max(this.minZ, Math.min(this.maxZ, r.position.z));
      else if (i === "scale") {
        if (n.search("XYZ") !== -1) {
          let l = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (l *= -1), Ys.set(l, l, l);
        } else
          Wn.copy(this.pointStart), Ys.copy(this.pointEnd), Wn.applyQuaternion(this._worldQuaternionInv), Ys.applyQuaternion(this._worldQuaternionInv), Ys.divide(Wn), n.search("X") === -1 && (Ys.x = 1), n.search("Y") === -1 && (Ys.y = 1), n.search("Z") === -1 && (Ys.z = 1);
        r.scale.copy(this._scaleStart).multiply(Ys), this.scaleSnap && (n.search("X") !== -1 && (r.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), n.search("Y") !== -1 && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), n.search("Z") !== -1 && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (i === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const l = 20 / this.worldPosition.distanceTo(Wn.setFromMatrixPosition(this.camera.matrixWorld));
        let c = !1;
        n === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Wn.copy(this.rotationAxis).cross(this.eye)) * l) : (n === "X" || n === "Y" || n === "Z") && (this.rotationAxis.copy(Pv[n]), Wn.copy(Pv[n]), o === "local" && Wn.applyQuaternion(this.worldQuaternion), Wn.cross(this.eye), Wn.length() === 0 ? c = !0 : this.rotationAngle = this._offset.dot(Wn.normalize()) * l), (n === "E" || c) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), o === "local" && n !== "E" && n !== "XYZE" ? (r.quaternion.copy(this._quaternionStart), r.quaternion.multiply(on.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), r.quaternion.copy(on.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Vd), this.dispatchEvent(kv);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (Dv.mode = this.mode, this.dispatchEvent(Dv)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.disconnect(), this._root.dispose();
  }
  // Set current object
  attach(e) {
    return this.object = e, this._root.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.axis = null, this._root.visible = !1, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Vd), this.dispatchEvent(kv), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return wr;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function k6(s) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: s.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (s.clientX - e.left) / e.width * 2 - 1,
      y: -(s.clientY - e.top) / e.height * 2 + 1,
      button: s.button
    };
  }
}
function I6(s) {
  if (this.enabled)
    switch (s.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(s));
        break;
    }
}
function L6(s) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(s)), this.pointerDown(this._getPointer(s)));
}
function F6(s) {
  this.enabled && this.pointerMove(this._getPointer(s));
}
function U6(s) {
  this.enabled && (this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(s)));
}
function Gd(s, e, n) {
  const i = e.intersectObject(s, !0);
  for (let r = 0; r < i.length; r++)
    if (i[r].object.visible || n)
      return i[r];
  return !1;
}
const gc = new Mi(), Qt = new de(0, 1, 0), Iv = new de(0, 0, 0), Lv = new Zt(), yc = new ni(), Nc = new ni(), Ji = new de(), Fv = new Zt(), Da = new de(1, 0, 0), Pr = new de(0, 1, 0), ka = new de(0, 0, 1), _c = new de(), _a = new de(), xa = new de();
class O6 extends cn {
  constructor(e) {
    super(), this.isTransformControlsRoot = !0, this.controls = e, this.visible = !1;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(e) {
    const n = this.controls;
    n.object !== void 0 && (n.object.updateMatrixWorld(), n.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : n.object.parent.matrixWorld.decompose(n._parentPosition, n._parentQuaternion, n._parentScale), n.object.matrixWorld.decompose(n.worldPosition, n.worldQuaternion, n._worldScale), n._parentQuaternionInv.copy(n._parentQuaternion).invert(), n._worldQuaternionInv.copy(n.worldQuaternion).invert()), n.camera.updateMatrixWorld(), n.camera.matrixWorld.decompose(n.cameraPosition, n.cameraQuaternion, n._cameraScale), n.camera.isOrthographicCamera ? n.camera.getWorldDirection(n.eye).negate() : n.eye.copy(n.cameraPosition).sub(n.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
  dispose() {
    this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
}
class z6 extends cn {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new En({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), n = new ji({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), i = e.clone();
    i.opacity = 0.15;
    const r = n.clone();
    r.opacity = 0.5;
    const o = e.clone();
    o.color.setHex(16711680);
    const a = e.clone();
    a.color.setHex(65280);
    const l = e.clone();
    l.color.setHex(255);
    const c = e.clone();
    c.color.setHex(16711680), c.opacity = 0.5;
    const u = e.clone();
    u.color.setHex(65280), u.opacity = 0.5;
    const d = e.clone();
    d.color.setHex(255), d.opacity = 0.5;
    const h = e.clone();
    h.opacity = 0.25;
    const m = e.clone();
    m.color.setHex(16776960), m.opacity = 0.25, e.clone().color.setHex(16776960);
    const v = e.clone();
    v.color.setHex(7895160);
    const x = new In(0, 0.04, 0.1, 12);
    x.translate(0, 0.05, 0);
    const g = new pn(0.08, 0.08, 0.08);
    g.translate(0, 0.04, 0);
    const _ = new Vt();
    _.setAttribute("position", new Pt([0, 0, 0, 1, 0, 0], 3));
    const M = new In(75e-4, 75e-4, 0.5, 3);
    M.translate(0, 0.25, 0);
    function S(A, G) {
      const ue = new kr(A, 75e-4, 3, 64, G * Math.PI * 2);
      return ue.rotateY(Math.PI / 2), ue.rotateX(Math.PI / 2), ue;
    }
    function b() {
      const A = new Vt();
      return A.setAttribute("position", new Pt([0, 0, 0, 1, 1, 1], 3)), A;
    }
    const C = {
      X: [
        [new Ze(x, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ze(x, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Ze(M, o), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Ze(x, a), [0, 0.5, 0]],
        [new Ze(x, a), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Ze(M, a)]
      ],
      Z: [
        [new Ze(x, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Ze(x, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Ze(M, l), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ze(new Eo(0.1, 0), h.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Ze(new pn(0.15, 0.15, 0.01), d.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ze(new pn(0.15, 0.15, 0.01), c.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ze(new pn(0.15, 0.15, 0.01), u.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, E = {
      X: [
        [new Ze(new In(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ze(new In(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ze(new In(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new Ze(new In(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ze(new In(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Ze(new In(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ze(new Eo(0.2, 0), i)]
      ],
      XY: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, P = {
      START: [
        [new Ze(new Eo(0.01, 2), r), null, null, null, "helper"]
      ],
      END: [
        [new Ze(new Eo(0.01, 2), r), null, null, null, "helper"]
      ],
      DELTA: [
        [new ln(b(), r), null, null, null, "helper"]
      ],
      X: [
        [new ln(_, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new ln(_, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new ln(_, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, T = {
      XYZE: [
        [new Ze(S(0.5, 1), v), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Ze(S(0.5, 0.5), o)]
      ],
      Y: [
        [new Ze(S(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Ze(S(0.5, 0.5), l), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Ze(S(0.75, 1), m), null, [0, Math.PI / 2, 0]]
      ]
    }, y = {
      AXIS: [
        [new ln(_, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, w = {
      XYZE: [
        [new Ze(new Ru(0.25, 10, 8), i)]
      ],
      X: [
        [new Ze(new kr(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Ze(new kr(0.5, 0.1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Ze(new kr(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Ze(new kr(0.75, 0.1, 2, 24), i)]
      ]
    }, D = {
      X: [
        [new Ze(g, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ze(M, o), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ze(g, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ze(g, a), [0, 0.5, 0]],
        [new Ze(M, a)],
        [new Ze(g, a), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ze(g, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Ze(M, l), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Ze(g, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Ze(new pn(0.15, 0.15, 0.01), d), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ze(new pn(0.15, 0.15, 0.01), c), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ze(new pn(0.15, 0.15, 0.01), u), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ze(new pn(0.1, 0.1, 0.1), h.clone())]
      ]
    }, U = {
      X: [
        [new Ze(new In(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ze(new In(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ze(new In(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new Ze(new In(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ze(new In(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Ze(new In(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ze(new pn(0.2, 0.2, 0.2), i), [0, 0, 0]]
      ]
    }, R = {
      X: [
        [new ln(_, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new ln(_, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new ln(_, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function O(A) {
      const G = new cn();
      for (const ue in A)
        for (let Q = A[ue].length; Q--; ) {
          const le = A[ue][Q][0].clone(), re = A[ue][Q][1], j = A[ue][Q][2], $ = A[ue][Q][3], q = A[ue][Q][4];
          le.name = ue, le.tag = q, re && le.position.set(re[0], re[1], re[2]), j && le.rotation.set(j[0], j[1], j[2]), $ && le.scale.set($[0], $[1], $[2]), le.updateMatrix();
          const oe = le.geometry.clone();
          oe.applyMatrix4(le.matrix), le.geometry = oe, le.renderOrder = 1 / 0, le.position.set(0, 0, 0), le.rotation.set(0, 0, 0), le.scale.set(1, 1, 1), G.add(le);
        }
      return G;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = O(C)), this.add(this.gizmo.rotate = O(T)), this.add(this.gizmo.scale = O(D)), this.add(this.picker.translate = O(E)), this.add(this.picker.rotate = O(w)), this.add(this.picker.scale = O(U)), this.add(this.helper.translate = O(P)), this.add(this.helper.rotate = O(y)), this.add(this.helper.scale = O(R)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const i = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Nc;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let r = [];
    r = r.concat(this.picker[this.mode].children), r = r.concat(this.gizmo[this.mode].children), r = r.concat(this.helper[this.mode].children);
    for (let o = 0; o < r.length; o++) {
      const a = r[o];
      a.visible = !0, a.rotation.set(0, 0, 0), a.position.copy(this.worldPosition);
      let l;
      if (this.camera.isOrthographicCamera ? l = (this.camera.top - this.camera.bottom) / this.camera.zoom : l = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), a.scale.set(1, 1, 1).multiplyScalar(l * this.size / 4), a.tag === "helper") {
        a.visible = !1, a.name === "AXIS" ? (a.visible = !!this.axis, this.axis === "X" && (on.setFromEuler(gc.set(0, 0, 0)), a.quaternion.copy(i).multiply(on), Math.abs(Qt.copy(Da).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Y" && (on.setFromEuler(gc.set(0, 0, Math.PI / 2)), a.quaternion.copy(i).multiply(on), Math.abs(Qt.copy(Pr).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Z" && (on.setFromEuler(gc.set(0, Math.PI / 2, 0)), a.quaternion.copy(i).multiply(on), Math.abs(Qt.copy(ka).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "XYZE" && (on.setFromEuler(gc.set(0, Math.PI / 2, 0)), Qt.copy(this.rotationAxis), a.quaternion.setFromRotationMatrix(Lv.lookAt(Iv, Qt, Pr)), a.quaternion.multiply(on), a.visible = this.dragging), this.axis === "E" && (a.visible = !1)) : a.name === "START" ? (a.position.copy(this.worldPositionStart), a.visible = this.dragging) : a.name === "END" ? (a.position.copy(this.worldPosition), a.visible = this.dragging) : a.name === "DELTA" ? (a.position.copy(this.worldPositionStart), a.quaternion.copy(this.worldQuaternionStart), Wn.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Wn.applyQuaternion(this.worldQuaternionStart.clone().invert()), a.scale.copy(Wn), a.visible = this.dragging) : (a.quaternion.copy(i), this.dragging ? a.position.copy(this.worldPositionStart) : a.position.copy(this.worldPosition), this.axis && (a.visible = this.axis.search(a.name) !== -1));
        continue;
      }
      a.quaternion.copy(i), this.mode === "translate" || this.mode === "scale" ? (a.name === "X" && Math.abs(Qt.copy(Da).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Y" && Math.abs(Qt.copy(Pr).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Z" && Math.abs(Qt.copy(ka).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XY" && Math.abs(Qt.copy(ka).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "YZ" && Math.abs(Qt.copy(Da).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XZ" && Math.abs(Qt.copy(Pr).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1)) : this.mode === "rotate" && (yc.copy(i), Qt.copy(this.eye).applyQuaternion(on.copy(i).invert()), a.name.search("E") !== -1 && a.quaternion.setFromRotationMatrix(Lv.lookAt(this.eye, Iv, Pr)), a.name === "X" && (on.setFromAxisAngle(Da, Math.atan2(-Qt.y, Qt.z)), on.multiplyQuaternions(yc, on), a.quaternion.copy(on)), a.name === "Y" && (on.setFromAxisAngle(Pr, Math.atan2(Qt.x, Qt.z)), on.multiplyQuaternions(yc, on), a.quaternion.copy(on)), a.name === "Z" && (on.setFromAxisAngle(ka, Math.atan2(Qt.y, Qt.x)), on.multiplyQuaternions(yc, on), a.quaternion.copy(on))), a.visible = a.visible && (a.name.indexOf("X") === -1 || this.showX), a.visible = a.visible && (a.name.indexOf("Y") === -1 || this.showY), a.visible = a.visible && (a.name.indexOf("Z") === -1 || this.showZ), a.visible = a.visible && (a.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), a.material._color = a.material._color || a.material.color.clone(), a.material._opacity = a.material._opacity || a.material.opacity, a.material.color.copy(a.material._color), a.material.opacity = a.material._opacity, this.enabled && this.axis && (a.name === this.axis || this.axis.split("").some(function(c) {
        return a.name === c;
      })) && (a.material.color.setHex(16776960), a.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class N6 extends Ze {
  constructor() {
    super(
      new un(1e5, 1e5, 2, 2),
      new En({ visible: !1, wireframe: !0, side: vn, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let n = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (n = "local"), _c.copy(Da).applyQuaternion(n === "local" ? this.worldQuaternion : Nc), _a.copy(Pr).applyQuaternion(n === "local" ? this.worldQuaternion : Nc), xa.copy(ka).applyQuaternion(n === "local" ? this.worldQuaternion : Nc), Qt.copy(_a), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            Qt.copy(this.eye).cross(_c), Ji.copy(_c).cross(Qt);
            break;
          case "Y":
            Qt.copy(this.eye).cross(_a), Ji.copy(_a).cross(Qt);
            break;
          case "Z":
            Qt.copy(this.eye).cross(xa), Ji.copy(xa).cross(Qt);
            break;
          case "XY":
            Ji.copy(xa);
            break;
          case "YZ":
            Ji.copy(_c);
            break;
          case "XZ":
            Qt.copy(xa), Ji.copy(_a);
            break;
          case "XYZ":
          case "E":
            Ji.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        Ji.set(0, 0, 0);
    }
    Ji.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (Fv.lookAt(Wn.set(0, 0, 0), Ji, Qt), this.quaternion.setFromRotationMatrix(Fv)), super.updateMatrixWorld(e);
  }
}
class B6 {
  constructor(e = null) {
    /** The main Three.js scene */
    fe(this, "scene");
    /** Group for composition layers (rendered content) */
    fe(this, "compositionGroup");
    /** Group for UI overlay elements */
    fe(this, "overlayGroup");
    /** Group for debug helpers */
    fe(this, "debugGroup");
    /** Composition bounds frame */
    fe(this, "compositionBounds", null);
    /** Composition dimensions */
    fe(this, "compositionWidth", 1920);
    fe(this, "compositionHeight", 1080);
    /** O(1) layer lookup map - optimization for frequent ID-based lookups */
    fe(this, "layerLookupMap", /* @__PURE__ */ new Map());
    /** Track Z positions to avoid unnecessary sorting */
    fe(this, "zPositionCache", /* @__PURE__ */ new Map());
    fe(this, "needsZSort", !1);
    this.scene = new F2(), this.scene.name = "WeylScene", e ? this.scene.background = new Mt(e) : this.scene.background = null, this.compositionGroup = new Ai(), this.compositionGroup.name = "composition", this.scene.add(this.compositionGroup), this.overlayGroup = new Ai(), this.overlayGroup.name = "overlay", this.overlayGroup.renderOrder = 1e3, this.scene.add(this.overlayGroup), this.debugGroup = new Ai(), this.debugGroup.name = "debug", this.debugGroup.visible = !1, this.scene.add(this.debugGroup), this.setupDefaultLighting();
  }
  /**
   * Set up default ambient and directional lighting
   */
  setupDefaultLighting() {
    const e = new by(16777215, 0.6);
    e.name = "ambientLight", this.scene.add(e);
    const n = new To(16777215, 0.8);
    n.name = "keyLight", n.position.set(1e3, -1e3, 2e3), n.castShadow = !0, n.shadow.mapSize.width = 2048, n.shadow.mapSize.height = 2048, this.scene.add(n);
    const i = new To(16777215, 0.3);
    i.name = "fillLight", i.position.set(-500, 500, 1e3), this.scene.add(i);
  }
  // ============================================================================
  // COMPOSITION MANAGEMENT
  // ============================================================================
  /**
   * Add object to composition group
   */
  addToComposition(e) {
    var i;
    this.compositionGroup.add(e), this.markNeedsZSort();
    const n = (i = e.userData) == null ? void 0 : i.layerId;
    n && this.layerLookupMap.set(n, e);
  }
  /**
   * Remove object from composition group
   */
  removeFromComposition(e) {
    var i;
    this.compositionGroup.remove(e);
    const n = (i = e.userData) == null ? void 0 : i.layerId;
    n && this.layerLookupMap.delete(n), this.zPositionCache.delete(e);
  }
  /**
   * Sort composition layers by Z position for proper depth ordering
   * Optimized to only sort when Z positions have actually changed
   */
  sortByZ() {
    if (!this.needsZSort) {
      let e = !1;
      for (const n of this.compositionGroup.children) {
        const i = this.zPositionCache.get(n), r = n.position.z || 0;
        if (i === void 0 || i !== r) {
          e = !0;
          break;
        }
      }
      if (!e)
        return;
    }
    this.compositionGroup.children.sort((e, n) => (e.position.z || 0) - (n.position.z || 0));
    for (const e of this.compositionGroup.children)
      this.zPositionCache.set(e, e.position.z || 0);
    this.needsZSort = !1;
  }
  /**
   * Mark that Z sorting is needed (call when Z positions may have changed)
   */
  markNeedsZSort() {
    this.needsZSort = !0;
  }
  /**
   * Get all composition layer objects
   */
  getCompositionObjects() {
    return [...this.compositionGroup.children];
  }
  // ============================================================================
  // OVERLAY MANAGEMENT
  // ============================================================================
  /**
   * Add object to overlay group
   */
  addToOverlay(e) {
    this.overlayGroup.add(e);
  }
  /**
   * Remove object from overlay group
   */
  removeFromOverlay(e) {
    this.overlayGroup.remove(e);
  }
  /**
   * Clear all overlay objects
   */
  clearOverlay() {
    for (; this.overlayGroup.children.length > 0; ) {
      const e = this.overlayGroup.children[0];
      this.overlayGroup.remove(e), this.disposeObject(e);
    }
  }
  /**
   * Add a UI element directly to the scene (for transform controls, etc.)
   * UI elements are added to the scene root so they're always visible
   */
  addUIElement(e) {
    this.scene.add(e);
  }
  /**
   * Remove a UI element from the scene
   */
  removeUIElement(e) {
    this.scene.remove(e);
  }
  // ============================================================================
  // DEBUG HELPERS
  // ============================================================================
  /**
   * Toggle debug helpers visibility
   */
  setDebugVisible(e) {
    this.debugGroup.visible = e;
  }
  /**
   * Add axis helper to debug group
   */
  addAxisHelper(e = 500) {
    const n = this.debugGroup.getObjectByName("axisHelper");
    n && this.debugGroup.remove(n);
    const i = new CE(e);
    i.name = "axisHelper", this.debugGroup.add(i);
  }
  /**
   * Add grid helper to debug group
   */
  addGridHelper(e = 2e3, n = 40) {
    const i = this.debugGroup.getObjectByName("gridHelper");
    i && this.debugGroup.remove(i);
    const r = new ME(e, n, 4473924, 2236962);
    r.name = "gridHelper", r.rotation.x = Math.PI / 2, this.debugGroup.add(r);
  }
  // ============================================================================
  // BACKGROUND
  // ============================================================================
  /**
   * Set scene background color
   */
  setBackground(e) {
    e ? this.scene.background = new Mt(e) : this.scene.background = null;
  }
  /**
   * Get current background color
   */
  getBackground() {
    return this.scene.background instanceof Mt ? "#" + this.scene.background.getHexString() : null;
  }
  // ============================================================================
  // COMPOSITION BOUNDS
  // ============================================================================
  /**
   * Set composition dimensions and create/update bounds frame
   */
  setCompositionSize(e, n) {
    this.compositionWidth = e, this.compositionHeight = n, this.updateCompositionBounds();
  }
  /**
   * Get composition dimensions
   */
  getCompositionSize() {
    return { width: this.compositionWidth, height: this.compositionHeight };
  }
  /**
   * Create or update composition bounds frame
   */
  updateCompositionBounds() {
    this.compositionBounds && (this.overlayGroup.remove(this.compositionBounds), this.compositionBounds.geometry.dispose(), this.compositionBounds.material.dispose());
    const e = this.compositionWidth, n = this.compositionHeight, i = [
      new de(0, 0, 0),
      new de(e, 0, 0),
      new de(e, -n, 0),
      new de(0, -n, 0)
    ], r = new Vt().setFromPoints(i), o = new ji({
      color: 4886745,
      linewidth: 2,
      depthTest: !1
    });
    this.compositionBounds = new U2(r, o), this.compositionBounds.name = "compositionBounds", this.compositionBounds.renderOrder = 998, this.overlayGroup.add(this.compositionBounds);
  }
  /**
   * Show/hide composition bounds
   */
  setCompositionBoundsVisible(e) {
    this.compositionBounds && (this.compositionBounds.visible = e);
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast against composition objects
   */
  raycastComposition(e) {
    return e.intersectObjects(this.compositionGroup.children, !0);
  }
  /**
   * Find layer object by ID - O(1) lookup via Map
   */
  findLayerById(e) {
    return this.layerLookupMap.get(e) ?? null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose object and its resources
   */
  disposeObject(e) {
    var n;
    for (e instanceof Ze && ((n = e.geometry) == null || n.dispose(), Array.isArray(e.material) ? e.material.forEach((i) => {
      this.disposeMaterial(i);
    }) : e.material && this.disposeMaterial(e.material)); e.children.length > 0; ) {
      const i = e.children[0];
      e.remove(i), this.disposeObject(i);
    }
  }
  /**
   * Dispose material and its textures
   */
  disposeMaterial(e) {
    var i, r, o, a, l, c, u, d;
    const n = e;
    (i = n.map) == null || i.dispose(), (r = n.normalMap) == null || r.dispose(), (o = n.roughnessMap) == null || o.dispose(), (a = n.metalnessMap) == null || a.dispose(), (l = n.aoMap) == null || l.dispose(), (c = n.emissiveMap) == null || c.dispose(), (u = n.alphaMap) == null || u.dispose(), (d = n.envMap) == null || d.dispose(), e.dispose();
  }
  /**
   * Dispose all scene resources
   */
  dispose() {
    for (; this.compositionGroup.children.length > 0; ) {
      const e = this.compositionGroup.children[0];
      this.compositionGroup.remove(e), this.disposeObject(e);
    }
    for (this.layerLookupMap.clear(), this.zPositionCache.clear(), this.clearOverlay(); this.debugGroup.children.length > 0; ) {
      const e = this.debugGroup.children[0];
      this.debugGroup.remove(e), this.disposeObject(e);
    }
    this.scene.clear();
  }
}
const V6 = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class Qo {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const G6 = new Eu(-1, 1, 1, -1, 0, 1);
class H6 extends Vt {
  constructor() {
    super(), this.setAttribute("position", new Pt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Pt([0, 2, 0, 0, 2, 0], 2));
  }
}
const $6 = new H6();
class Kf {
  constructor(e) {
    this._mesh = new Ze($6, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, G6);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class W6 extends Qo {
  constructor(e, n) {
    super(), this.textureID = n !== void 0 ? n : "tDiffuse", e instanceof zn ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = Sl.clone(e.uniforms), this.material = new zn({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new Kf(this.material);
  }
  render(e, n, i) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class Uv extends Qo {
  constructor(e, n) {
    super(), this.scene = e, this.camera = n, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, n, i) {
    const r = e.getContext(), o = e.state;
    o.buffers.color.setMask(!1), o.buffers.depth.setMask(!1), o.buffers.color.setLocked(!0), o.buffers.depth.setLocked(!0);
    let a, l;
    this.inverse ? (a = 0, l = 1) : (a = 1, l = 0), o.buffers.stencil.setTest(!0), o.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), o.buffers.stencil.setFunc(r.ALWAYS, a, 4294967295), o.buffers.stencil.setClear(l), o.buffers.stencil.setLocked(!0), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), o.buffers.color.setLocked(!1), o.buffers.depth.setLocked(!1), o.buffers.color.setMask(!0), o.buffers.depth.setMask(!0), o.buffers.stencil.setLocked(!1), o.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), o.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), o.buffers.stencil.setLocked(!0);
  }
}
class X6 extends Qo {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class j6 {
  constructor(e, n) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), n === void 0) {
      const i = e.getSize(new rt());
      this._width = i.width, this._height = i.height, n = new Ri(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: ur }), n.texture.name = "EffectComposer.rt1";
    } else
      this._width = n.width, this._height = n.height;
    this.renderTarget1 = n, this.renderTarget2 = n.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new W6(V6), this.copyPass.material.blending = rs, this.clock = new SE();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, n) {
    this.passes.splice(n, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const n = this.passes.indexOf(e);
    n !== -1 && this.passes.splice(n, 1);
  }
  isLastEnabledPass(e) {
    for (let n = e + 1; n < this.passes.length; n++)
      if (this.passes[n].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const n = this.renderer.getRenderTarget();
    let i = !1;
    for (let r = 0, o = this.passes.length; r < o; r++) {
      const a = this.passes[r];
      if (a.enabled !== !1) {
        if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r), a.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), a.needsSwap) {
          if (i) {
            const l = this.renderer.getContext(), c = this.renderer.state.buffers.stencil;
            c.setFunc(l.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), c.setFunc(l.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        Uv !== void 0 && (a instanceof Uv ? i = !0 : a instanceof X6 && (i = !1));
      }
    }
    this.renderer.setRenderTarget(n);
  }
  reset(e) {
    if (e === void 0) {
      const n = this.renderer.getSize(new rt());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = n.width, this._height = n.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, n) {
    this._width = e, this._height = n;
    const i = this._width * this._pixelRatio, r = this._height * this._pixelRatio;
    this.renderTarget1.setSize(i, r), this.renderTarget2.setSize(i, r);
    for (let o = 0; o < this.passes.length; o++)
      this.passes[o].setSize(i, r);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class Y6 extends Qo {
  constructor(e, n, i = null, r = null, o = null) {
    super(), this.scene = e, this.camera = n, this.overrideMaterial = i, this.clearColor = r, this.clearAlpha = o, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Mt();
  }
  render(e, n, i) {
    const r = e.autoClear;
    e.autoClear = !1;
    let o, a;
    this.overrideMaterial !== null && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (o = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(o), this.overrideMaterial !== null && (this.scene.overrideMaterial = a), e.autoClear = r;
  }
}
const q6 = {
  name: "OutputShader",
  uniforms: {
    tDiffuse: { value: null },
    toneMappingExposure: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
	
		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#elif defined( AGX_TONE_MAPPING )

				gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );

			#elif defined( NEUTRAL_TONE_MAPPING )

				gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}`
  )
};
class Z6 extends Qo {
  constructor() {
    super();
    const e = q6;
    this.uniforms = Sl.clone(e.uniforms), this.material = new fE({
      name: e.name,
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    }), this.fsQuad = new Kf(this.material), this._outputColorSpace = null, this._toneMapping = null;
  }
  render(e, n, i) {
    this.uniforms.tDiffuse.value = i.texture, this.uniforms.toneMappingExposure.value = e.toneMappingExposure, (this._outputColorSpace !== e.outputColorSpace || this._toneMapping !== e.toneMapping) && (this._outputColorSpace = e.outputColorSpace, this._toneMapping = e.toneMapping, this.material.defines = {}, It.getTransfer(this._outputColorSpace) === qt && (this.material.defines.SRGB_TRANSFER = ""), this._toneMapping === U0 ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === O0 ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === z0 ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === wf ? this.material.defines.ACES_FILMIC_TONE_MAPPING = "" : this._toneMapping === N0 ? this.material.defines.AGX_TONE_MAPPING = "" : this._toneMapping === B0 && (this.material.defines.NEUTRAL_TONE_MAPPING = ""), this.material.needsUpdate = !0), this.renderToScreen === !0 ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const K6 = {
  defines: {
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tColor: { value: null },
    tDepth: { value: null },
    focus: { value: 1 },
    aspect: { value: 1 },
    aperture: { value: 0.025 },
    maxblur: { value: 0.01 },
    nearClip: { value: 1 },
    farClip: { value: 1e3 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`
  )
};
class J6 extends Qo {
  constructor(e, n, i) {
    super(), this.scene = e, this.camera = n;
    const r = i.focus !== void 0 ? i.focus : 1, o = i.aperture !== void 0 ? i.aperture : 0.025, a = i.maxblur !== void 0 ? i.maxblur : 1;
    this.renderTargetDepth = new Ri(1, 1, {
      // will be resized later
      minFilter: On,
      magFilter: On,
      type: ur
    }), this.renderTargetDepth.texture.name = "BokehPass.depth", this.materialDepth = new Of(), this.materialDepth.depthPacking = Pf, this.materialDepth.blending = rs;
    const l = K6, c = Sl.clone(l.uniforms);
    c.tDepth.value = this.renderTargetDepth.texture, c.focus.value = r, c.aspect.value = n.aspect, c.aperture.value = o, c.maxblur.value = a, c.nearClip.value = n.near, c.farClip.value = n.far, this.materialBokeh = new zn({
      defines: Object.assign({}, l.defines),
      uniforms: c,
      vertexShader: l.vertexShader,
      fragmentShader: l.fragmentShader
    }), this.uniforms = c, this.fsQuad = new Kf(this.materialBokeh), this._oldClearColor = new Mt();
  }
  render(e, n, i) {
    this.scene.overrideMaterial = this.materialDepth, e.getClearColor(this._oldClearColor);
    const r = e.getClearAlpha(), o = e.autoClear;
    e.autoClear = !1, e.setClearColor(16777215), e.setClearAlpha(1), e.setRenderTarget(this.renderTargetDepth), e.clear(), e.render(this.scene, this.camera), this.uniforms.tColor.value = i.texture, this.uniforms.nearClip.value = this.camera.near, this.uniforms.farClip.value = this.camera.far, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), e.clear(), this.fsQuad.render(e)), this.scene.overrideMaterial = null, e.setClearColor(this._oldClearColor), e.setClearAlpha(r), e.autoClear = o;
  }
  setSize(e, n) {
    this.materialBokeh.uniforms.aspect.value = e / n, this.renderTargetDepth.setSize(e, n);
  }
  dispose() {
    this.renderTargetDepth.dispose(), this.materialDepth.dispose(), this.materialBokeh.dispose(), this.fsQuad.dispose();
  }
}
class Q6 {
  constructor(e, n, i) {
    fe(this, "renderer");
    fe(this, "composer");
    fe(this, "scene");
    fe(this, "camera");
    // Render targets
    fe(this, "colorTarget");
    fe(this, "depthTarget");
    // Frame capture
    fe(this, "captureCanvas");
    fe(this, "captureCtx");
    // Depth capture material
    fe(this, "depthMaterial");
    // Normal material for normal pass
    fe(this, "normalMaterial");
    // Dimensions
    fe(this, "width");
    fe(this, "height");
    fe(this, "pixelRatio");
    // Render mode
    fe(this, "renderMode", "color");
    // DOF pass
    fe(this, "bokehPass", null);
    fe(this, "dofConfig", {
      enabled: !1,
      focusDistance: 500,
      aperture: 0.025,
      maxBlur: 0.01
    });
    // ============================================================================
    // PRECOMP RENDER-TO-TEXTURE
    // ============================================================================
    /** Cache of render targets for precomps (keyed by compositionId) */
    fe(this, "precompTargets", /* @__PURE__ */ new Map());
    this.scene = n, this.camera = i, this.width = e.width, this.height = e.height, this.pixelRatio = e.pixelRatio ?? Math.min(window.devicePixelRatio, 2), this.renderer = new L2({
      canvas: e.canvas,
      antialias: e.antialias ?? !0,
      alpha: e.alpha ?? !0,
      preserveDrawingBuffer: !0,
      // Required for frame capture
      powerPreference: "high-performance",
      stencil: !1,
      depth: !0
    }), this.renderer.setPixelRatio(this.pixelRatio), this.renderer.setSize(this.width, this.height), this.renderer.outputColorSpace = dn, this.renderer.toneMapping = wf, this.renderer.toneMappingExposure = 1, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = R0;
    const r = Math.floor(this.width * this.pixelRatio), o = Math.floor(this.height * this.pixelRatio);
    this.colorTarget = this.createColorTarget(r, o), this.depthTarget = this.createDepthTarget(r, o), this.composer = new j6(this.renderer, this.colorTarget), this.setupDefaultPasses(), this.captureCanvas = new OffscreenCanvas(r, o), this.captureCtx = this.captureCanvas.getContext("2d"), this.depthMaterial = this.createDepthMaterial(), this.normalMaterial = new mE();
  }
  // ============================================================================
  // RENDER TARGET CREATION
  // ============================================================================
  createColorTarget(e, n) {
    return new Ri(e, n, {
      minFilter: Bt,
      magFilter: Bt,
      format: Un,
      type: ur,
      colorSpace: dn,
      depthBuffer: !0,
      stencilBuffer: !1,
      samples: 4
      // MSAA
    });
  }
  createDepthTarget(e, n) {
    const i = new Ri(e, n, {
      minFilter: On,
      magFilter: On,
      format: Un,
      type: di,
      depthBuffer: !0,
      stencilBuffer: !1
    });
    return i.depthTexture = new Uf(e, n), i.depthTexture.format = Nr, i.depthTexture.type = di, i;
  }
  createDepthMaterial() {
    return new zn({
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        #include <packing>

        varying vec2 vUv;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;

        float readDepth(sampler2D depthSampler, vec2 coord) {
          float fragCoordZ = texture2D(depthSampler, coord).x;
          float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
          return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        }

        void main() {
          float depth = readDepth(tDepth, vUv);
          gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
        }
      `,
      uniforms: {
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1e4 }
      },
      depthWrite: !1,
      depthTest: !1
    });
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  setupDefaultPasses() {
    const e = new Y6(this.scene.scene, this.camera.camera);
    this.composer.addPass(e);
    const n = new Z6();
    this.composer.addPass(n);
  }
  /**
   * Add a post-processing pass
   */
  addPass(e) {
    const n = this.composer.passes.findIndex(
      (i) => i.constructor.name === "OutputPass"
    );
    n > -1 ? this.composer.insertPass(e, n) : this.composer.addPass(e);
  }
  /**
   * Remove a post-processing pass
   */
  removePass(e) {
    this.composer.removePass(e);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field effect
   */
  setDOF(e) {
    this.dofConfig = { ...this.dofConfig, ...e }, this.dofConfig.enabled ? (this.bokehPass || this.createBokehPass(), this.updateBokehPass()) : this.bokehPass && (this.composer.removePass(this.bokehPass), this.bokehPass = null);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return { ...this.dofConfig };
  }
  /**
   * Create the bokeh (DOF) pass
   */
  createBokehPass() {
    Math.floor(this.width * this.pixelRatio), Math.floor(this.height * this.pixelRatio), this.bokehPass = new J6(
      this.scene.scene,
      this.camera.camera,
      {
        focus: this.dofConfig.focusDistance,
        aperture: this.dofConfig.aperture,
        maxblur: this.dofConfig.maxBlur
      }
      // width/height are needed but not in types
    ), this.addPass(this.bokehPass);
  }
  /**
   * Update bokeh pass parameters
   */
  updateBokehPass() {
    if (!this.bokehPass) return;
    const e = this.bokehPass.uniforms;
    e && (e.focus.value = this.dofConfig.focusDistance, e.aperture.value = this.dofConfig.aperture, e.maxblur.value = this.dofConfig.maxBlur);
  }
  /**
   * Set focus distance (convenience method)
   */
  setFocusDistance(e) {
    this.setDOF({ focusDistance: e });
  }
  /**
   * Set aperture size (convenience method)
   */
  setAperture(e) {
    this.setDOF({ aperture: e });
  }
  /**
   * Enable/disable DOF (convenience method)
   */
  setDOFEnabled(e) {
    this.setDOF({ enabled: e });
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.scene.sortByZ(), this.composer.render();
  }
  /**
   * Render directly to a render target
   */
  renderToTarget(e) {
    const n = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(e), this.renderer.render(this.scene.scene, this.camera.camera), this.renderer.setRenderTarget(n);
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(e) {
    this.renderMode = e, e === "depth" || e === "normal" ? this.scene.scene.overrideMaterial = e === "depth" ? this.depthMaterial : this.normalMaterial : this.scene.scene.overrideMaterial = null;
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // FRAME CAPTURE
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio), i = new Uint8Array(e * n * 4);
    this.renderer.readRenderTargetPixels(
      this.colorTarget,
      0,
      0,
      e,
      n,
      i
    );
    const r = new Uint8ClampedArray(i.length), o = e * 4;
    for (let a = 0; a < n; a++) {
      const l = (n - 1 - a) * o, c = a * o;
      r.set(i.subarray(l, l + o), c);
    }
    return new ImageData(r, e, n);
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio);
    this.renderToTarget(this.depthTarget);
    const i = new Float32Array(e * n * 4);
    this.renderer.readRenderTargetPixels(
      this.depthTarget,
      0,
      0,
      e,
      n,
      i
    );
    const r = new Float32Array(e * n);
    for (let a = 0; a < e * n; a++)
      r[a] = i[a * 4];
    const o = new Float32Array(e * n);
    for (let a = 0; a < n; a++) {
      const l = (n - 1 - a) * e, c = a * e;
      o.set(r.subarray(l, l + e), c);
    }
    return o;
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize the renderer and targets
   */
  resize(e, n) {
    this.width = e, this.height = n;
    const i = Math.floor(e * this.pixelRatio), r = Math.floor(n * this.pixelRatio);
    this.renderer.setSize(e, n), this.composer.setSize(i, r), this.colorTarget.dispose(), this.depthTarget.dispose(), this.colorTarget = this.createColorTarget(i, r), this.depthTarget = this.createDepthTarget(i, r), this.composer.renderTarget1.dispose(), this.composer.renderTarget2.dispose(), this.composer.renderTarget1 = this.colorTarget.clone(), this.composer.renderTarget2 = this.colorTarget.clone(), this.captureCanvas.width = i, this.captureCanvas.height = r, this.bokehPass && this.dofConfig.enabled && (this.composer.removePass(this.bokehPass), this.bokehPass = null, this.createBokehPass());
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying WebGL renderer
   */
  getWebGLRenderer() {
    return this.renderer;
  }
  /**
   * Get renderer info (for debugging)
   */
  getInfo() {
    return this.renderer.info;
  }
  /**
   * Get current dimensions
   */
  getDimensions() {
    return {
      width: this.width,
      height: this.height,
      pixelRatio: this.pixelRatio
    };
  }
  /**
   * Create or get a render target for a precomp composition
   */
  getPrecompRenderTarget(e, n, i) {
    const r = `${e}_${n}_${i}`;
    let o = this.precompTargets.get(r);
    return o || (o = new Ri(n, i, {
      minFilter: Bt,
      magFilter: Bt,
      format: Un,
      type: Xi,
      colorSpace: dn,
      depthBuffer: !0,
      stencilBuffer: !1
    }), this.precompTargets.set(r, o)), o;
  }
  /**
   * Render a scene to an offscreen target and return the texture
   * Used for precomp rendering
   */
  renderSceneToTexture(e, n, i) {
    const r = this.renderer.getRenderTarget();
    return this.renderer.setRenderTarget(i), this.renderer.clear(), this.renderer.render(e, n), this.renderer.setRenderTarget(r), i.texture;
  }
  /**
   * Dispose a precomp render target
   */
  disposePrecompTarget(e) {
    for (const [n, i] of this.precompTargets.entries())
      n.startsWith(e + "_") && (i.dispose(), this.precompTargets.delete(n));
  }
  /**
   * Dispose all precomp render targets
   */
  disposeAllPrecompTargets() {
    for (const e of this.precompTargets.values())
      e.dispose();
    this.precompTargets.clear();
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Get the DOM element (canvas) attached to the renderer
   * Used for attaching controls like TransformControls
   */
  getDomElement() {
    return this.renderer.domElement;
  }
  /**
   * Dispose all resources
   */
  dispose() {
    this.bokehPass && (this.composer.removePass(this.bokehPass), this.bokehPass = null), this.disposeAllPrecompTargets(), this.colorTarget.dispose(), this.depthTarget.dispose(), this.depthMaterial.dispose(), this.normalMaterial.dispose(), this.composer.dispose(), this.renderer.dispose();
  }
}
class eN extends Yi {
  constructor(n, i) {
    super(n);
    fe(this, "mesh");
    fe(this, "geometry");
    fe(this, "material");
    fe(this, "texture", null);
    /** Resource manager for texture loading */
    fe(this, "resources");
    /** Image dimensions */
    fe(this, "imageWidth", 100);
    fe(this, "imageHeight", 100);
    /** Source URL or asset ID */
    fe(this, "sourceUrl", null);
    /** Original (unprocessed) texture for effects source */
    fe(this, "originalTexture", null);
    /** Canvas for rendering texture to 2D for effect processing */
    fe(this, "textureCanvas", null);
    fe(this, "textureCanvasCtx", null);
    this.resources = i, this.geometry = new un(1, 1), this.material = new En({
      color: 16777215,
      transparent: !0,
      side: vn,
      depthWrite: !1
    }), this.mesh = new Ze(this.geometry, this.material), this.mesh.name = `image_${this.id}`, this.group.add(this.mesh);
    const r = this.extractImageData(n);
    r.source && this.loadImage(r.source), this.initializeBlendMode();
  }
  /**
   * Extract image data from layer object
   */
  extractImageData(n) {
    const i = n.data;
    return {
      source: (i == null ? void 0 : i.source) ?? (i == null ? void 0 : i.url) ?? (i == null ? void 0 : i.assetId) ?? null,
      width: (i == null ? void 0 : i.width) ?? 100,
      height: (i == null ? void 0 : i.height) ?? 100
    };
  }
  // ============================================================================
  // IMAGE LOADING
  // ============================================================================
  /**
   * Load image from URL
   */
  async loadImage(n) {
    this.sourceUrl = n;
    try {
      const i = await this.resources.loadTexture(n, {
        minFilter: Bt,
        magFilter: Bt,
        generateMipmaps: !1,
        colorSpace: dn
      });
      this.setTexture(i);
    } catch (i) {
      Ti.error(`ImageLayer: Failed to load image: ${n}`, i);
    }
  }
  /**
   * Set texture directly
   */
  setTexture(n) {
    this.texture = n, this.originalTexture = n, this.material.map = n, this.material.needsUpdate = !0, n.image && (this.imageWidth = n.image.width || n.image.videoWidth || 100, this.imageHeight = n.image.height || n.image.videoHeight || 100, this.updateMeshSize(), this.textureCanvas = null, this.textureCanvasCtx = null, this.effectsDirty = !0);
  }
  /**
   * Set texture from ImageData
   */
  setTextureFromImageData(n) {
    const i = this.resources.createTextureFromImageData(
      n,
      `layer_${this.id}_imagedata`,
      {
        minFilter: Bt,
        magFilter: Bt,
        generateMipmaps: !1,
        colorSpace: dn
      }
    );
    this.setTexture(i);
  }
  /**
   * Set texture from canvas
   */
  setTextureFromCanvas(n) {
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_canvas`,
      {
        minFilter: Bt,
        magFilter: Bt,
        generateMipmaps: !1,
        colorSpace: dn
      }
    );
    this.setTexture(i);
  }
  /**
   * Update mesh size to match image dimensions
   */
  updateMeshSize() {
    this.geometry.dispose(), this.geometry = new un(this.imageWidth, this.imageHeight), this.mesh.geometry = this.geometry;
  }
  // ============================================================================
  // PROPERTIES
  // ============================================================================
  /**
   * Get image dimensions
   */
  getDimensions() {
    return {
      width: this.imageWidth,
      height: this.imageHeight
    };
  }
  /**
   * Set dimensions (stretches the image)
   */
  setDimensions(n, i) {
    this.imageWidth = n, this.imageHeight = i, this.updateMeshSize();
  }
  /**
   * Get source URL
   */
  getSource() {
    return this.sourceUrl;
  }
  /**
   * Set tint color
   */
  setTint(n) {
    this.material.color.set(n), this.material.needsUpdate = !0;
  }
  /**
   * Clear tint (reset to white)
   */
  clearTint() {
    this.material.color.set(16777215), this.material.needsUpdate = !0;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the original texture to a 2D canvas
   */
  getSourceCanvas() {
    var i;
    if (!((i = this.originalTexture) != null && i.image))
      return null;
    const n = this.originalTexture.image;
    return (!this.textureCanvas || this.textureCanvas.width !== this.imageWidth || this.textureCanvas.height !== this.imageHeight) && (this.textureCanvas = document.createElement("canvas"), this.textureCanvas.width = this.imageWidth, this.textureCanvas.height = this.imageHeight, this.textureCanvasCtx = this.textureCanvas.getContext("2d")), this.textureCanvasCtx ? (this.textureCanvasCtx.clearRect(0, 0, this.imageWidth, this.imageHeight), this.textureCanvasCtx.drawImage(n, 0, 0, this.imageWidth, this.imageHeight), this.textureCanvas) : null;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(n) {
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_effects`,
      {
        minFilter: Bt,
        magFilter: Bt,
        generateMipmaps: !1,
        colorSpace: dn
      }
    );
    this.texture = i, this.material.map = i, this.material.needsUpdate = !0;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    this.evaluateEffects(n);
  }
  onUpdate(n) {
    const i = n.data;
    if (i != null && i.source || i != null && i.url || i != null && i.assetId) {
      const r = i.source ?? i.url ?? i.assetId;
      r !== this.sourceUrl && this.loadImage(r);
    }
    ((i == null ? void 0 : i.width) !== void 0 || (i == null ? void 0 : i.height) !== void 0) && this.setDimensions(
      i.width ?? this.imageWidth,
      i.height ?? this.imageHeight
    );
  }
  onDispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class tN extends Yi {
  constructor(n) {
    super(n);
    fe(this, "mesh");
    fe(this, "geometry");
    fe(this, "material");
    /** Solid color */
    fe(this, "color");
    /** Solid dimensions */
    fe(this, "width");
    fe(this, "height");
    /** Animated color property */
    fe(this, "animatedColor");
    const i = this.extractSolidData(n);
    this.color = i.color, this.width = i.width, this.height = i.height, this.animatedColor = i.animatedColor, this.geometry = new un(this.width, this.height), this.material = new En({
      color: this.color,
      transparent: !0,
      side: vn,
      depthWrite: !1
    }), this.mesh = new Ze(this.geometry, this.material), this.mesh.name = `solid_${this.id}`, this.group.add(this.mesh), this.initializeBlendMode();
  }
  /**
   * Extract solid layer data from layer object
   */
  extractSolidData(n) {
    const i = n.data;
    return {
      color: (i == null ? void 0 : i.color) ?? "#808080",
      width: (i == null ? void 0 : i.width) ?? 1920,
      height: (i == null ? void 0 : i.height) ?? 1080,
      animatedColor: i == null ? void 0 : i.animatedColor
    };
  }
  /**
   * Set solid color
   */
  setColor(n) {
    this.color = n, this.material.color.set(n), this.material.needsUpdate = !0;
  }
  /**
   * Get current color
   */
  getColor() {
    return this.color;
  }
  /**
   * Set solid dimensions
   */
  setDimensions(n, i) {
    n === this.width && i === this.height || (this.width = n, this.height = i, this.geometry.dispose(), this.geometry = new un(n, i), this.mesh.geometry = this.geometry);
  }
  /**
   * Get dimensions
   */
  getDimensions() {
    return { width: this.width, height: this.height };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    var i;
    if ((i = this.animatedColor) != null && i.animated) {
      const r = this.evaluator.evaluate(this.animatedColor, n);
      this.material.color.set(r), this.material.needsUpdate = !0;
    }
  }
  onUpdate(n) {
    const i = n.data;
    (i == null ? void 0 : i.color) !== void 0 && this.setColor(i.color), ((i == null ? void 0 : i.width) !== void 0 || (i == null ? void 0 : i.height) !== void 0) && this.setDimensions(
      (i == null ? void 0 : i.width) ?? this.width,
      (i == null ? void 0 : i.height) ?? this.height
    ), (i == null ? void 0 : i.animatedColor) !== void 0 && (this.animatedColor = i.animatedColor), i === void 0 && n.labelColor !== void 0 && this.setColor(n.labelColor);
  }
  onDispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Ov extends Yi {
  constructor(n, i = !0) {
    super(n);
    /** Visual indicator (crosshair) for editor visibility */
    fe(this, "indicator", null);
    /** Whether to show the null indicator */
    fe(this, "showIndicator");
    /** Indicator size */
    fe(this, "indicatorSize");
    this.showIndicator = i, this.indicatorSize = 50, this.showIndicator && this.createIndicator();
  }
  /**
   * Create visual indicator (crosshair) for the null object
   */
  createIndicator() {
    this.indicator = new Ai(), this.indicator.name = `null_indicator_${this.id}`;
    const n = this.indicatorSize, i = 16737792, r = new ji({
      color: i,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), o = [
      new de(-n / 2, 0, 0),
      new de(n / 2, 0, 0)
    ], a = new Vt().setFromPoints(o), l = new ln(a, r);
    this.indicator.add(l);
    const c = [
      new de(0, -n / 2, 0),
      new de(0, n / 2, 0)
    ], u = new Vt().setFromPoints(c), d = new ln(u, r);
    if (this.indicator.add(d), this.threeD) {
      const v = [
        new de(0, 0, -n / 2),
        new de(0, 0, n / 2)
      ], x = new Vt().setFromPoints(v), g = new ln(x, r);
      this.indicator.add(g);
    }
    const h = new Au(3, 16), m = new En({
      color: i,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1,
      side: vn
    }), p = new Ze(h, m);
    this.indicator.add(p), this.group.add(this.indicator), this.indicator.renderOrder = 999;
  }
  /**
   * Set indicator visibility
   */
  setIndicatorVisible(n) {
    this.indicator && (this.indicator.visible = n);
  }
  /**
   * Set indicator size
   */
  setIndicatorSize(n) {
    n !== this.indicatorSize && (this.indicatorSize = n, this.indicator && (this.group.remove(this.indicator), this.disposeIndicator(), this.createIndicator()));
  }
  /**
   * Dispose indicator resources
   */
  disposeIndicator() {
    this.indicator && (this.indicator.traverse((n) => {
      n instanceof ln && (n.geometry.dispose(), n.material.dispose()), n instanceof Ze && (n.geometry.dispose(), n.material.dispose());
    }), this.indicator.clear(), this.indicator = null);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
  }
  onUpdate(n) {
    n.threeD !== void 0 && n.threeD !== this.threeD && (this.threeD = n.threeD, this.indicator && this.showIndicator && (this.group.remove(this.indicator), this.disposeIndicator(), this.createIndicator()));
  }
  onDispose() {
    this.disposeIndicator();
  }
}
function nN() {
  var s = /* @__PURE__ */ Object.create(null);
  function e(r, o) {
    var a = r.id, l = r.name, c = r.dependencies;
    c === void 0 && (c = []);
    var u = r.init;
    u === void 0 && (u = function() {
    });
    var d = r.getTransferables;
    if (d === void 0 && (d = null), !s[a])
      try {
        c = c.map(function(m) {
          return m && m.isWorkerModule && (e(m, function(p) {
            if (p instanceof Error)
              throw p;
          }), m = s[m.id].value), m;
        }), u = i("<" + l + ">.init", u), d && (d = i("<" + l + ">.getTransferables", d));
        var h = null;
        typeof u == "function" ? h = u.apply(void 0, c) : console.error("worker module init function failed to rehydrate"), s[a] = {
          id: a,
          value: h,
          getTransferables: d
        }, o(h);
      } catch (m) {
        m && m.noLog || console.error(m), o(m);
      }
  }
  function n(r, o) {
    var a, l = r.id, c = r.args;
    (!s[l] || typeof s[l].value != "function") && o(new Error("Worker module " + l + ": not found or its 'init' did not return a function"));
    try {
      var u = (a = s[l]).value.apply(a, c);
      u && typeof u.then == "function" ? u.then(d, function(h) {
        return o(h instanceof Error ? h : new Error("" + h));
      }) : d(u);
    } catch (h) {
      o(h);
    }
    function d(h) {
      try {
        var m = s[l].getTransferables && s[l].getTransferables(h);
        (!m || !Array.isArray(m) || !m.length) && (m = void 0), o(h, m);
      } catch (p) {
        console.error(p), o(p);
      }
    }
  }
  function i(r, o) {
    var a = void 0;
    self.troikaDefine = function(c) {
      return a = c;
    };
    var l = URL.createObjectURL(
      new Blob(
        ["/** " + r.replace(/\*/g, "") + ` **/

troikaDefine(
` + o + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(l);
    } catch (c) {
      console.error(c);
    }
    return URL.revokeObjectURL(l), delete self.troikaDefine, a;
  }
  self.addEventListener("message", function(r) {
    var o = r.data, a = o.messageId, l = o.action, c = o.data;
    try {
      l === "registerModule" && e(c, function(u) {
        u instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: u.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: { isCallable: typeof u == "function" }
        });
      }), l === "callModule" && n(c, function(u, d) {
        u instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: u.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: u
        }, d || void 0);
      });
    } catch (u) {
      postMessage({
        messageId: a,
        success: !1,
        error: u.stack
      });
    }
  });
}
function iN(s) {
  var e = function() {
    for (var n = [], i = arguments.length; i--; ) n[i] = arguments[i];
    return e._getInitResult().then(function(r) {
      if (typeof r == "function")
        return r.apply(void 0, n);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var n = s.dependencies, i = s.init;
    n = Array.isArray(n) ? n.map(function(o) {
      return o && (o = o.onMainThread || o, o._getInitResult && (o = o._getInitResult())), o;
    }) : [];
    var r = Promise.all(n).then(function(o) {
      return i.apply(null, o);
    });
    return e._getInitResult = function() {
      return r;
    }, r;
  }, e;
}
var Iy = function() {
  var s = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), s = !0;
    } catch (n) {
      console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + n.message + "]"
      );
    }
  return Iy = function() {
    return s;
  }, s;
}, sN = 0, rN = 0, Hd = !1, qa = /* @__PURE__ */ Object.create(null), Za = /* @__PURE__ */ Object.create(null), Jh = /* @__PURE__ */ Object.create(null);
function ea(s) {
  if ((!s || typeof s.init != "function") && !Hd)
    throw new Error("requires `options.init` function");
  var e = s.dependencies, n = s.init, i = s.getTransferables, r = s.workerId, o = iN(s);
  r == null && (r = "#default");
  var a = "workerModule" + ++sN, l = s.name || a, c = null;
  e = e && e.map(function(d) {
    return typeof d == "function" && !d.workerModuleData && (Hd = !0, d = ea({
      workerId: r,
      name: "<" + l + "> function dependency: " + d.name,
      init: `function(){return (
` + Bc(d) + `
)}`
    }), Hd = !1), d && d.workerModuleData && (d = d.workerModuleData), d;
  });
  function u() {
    for (var d = [], h = arguments.length; h--; ) d[h] = arguments[h];
    if (!Iy())
      return o.apply(void 0, d);
    if (!c) {
      c = zv(r, "registerModule", u.workerModuleData);
      var m = function() {
        c = null, Za[r].delete(m);
      };
      (Za[r] || (Za[r] = /* @__PURE__ */ new Set())).add(m);
    }
    return c.then(function(p) {
      var v = p.isCallable;
      if (v)
        return zv(r, "callModule", { id: a, args: d });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return u.workerModuleData = {
    isWorkerModule: !0,
    id: a,
    name: l,
    dependencies: e,
    init: Bc(n),
    getTransferables: i && Bc(i)
  }, u.onMainThread = o, u;
}
function oN(s) {
  Za[s] && Za[s].forEach(function(e) {
    e();
  }), qa[s] && (qa[s].terminate(), delete qa[s]);
}
function Bc(s) {
  var e = s.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function aN(s) {
  var e = qa[s];
  if (!e) {
    var n = Bc(nN);
    e = qa[s] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + s.replace(/\*/g, "") + ` **/

;(` + n + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(i) {
      var r = i.data, o = r.messageId, a = Jh[o];
      if (!a)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete Jh[o], a(r);
    };
  }
  return e;
}
function zv(s, e, n) {
  return new Promise(function(i, r) {
    var o = ++rN;
    Jh[o] = function(a) {
      a.success ? i(a.result) : r(new Error("Error in worker " + e + " call: " + a.error));
    }, aN(s).postMessage({
      messageId: o,
      action: e,
      data: n
    });
  });
}
function Ly() {
  var s = function(e) {
    function n(le, re, j, $, q, oe, ie, ce) {
      var V = 1 - ie;
      ce.x = V * V * le + 2 * V * ie * j + ie * ie * q, ce.y = V * V * re + 2 * V * ie * $ + ie * ie * oe;
    }
    function i(le, re, j, $, q, oe, ie, ce, V, Y) {
      var H = 1 - V;
      Y.x = H * H * H * le + 3 * H * H * V * j + 3 * H * V * V * q + V * V * V * ie, Y.y = H * H * H * re + 3 * H * H * V * $ + 3 * H * V * V * oe + V * V * V * ce;
    }
    function r(le, re) {
      for (var j = /([MLQCZ])([^MLQCZ]*)/g, $, q, oe, ie, ce; $ = j.exec(le); ) {
        var V = $[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(Y) {
          return parseFloat(Y);
        });
        switch ($[1]) {
          case "M":
            ie = q = V[0], ce = oe = V[1];
            break;
          case "L":
            (V[0] !== ie || V[1] !== ce) && re("L", ie, ce, ie = V[0], ce = V[1]);
            break;
          case "Q": {
            re("Q", ie, ce, ie = V[2], ce = V[3], V[0], V[1]);
            break;
          }
          case "C": {
            re("C", ie, ce, ie = V[4], ce = V[5], V[0], V[1], V[2], V[3]);
            break;
          }
          case "Z":
            (ie !== q || ce !== oe) && re("L", ie, ce, q, oe);
            break;
        }
      }
    }
    function o(le, re, j) {
      j === void 0 && (j = 16);
      var $ = { x: 0, y: 0 };
      r(le, function(q, oe, ie, ce, V, Y, H, I, F) {
        switch (q) {
          case "L":
            re(oe, ie, ce, V);
            break;
          case "Q": {
            for (var L = oe, ee = ie, Z = 1; Z < j; Z++)
              n(
                oe,
                ie,
                Y,
                H,
                ce,
                V,
                Z / (j - 1),
                $
              ), re(L, ee, $.x, $.y), L = $.x, ee = $.y;
            break;
          }
          case "C": {
            for (var k = oe, ne = ie, J = 1; J < j; J++)
              i(
                oe,
                ie,
                Y,
                H,
                I,
                F,
                ce,
                V,
                J / (j - 1),
                $
              ), re(k, ne, $.x, $.y), k = $.x, ne = $.y;
            break;
          }
        }
      });
    }
    var a = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", l = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", c = /* @__PURE__ */ new WeakMap(), u = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function d(le, re) {
      var j = le.getContext ? le.getContext("webgl", u) : le, $ = c.get(j);
      if (!$) {
        let H = function(k) {
          var ne = oe[k];
          if (!ne && (ne = oe[k] = j.getExtension(k), !ne))
            throw new Error(k + " not supported");
          return ne;
        }, I = function(k, ne) {
          var J = j.createShader(ne);
          return j.shaderSource(J, k), j.compileShader(J), J;
        }, F = function(k, ne, J, B) {
          if (!ie[k]) {
            var X = {}, se = {}, z = j.createProgram();
            j.attachShader(z, I(ne, j.VERTEX_SHADER)), j.attachShader(z, I(J, j.FRAGMENT_SHADER)), j.linkProgram(z), ie[k] = {
              program: z,
              transaction: function(K) {
                j.useProgram(z), K({
                  setUniform: function(me, ge) {
                    for (var Me = [], Te = arguments.length - 2; Te-- > 0; ) Me[Te] = arguments[Te + 2];
                    var Ae = se[ge] || (se[ge] = j.getUniformLocation(z, ge));
                    j["uniform" + me].apply(j, [Ae].concat(Me));
                  },
                  setAttribute: function(me, ge, Me, Te, Ae) {
                    var Xe = X[me];
                    Xe || (Xe = X[me] = {
                      buf: j.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: j.getAttribLocation(z, me),
                      data: null
                    }), j.bindBuffer(j.ARRAY_BUFFER, Xe.buf), j.vertexAttribPointer(Xe.loc, ge, j.FLOAT, !1, 0, 0), j.enableVertexAttribArray(Xe.loc), q ? j.vertexAttribDivisor(Xe.loc, Te) : H("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Xe.loc, Te), Ae !== Xe.data && (j.bufferData(j.ARRAY_BUFFER, Ae, Me), Xe.data = Ae);
                  }
                });
              }
            };
          }
          ie[k].transaction(B);
        }, L = function(k, ne) {
          V++;
          try {
            j.activeTexture(j.TEXTURE0 + V);
            var J = ce[k];
            J || (J = ce[k] = j.createTexture(), j.bindTexture(j.TEXTURE_2D, J), j.texParameteri(j.TEXTURE_2D, j.TEXTURE_MIN_FILTER, j.NEAREST), j.texParameteri(j.TEXTURE_2D, j.TEXTURE_MAG_FILTER, j.NEAREST)), j.bindTexture(j.TEXTURE_2D, J), ne(J, V);
          } finally {
            V--;
          }
        }, ee = function(k, ne, J) {
          var B = j.createFramebuffer();
          Y.push(B), j.bindFramebuffer(j.FRAMEBUFFER, B), j.activeTexture(j.TEXTURE0 + ne), j.bindTexture(j.TEXTURE_2D, k), j.framebufferTexture2D(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, j.TEXTURE_2D, k, 0);
          try {
            J(B);
          } finally {
            j.deleteFramebuffer(B), j.bindFramebuffer(j.FRAMEBUFFER, Y[--Y.length - 1] || null);
          }
        }, Z = function() {
          oe = {}, ie = {}, ce = {}, V = -1, Y.length = 0;
        };
        var q = typeof WebGL2RenderingContext < "u" && j instanceof WebGL2RenderingContext, oe = {}, ie = {}, ce = {}, V = -1, Y = [];
        j.canvas.addEventListener("webglcontextlost", function(k) {
          Z(), k.preventDefault();
        }, !1), c.set(j, $ = {
          gl: j,
          isWebGL2: q,
          getExtension: H,
          withProgram: F,
          withTexture: L,
          withTextureFramebuffer: ee,
          handleContextLoss: Z
        });
      }
      re($);
    }
    function h(le, re, j, $, q, oe, ie, ce) {
      ie === void 0 && (ie = 15), ce === void 0 && (ce = null), d(le, function(V) {
        var Y = V.gl, H = V.withProgram, I = V.withTexture;
        I("copy", function(F, L) {
          Y.texImage2D(Y.TEXTURE_2D, 0, Y.RGBA, q, oe, 0, Y.RGBA, Y.UNSIGNED_BYTE, re), H("copy", a, l, function(ee) {
            var Z = ee.setUniform, k = ee.setAttribute;
            k("aUV", 2, Y.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), Z("1i", "image", L), Y.bindFramebuffer(Y.FRAMEBUFFER, ce || null), Y.disable(Y.BLEND), Y.colorMask(ie & 8, ie & 4, ie & 2, ie & 1), Y.viewport(j, $, q, oe), Y.scissor(j, $, q, oe), Y.drawArrays(Y.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function m(le, re, j) {
      var $ = le.width, q = le.height;
      d(le, function(oe) {
        var ie = oe.gl, ce = new Uint8Array($ * q * 4);
        ie.readPixels(0, 0, $, q, ie.RGBA, ie.UNSIGNED_BYTE, ce), le.width = re, le.height = j, h(ie, ce, 0, 0, $, q);
      });
    }
    var p = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: d,
      renderImageData: h,
      resizeWebGLCanvasWithoutClearing: m
    });
    function v(le, re, j, $, q, oe) {
      oe === void 0 && (oe = 1);
      var ie = new Uint8Array(le * re), ce = $[2] - $[0], V = $[3] - $[1], Y = [];
      o(j, function(k, ne, J, B) {
        Y.push({
          x1: k,
          y1: ne,
          x2: J,
          y2: B,
          minX: Math.min(k, J),
          minY: Math.min(ne, B),
          maxX: Math.max(k, J),
          maxY: Math.max(ne, B)
        });
      }), Y.sort(function(k, ne) {
        return k.maxX - ne.maxX;
      });
      for (var H = 0; H < le; H++)
        for (var I = 0; I < re; I++) {
          var F = ee(
            $[0] + ce * (H + 0.5) / le,
            $[1] + V * (I + 0.5) / re
          ), L = Math.pow(1 - Math.abs(F) / q, oe) / 2;
          F < 0 && (L = 1 - L), L = Math.max(0, Math.min(255, Math.round(L * 255))), ie[I * le + H] = L;
        }
      return ie;
      function ee(k, ne) {
        for (var J = 1 / 0, B = 1 / 0, X = Y.length; X--; ) {
          var se = Y[X];
          if (se.maxX + B <= k)
            break;
          if (k + B > se.minX && ne - B < se.maxY && ne + B > se.minY) {
            var z = _(k, ne, se.x1, se.y1, se.x2, se.y2);
            z < J && (J = z, B = Math.sqrt(J));
          }
        }
        return Z(k, ne) && (B = -B), B;
      }
      function Z(k, ne) {
        for (var J = 0, B = Y.length; B--; ) {
          var X = Y[B];
          if (X.maxX <= k)
            break;
          var se = X.y1 > ne != X.y2 > ne && k < (X.x2 - X.x1) * (ne - X.y1) / (X.y2 - X.y1) + X.x1;
          se && (J += X.y1 < X.y2 ? 1 : -1);
        }
        return J !== 0;
      }
    }
    function x(le, re, j, $, q, oe, ie, ce, V, Y) {
      oe === void 0 && (oe = 1), ce === void 0 && (ce = 0), V === void 0 && (V = 0), Y === void 0 && (Y = 0), g(le, re, j, $, q, oe, ie, null, ce, V, Y);
    }
    function g(le, re, j, $, q, oe, ie, ce, V, Y, H) {
      oe === void 0 && (oe = 1), V === void 0 && (V = 0), Y === void 0 && (Y = 0), H === void 0 && (H = 0);
      for (var I = v(le, re, j, $, q, oe), F = new Uint8Array(I.length * 4), L = 0; L < I.length; L++)
        F[L * 4 + H] = I[L];
      h(ie, F, V, Y, le, re, 1 << 3 - H, ce);
    }
    function _(le, re, j, $, q, oe) {
      var ie = q - j, ce = oe - $, V = ie * ie + ce * ce, Y = V ? Math.max(0, Math.min(1, ((le - j) * ie + (re - $) * ce) / V)) : 0, H = le - (j + Y * ie), I = re - ($ + Y * ce);
      return H * H + I * I;
    }
    var M = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: v,
      generateIntoCanvas: x,
      generateIntoFramebuffer: g
    }), S = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", b = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", C = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", E = new Float32Array([0, 0, 2, 0, 0, 2]), P = null, T = !1, y = {}, w = /* @__PURE__ */ new WeakMap();
    function D(le) {
      if (!T && !A(le))
        throw new Error("WebGL generation not supported");
    }
    function U(le, re, j, $, q, oe, ie) {
      if (oe === void 0 && (oe = 1), ie === void 0 && (ie = null), !ie && (ie = P, !ie)) {
        var ce = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!ce)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        ie = P = ce.getContext("webgl", { depth: !1 });
      }
      D(ie);
      var V = new Uint8Array(le * re * 4);
      d(ie, function(F) {
        var L = F.gl, ee = F.withTexture, Z = F.withTextureFramebuffer;
        ee("readable", function(k, ne) {
          L.texImage2D(L.TEXTURE_2D, 0, L.RGBA, le, re, 0, L.RGBA, L.UNSIGNED_BYTE, null), Z(k, ne, function(J) {
            O(
              le,
              re,
              j,
              $,
              q,
              oe,
              L,
              J,
              0,
              0,
              0
              // red channel
            ), L.readPixels(0, 0, le, re, L.RGBA, L.UNSIGNED_BYTE, V);
          });
        });
      });
      for (var Y = new Uint8Array(le * re), H = 0, I = 0; H < V.length; H += 4)
        Y[I++] = V[H];
      return Y;
    }
    function R(le, re, j, $, q, oe, ie, ce, V, Y) {
      oe === void 0 && (oe = 1), ce === void 0 && (ce = 0), V === void 0 && (V = 0), Y === void 0 && (Y = 0), O(le, re, j, $, q, oe, ie, null, ce, V, Y);
    }
    function O(le, re, j, $, q, oe, ie, ce, V, Y, H) {
      oe === void 0 && (oe = 1), V === void 0 && (V = 0), Y === void 0 && (Y = 0), H === void 0 && (H = 0), D(ie);
      var I = [];
      o(j, function(F, L, ee, Z) {
        I.push(F, L, ee, Z);
      }), I = new Float32Array(I), d(ie, function(F) {
        var L = F.gl, ee = F.isWebGL2, Z = F.getExtension, k = F.withProgram, ne = F.withTexture, J = F.withTextureFramebuffer, B = F.handleContextLoss;
        if (ne("rawDistances", function(X, se) {
          (le !== X._lastWidth || re !== X._lastHeight) && L.texImage2D(
            L.TEXTURE_2D,
            0,
            L.RGBA,
            X._lastWidth = le,
            X._lastHeight = re,
            0,
            L.RGBA,
            L.UNSIGNED_BYTE,
            null
          ), k("main", S, b, function(z) {
            var N = z.setAttribute, K = z.setUniform, he = !ee && Z("ANGLE_instanced_arrays"), me = !ee && Z("EXT_blend_minmax");
            N("aUV", 2, L.STATIC_DRAW, 0, E), N("aLineSegment", 4, L.DYNAMIC_DRAW, 1, I), K.apply(void 0, ["4f", "uGlyphBounds"].concat($)), K("1f", "uMaxDistance", q), K("1f", "uExponent", oe), J(X, se, function(ge) {
              L.enable(L.BLEND), L.colorMask(!0, !0, !0, !0), L.viewport(0, 0, le, re), L.scissor(0, 0, le, re), L.blendFunc(L.ONE, L.ONE), L.blendEquationSeparate(L.FUNC_ADD, ee ? L.MAX : me.MAX_EXT), L.clear(L.COLOR_BUFFER_BIT), ee ? L.drawArraysInstanced(L.TRIANGLES, 0, 3, I.length / 4) : he.drawArraysInstancedANGLE(L.TRIANGLES, 0, 3, I.length / 4);
            });
          }), k("post", a, C, function(z) {
            z.setAttribute("aUV", 2, L.STATIC_DRAW, 0, E), z.setUniform("1i", "tex", se), L.bindFramebuffer(L.FRAMEBUFFER, ce), L.disable(L.BLEND), L.colorMask(H === 0, H === 1, H === 2, H === 3), L.viewport(V, Y, le, re), L.scissor(V, Y, le, re), L.drawArrays(L.TRIANGLES, 0, 3);
          });
        }), L.isContextLost())
          throw B(), new Error("webgl context lost");
      });
    }
    function A(le) {
      var re = !le || le === P ? y : le.canvas || le, j = w.get(re);
      if (j === void 0) {
        T = !0;
        var $ = null;
        try {
          var q = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], oe = U(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            le
          );
          j = oe && q.length === oe.length && oe.every(function(ie, ce) {
            return ie === q[ce];
          }), j || ($ = "bad trial run results", console.info(q, oe));
        } catch (ie) {
          j = !1, $ = ie.message;
        }
        $ && console.warn("WebGL SDF generation not supported:", $), T = !1, w.set(re, j);
      }
      return j;
    }
    var G = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: U,
      generateIntoCanvas: R,
      generateIntoFramebuffer: O,
      isSupported: A
    });
    function ue(le, re, j, $, q, oe) {
      q === void 0 && (q = Math.max($[2] - $[0], $[3] - $[1]) / 2), oe === void 0 && (oe = 1);
      try {
        return U.apply(G, arguments);
      } catch (ie) {
        return console.info("WebGL SDF generation failed, falling back to JS", ie), v.apply(M, arguments);
      }
    }
    function Q(le, re, j, $, q, oe, ie, ce, V, Y) {
      q === void 0 && (q = Math.max($[2] - $[0], $[3] - $[1]) / 2), oe === void 0 && (oe = 1), ce === void 0 && (ce = 0), V === void 0 && (V = 0), Y === void 0 && (Y = 0);
      try {
        return R.apply(G, arguments);
      } catch (H) {
        return console.info("WebGL SDF generation failed, falling back to JS", H), x.apply(M, arguments);
      }
    }
    return e.forEachPathCommand = r, e.generate = ue, e.generateIntoCanvas = Q, e.javascript = M, e.pathToLineSegments = o, e.webgl = G, e.webglUtils = p, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
function lN() {
  var s = function(e) {
    var n = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, i = {}, r = {};
    i.L = 1, r[1] = "L", Object.keys(n).forEach(function(B, X) {
      i[B] = 1 << X + 1, r[i[B]] = B;
    }), Object.freeze(i);
    var o = i.LRI | i.RLI | i.FSI, a = i.L | i.R | i.AL, l = i.B | i.S | i.WS | i.ON | i.FSI | i.LRI | i.RLI | i.PDI, c = i.BN | i.RLE | i.LRE | i.RLO | i.LRO | i.PDF, u = i.S | i.WS | i.B | o | i.PDI | c, d = null;
    function h() {
      if (!d) {
        d = /* @__PURE__ */ new Map();
        var B = function(se) {
          if (n.hasOwnProperty(se)) {
            var z = 0;
            n[se].split(",").forEach(function(N) {
              var K = N.split("+"), he = K[0], me = K[1];
              he = parseInt(he, 36), me = me ? parseInt(me, 36) : 0, d.set(z += he, i[se]);
              for (var ge = 0; ge < me; ge++)
                d.set(++z, i[se]);
            });
          }
        };
        for (var X in n) B(X);
      }
    }
    function m(B) {
      return h(), d.get(B.codePointAt(0)) || i.L;
    }
    function p(B) {
      return r[m(B)];
    }
    var v = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function x(B, X) {
      var se = 36, z = 0, N = /* @__PURE__ */ new Map(), K = X && /* @__PURE__ */ new Map(), he;
      return B.split(",").forEach(function me(ge) {
        if (ge.indexOf("+") !== -1)
          for (var Me = +ge; Me--; )
            me(he);
        else {
          he = ge;
          var Te = ge.split(">"), Ae = Te[0], Xe = Te[1];
          Ae = String.fromCodePoint(z += parseInt(Ae, se)), Xe = String.fromCodePoint(z += parseInt(Xe, se)), N.set(Ae, Xe), X && K.set(Xe, Ae);
        }
      }), { map: N, reverseMap: K };
    }
    var g, _, M;
    function S() {
      if (!g) {
        var B = x(v.pairs, !0), X = B.map, se = B.reverseMap;
        g = X, _ = se, M = x(v.canonical, !1).map;
      }
    }
    function b(B) {
      return S(), g.get(B) || null;
    }
    function C(B) {
      return S(), _.get(B) || null;
    }
    function E(B) {
      return S(), M.get(B) || null;
    }
    var P = i.L, T = i.R, y = i.EN, w = i.ES, D = i.ET, U = i.AN, R = i.CS, O = i.B, A = i.S, G = i.ON, ue = i.BN, Q = i.NSM, le = i.AL, re = i.LRO, j = i.RLO, $ = i.LRE, q = i.RLE, oe = i.PDF, ie = i.LRI, ce = i.RLI, V = i.FSI, Y = i.PDI;
    function H(B, X) {
      for (var se = 125, z = new Uint32Array(B.length), N = 0; N < B.length; N++)
        z[N] = m(B[N]);
      var K = /* @__PURE__ */ new Map();
      function he(li, Li) {
        var ci = z[li];
        z[li] = Li, K.set(ci, K.get(ci) - 1), ci & l && K.set(l, K.get(l) - 1), K.set(Li, (K.get(Li) || 0) + 1), Li & l && K.set(l, (K.get(l) || 0) + 1);
      }
      for (var me = new Uint8Array(B.length), ge = /* @__PURE__ */ new Map(), Me = [], Te = null, Ae = 0; Ae < B.length; Ae++)
        Te || Me.push(Te = {
          start: Ae,
          end: B.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: X === "rtl" ? 1 : X === "ltr" ? 0 : fp(Ae, !1)
        }), z[Ae] & O && (Te.end = Ae, Te = null);
      for (var Xe = q | $ | j | re | o | Y | oe | O, Oe = function(li) {
        return li + (li & 1 ? 1 : 2);
      }, He = function(li) {
        return li + (li & 1 ? 2 : 1);
      }, Ye = 0; Ye < Me.length; Ye++) {
        Te = Me[Ye];
        var $e = [{
          _level: Te.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], Le = void 0, nt = 0, Je = 0, bt = 0;
        K.clear();
        for (var Se = Te.start; Se <= Te.end; Se++) {
          var Ne = z[Se];
          if (Le = $e[$e.length - 1], K.set(Ne, (K.get(Ne) || 0) + 1), Ne & l && K.set(l, (K.get(l) || 0) + 1), Ne & Xe)
            if (Ne & (q | $)) {
              me[Se] = Le._level;
              var Re = (Ne === q ? He : Oe)(Le._level);
              Re <= se && !nt && !Je ? $e.push({
                _level: Re,
                _override: 0,
                _isolate: 0
              }) : nt || Je++;
            } else if (Ne & (j | re)) {
              me[Se] = Le._level;
              var Be = (Ne === j ? He : Oe)(Le._level);
              Be <= se && !nt && !Je ? $e.push({
                _level: Be,
                _override: Ne & j ? T : P,
                _isolate: 0
              }) : nt || Je++;
            } else if (Ne & o) {
              Ne & V && (Ne = fp(Se + 1, !0) === 1 ? ce : ie), me[Se] = Le._level, Le._override && he(Se, Le._override);
              var je = (Ne === ce ? He : Oe)(Le._level);
              je <= se && nt === 0 && Je === 0 ? (bt++, $e.push({
                _level: je,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: Se
              })) : nt++;
            } else if (Ne & Y) {
              if (nt > 0)
                nt--;
              else if (bt > 0) {
                for (Je = 0; !$e[$e.length - 1]._isolate; )
                  $e.pop();
                var Ge = $e[$e.length - 1]._isolInitIndex;
                Ge != null && (ge.set(Ge, Se), ge.set(Se, Ge)), $e.pop(), bt--;
              }
              Le = $e[$e.length - 1], me[Se] = Le._level, Le._override && he(Se, Le._override);
            } else Ne & oe ? (nt === 0 && (Je > 0 ? Je-- : !Le._isolate && $e.length > 1 && ($e.pop(), Le = $e[$e.length - 1])), me[Se] = Le._level) : Ne & O && (me[Se] = Te.level);
          else
            me[Se] = Le._level, Le._override && Ne !== ue && he(Se, Le._override);
        }
        for (var ut = [], at = null, dt = Te.start; dt <= Te.end; dt++) {
          var pt = z[dt];
          if (!(pt & c)) {
            var zt = me[dt], Kt = pt & o, rn = pt === Y;
            at && zt === at._level ? (at._end = dt, at._endsWithIsolInit = Kt) : ut.push(at = {
              _start: dt,
              _end: dt,
              _level: zt,
              _startsWithPDI: rn,
              _endsWithIsolInit: Kt
            });
          }
        }
        for (var Bn = [], bn = 0; bn < ut.length; bn++) {
          var Kn = ut[bn];
          if (!Kn._startsWithPDI || Kn._startsWithPDI && !ge.has(Kn._start)) {
            for (var fi = [at = Kn], pi = void 0; at && at._endsWithIsolInit && (pi = ge.get(at._end)) != null; )
              for (var Vn = bn + 1; Vn < ut.length; Vn++)
                if (ut[Vn]._start === pi) {
                  fi.push(at = ut[Vn]);
                  break;
                }
            for (var wn = [], si = 0; si < fi.length; si++)
              for (var ki = fi[si], pe = ki._start; pe <= ki._end; pe++)
                wn.push(pe);
            for (var _e = me[wn[0]], Ee = Te.level, Ue = wn[0] - 1; Ue >= 0; Ue--)
              if (!(z[Ue] & c)) {
                Ee = me[Ue];
                break;
              }
            var W = wn[wn.length - 1], ve = me[W], ye = Te.level;
            if (!(z[W] & o)) {
              for (var Ce = W + 1; Ce <= Te.end; Ce++)
                if (!(z[Ce] & c)) {
                  ye = me[Ce];
                  break;
                }
            }
            Bn.push({
              _seqIndices: wn,
              _sosType: Math.max(Ee, _e) % 2 ? T : P,
              _eosType: Math.max(ye, ve) % 2 ? T : P
            });
          }
        }
        for (var be = 0; be < Bn.length; be++) {
          var ke = Bn[be], De = ke._seqIndices, Qe = ke._sosType, it = ke._eosType, mt = me[De[0]] & 1 ? T : P;
          if (K.get(Q))
            for (var gt = 0; gt < De.length; gt++) {
              var lt = De[gt];
              if (z[lt] & Q) {
                for (var Rt = Qe, Ht = gt - 1; Ht >= 0; Ht--)
                  if (!(z[De[Ht]] & c)) {
                    Rt = z[De[Ht]];
                    break;
                  }
                he(lt, Rt & (o | Y) ? G : Rt);
              }
            }
          if (K.get(y))
            for (var $t = 0; $t < De.length; $t++) {
              var Rn = De[$t];
              if (z[Rn] & y)
                for (var kt = $t - 1; kt >= -1; kt--) {
                  var ht = kt === -1 ? Qe : z[De[kt]];
                  if (ht & a) {
                    ht === le && he(Rn, U);
                    break;
                  }
                }
            }
          if (K.get(le))
            for (var mi = 0; mi < De.length; mi++) {
              var Lt = De[mi];
              z[Lt] & le && he(Lt, T);
            }
          if (K.get(w) || K.get(R))
            for (var Dn = 1; Dn < De.length - 1; Dn++) {
              var qi = De[Dn];
              if (z[qi] & (w | R)) {
                for (var Sn = 0, cs = 0, Yt = Dn - 1; Yt >= 0 && (Sn = z[De[Yt]], !!(Sn & c)); Yt--)
                  ;
                for (var ri = Dn + 1; ri < De.length && (cs = z[De[ri]], !!(cs & c)); ri++)
                  ;
                Sn === cs && (z[qi] === w ? Sn === y : Sn & (y | U)) && he(qi, Sn);
              }
            }
          if (K.get(y))
            for (var Gn = 0; Gn < De.length; Gn++) {
              var oi = De[Gn];
              if (z[oi] & y) {
                for (var vi = Gn - 1; vi >= 0 && z[De[vi]] & (D | c); vi--)
                  he(De[vi], y);
                for (Gn++; Gn < De.length && z[De[Gn]] & (D | c | y); Gn++)
                  z[De[Gn]] !== y && he(De[Gn], y);
              }
            }
          if (K.get(D) || K.get(w) || K.get(R))
            for (var ai = 0; ai < De.length; ai++) {
              var ta = De[ai];
              if (z[ta] & (D | w | R)) {
                he(ta, G);
                for (var Al = ai - 1; Al >= 0 && z[De[Al]] & c; Al--)
                  he(De[Al], G);
                for (var Pl = ai + 1; Pl < De.length && z[De[Pl]] & c; Pl++)
                  he(De[Pl], G);
              }
            }
          if (K.get(y))
            for (var Lu = 0, tp = Qe; Lu < De.length; Lu++) {
              var np = De[Lu], Fu = z[np];
              Fu & y ? tp === P && he(np, P) : Fu & a && (tp = Fu);
            }
          if (K.get(l)) {
            var na = T | y | U, ip = na | P, Rl = [];
            {
              for (var Yr = [], qr = 0; qr < De.length; qr++)
                if (z[De[qr]] & l) {
                  var ia = B[De[qr]], sp = void 0;
                  if (b(ia) !== null)
                    if (Yr.length < 63)
                      Yr.push({ char: ia, seqIndex: qr });
                    else
                      break;
                  else if ((sp = C(ia)) !== null)
                    for (var sa = Yr.length - 1; sa >= 0; sa--) {
                      var Uu = Yr[sa].char;
                      if (Uu === sp || Uu === C(E(ia)) || b(E(Uu)) === ia) {
                        Rl.push([Yr[sa].seqIndex, qr]), Yr.length = sa;
                        break;
                      }
                    }
                }
              Rl.sort(function(li, Li) {
                return li[0] - Li[0];
              });
            }
            for (var Ou = 0; Ou < Rl.length; Ou++) {
              for (var rp = Rl[Ou], Dl = rp[0], zu = rp[1], op = !1, Ii = 0, Nu = Dl + 1; Nu < zu; Nu++) {
                var ap = De[Nu];
                if (z[ap] & ip) {
                  op = !0;
                  var lp = z[ap] & na ? T : P;
                  if (lp === mt) {
                    Ii = lp;
                    break;
                  }
                }
              }
              if (op && !Ii) {
                Ii = Qe;
                for (var Bu = Dl - 1; Bu >= 0; Bu--) {
                  var cp = De[Bu];
                  if (z[cp] & ip) {
                    var up = z[cp] & na ? T : P;
                    up !== mt ? Ii = up : Ii = mt;
                    break;
                  }
                }
              }
              if (Ii) {
                if (z[De[Dl]] = z[De[zu]] = Ii, Ii !== mt) {
                  for (var ra = Dl + 1; ra < De.length; ra++)
                    if (!(z[De[ra]] & c)) {
                      m(B[De[ra]]) & Q && (z[De[ra]] = Ii);
                      break;
                    }
                }
                if (Ii !== mt) {
                  for (var oa = zu + 1; oa < De.length; oa++)
                    if (!(z[De[oa]] & c)) {
                      m(B[De[oa]]) & Q && (z[De[oa]] = Ii);
                      break;
                    }
                }
              }
            }
            for (var zs = 0; zs < De.length; zs++)
              if (z[De[zs]] & l) {
                for (var dp = zs, Vu = zs, Gu = Qe, aa = zs - 1; aa >= 0; aa--)
                  if (z[De[aa]] & c)
                    dp = aa;
                  else {
                    Gu = z[De[aa]] & na ? T : P;
                    break;
                  }
                for (var hp = it, la = zs + 1; la < De.length; la++)
                  if (z[De[la]] & (l | c))
                    Vu = la;
                  else {
                    hp = z[De[la]] & na ? T : P;
                    break;
                  }
                for (var Hu = dp; Hu <= Vu; Hu++)
                  z[De[Hu]] = Gu === hp ? Gu : mt;
                zs = Vu;
              }
          }
        }
        for (var gi = Te.start; gi <= Te.end; gi++) {
          var e1 = me[gi], kl = z[gi];
          if (e1 & 1 ? kl & (P | y | U) && me[gi]++ : kl & T ? me[gi]++ : kl & (U | y) && (me[gi] += 2), kl & c && (me[gi] = gi === 0 ? Te.level : me[gi - 1]), gi === Te.end || m(B[gi]) & (A | O))
            for (var Il = gi; Il >= 0 && m(B[Il]) & u; Il--)
              me[Il] = Te.level;
        }
      }
      return {
        levels: me,
        paragraphs: Me
      };
      function fp(li, Li) {
        for (var ci = li; ci < B.length; ci++) {
          var Ns = z[ci];
          if (Ns & (T | le))
            return 1;
          if (Ns & (O | P) || Li && Ns === Y)
            return 0;
          if (Ns & o) {
            var pp = t1(ci);
            ci = pp === -1 ? B.length : pp;
          }
        }
        return 0;
      }
      function t1(li) {
        for (var Li = 1, ci = li + 1; ci < B.length; ci++) {
          var Ns = z[ci];
          if (Ns & O)
            break;
          if (Ns & Y) {
            if (--Li === 0)
              return ci;
          } else Ns & o && Li++;
        }
        return -1;
      }
    }
    var I = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", F;
    function L() {
      if (!F) {
        var B = x(I, !0), X = B.map, se = B.reverseMap;
        se.forEach(function(z, N) {
          X.set(N, z);
        }), F = X;
      }
    }
    function ee(B) {
      return L(), F.get(B) || null;
    }
    function Z(B, X, se, z) {
      var N = B.length;
      se = Math.max(0, se == null ? 0 : +se), z = Math.min(N - 1, z == null ? N - 1 : +z);
      for (var K = /* @__PURE__ */ new Map(), he = se; he <= z; he++)
        if (X[he] & 1) {
          var me = ee(B[he]);
          me !== null && K.set(he, me);
        }
      return K;
    }
    function k(B, X, se, z) {
      var N = B.length;
      se = Math.max(0, se == null ? 0 : +se), z = Math.min(N - 1, z == null ? N - 1 : +z);
      var K = [];
      return X.paragraphs.forEach(function(he) {
        var me = Math.max(se, he.start), ge = Math.min(z, he.end);
        if (me < ge) {
          for (var Me = X.levels.slice(me, ge + 1), Te = ge; Te >= me && m(B[Te]) & u; Te--)
            Me[Te] = he.level;
          for (var Ae = he.level, Xe = 1 / 0, Oe = 0; Oe < Me.length; Oe++) {
            var He = Me[Oe];
            He > Ae && (Ae = He), He < Xe && (Xe = He | 1);
          }
          for (var Ye = Ae; Ye >= Xe; Ye--)
            for (var $e = 0; $e < Me.length; $e++)
              if (Me[$e] >= Ye) {
                for (var Le = $e; $e + 1 < Me.length && Me[$e + 1] >= Ye; )
                  $e++;
                $e > Le && K.push([Le + me, $e + me]);
              }
        }
      }), K;
    }
    function ne(B, X, se, z) {
      var N = J(B, X, se, z), K = [].concat(B);
      return N.forEach(function(he, me) {
        K[me] = (X.levels[he] & 1 ? ee(B[he]) : null) || B[he];
      }), K.join("");
    }
    function J(B, X, se, z) {
      for (var N = k(B, X, se, z), K = [], he = 0; he < B.length; he++)
        K[he] = he;
      return N.forEach(function(me) {
        for (var ge = me[0], Me = me[1], Te = K.slice(ge, Me + 1), Ae = Te.length; Ae--; )
          K[Me - Ae] = Te[Ae];
      }), K;
    }
    return e.closingToOpeningBracket = C, e.getBidiCharType = m, e.getBidiCharTypeName = p, e.getCanonicalBracket = E, e.getEmbeddingLevels = H, e.getMirroredCharacter = ee, e.getMirroredCharactersMap = Z, e.getReorderSegments = k, e.getReorderedIndices = J, e.getReorderedString = ne, e.openingToClosingBracket = b, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
const Fy = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function Qh(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function n(i, r) {
    let o = Tt[r];
    return o ? Qh(o) : i;
  }
  return s.replace(e, n);
}
const kn = [];
for (let s = 0; s < 256; s++)
  kn[s] = (s < 16 ? "0" : "") + s.toString(16);
function cN() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (kn[s & 255] + kn[s >> 8 & 255] + kn[s >> 16 & 255] + kn[s >> 24 & 255] + "-" + kn[e & 255] + kn[e >> 8 & 255] + "-" + kn[e >> 16 & 15 | 64] + kn[e >> 24 & 255] + "-" + kn[n & 63 | 128] + kn[n >> 8 & 255] + "-" + kn[n >> 16 & 255] + kn[n >> 24 & 255] + kn[i & 255] + kn[i >> 8 & 255] + kn[i >> 16 & 255] + kn[i >> 24 & 255]).toUpperCase();
}
const Sr = Object.assign || function() {
  let s = arguments[0];
  for (let e = 1, n = arguments.length; e < n; e++) {
    let i = arguments[e];
    if (i)
      for (let r in i)
        Object.prototype.hasOwnProperty.call(i, r) && (s[r] = i[r]);
  }
  return s;
}, uN = Date.now(), Nv = /* @__PURE__ */ new WeakMap(), Bv = /* @__PURE__ */ new Map();
let dN = 1e10;
function ef(s, e) {
  const n = mN(e);
  let i = Nv.get(s);
  if (i || Nv.set(s, i = /* @__PURE__ */ Object.create(null)), i[n])
    return new i[n]();
  const r = `_onBeforeCompile${n}`, o = function(u, d) {
    s.onBeforeCompile.call(this, u, d);
    const h = this.customProgramCacheKey() + "|" + u.vertexShader + "|" + u.fragmentShader;
    let m = Bv[h];
    if (!m) {
      const p = hN(this, u, e, n);
      m = Bv[h] = p;
    }
    u.vertexShader = m.vertexShader, u.fragmentShader = m.fragmentShader, Sr(u.uniforms, this.uniforms), e.timeUniform && (u.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - uN;
      }
    }), this[r] && this[r](u);
  }, a = function() {
    return l(e.chained ? s : s.clone());
  }, l = function(u) {
    const d = Object.create(u, c);
    return Object.defineProperty(d, "baseMaterial", { value: s }), Object.defineProperty(d, "id", { value: dN++ }), d.uuid = cN(), d.uniforms = Sr({}, u.uniforms, e.uniforms), d.defines = Sr({}, u.defines, e.defines), d.defines[`TROIKA_DERIVED_MATERIAL_${n}`] = "", d.extensions = Sr({}, u.extensions, e.extensions), d._listeners = void 0, d;
  }, c = {
    constructor: { value: a },
    isDerivedMaterial: { value: !0 },
    type: {
      get: () => s.type,
      set: (u) => {
        s.type = u;
      }
    },
    isDerivedFrom: {
      writable: !0,
      configurable: !0,
      value: function(u) {
        const d = this.baseMaterial;
        return u === d || d.isDerivedMaterial && d.isDerivedFrom(u) || !1;
      }
    },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return s.customProgramCacheKey() + "|" + n;
      }
    },
    onBeforeCompile: {
      get() {
        return o;
      },
      set(u) {
        this[r] = u;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(u) {
        return s.copy.call(this, u), !s.isShaderMaterial && !s.isDerivedMaterial && (Sr(this.extensions, u.extensions), Sr(this.defines, u.defines), Sr(this.uniforms, Sl.clone(u.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const u = new s.constructor();
        return l(u).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let u = this._depthMaterial;
        return u || (u = this._depthMaterial = ef(
          s.isDerivedMaterial ? s.getDepthMaterial() : new Of({ depthPacking: Pf }),
          e
        ), u.defines.IS_DEPTH_MATERIAL = "", u.uniforms = this.uniforms), u;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let u = this._distanceMaterial;
        return u || (u = this._distanceMaterial = ef(
          s.isDerivedMaterial ? s.getDistanceMaterial() : new hy(),
          e
        ), u.defines.IS_DISTANCE_MATERIAL = "", u.uniforms = this.uniforms), u;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: u, _distanceMaterial: d } = this;
        u && u.dispose(), d && d.dispose(), s.dispose.call(this);
      }
    }
  };
  return i[n] = a, new a();
}
function hN(s, { vertexShader: e, fragmentShader: n }, i, r) {
  let {
    vertexDefs: o,
    vertexMainIntro: a,
    vertexMainOutro: l,
    vertexTransform: c,
    fragmentDefs: u,
    fragmentMainIntro: d,
    fragmentMainOutro: h,
    fragmentColorTransform: m,
    customRewriter: p,
    timeUniform: v
  } = i;
  if (o = o || "", a = a || "", l = l || "", u = u || "", d = d || "", h = h || "", (c || p) && (e = Qh(e)), (m || p) && (n = n.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), n = Qh(n)), p) {
    let x = p({ vertexShader: e, fragmentShader: n });
    e = x.vertexShader, n = x.fragmentShader;
  }
  if (m) {
    let x = [];
    n = n.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (g) => (x.push(g), "")
    ), h = `${m}
${x.join(`
`)}
${h}`;
  }
  if (v) {
    const x = `
uniform float ${v};
`;
    o = x + o, u = x + u;
  }
  return c && (e = `vec3 troika_position_${r};
vec3 troika_normal_${r};
vec2 troika_uv_${r};
${e}
`, o = `${o}
void troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${c}
}
`, a = `
troika_position_${r} = vec3(position);
troika_normal_${r} = vec3(normal);
troika_uv_${r} = vec2(uv);
troikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});
${a}
`, e = e.replace(/\b(position|normal|uv)\b/g, (x, g, _, M) => /\battribute\s+vec[23]\s+$/.test(M.substr(0, _)) ? g : `troika_${g}_${r}`), s.map && s.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${r}`))), e = Vv(e, r, o, a, l), n = Vv(n, r, u, d, h), {
    vertexShader: e,
    fragmentShader: n
  };
}
function Vv(s, e, n, i, r) {
  return (i || r || n) && (s = s.replace(
    Fy,
    `
${n}
void troikaOrigMain${e}() {`
  ), s += `
void main() {
  ${i}
  troikaOrigMain${e}();
  ${r}
}`), s;
}
function fN(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let pN = 0;
const Gv = /* @__PURE__ */ new Map();
function mN(s) {
  const e = JSON.stringify(s, fN);
  let n = Gv.get(e);
  return n == null && Gv.set(e, n = ++pN), n;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function vN() {
  return typeof window > "u" && (self.window = self), function(s) {
    var e = { parse: function(r) {
      var o = e._bin, a = new Uint8Array(r);
      if (o.readASCII(a, 0, 4) == "ttcf") {
        var l = 4;
        o.readUshort(a, l), l += 2, o.readUshort(a, l), l += 2;
        var c = o.readUint(a, l);
        l += 4;
        for (var u = [], d = 0; d < c; d++) {
          var h = o.readUint(a, l);
          l += 4, u.push(e._readFont(a, h));
        }
        return u;
      }
      return [e._readFont(a, 0)];
    }, _readFont: function(r, o) {
      var a = e._bin, l = o;
      a.readFixed(r, o), o += 4;
      var c = a.readUshort(r, o);
      o += 2, a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2;
      for (var u = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], d = { _data: r, _offset: l }, h = {}, m = 0; m < c; m++) {
        var p = a.readASCII(r, o, 4);
        o += 4, a.readUint(r, o), o += 4;
        var v = a.readUint(r, o);
        o += 4;
        var x = a.readUint(r, o);
        o += 4, h[p] = { offset: v, length: x };
      }
      for (m = 0; m < u.length; m++) {
        var g = u[m];
        h[g] && (d[g.trim()] = e[g.trim()].parse(r, h[g].offset, h[g].length, d));
      }
      return d;
    }, _tabOffset: function(r, o, a) {
      for (var l = e._bin, c = l.readUshort(r, a + 4), u = a + 12, d = 0; d < c; d++) {
        var h = l.readASCII(r, u, 4);
        u += 4, l.readUint(r, u), u += 4;
        var m = l.readUint(r, u);
        if (u += 4, l.readUint(r, u), u += 4, h == o) return m;
      }
      return 0;
    } };
    e._bin = { readFixed: function(r, o) {
      return (r[o] << 8 | r[o + 1]) + (r[o + 2] << 8 | r[o + 3]) / 65540;
    }, readF2dot14: function(r, o) {
      return e._bin.readShort(r, o) / 16384;
    }, readInt: function(r, o) {
      return e._bin._view(r).getInt32(o);
    }, readInt8: function(r, o) {
      return e._bin._view(r).getInt8(o);
    }, readShort: function(r, o) {
      return e._bin._view(r).getInt16(o);
    }, readUshort: function(r, o) {
      return e._bin._view(r).getUint16(o);
    }, readUshorts: function(r, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(e._bin.readUshort(r, o + 2 * c));
      return l;
    }, readUint: function(r, o) {
      return e._bin._view(r).getUint32(o);
    }, readUint64: function(r, o) {
      return 4294967296 * e._bin.readUint(r, o) + e._bin.readUint(r, o + 4);
    }, readASCII: function(r, o, a) {
      for (var l = "", c = 0; c < a; c++) l += String.fromCharCode(r[o + c]);
      return l;
    }, readUnicode: function(r, o, a) {
      for (var l = "", c = 0; c < a; c++) {
        var u = r[o++] << 8 | r[o++];
        l += String.fromCharCode(u);
      }
      return l;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r, o, a) {
      var l = e._bin._tdec;
      return l && o == 0 && a == r.length ? l.decode(r) : e._bin.readASCII(r, o, a);
    }, readBytes: function(r, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(r[o + c]);
      return l;
    }, readASCIIArray: function(r, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(String.fromCharCode(r[o + c]));
      return l;
    }, _view: function(r) {
      return r._dataView || (r._dataView = r.buffer ? new DataView(r.buffer, r.byteOffset, r.byteLength) : new DataView(new Uint8Array(r).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(r, o, a, l, c) {
      var u = e._bin, d = {}, h = o;
      u.readFixed(r, o), o += 4;
      var m = u.readUshort(r, o);
      o += 2;
      var p = u.readUshort(r, o);
      o += 2;
      var v = u.readUshort(r, o);
      return o += 2, d.scriptList = e._lctf.readScriptList(r, h + m), d.featureList = e._lctf.readFeatureList(r, h + p), d.lookupList = e._lctf.readLookupList(r, h + v, c), d;
    }, e._lctf.readLookupList = function(r, o, a) {
      var l = e._bin, c = o, u = [], d = l.readUshort(r, o);
      o += 2;
      for (var h = 0; h < d; h++) {
        var m = l.readUshort(r, o);
        o += 2;
        var p = e._lctf.readLookupTable(r, c + m, a);
        u.push(p);
      }
      return u;
    }, e._lctf.readLookupTable = function(r, o, a) {
      var l = e._bin, c = o, u = { tabs: [] };
      u.ltype = l.readUshort(r, o), o += 2, u.flag = l.readUshort(r, o), o += 2;
      var d = l.readUshort(r, o);
      o += 2;
      for (var h = u.ltype, m = 0; m < d; m++) {
        var p = l.readUshort(r, o);
        o += 2;
        var v = a(r, h, c + p, u);
        u.tabs.push(v);
      }
      return u;
    }, e._lctf.numOfOnes = function(r) {
      for (var o = 0, a = 0; a < 32; a++) r >>> a & 1 && o++;
      return o;
    }, e._lctf.readClassDef = function(r, o) {
      var a = e._bin, l = [], c = a.readUshort(r, o);
      if (o += 2, c == 1) {
        var u = a.readUshort(r, o);
        o += 2;
        var d = a.readUshort(r, o);
        o += 2;
        for (var h = 0; h < d; h++) l.push(u + h), l.push(u + h), l.push(a.readUshort(r, o)), o += 2;
      }
      if (c == 2) {
        var m = a.readUshort(r, o);
        for (o += 2, h = 0; h < m; h++) l.push(a.readUshort(r, o)), o += 2, l.push(a.readUshort(r, o)), o += 2, l.push(a.readUshort(r, o)), o += 2;
      }
      return l;
    }, e._lctf.getInterval = function(r, o) {
      for (var a = 0; a < r.length; a += 3) {
        var l = r[a], c = r[a + 1];
        if (r[a + 2], l <= o && o <= c) return a;
      }
      return -1;
    }, e._lctf.readCoverage = function(r, o) {
      var a = e._bin, l = {};
      l.fmt = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      return o += 2, l.fmt == 1 && (l.tab = a.readUshorts(r, o, c)), l.fmt == 2 && (l.tab = a.readUshorts(r, o, 3 * c)), l;
    }, e._lctf.coverageIndex = function(r, o) {
      var a = r.tab;
      if (r.fmt == 1) return a.indexOf(o);
      if (r.fmt == 2) {
        var l = e._lctf.getInterval(a, o);
        if (l != -1) return a[l + 2] + (o - a[l]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(r, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readASCII(r, o, 4);
        o += 4;
        var m = a.readUshort(r, o);
        o += 2;
        var p = e._lctf.readFeatureTable(r, l + m);
        p.tag = h.trim(), c.push(p);
      }
      return c;
    }, e._lctf.readFeatureTable = function(r, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(r, o);
      o += 2, u > 0 && (c.featureParams = l + u);
      var d = a.readUshort(r, o);
      o += 2, c.tab = [];
      for (var h = 0; h < d; h++) c.tab.push(a.readUshort(r, o + 2 * h));
      return c;
    }, e._lctf.readScriptList = function(r, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readASCII(r, o, 4);
        o += 4;
        var m = a.readUshort(r, o);
        o += 2, c[h.trim()] = e._lctf.readScriptTable(r, l + m);
      }
      return c;
    }, e._lctf.readScriptTable = function(r, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(r, o);
      o += 2, u > 0 && (c.default = e._lctf.readLangSysTable(r, l + u));
      var d = a.readUshort(r, o);
      o += 2;
      for (var h = 0; h < d; h++) {
        var m = a.readASCII(r, o, 4);
        o += 4;
        var p = a.readUshort(r, o);
        o += 2, c[m.trim()] = e._lctf.readLangSysTable(r, l + p);
      }
      return c;
    }, e._lctf.readLangSysTable = function(r, o) {
      var a = e._bin, l = {};
      a.readUshort(r, o), o += 2, l.reqFeature = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      return o += 2, l.features = a.readUshorts(r, o, c), l;
    }, e.CFF = {}, e.CFF.parse = function(r, o, a) {
      var l = e._bin;
      (r = new Uint8Array(r.buffer, o, a))[o = 0], r[++o], r[++o], r[++o], o++;
      var c = [];
      o = e.CFF.readIndex(r, o, c);
      for (var u = [], d = 0; d < c.length - 1; d++) u.push(l.readASCII(r, o + c[d], c[d + 1] - c[d]));
      o += c[c.length - 1];
      var h = [];
      o = e.CFF.readIndex(r, o, h);
      var m = [];
      for (d = 0; d < h.length - 1; d++) m.push(e.CFF.readDict(r, o + h[d], o + h[d + 1]));
      o += h[h.length - 1];
      var p = m[0], v = [];
      o = e.CFF.readIndex(r, o, v);
      var x = [];
      for (d = 0; d < v.length - 1; d++) x.push(l.readASCII(r, o + v[d], v[d + 1] - v[d]));
      if (o += v[v.length - 1], e.CFF.readSubrs(r, o, p), p.CharStrings) {
        o = p.CharStrings, v = [], o = e.CFF.readIndex(r, o, v);
        var g = [];
        for (d = 0; d < v.length - 1; d++) g.push(l.readBytes(r, o + v[d], v[d + 1] - v[d]));
        p.CharStrings = g;
      }
      if (p.ROS) {
        o = p.FDArray;
        var _ = [];
        for (o = e.CFF.readIndex(r, o, _), p.FDArray = [], d = 0; d < _.length - 1; d++) {
          var M = e.CFF.readDict(r, o + _[d], o + _[d + 1]);
          e.CFF._readFDict(r, M, x), p.FDArray.push(M);
        }
        o += _[_.length - 1], o = p.FDSelect, p.FDSelect = [];
        var S = r[o];
        if (o++, S != 3) throw S;
        var b = l.readUshort(r, o);
        for (o += 2, d = 0; d < b + 1; d++) p.FDSelect.push(l.readUshort(r, o), r[o + 2]), o += 3;
      }
      return p.Encoding && (p.Encoding = e.CFF.readEncoding(r, p.Encoding, p.CharStrings.length)), p.charset && (p.charset = e.CFF.readCharset(r, p.charset, p.CharStrings.length)), e.CFF._readFDict(r, p, x), p;
    }, e.CFF._readFDict = function(r, o, a) {
      var l;
      for (var c in o.Private && (l = o.Private[1], o.Private = e.CFF.readDict(r, l, l + o.Private[0]), o.Private.Subrs && e.CFF.readSubrs(r, l + o.Private.Subrs, o.Private)), o) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(c) != -1 && (o[c] = a[o[c] - 426 + 35]);
    }, e.CFF.readSubrs = function(r, o, a) {
      var l = e._bin, c = [];
      o = e.CFF.readIndex(r, o, c);
      var u, d = c.length;
      u = d < 1240 ? 107 : d < 33900 ? 1131 : 32768, a.Bias = u, a.Subrs = [];
      for (var h = 0; h < c.length - 1; h++) a.Subrs.push(l.readBytes(r, o + c[h], c[h + 1] - c[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(r, o) {
      for (var a = 0; a < r.charset.length; a++) if (r.charset[a] == o) return a;
      return -1;
    }, e.CFF.glyphBySE = function(r, o) {
      return o < 0 || o > 255 ? -1 : e.CFF.glyphByUnicode(r, e.CFF.tableSE[o]);
    }, e.CFF.readEncoding = function(r, o, a) {
      e._bin;
      var l = [".notdef"], c = r[o];
      if (o++, c != 0) throw "error: unknown encoding format: " + c;
      var u = r[o];
      o++;
      for (var d = 0; d < u; d++) l.push(r[o + d]);
      return l;
    }, e.CFF.readCharset = function(r, o, a) {
      var l = e._bin, c = [".notdef"], u = r[o];
      if (o++, u == 0) for (var d = 0; d < a; d++) {
        var h = l.readUshort(r, o);
        o += 2, c.push(h);
      }
      else {
        if (u != 1 && u != 2) throw "error: format: " + u;
        for (; c.length < a; ) {
          h = l.readUshort(r, o), o += 2;
          var m = 0;
          for (u == 1 ? (m = r[o], o++) : (m = l.readUshort(r, o), o += 2), d = 0; d <= m; d++) c.push(h), h++;
        }
      }
      return c;
    }, e.CFF.readIndex = function(r, o, a) {
      var l = e._bin, c = l.readUshort(r, o) + 1, u = r[o += 2];
      if (o++, u == 1) for (var d = 0; d < c; d++) a.push(r[o + d]);
      else if (u == 2) for (d = 0; d < c; d++) a.push(l.readUshort(r, o + 2 * d));
      else if (u == 3) for (d = 0; d < c; d++) a.push(16777215 & l.readUint(r, o + 3 * d - 1));
      else if (c != 1) throw "unsupported offset size: " + u + ", count: " + c;
      return (o += c * u) - 1;
    }, e.CFF.getCharString = function(r, o, a) {
      var l = e._bin, c = r[o], u = r[o + 1];
      r[o + 2], r[o + 3], r[o + 4];
      var d = 1, h = null, m = null;
      c <= 20 && (h = c, d = 1), c == 12 && (h = 100 * c + u, d = 2), 21 <= c && c <= 27 && (h = c, d = 1), c == 28 && (m = l.readShort(r, o + 1), d = 3), 29 <= c && c <= 31 && (h = c, d = 1), 32 <= c && c <= 246 && (m = c - 139, d = 1), 247 <= c && c <= 250 && (m = 256 * (c - 247) + u + 108, d = 2), 251 <= c && c <= 254 && (m = 256 * -(c - 251) - u - 108, d = 2), c == 255 && (m = l.readInt(r, o + 1) / 65535, d = 5), a.val = m ?? "o" + h, a.size = d;
    }, e.CFF.readCharString = function(r, o, a) {
      for (var l = o + a, c = e._bin, u = []; o < l; ) {
        var d = r[o], h = r[o + 1];
        r[o + 2], r[o + 3], r[o + 4];
        var m = 1, p = null, v = null;
        d <= 20 && (p = d, m = 1), d == 12 && (p = 100 * d + h, m = 2), d != 19 && d != 20 || (p = d, m = 2), 21 <= d && d <= 27 && (p = d, m = 1), d == 28 && (v = c.readShort(r, o + 1), m = 3), 29 <= d && d <= 31 && (p = d, m = 1), 32 <= d && d <= 246 && (v = d - 139, m = 1), 247 <= d && d <= 250 && (v = 256 * (d - 247) + h + 108, m = 2), 251 <= d && d <= 254 && (v = 256 * -(d - 251) - h - 108, m = 2), d == 255 && (v = c.readInt(r, o + 1) / 65535, m = 5), u.push(v ?? "o" + p), o += m;
      }
      return u;
    }, e.CFF.readDict = function(r, o, a) {
      for (var l = e._bin, c = {}, u = []; o < a; ) {
        var d = r[o], h = r[o + 1];
        r[o + 2], r[o + 3], r[o + 4];
        var m = 1, p = null, v = null;
        if (d == 28 && (v = l.readShort(r, o + 1), m = 3), d == 29 && (v = l.readInt(r, o + 1), m = 5), 32 <= d && d <= 246 && (v = d - 139, m = 1), 247 <= d && d <= 250 && (v = 256 * (d - 247) + h + 108, m = 2), 251 <= d && d <= 254 && (v = 256 * -(d - 251) - h - 108, m = 2), d == 255) throw v = l.readInt(r, o + 1) / 65535, m = 5, "unknown number";
        if (d == 30) {
          var x = [];
          for (m = 1; ; ) {
            var g = r[o + m];
            m++;
            var _ = g >> 4, M = 15 & g;
            if (_ != 15 && x.push(_), M != 15 && x.push(M), M == 15) break;
          }
          for (var S = "", b = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], C = 0; C < x.length; C++) S += b[x[C]];
          v = parseFloat(S);
        }
        d <= 21 && (p = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][d], m = 1, d == 12 && (p = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], m = 2)), p != null ? (c[p] = u.length == 1 ? u[0] : u, u = []) : u.push(v), o += m;
      }
      return c;
    }, e.cmap = {}, e.cmap.parse = function(r, o, a) {
      r = new Uint8Array(r.buffer, o, a), o = 0;
      var l = e._bin, c = {};
      l.readUshort(r, o), o += 2;
      var u = l.readUshort(r, o);
      o += 2;
      var d = [];
      c.tables = [];
      for (var h = 0; h < u; h++) {
        var m = l.readUshort(r, o);
        o += 2;
        var p = l.readUshort(r, o);
        o += 2;
        var v = l.readUint(r, o);
        o += 4;
        var x = "p" + m + "e" + p, g = d.indexOf(v);
        if (g == -1) {
          var _;
          g = c.tables.length, d.push(v);
          var M = l.readUshort(r, v);
          M == 0 ? _ = e.cmap.parse0(r, v) : M == 4 ? _ = e.cmap.parse4(r, v) : M == 6 ? _ = e.cmap.parse6(r, v) : M == 12 ? _ = e.cmap.parse12(r, v) : console.debug("unknown format: " + M, m, p, v), c.tables.push(_);
        }
        if (c[x] != null) throw "multiple tables for one platform+encoding";
        c[x] = g;
      }
      return c;
    }, e.cmap.parse0 = function(r, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      o += 2, a.readUshort(r, o), o += 2, l.map = [];
      for (var u = 0; u < c - 6; u++) l.map.push(r[o + u]);
      return l;
    }, e.cmap.parse4 = function(r, o) {
      var a = e._bin, l = o, c = {};
      c.format = a.readUshort(r, o), o += 2;
      var u = a.readUshort(r, o);
      o += 2, a.readUshort(r, o), o += 2;
      var d = a.readUshort(r, o);
      o += 2;
      var h = d / 2;
      c.searchRange = a.readUshort(r, o), o += 2, c.entrySelector = a.readUshort(r, o), o += 2, c.rangeShift = a.readUshort(r, o), o += 2, c.endCount = a.readUshorts(r, o, h), o += 2 * h, o += 2, c.startCount = a.readUshorts(r, o, h), o += 2 * h, c.idDelta = [];
      for (var m = 0; m < h; m++) c.idDelta.push(a.readShort(r, o)), o += 2;
      for (c.idRangeOffset = a.readUshorts(r, o, h), o += 2 * h, c.glyphIdArray = []; o < l + u; ) c.glyphIdArray.push(a.readUshort(r, o)), o += 2;
      return c;
    }, e.cmap.parse6 = function(r, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2, l.firstCode = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      o += 2, l.glyphIdArray = [];
      for (var u = 0; u < c; u++) l.glyphIdArray.push(a.readUshort(r, o)), o += 2;
      return l;
    }, e.cmap.parse12 = function(r, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(r, o), o += 2, o += 2, a.readUint(r, o), o += 4, a.readUint(r, o), o += 4;
      var c = a.readUint(r, o);
      o += 4, l.groups = [];
      for (var u = 0; u < c; u++) {
        var d = o + 12 * u, h = a.readUint(r, d + 0), m = a.readUint(r, d + 4), p = a.readUint(r, d + 8);
        l.groups.push([h, m, p]);
      }
      return l;
    }, e.glyf = {}, e.glyf.parse = function(r, o, a, l) {
      for (var c = [], u = 0; u < l.maxp.numGlyphs; u++) c.push(null);
      return c;
    }, e.glyf._parseGlyf = function(r, o) {
      var a = e._bin, l = r._data, c = e._tabOffset(l, "glyf", r._offset) + r.loca[o];
      if (r.loca[o] == r.loca[o + 1]) return null;
      var u = {};
      if (u.noc = a.readShort(l, c), c += 2, u.xMin = a.readShort(l, c), c += 2, u.yMin = a.readShort(l, c), c += 2, u.xMax = a.readShort(l, c), c += 2, u.yMax = a.readShort(l, c), c += 2, u.xMin >= u.xMax || u.yMin >= u.yMax) return null;
      if (u.noc > 0) {
        u.endPts = [];
        for (var d = 0; d < u.noc; d++) u.endPts.push(a.readUshort(l, c)), c += 2;
        var h = a.readUshort(l, c);
        if (c += 2, l.length - c < h) return null;
        u.instructions = a.readBytes(l, c, h), c += h;
        var m = u.endPts[u.noc - 1] + 1;
        for (u.flags = [], d = 0; d < m; d++) {
          var p = l[c];
          if (c++, u.flags.push(p), (8 & p) != 0) {
            var v = l[c];
            c++;
            for (var x = 0; x < v; x++) u.flags.push(p), d++;
          }
        }
        for (u.xs = [], d = 0; d < m; d++) {
          var g = (2 & u.flags[d]) != 0, _ = (16 & u.flags[d]) != 0;
          g ? (u.xs.push(_ ? l[c] : -l[c]), c++) : _ ? u.xs.push(0) : (u.xs.push(a.readShort(l, c)), c += 2);
        }
        for (u.ys = [], d = 0; d < m; d++)
          g = (4 & u.flags[d]) != 0, _ = (32 & u.flags[d]) != 0, g ? (u.ys.push(_ ? l[c] : -l[c]), c++) : _ ? u.ys.push(0) : (u.ys.push(a.readShort(l, c)), c += 2);
        var M = 0, S = 0;
        for (d = 0; d < m; d++) M += u.xs[d], S += u.ys[d], u.xs[d] = M, u.ys[d] = S;
      } else {
        var b;
        u.parts = [];
        do {
          b = a.readUshort(l, c), c += 2;
          var C = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (u.parts.push(C), C.glyphIndex = a.readUshort(l, c), c += 2, 1 & b) {
            var E = a.readShort(l, c);
            c += 2;
            var P = a.readShort(l, c);
            c += 2;
          } else
            E = a.readInt8(l, c), c++, P = a.readInt8(l, c), c++;
          2 & b ? (C.m.tx = E, C.m.ty = P) : (C.p1 = E, C.p2 = P), 8 & b ? (C.m.a = C.m.d = a.readF2dot14(l, c), c += 2) : 64 & b ? (C.m.a = a.readF2dot14(l, c), c += 2, C.m.d = a.readF2dot14(l, c), c += 2) : 128 & b && (C.m.a = a.readF2dot14(l, c), c += 2, C.m.b = a.readF2dot14(l, c), c += 2, C.m.c = a.readF2dot14(l, c), c += 2, C.m.d = a.readF2dot14(l, c), c += 2);
        } while (32 & b);
        if (256 & b) {
          var T = a.readUshort(l, c);
          for (c += 2, u.instr = [], d = 0; d < T; d++) u.instr.push(l[c]), c++;
        }
      }
      return u;
    }, e.GDEF = {}, e.GDEF.parse = function(r, o, a, l) {
      var c = o;
      o += 4;
      var u = e._bin.readUshort(r, o);
      return { glyphClassDef: u === 0 ? null : e._lctf.readClassDef(r, c + u) };
    }, e.GPOS = {}, e.GPOS.parse = function(r, o, a, l) {
      return e._lctf.parse(r, o, a, l, e.GPOS.subt);
    }, e.GPOS.subt = function(r, o, a, l) {
      var c = e._bin, u = a, d = {};
      if (d.fmt = c.readUshort(r, a), a += 2, o == 1 || o == 2 || o == 3 || o == 7 || o == 8 && d.fmt <= 2) {
        var h = c.readUshort(r, a);
        a += 2, d.coverage = e._lctf.readCoverage(r, h + u);
      }
      if (o == 1 && d.fmt == 1) {
        var m = c.readUshort(r, a);
        a += 2, m != 0 && (d.pos = e.GPOS.readValueRecord(r, a, m));
      } else if (o == 2 && d.fmt >= 1 && d.fmt <= 2) {
        m = c.readUshort(r, a), a += 2;
        var p = c.readUshort(r, a);
        a += 2;
        var v = e._lctf.numOfOnes(m), x = e._lctf.numOfOnes(p);
        if (d.fmt == 1) {
          d.pairsets = [];
          var g = c.readUshort(r, a);
          a += 2;
          for (var _ = 0; _ < g; _++) {
            var M = u + c.readUshort(r, a);
            a += 2;
            var S = c.readUshort(r, M);
            M += 2;
            for (var b = [], C = 0; C < S; C++) {
              var E = c.readUshort(r, M);
              M += 2, m != 0 && (U = e.GPOS.readValueRecord(r, M, m), M += 2 * v), p != 0 && (R = e.GPOS.readValueRecord(r, M, p), M += 2 * x), b.push({ gid2: E, val1: U, val2: R });
            }
            d.pairsets.push(b);
          }
        }
        if (d.fmt == 2) {
          var P = c.readUshort(r, a);
          a += 2;
          var T = c.readUshort(r, a);
          a += 2;
          var y = c.readUshort(r, a);
          a += 2;
          var w = c.readUshort(r, a);
          for (a += 2, d.classDef1 = e._lctf.readClassDef(r, u + P), d.classDef2 = e._lctf.readClassDef(r, u + T), d.matrix = [], _ = 0; _ < y; _++) {
            var D = [];
            for (C = 0; C < w; C++) {
              var U = null, R = null;
              m != 0 && (U = e.GPOS.readValueRecord(r, a, m), a += 2 * v), p != 0 && (R = e.GPOS.readValueRecord(r, a, p), a += 2 * x), D.push({ val1: U, val2: R });
            }
            d.matrix.push(D);
          }
        }
      } else if (o == 4 && d.fmt == 1) d.markCoverage = e._lctf.readCoverage(r, c.readUshort(r, a) + u), d.baseCoverage = e._lctf.readCoverage(r, c.readUshort(r, a + 2) + u), d.markClassCount = c.readUshort(r, a + 4), d.markArray = e.GPOS.readMarkArray(r, c.readUshort(r, a + 6) + u), d.baseArray = e.GPOS.readBaseArray(r, c.readUshort(r, a + 8) + u, d.markClassCount);
      else if (o == 6 && d.fmt == 1) d.mark1Coverage = e._lctf.readCoverage(r, c.readUshort(r, a) + u), d.mark2Coverage = e._lctf.readCoverage(r, c.readUshort(r, a + 2) + u), d.markClassCount = c.readUshort(r, a + 4), d.mark1Array = e.GPOS.readMarkArray(r, c.readUshort(r, a + 6) + u), d.mark2Array = e.GPOS.readBaseArray(r, c.readUshort(r, a + 8) + u, d.markClassCount);
      else {
        if (o == 9 && d.fmt == 1) {
          var O = c.readUshort(r, a);
          a += 2;
          var A = c.readUint(r, a);
          if (a += 4, l.ltype == 9) l.ltype = O;
          else if (l.ltype != O) throw "invalid extension substitution";
          return e.GPOS.subt(r, l.ltype, u + A);
        }
        console.debug("unsupported GPOS table LookupType", o, "format", d.fmt);
      }
      return d;
    }, e.GPOS.readValueRecord = function(r, o, a) {
      var l = e._bin, c = [];
      return c.push(1 & a ? l.readShort(r, o) : 0), o += 1 & a ? 2 : 0, c.push(2 & a ? l.readShort(r, o) : 0), o += 2 & a ? 2 : 0, c.push(4 & a ? l.readShort(r, o) : 0), o += 4 & a ? 2 : 0, c.push(8 & a ? l.readShort(r, o) : 0), o += 8 & a ? 2 : 0, c;
    }, e.GPOS.readBaseArray = function(r, o, a) {
      var l = e._bin, c = [], u = o, d = l.readUshort(r, o);
      o += 2;
      for (var h = 0; h < d; h++) {
        for (var m = [], p = 0; p < a; p++) m.push(e.GPOS.readAnchorRecord(r, u + l.readUshort(r, o))), o += 2;
        c.push(m);
      }
      return c;
    }, e.GPOS.readMarkArray = function(r, o) {
      var a = e._bin, l = [], c = o, u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = e.GPOS.readAnchorRecord(r, a.readUshort(r, o + 2) + c);
        h.markClass = a.readUshort(r, o), l.push(h), o += 4;
      }
      return l;
    }, e.GPOS.readAnchorRecord = function(r, o) {
      var a = e._bin, l = {};
      return l.fmt = a.readUshort(r, o), l.x = a.readShort(r, o + 2), l.y = a.readShort(r, o + 4), l;
    }, e.GSUB = {}, e.GSUB.parse = function(r, o, a, l) {
      return e._lctf.parse(r, o, a, l, e.GSUB.subt);
    }, e.GSUB.subt = function(r, o, a, l) {
      var c = e._bin, u = a, d = {};
      if (d.fmt = c.readUshort(r, a), a += 2, o != 1 && o != 2 && o != 4 && o != 5 && o != 6) return null;
      if (o == 1 || o == 2 || o == 4 || o == 5 && d.fmt <= 2 || o == 6 && d.fmt <= 2) {
        var h = c.readUshort(r, a);
        a += 2, d.coverage = e._lctf.readCoverage(r, u + h);
      }
      if (o == 1 && d.fmt >= 1 && d.fmt <= 2) {
        if (d.fmt == 1) d.delta = c.readShort(r, a), a += 2;
        else if (d.fmt == 2) {
          var m = c.readUshort(r, a);
          a += 2, d.newg = c.readUshorts(r, a, m), a += 2 * d.newg.length;
        }
      } else if (o == 2 && d.fmt == 1) {
        m = c.readUshort(r, a), a += 2, d.seqs = [];
        for (var p = 0; p < m; p++) {
          var v = c.readUshort(r, a) + u;
          a += 2;
          var x = c.readUshort(r, v);
          d.seqs.push(c.readUshorts(r, v + 2, x));
        }
      } else if (o == 4)
        for (d.vals = [], m = c.readUshort(r, a), a += 2, p = 0; p < m; p++) {
          var g = c.readUshort(r, a);
          a += 2, d.vals.push(e.GSUB.readLigatureSet(r, u + g));
        }
      else if (o == 5 && d.fmt == 2) {
        if (d.fmt == 2) {
          var _ = c.readUshort(r, a);
          a += 2, d.cDef = e._lctf.readClassDef(r, u + _), d.scset = [];
          var M = c.readUshort(r, a);
          for (a += 2, p = 0; p < M; p++) {
            var S = c.readUshort(r, a);
            a += 2, d.scset.push(S == 0 ? null : e.GSUB.readSubClassSet(r, u + S));
          }
        }
      } else if (o == 6 && d.fmt == 3) {
        if (d.fmt == 3) {
          for (p = 0; p < 3; p++) {
            m = c.readUshort(r, a), a += 2;
            for (var b = [], C = 0; C < m; C++) b.push(e._lctf.readCoverage(r, u + c.readUshort(r, a + 2 * C)));
            a += 2 * m, p == 0 && (d.backCvg = b), p == 1 && (d.inptCvg = b), p == 2 && (d.ahedCvg = b);
          }
          m = c.readUshort(r, a), a += 2, d.lookupRec = e.GSUB.readSubstLookupRecords(r, a, m);
        }
      } else {
        if (o == 7 && d.fmt == 1) {
          var E = c.readUshort(r, a);
          a += 2;
          var P = c.readUint(r, a);
          if (a += 4, l.ltype == 9) l.ltype = E;
          else if (l.ltype != E) throw "invalid extension substitution";
          return e.GSUB.subt(r, l.ltype, u + P);
        }
        console.debug("unsupported GSUB table LookupType", o, "format", d.fmt);
      }
      return d;
    }, e.GSUB.readSubClassSet = function(r, o) {
      var a = e._bin.readUshort, l = o, c = [], u = a(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a(r, o);
        o += 2, c.push(e.GSUB.readSubClassRule(r, l + h));
      }
      return c;
    }, e.GSUB.readSubClassRule = function(r, o) {
      var a = e._bin.readUshort, l = {}, c = a(r, o), u = a(r, o += 2);
      o += 2, l.input = [];
      for (var d = 0; d < c - 1; d++) l.input.push(a(r, o)), o += 2;
      return l.substLookupRecords = e.GSUB.readSubstLookupRecords(r, o, u), l;
    }, e.GSUB.readSubstLookupRecords = function(r, o, a) {
      for (var l = e._bin.readUshort, c = [], u = 0; u < a; u++) c.push(l(r, o), l(r, o + 2)), o += 4;
      return c;
    }, e.GSUB.readChainSubClassSet = function(r, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readUshort(r, o);
        o += 2, c.push(e.GSUB.readChainSubClassRule(r, l + h));
      }
      return c;
    }, e.GSUB.readChainSubClassRule = function(r, o) {
      for (var a = e._bin, l = {}, c = ["backtrack", "input", "lookahead"], u = 0; u < c.length; u++) {
        var d = a.readUshort(r, o);
        o += 2, u == 1 && d--, l[c[u]] = a.readUshorts(r, o, d), o += 2 * l[c[u]].length;
      }
      return d = a.readUshort(r, o), o += 2, l.subst = a.readUshorts(r, o, 2 * d), o += 2 * l.subst.length, l;
    }, e.GSUB.readLigatureSet = function(r, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readUshort(r, o);
        o += 2, c.push(e.GSUB.readLigature(r, l + h));
      }
      return c;
    }, e.GSUB.readLigature = function(r, o) {
      var a = e._bin, l = { chain: [] };
      l.nglyph = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      o += 2;
      for (var u = 0; u < c - 1; u++) l.chain.push(a.readUshort(r, o)), o += 2;
      return l;
    }, e.head = {}, e.head.parse = function(r, o, a) {
      var l = e._bin, c = {};
      return l.readFixed(r, o), o += 4, c.fontRevision = l.readFixed(r, o), o += 4, l.readUint(r, o), o += 4, l.readUint(r, o), o += 4, c.flags = l.readUshort(r, o), o += 2, c.unitsPerEm = l.readUshort(r, o), o += 2, c.created = l.readUint64(r, o), o += 8, c.modified = l.readUint64(r, o), o += 8, c.xMin = l.readShort(r, o), o += 2, c.yMin = l.readShort(r, o), o += 2, c.xMax = l.readShort(r, o), o += 2, c.yMax = l.readShort(r, o), o += 2, c.macStyle = l.readUshort(r, o), o += 2, c.lowestRecPPEM = l.readUshort(r, o), o += 2, c.fontDirectionHint = l.readShort(r, o), o += 2, c.indexToLocFormat = l.readShort(r, o), o += 2, c.glyphDataFormat = l.readShort(r, o), o += 2, c;
    }, e.hhea = {}, e.hhea.parse = function(r, o, a) {
      var l = e._bin, c = {};
      return l.readFixed(r, o), o += 4, c.ascender = l.readShort(r, o), o += 2, c.descender = l.readShort(r, o), o += 2, c.lineGap = l.readShort(r, o), o += 2, c.advanceWidthMax = l.readUshort(r, o), o += 2, c.minLeftSideBearing = l.readShort(r, o), o += 2, c.minRightSideBearing = l.readShort(r, o), o += 2, c.xMaxExtent = l.readShort(r, o), o += 2, c.caretSlopeRise = l.readShort(r, o), o += 2, c.caretSlopeRun = l.readShort(r, o), o += 2, c.caretOffset = l.readShort(r, o), o += 2, o += 8, c.metricDataFormat = l.readShort(r, o), o += 2, c.numberOfHMetrics = l.readUshort(r, o), o += 2, c;
    }, e.hmtx = {}, e.hmtx.parse = function(r, o, a, l) {
      for (var c = e._bin, u = { aWidth: [], lsBearing: [] }, d = 0, h = 0, m = 0; m < l.maxp.numGlyphs; m++) m < l.hhea.numberOfHMetrics && (d = c.readUshort(r, o), o += 2, h = c.readShort(r, o), o += 2), u.aWidth.push(d), u.lsBearing.push(h);
      return u;
    }, e.kern = {}, e.kern.parse = function(r, o, a, l) {
      var c = e._bin, u = c.readUshort(r, o);
      if (o += 2, u == 1) return e.kern.parseV1(r, o - 2, a, l);
      var d = c.readUshort(r, o);
      o += 2;
      for (var h = { glyph1: [], rval: [] }, m = 0; m < d; m++) {
        o += 2, a = c.readUshort(r, o), o += 2;
        var p = c.readUshort(r, o);
        o += 2;
        var v = p >>> 8;
        if ((v &= 15) != 0) throw "unknown kern table format: " + v;
        o = e.kern.readFormat0(r, o, h);
      }
      return h;
    }, e.kern.parseV1 = function(r, o, a, l) {
      var c = e._bin;
      c.readFixed(r, o), o += 4;
      var u = c.readUint(r, o);
      o += 4;
      for (var d = { glyph1: [], rval: [] }, h = 0; h < u; h++) {
        c.readUint(r, o), o += 4;
        var m = c.readUshort(r, o);
        o += 2, c.readUshort(r, o), o += 2;
        var p = m >>> 8;
        if ((p &= 15) != 0) throw "unknown kern table format: " + p;
        o = e.kern.readFormat0(r, o, d);
      }
      return d;
    }, e.kern.readFormat0 = function(r, o, a) {
      var l = e._bin, c = -1, u = l.readUshort(r, o);
      o += 2, l.readUshort(r, o), o += 2, l.readUshort(r, o), o += 2, l.readUshort(r, o), o += 2;
      for (var d = 0; d < u; d++) {
        var h = l.readUshort(r, o);
        o += 2;
        var m = l.readUshort(r, o);
        o += 2;
        var p = l.readShort(r, o);
        o += 2, h != c && (a.glyph1.push(h), a.rval.push({ glyph2: [], vals: [] }));
        var v = a.rval[a.rval.length - 1];
        v.glyph2.push(m), v.vals.push(p), c = h;
      }
      return o;
    }, e.loca = {}, e.loca.parse = function(r, o, a, l) {
      var c = e._bin, u = [], d = l.head.indexToLocFormat, h = l.maxp.numGlyphs + 1;
      if (d == 0) for (var m = 0; m < h; m++) u.push(c.readUshort(r, o + (m << 1)) << 1);
      if (d == 1) for (m = 0; m < h; m++) u.push(c.readUint(r, o + (m << 2)));
      return u;
    }, e.maxp = {}, e.maxp.parse = function(r, o, a) {
      var l = e._bin, c = {}, u = l.readUint(r, o);
      return o += 4, c.numGlyphs = l.readUshort(r, o), o += 2, u == 65536 && (c.maxPoints = l.readUshort(r, o), o += 2, c.maxContours = l.readUshort(r, o), o += 2, c.maxCompositePoints = l.readUshort(r, o), o += 2, c.maxCompositeContours = l.readUshort(r, o), o += 2, c.maxZones = l.readUshort(r, o), o += 2, c.maxTwilightPoints = l.readUshort(r, o), o += 2, c.maxStorage = l.readUshort(r, o), o += 2, c.maxFunctionDefs = l.readUshort(r, o), o += 2, c.maxInstructionDefs = l.readUshort(r, o), o += 2, c.maxStackElements = l.readUshort(r, o), o += 2, c.maxSizeOfInstructions = l.readUshort(r, o), o += 2, c.maxComponentElements = l.readUshort(r, o), o += 2, c.maxComponentDepth = l.readUshort(r, o), o += 2), c;
    }, e.name = {}, e.name.parse = function(r, o, a) {
      var l = e._bin, c = {};
      l.readUshort(r, o), o += 2;
      var u = l.readUshort(r, o);
      o += 2, l.readUshort(r, o);
      for (var d, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], m = o += 2, p = 0; p < u; p++) {
        var v = l.readUshort(r, o);
        o += 2;
        var x = l.readUshort(r, o);
        o += 2;
        var g = l.readUshort(r, o);
        o += 2;
        var _ = l.readUshort(r, o);
        o += 2;
        var M = l.readUshort(r, o);
        o += 2;
        var S = l.readUshort(r, o);
        o += 2;
        var b, C = h[_], E = m + 12 * u + S;
        if (v == 0) b = l.readUnicode(r, E, M / 2);
        else if (v == 3 && x == 0) b = l.readUnicode(r, E, M / 2);
        else if (x == 0) b = l.readASCII(r, E, M);
        else if (x == 1) b = l.readUnicode(r, E, M / 2);
        else if (x == 3) b = l.readUnicode(r, E, M / 2);
        else {
          if (v != 1) throw "unknown encoding " + x + ", platformID: " + v;
          b = l.readASCII(r, E, M), console.debug("reading unknown MAC encoding " + x + " as ASCII");
        }
        var P = "p" + v + "," + g.toString(16);
        c[P] == null && (c[P] = {}), c[P][C !== void 0 ? C : _] = b, c[P]._lang = g;
      }
      for (var T in c) if (c[T].postScriptName != null && c[T]._lang == 1033) return c[T];
      for (var T in c) if (c[T].postScriptName != null && c[T]._lang == 0) return c[T];
      for (var T in c) if (c[T].postScriptName != null && c[T]._lang == 3084) return c[T];
      for (var T in c) if (c[T].postScriptName != null) return c[T];
      for (var T in c) {
        d = T;
        break;
      }
      return console.debug("returning name table with languageID " + c[d]._lang), c[d];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(r, o, a) {
      var l = e._bin.readUshort(r, o);
      o += 2;
      var c = {};
      if (l == 0) e["OS/2"].version0(r, o, c);
      else if (l == 1) e["OS/2"].version1(r, o, c);
      else if (l == 2 || l == 3 || l == 4) e["OS/2"].version2(r, o, c);
      else {
        if (l != 5) throw "unknown OS/2 table version: " + l;
        e["OS/2"].version5(r, o, c);
      }
      return c;
    }, e["OS/2"].version0 = function(r, o, a) {
      var l = e._bin;
      return a.xAvgCharWidth = l.readShort(r, o), o += 2, a.usWeightClass = l.readUshort(r, o), o += 2, a.usWidthClass = l.readUshort(r, o), o += 2, a.fsType = l.readUshort(r, o), o += 2, a.ySubscriptXSize = l.readShort(r, o), o += 2, a.ySubscriptYSize = l.readShort(r, o), o += 2, a.ySubscriptXOffset = l.readShort(r, o), o += 2, a.ySubscriptYOffset = l.readShort(r, o), o += 2, a.ySuperscriptXSize = l.readShort(r, o), o += 2, a.ySuperscriptYSize = l.readShort(r, o), o += 2, a.ySuperscriptXOffset = l.readShort(r, o), o += 2, a.ySuperscriptYOffset = l.readShort(r, o), o += 2, a.yStrikeoutSize = l.readShort(r, o), o += 2, a.yStrikeoutPosition = l.readShort(r, o), o += 2, a.sFamilyClass = l.readShort(r, o), o += 2, a.panose = l.readBytes(r, o, 10), o += 10, a.ulUnicodeRange1 = l.readUint(r, o), o += 4, a.ulUnicodeRange2 = l.readUint(r, o), o += 4, a.ulUnicodeRange3 = l.readUint(r, o), o += 4, a.ulUnicodeRange4 = l.readUint(r, o), o += 4, a.achVendID = [l.readInt8(r, o), l.readInt8(r, o + 1), l.readInt8(r, o + 2), l.readInt8(r, o + 3)], o += 4, a.fsSelection = l.readUshort(r, o), o += 2, a.usFirstCharIndex = l.readUshort(r, o), o += 2, a.usLastCharIndex = l.readUshort(r, o), o += 2, a.sTypoAscender = l.readShort(r, o), o += 2, a.sTypoDescender = l.readShort(r, o), o += 2, a.sTypoLineGap = l.readShort(r, o), o += 2, a.usWinAscent = l.readUshort(r, o), o += 2, a.usWinDescent = l.readUshort(r, o), o += 2;
    }, e["OS/2"].version1 = function(r, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version0(r, o, a), a.ulCodePageRange1 = l.readUint(r, o), o += 4, a.ulCodePageRange2 = l.readUint(r, o), o += 4;
    }, e["OS/2"].version2 = function(r, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version1(r, o, a), a.sxHeight = l.readShort(r, o), o += 2, a.sCapHeight = l.readShort(r, o), o += 2, a.usDefault = l.readUshort(r, o), o += 2, a.usBreak = l.readUshort(r, o), o += 2, a.usMaxContext = l.readUshort(r, o), o += 2;
    }, e["OS/2"].version5 = function(r, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version2(r, o, a), a.usLowerOpticalPointSize = l.readUshort(r, o), o += 2, a.usUpperOpticalPointSize = l.readUshort(r, o), o += 2;
    }, e.post = {}, e.post.parse = function(r, o, a) {
      var l = e._bin, c = {};
      return c.version = l.readFixed(r, o), o += 4, c.italicAngle = l.readFixed(r, o), o += 4, c.underlinePosition = l.readShort(r, o), o += 2, c.underlineThickness = l.readShort(r, o), o += 2, c;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(r, o) {
      var a = r.cmap, l = -1;
      if (a.p0e4 != null ? l = a.p0e4 : a.p3e1 != null ? l = a.p3e1 : a.p1e0 != null ? l = a.p1e0 : a.p0e3 != null && (l = a.p0e3), l == -1) throw "no familiar platform and encoding!";
      var c = a.tables[l];
      if (c.format == 0) return o >= c.map.length ? 0 : c.map[o];
      if (c.format == 4) {
        for (var u = -1, d = 0; d < c.endCount.length; d++) if (o <= c.endCount[d]) {
          u = d;
          break;
        }
        return u == -1 || c.startCount[u] > o ? 0 : 65535 & (c.idRangeOffset[u] != 0 ? c.glyphIdArray[o - c.startCount[u] + (c.idRangeOffset[u] >> 1) - (c.idRangeOffset.length - u)] : o + c.idDelta[u]);
      }
      if (c.format == 12) {
        if (o > c.groups[c.groups.length - 1][1]) return 0;
        for (d = 0; d < c.groups.length; d++) {
          var h = c.groups[d];
          if (h[0] <= o && o <= h[1]) return h[2] + (o - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + c.format;
    }, e.U.glyphToPath = function(r, o) {
      var a = { cmds: [], crds: [] };
      if (r.SVG && r.SVG.entries[o]) {
        var l = r.SVG.entries[o];
        return l == null ? a : (typeof l == "string" && (l = e.SVG.toPath(l), r.SVG.entries[o] = l), l);
      }
      if (r.CFF) {
        var c = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: r.CFF.Private ? r.CFF.Private.defaultWidthX : 0, open: !1 }, u = r.CFF, d = r.CFF.Private;
        if (u.ROS) {
          for (var h = 0; u.FDSelect[h + 2] <= o; ) h += 2;
          d = u.FDArray[u.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r.CFF.CharStrings[o], c, u, d, a);
      } else r.glyf && e.U._drawGlyf(o, r, a);
      return a;
    }, e.U._drawGlyf = function(r, o, a) {
      var l = o.glyf[r];
      l == null && (l = o.glyf[r] = e.glyf._parseGlyf(o, r)), l != null && (l.noc > -1 ? e.U._simpleGlyph(l, a) : e.U._compoGlyph(l, o, a));
    }, e.U._simpleGlyph = function(r, o) {
      for (var a = 0; a < r.noc; a++) {
        for (var l = a == 0 ? 0 : r.endPts[a - 1] + 1, c = r.endPts[a], u = l; u <= c; u++) {
          var d = u == l ? c : u - 1, h = u == c ? l : u + 1, m = 1 & r.flags[u], p = 1 & r.flags[d], v = 1 & r.flags[h], x = r.xs[u], g = r.ys[u];
          if (u == l) if (m) {
            if (!p) {
              e.U.P.moveTo(o, x, g);
              continue;
            }
            e.U.P.moveTo(o, r.xs[d], r.ys[d]);
          } else p ? e.U.P.moveTo(o, r.xs[d], r.ys[d]) : e.U.P.moveTo(o, (r.xs[d] + x) / 2, (r.ys[d] + g) / 2);
          m ? p && e.U.P.lineTo(o, x, g) : v ? e.U.P.qcurveTo(o, x, g, r.xs[h], r.ys[h]) : e.U.P.qcurveTo(o, x, g, (x + r.xs[h]) / 2, (g + r.ys[h]) / 2);
        }
        e.U.P.closePath(o);
      }
    }, e.U._compoGlyph = function(r, o, a) {
      for (var l = 0; l < r.parts.length; l++) {
        var c = { cmds: [], crds: [] }, u = r.parts[l];
        e.U._drawGlyf(u.glyphIndex, o, c);
        for (var d = u.m, h = 0; h < c.crds.length; h += 2) {
          var m = c.crds[h], p = c.crds[h + 1];
          a.crds.push(m * d.a + p * d.b + d.tx), a.crds.push(m * d.c + p * d.d + d.ty);
        }
        for (h = 0; h < c.cmds.length; h++) a.cmds.push(c.cmds[h]);
      }
    }, e.U._getGlyphClass = function(r, o) {
      var a = e._lctf.getInterval(o, r);
      return a == -1 ? 0 : o[a + 2];
    }, e.U._applySubs = function(r, o, a, l) {
      for (var c = r.length - o - 1, u = 0; u < a.tabs.length; u++) if (a.tabs[u] != null) {
        var d, h = a.tabs[u];
        if (!h.coverage || (d = e._lctf.coverageIndex(h.coverage, r[o])) != -1) {
          if (a.ltype == 1) r[o], h.fmt == 1 ? r[o] = r[o] + h.delta : r[o] = h.newg[d];
          else if (a.ltype == 4) for (var m = h.vals[d], p = 0; p < m.length; p++) {
            var v = m[p], x = v.chain.length;
            if (!(x > c)) {
              for (var g = !0, _ = 0, M = 0; M < x; M++) {
                for (; r[o + _ + (1 + M)] == -1; ) _++;
                v.chain[M] != r[o + _ + (1 + M)] && (g = !1);
              }
              if (g) {
                for (r[o] = v.nglyph, M = 0; M < x + _; M++) r[o + M + 1] = -1;
                break;
              }
            }
          }
          else if (a.ltype == 5 && h.fmt == 2) for (var S = e._lctf.getInterval(h.cDef, r[o]), b = h.cDef[S + 2], C = h.scset[b], E = 0; E < C.length; E++) {
            var P = C[E], T = P.input;
            if (!(T.length > c)) {
              for (g = !0, M = 0; M < T.length; M++) {
                var y = e._lctf.getInterval(h.cDef, r[o + 1 + M]);
                if (S == -1 && h.cDef[y + 2] != T[M]) {
                  g = !1;
                  break;
                }
              }
              if (g) {
                var w = P.substLookupRecords;
                for (p = 0; p < w.length; p += 2) w[p], w[p + 1];
              }
            }
          }
          else if (a.ltype == 6 && h.fmt == 3) {
            if (!e.U._glsCovered(r, h.backCvg, o - h.backCvg.length) || !e.U._glsCovered(r, h.inptCvg, o) || !e.U._glsCovered(r, h.ahedCvg, o + h.inptCvg.length)) continue;
            var D = h.lookupRec;
            for (E = 0; E < D.length; E += 2) {
              S = D[E];
              var U = l[D[E + 1]];
              e.U._applySubs(r, o + S, U, l);
            }
          }
        }
      }
    }, e.U._glsCovered = function(r, o, a) {
      for (var l = 0; l < o.length; l++)
        if (e._lctf.coverageIndex(o[l], r[a + l]) == -1) return !1;
      return !0;
    }, e.U.glyphsToPath = function(r, o, a) {
      for (var l = { cmds: [], crds: [] }, c = 0, u = 0; u < o.length; u++) {
        var d = o[u];
        if (d != -1) {
          for (var h = u < o.length - 1 && o[u + 1] != -1 ? o[u + 1] : 0, m = e.U.glyphToPath(r, d), p = 0; p < m.crds.length; p += 2) l.crds.push(m.crds[p] + c), l.crds.push(m.crds[p + 1]);
          for (a && l.cmds.push(a), p = 0; p < m.cmds.length; p++) l.cmds.push(m.cmds[p]);
          a && l.cmds.push("X"), c += r.hmtx.aWidth[d], u < o.length - 1 && (c += e.U.getPairAdjustment(r, d, h));
        }
      }
      return l;
    }, e.U.P = {}, e.U.P.moveTo = function(r, o, a) {
      r.cmds.push("M"), r.crds.push(o, a);
    }, e.U.P.lineTo = function(r, o, a) {
      r.cmds.push("L"), r.crds.push(o, a);
    }, e.U.P.curveTo = function(r, o, a, l, c, u, d) {
      r.cmds.push("C"), r.crds.push(o, a, l, c, u, d);
    }, e.U.P.qcurveTo = function(r, o, a, l, c) {
      r.cmds.push("Q"), r.crds.push(o, a, l, c);
    }, e.U.P.closePath = function(r) {
      r.cmds.push("Z");
    }, e.U._drawCFF = function(r, o, a, l, c) {
      for (var u = o.stack, d = o.nStems, h = o.haveWidth, m = o.width, p = o.open, v = 0, x = o.x, g = o.y, _ = 0, M = 0, S = 0, b = 0, C = 0, E = 0, P = 0, T = 0, y = 0, w = 0, D = { val: 0, size: 0 }; v < r.length; ) {
        e.CFF.getCharString(r, v, D);
        var U = D.val;
        if (v += D.size, U == "o1" || U == "o18") u.length % 2 != 0 && !h && (m = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0;
        else if (U == "o3" || U == "o23")
          u.length % 2 != 0 && !h && (m = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0;
        else if (U == "o4") u.length > 1 && !h && (m = u.shift() + l.nominalWidthX, h = !0), p && e.U.P.closePath(c), g += u.pop(), e.U.P.moveTo(c, x, g), p = !0;
        else if (U == "o5") for (; u.length > 0; ) x += u.shift(), g += u.shift(), e.U.P.lineTo(c, x, g);
        else if (U == "o6" || U == "o7") for (var R = u.length, O = U == "o6", A = 0; A < R; A++) {
          var G = u.shift();
          O ? x += G : g += G, O = !O, e.U.P.lineTo(c, x, g);
        }
        else if (U == "o8" || U == "o24") {
          R = u.length;
          for (var ue = 0; ue + 6 <= R; ) _ = x + u.shift(), M = g + u.shift(), S = _ + u.shift(), b = M + u.shift(), x = S + u.shift(), g = b + u.shift(), e.U.P.curveTo(c, _, M, S, b, x, g), ue += 6;
          U == "o24" && (x += u.shift(), g += u.shift(), e.U.P.lineTo(c, x, g));
        } else {
          if (U == "o11") break;
          if (U == "o1234" || U == "o1235" || U == "o1236" || U == "o1237") U == "o1234" && (M = g, S = (_ = x + u.shift()) + u.shift(), w = b = M + u.shift(), E = b, T = g, x = (P = (C = (y = S + u.shift()) + u.shift()) + u.shift()) + u.shift(), e.U.P.curveTo(c, _, M, S, b, y, w), e.U.P.curveTo(c, C, E, P, T, x, g)), U == "o1235" && (_ = x + u.shift(), M = g + u.shift(), S = _ + u.shift(), b = M + u.shift(), y = S + u.shift(), w = b + u.shift(), C = y + u.shift(), E = w + u.shift(), P = C + u.shift(), T = E + u.shift(), x = P + u.shift(), g = T + u.shift(), u.shift(), e.U.P.curveTo(c, _, M, S, b, y, w), e.U.P.curveTo(c, C, E, P, T, x, g)), U == "o1236" && (_ = x + u.shift(), M = g + u.shift(), S = _ + u.shift(), w = b = M + u.shift(), E = b, P = (C = (y = S + u.shift()) + u.shift()) + u.shift(), T = E + u.shift(), x = P + u.shift(), e.U.P.curveTo(c, _, M, S, b, y, w), e.U.P.curveTo(c, C, E, P, T, x, g)), U == "o1237" && (_ = x + u.shift(), M = g + u.shift(), S = _ + u.shift(), b = M + u.shift(), y = S + u.shift(), w = b + u.shift(), C = y + u.shift(), E = w + u.shift(), P = C + u.shift(), T = E + u.shift(), Math.abs(P - x) > Math.abs(T - g) ? x = P + u.shift() : g = T + u.shift(), e.U.P.curveTo(c, _, M, S, b, y, w), e.U.P.curveTo(c, C, E, P, T, x, g));
          else if (U == "o14") {
            if (u.length > 0 && !h && (m = u.shift() + a.nominalWidthX, h = !0), u.length == 4) {
              var Q = u.shift(), le = u.shift(), re = u.shift(), j = u.shift(), $ = e.CFF.glyphBySE(a, re), q = e.CFF.glyphBySE(a, j);
              e.U._drawCFF(a.CharStrings[$], o, a, l, c), o.x = Q, o.y = le, e.U._drawCFF(a.CharStrings[q], o, a, l, c);
            }
            p && (e.U.P.closePath(c), p = !1);
          } else if (U == "o19" || U == "o20")
            u.length % 2 != 0 && !h && (m = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0, v += d + 7 >> 3;
          else if (U == "o21") u.length > 2 && !h && (m = u.shift() + l.nominalWidthX, h = !0), g += u.pop(), x += u.pop(), p && e.U.P.closePath(c), e.U.P.moveTo(c, x, g), p = !0;
          else if (U == "o22") u.length > 1 && !h && (m = u.shift() + l.nominalWidthX, h = !0), x += u.pop(), p && e.U.P.closePath(c), e.U.P.moveTo(c, x, g), p = !0;
          else if (U == "o25") {
            for (; u.length > 6; ) x += u.shift(), g += u.shift(), e.U.P.lineTo(c, x, g);
            _ = x + u.shift(), M = g + u.shift(), S = _ + u.shift(), b = M + u.shift(), x = S + u.shift(), g = b + u.shift(), e.U.P.curveTo(c, _, M, S, b, x, g);
          } else if (U == "o26") for (u.length % 2 && (x += u.shift()); u.length > 0; ) _ = x, M = g + u.shift(), x = S = _ + u.shift(), g = (b = M + u.shift()) + u.shift(), e.U.P.curveTo(c, _, M, S, b, x, g);
          else if (U == "o27") for (u.length % 2 && (g += u.shift()); u.length > 0; ) M = g, S = (_ = x + u.shift()) + u.shift(), b = M + u.shift(), x = S + u.shift(), g = b, e.U.P.curveTo(c, _, M, S, b, x, g);
          else if (U == "o10" || U == "o29") {
            var oe = U == "o10" ? l : a;
            if (u.length == 0) console.debug("error: empty stack");
            else {
              var ie = u.pop(), ce = oe.Subrs[ie + oe.Bias];
              o.x = x, o.y = g, o.nStems = d, o.haveWidth = h, o.width = m, o.open = p, e.U._drawCFF(ce, o, a, l, c), x = o.x, g = o.y, d = o.nStems, h = o.haveWidth, m = o.width, p = o.open;
            }
          } else if (U == "o30" || U == "o31") {
            var V = u.length, Y = (ue = 0, U == "o31");
            for (ue += V - (R = -3 & V); ue < R; ) Y ? (M = g, S = (_ = x + u.shift()) + u.shift(), g = (b = M + u.shift()) + u.shift(), R - ue == 5 ? (x = S + u.shift(), ue++) : x = S, Y = !1) : (_ = x, M = g + u.shift(), S = _ + u.shift(), b = M + u.shift(), x = S + u.shift(), R - ue == 5 ? (g = b + u.shift(), ue++) : g = b, Y = !0), e.U.P.curveTo(c, _, M, S, b, x, g), ue += 4;
          } else {
            if ((U + "").charAt(0) == "o") throw console.debug("Unknown operation: " + U, r), U;
            u.push(U);
          }
        }
      }
      o.x = x, o.y = g, o.nStems = d, o.haveWidth = h, o.width = m, o.open = p;
    };
    var n = e, i = { Typr: n };
    return s.Typr = n, s.default = i, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function gN() {
  return function(s) {
    var e = Uint8Array, n = Uint16Array, i = Uint32Array, r = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), o = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), a = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), l = function(U, R) {
      for (var O = new n(31), A = 0; A < 31; ++A) O[A] = R += 1 << U[A - 1];
      var G = new i(O[30]);
      for (A = 1; A < 30; ++A) for (var ue = O[A]; ue < O[A + 1]; ++ue) G[ue] = ue - O[A] << 5 | A;
      return [O, G];
    }, c = l(r, 2), u = c[0], d = c[1];
    u[28] = 258, d[258] = 28;
    for (var h = l(o, 0)[0], m = new n(32768), p = 0; p < 32768; ++p) {
      var v = (43690 & p) >>> 1 | (21845 & p) << 1;
      v = (61680 & (v = (52428 & v) >>> 2 | (13107 & v) << 2)) >>> 4 | (3855 & v) << 4, m[p] = ((65280 & v) >>> 8 | (255 & v) << 8) >>> 1;
    }
    var x = function(U, R, O) {
      for (var A = U.length, G = 0, ue = new n(R); G < A; ++G) ++ue[U[G] - 1];
      var Q, le = new n(R);
      for (G = 0; G < R; ++G) le[G] = le[G - 1] + ue[G - 1] << 1;
      {
        Q = new n(1 << R);
        var re = 15 - R;
        for (G = 0; G < A; ++G) if (U[G]) for (var j = G << 4 | U[G], $ = R - U[G], q = le[U[G] - 1]++ << $, oe = q | (1 << $) - 1; q <= oe; ++q) Q[m[q] >>> re] = j;
      }
      return Q;
    }, g = new e(288);
    for (p = 0; p < 144; ++p) g[p] = 8;
    for (p = 144; p < 256; ++p) g[p] = 9;
    for (p = 256; p < 280; ++p) g[p] = 7;
    for (p = 280; p < 288; ++p) g[p] = 8;
    var _ = new e(32);
    for (p = 0; p < 32; ++p) _[p] = 5;
    var M = x(g, 9), S = x(_, 5), b = function(U) {
      for (var R = U[0], O = 1; O < U.length; ++O) U[O] > R && (R = U[O]);
      return R;
    }, C = function(U, R, O) {
      var A = R / 8 | 0;
      return (U[A] | U[A + 1] << 8) >> (7 & R) & O;
    }, E = function(U, R) {
      var O = R / 8 | 0;
      return (U[O] | U[O + 1] << 8 | U[O + 2] << 16) >> (7 & R);
    }, P = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T = function(U, R, O) {
      var A = new Error(R || P[U]);
      if (A.code = U, Error.captureStackTrace && Error.captureStackTrace(A, T), !O) throw A;
      return A;
    }, y = function(U, R, O) {
      var A = U.length;
      if (!A || O && !O.l && A < 5) return R || new e(0);
      var G = !R || O, ue = !O || O.i;
      O || (O = {}), R || (R = new e(3 * A));
      var Q, le = function(Le) {
        var nt = R.length;
        if (Le > nt) {
          var Je = new e(Math.max(2 * nt, Le));
          Je.set(R), R = Je;
        }
      }, re = O.f || 0, j = O.p || 0, $ = O.b || 0, q = O.l, oe = O.d, ie = O.m, ce = O.n, V = 8 * A;
      do {
        if (!q) {
          O.f = re = C(U, j, 1);
          var Y = C(U, j + 1, 3);
          if (j += 3, !Y) {
            var H = U[(se = ((Q = j) / 8 | 0) + (7 & Q && 1) + 4) - 4] | U[se - 3] << 8, I = se + H;
            if (I > A) {
              ue && T(0);
              break;
            }
            G && le($ + H), R.set(U.subarray(se, I), $), O.b = $ += H, O.p = j = 8 * I;
            continue;
          }
          if (Y == 1) q = M, oe = S, ie = 9, ce = 5;
          else if (Y == 2) {
            var F = C(U, j, 31) + 257, L = C(U, j + 10, 15) + 4, ee = F + C(U, j + 5, 31) + 1;
            j += 14;
            for (var Z = new e(ee), k = new e(19), ne = 0; ne < L; ++ne) k[a[ne]] = C(U, j + 3 * ne, 7);
            j += 3 * L;
            var J = b(k), B = (1 << J) - 1, X = x(k, J);
            for (ne = 0; ne < ee; ) {
              var se, z = X[C(U, j, B)];
              if (j += 15 & z, (se = z >>> 4) < 16) Z[ne++] = se;
              else {
                var N = 0, K = 0;
                for (se == 16 ? (K = 3 + C(U, j, 3), j += 2, N = Z[ne - 1]) : se == 17 ? (K = 3 + C(U, j, 7), j += 3) : se == 18 && (K = 11 + C(U, j, 127), j += 7); K--; ) Z[ne++] = N;
              }
            }
            var he = Z.subarray(0, F), me = Z.subarray(F);
            ie = b(he), ce = b(me), q = x(he, ie), oe = x(me, ce);
          } else T(1);
          if (j > V) {
            ue && T(0);
            break;
          }
        }
        G && le($ + 131072);
        for (var ge = (1 << ie) - 1, Me = (1 << ce) - 1, Te = j; ; Te = j) {
          var Ae = (N = q[E(U, j) & ge]) >>> 4;
          if ((j += 15 & N) > V) {
            ue && T(0);
            break;
          }
          if (N || T(2), Ae < 256) R[$++] = Ae;
          else {
            if (Ae == 256) {
              Te = j, q = null;
              break;
            }
            var Xe = Ae - 254;
            if (Ae > 264) {
              var Oe = r[ne = Ae - 257];
              Xe = C(U, j, (1 << Oe) - 1) + u[ne], j += Oe;
            }
            var He = oe[E(U, j) & Me], Ye = He >>> 4;
            if (He || T(3), j += 15 & He, me = h[Ye], Ye > 3 && (Oe = o[Ye], me += E(U, j) & (1 << Oe) - 1, j += Oe), j > V) {
              ue && T(0);
              break;
            }
            G && le($ + 131072);
            for (var $e = $ + Xe; $ < $e; $ += 4) R[$] = R[$ - me], R[$ + 1] = R[$ + 1 - me], R[$ + 2] = R[$ + 2 - me], R[$ + 3] = R[$ + 3 - me];
            $ = $e;
          }
        }
        O.l = q, O.p = Te, O.b = $, q && (re = 1, O.m = ie, O.d = oe, O.n = ce);
      } while (!re);
      return $ == R.length ? R : function(Le, nt, Je) {
        (Je == null || Je > Le.length) && (Je = Le.length);
        var bt = new (Le instanceof n ? n : Le instanceof i ? i : e)(Je - nt);
        return bt.set(Le.subarray(nt, Je)), bt;
      }(R, 0, $);
    }, w = new e(0), D = typeof TextDecoder < "u" && new TextDecoder();
    try {
      D.decode(w, { stream: !0 });
    } catch {
    }
    return s.convert_streams = function(U) {
      var R = new DataView(U), O = 0;
      function A() {
        var F = R.getUint16(O);
        return O += 2, F;
      }
      function G() {
        var F = R.getUint32(O);
        return O += 4, F;
      }
      function ue(F) {
        H.setUint16(I, F), I += 2;
      }
      function Q(F) {
        H.setUint32(I, F), I += 4;
      }
      for (var le = { signature: G(), flavor: G(), length: G(), numTables: A(), reserved: A(), totalSfntSize: G(), majorVersion: A(), minorVersion: A(), metaOffset: G(), metaLength: G(), metaOrigLength: G(), privOffset: G(), privLength: G() }, re = 0; Math.pow(2, re) <= le.numTables; ) re++;
      re--;
      for (var j = 16 * Math.pow(2, re), $ = 16 * le.numTables - j, q = 12, oe = [], ie = 0; ie < le.numTables; ie++) oe.push({ tag: G(), offset: G(), compLength: G(), origLength: G(), origChecksum: G() }), q += 16;
      var ce, V = new Uint8Array(12 + 16 * oe.length + oe.reduce(function(F, L) {
        return F + L.origLength + 4;
      }, 0)), Y = V.buffer, H = new DataView(Y), I = 0;
      return Q(le.flavor), ue(le.numTables), ue(j), ue(re), ue($), oe.forEach(function(F) {
        Q(F.tag), Q(F.origChecksum), Q(q), Q(F.origLength), F.outOffset = q, (q += F.origLength) % 4 != 0 && (q += 4 - q % 4);
      }), oe.forEach(function(F) {
        var L, ee = U.slice(F.offset, F.offset + F.compLength);
        if (F.compLength != F.origLength) {
          var Z = new Uint8Array(F.origLength);
          L = new Uint8Array(ee, 2), y(L, Z);
        } else Z = new Uint8Array(ee);
        V.set(Z, F.outOffset);
        var k = 0;
        (q = F.outOffset + F.origLength) % 4 != 0 && (k = 4 - q % 4), V.set(new Uint8Array(k).buffer, F.outOffset + F.origLength), ce = q + k;
      }), Y.slice(0, ce);
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).convert_streams;
}
function yN(s, e) {
  const n = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, i = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, r = 1, o = 2, a = 4, l = 8, c = 16, u = 32;
  let d;
  function h(P) {
    if (!d) {
      const T = {
        R: o,
        L: r,
        D: a,
        C: c,
        U: u,
        T: l
      };
      d = /* @__PURE__ */ new Map();
      for (let y in i) {
        let w = 0;
        i[y].split(",").forEach((D) => {
          let [U, R] = D.split("+");
          U = parseInt(U, 36), R = R ? parseInt(R, 36) : 0, d.set(w += U, T[y]);
          for (let O = R; O--; )
            d.set(++w, T[y]);
        });
      }
    }
    return d.get(P) || u;
  }
  const m = 1, p = 2, v = 3, x = 4, g = [null, "isol", "init", "fina", "medi"];
  function _(P) {
    const T = new Uint8Array(P.length);
    let y = u, w = m, D = -1;
    for (let U = 0; U < P.length; U++) {
      const R = P.codePointAt(U);
      let O = h(R) | 0, A = m;
      O & l || (y & (r | a | c) ? O & (o | a | c) ? (A = v, (w === m || w === v) && T[D]++) : O & (r | u) && (w === p || w === x) && T[D]-- : y & (o | u) && (w === p || w === x) && T[D]--, w = T[U] = A, y = O, D = U, R > 65535 && U++);
    }
    return T;
  }
  function M(P, T) {
    const y = [];
    for (let D = 0; D < T.length; D++) {
      const U = T.codePointAt(D);
      U > 65535 && D++, y.push(s.U.codeToGlyph(P, U));
    }
    const w = P.GSUB;
    if (w) {
      const { lookupList: D, featureList: U } = w;
      let R;
      const O = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/, A = [];
      U.forEach((G) => {
        if (O.test(G.tag))
          for (let ue = 0; ue < G.tab.length; ue++) {
            if (A[G.tab[ue]]) continue;
            A[G.tab[ue]] = !0;
            const Q = D[G.tab[ue]], le = /^(isol|init|fina|medi)$/.test(G.tag);
            le && !R && (R = _(T));
            for (let re = 0; re < y.length; re++)
              (!R || !le || g[R[re]] === G.tag) && s.U._applySubs(y, re, Q, D);
          }
      });
    }
    return y;
  }
  function S(P, T) {
    const y = new Int16Array(T.length * 3);
    let w = 0;
    for (; w < T.length; w++) {
      const O = T[w];
      if (O === -1) continue;
      y[w * 3 + 2] = P.hmtx.aWidth[O];
      const A = P.GPOS;
      if (A) {
        const G = A.lookupList;
        for (let ue = 0; ue < G.length; ue++) {
          const Q = G[ue];
          for (let le = 0; le < Q.tabs.length; le++) {
            const re = Q.tabs[le];
            if (Q.ltype === 1) {
              if (s._lctf.coverageIndex(re.coverage, O) !== -1 && re.pos) {
                R(re.pos, w);
                break;
              }
            } else if (Q.ltype === 2) {
              let j = null, $ = D();
              if ($ !== -1) {
                const q = s._lctf.coverageIndex(re.coverage, T[$]);
                if (q !== -1) {
                  if (re.fmt === 1) {
                    const oe = re.pairsets[q];
                    for (let ie = 0; ie < oe.length; ie++)
                      oe[ie].gid2 === O && (j = oe[ie]);
                  } else if (re.fmt === 2) {
                    const oe = s.U._getGlyphClass(T[$], re.classDef1), ie = s.U._getGlyphClass(O, re.classDef2);
                    j = re.matrix[oe][ie];
                  }
                  if (j) {
                    j.val1 && R(j.val1, $), j.val2 && R(j.val2, w);
                    break;
                  }
                }
              }
            } else if (Q.ltype === 4) {
              const j = s._lctf.coverageIndex(re.markCoverage, O);
              if (j !== -1) {
                const $ = D(U), q = $ === -1 ? -1 : s._lctf.coverageIndex(re.baseCoverage, T[$]);
                if (q !== -1) {
                  const oe = re.markArray[j], ie = re.baseArray[q][oe.markClass];
                  y[w * 3] = ie.x - oe.x + y[$ * 3] - y[$ * 3 + 2], y[w * 3 + 1] = ie.y - oe.y + y[$ * 3 + 1];
                  break;
                }
              }
            } else if (Q.ltype === 6) {
              const j = s._lctf.coverageIndex(re.mark1Coverage, O);
              if (j !== -1) {
                const $ = D();
                if ($ !== -1) {
                  const q = T[$];
                  if (b(P, q) === 3) {
                    const oe = s._lctf.coverageIndex(re.mark2Coverage, q);
                    if (oe !== -1) {
                      const ie = re.mark1Array[j], ce = re.mark2Array[oe][ie.markClass];
                      y[w * 3] = ce.x - ie.x + y[$ * 3] - y[$ * 3 + 2], y[w * 3 + 1] = ce.y - ie.y + y[$ * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (P.kern && !P.cff) {
        const G = D();
        if (G !== -1) {
          const ue = P.kern.glyph1.indexOf(T[G]);
          if (ue !== -1) {
            const Q = P.kern.rval[ue].glyph2.indexOf(O);
            Q !== -1 && (y[G * 3 + 2] += P.kern.rval[ue].vals[Q]);
          }
        }
      }
    }
    return y;
    function D(O) {
      for (let A = w - 1; A >= 0; A--)
        if (T[A] !== -1 && (!O || O(T[A])))
          return A;
      return -1;
    }
    function U(O) {
      return b(P, O) === 1;
    }
    function R(O, A) {
      for (let G = 0; G < 3; G++)
        y[A * 3 + G] += O[G] || 0;
    }
  }
  function b(P, T) {
    const y = P.GDEF && P.GDEF.glyphClassDef;
    return y ? s.U._getGlyphClass(T, y) : 0;
  }
  function C(...P) {
    for (let T = 0; T < P.length; T++)
      if (typeof P[T] == "number")
        return P[T];
  }
  function E(P) {
    const T = /* @__PURE__ */ Object.create(null), y = P["OS/2"], w = P.hhea, D = P.head.unitsPerEm, U = C(y && y.sTypoAscender, w && w.ascender, D), R = {
      unitsPerEm: D,
      ascender: U,
      descender: C(y && y.sTypoDescender, w && w.descender, 0),
      capHeight: C(y && y.sCapHeight, U),
      xHeight: C(y && y.sxHeight, U),
      lineGap: C(y && y.sTypoLineGap, w && w.lineGap),
      supportsCodePoint(O) {
        return s.U.codeToGlyph(P, O) > 0;
      },
      forEachGlyph(O, A, G, ue) {
        let Q = 0;
        const le = 1 / R.unitsPerEm * A, re = M(P, O);
        let j = 0;
        const $ = S(P, re);
        return re.forEach((q, oe) => {
          if (q !== -1) {
            let ie = T[q];
            if (!ie) {
              const { cmds: ce, crds: V } = s.U.glyphToPath(P, q);
              let Y = "", H = 0;
              for (let Z = 0, k = ce.length; Z < k; Z++) {
                const ne = n[ce[Z]];
                Y += ce[Z];
                for (let J = 1; J <= ne; J++)
                  Y += (J > 1 ? "," : "") + V[H++];
              }
              let I, F, L, ee;
              if (V.length) {
                I = F = 1 / 0, L = ee = -1 / 0;
                for (let Z = 0, k = V.length; Z < k; Z += 2) {
                  let ne = V[Z], J = V[Z + 1];
                  ne < I && (I = ne), J < F && (F = J), ne > L && (L = ne), J > ee && (ee = J);
                }
              } else
                I = L = F = ee = 0;
              ie = T[q] = {
                index: q,
                advanceWidth: P.hmtx.aWidth[q],
                xMin: I,
                yMin: F,
                xMax: L,
                yMax: ee,
                path: Y
              };
            }
            ue.call(
              null,
              ie,
              Q + $[oe * 3] * le,
              $[oe * 3 + 1] * le,
              j
            ), Q += $[oe * 3 + 2] * le, G && (Q += G * A);
          }
          j += O.codePointAt(j) > 65535 ? 2 : 1;
        }), Q;
      }
    };
    return R;
  }
  return function(T) {
    const y = new Uint8Array(T, 0, 4), w = s._bin.readASCII(y, 0, 4);
    if (w === "wOFF")
      T = e(T);
    else if (w === "wOF2")
      throw new Error("woff2 fonts not supported");
    return E(s.parse(T)[0]);
  };
}
const _N = /* @__PURE__ */ ea({
  name: "Typr Font Parser",
  dependencies: [vN, gN, yN],
  init(s, e, n) {
    const i = s(), r = e();
    return n(i, r);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function xN() {
  return function(s) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(S) {
      var b = S >> 5;
      this.buckets.set(b, (this.buckets.get(b) || 0) | 1 << (31 & S));
    }, e.prototype.has = function(S) {
      var b = this.buckets.get(S >> 5);
      return b !== void 0 && (b & 1 << (31 & S)) != 0;
    }, e.prototype.serialize = function() {
      var S = [];
      return this.buckets.forEach(function(b, C) {
        S.push((+C).toString(36) + ":" + b.toString(36));
      }), S.join(",");
    }, e.prototype.deserialize = function(S) {
      var b = this;
      this.buckets.clear(), S.split(",").forEach(function(C) {
        var E = C.split(":");
        b.buckets.set(parseInt(E[0], 36), parseInt(E[1], 36));
      });
    };
    var n = Math.pow(2, 8), i = n - 1, r = ~i;
    function o(S) {
      var b = function(E) {
        return E & r;
      }(S).toString(16), C = function(E) {
        return (E & r) + n - 1;
      }(S).toString(16);
      return "codepoint-index/plane" + (S >> 16) + "/" + b + "-" + C + ".json";
    }
    function a(S, b) {
      var C = S & i, E = b.codePointAt(C / 6 | 0);
      return ((E = (E || 48) - 48) & 1 << C % 6) != 0;
    }
    function l(S, b) {
      var C;
      (C = S, C.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(E) {
        return E.split("-").map(function(P) {
          return parseInt(P.trim(), 16);
        });
      })).forEach(function(E) {
        var P = E[0], T = E[1];
        T === void 0 && (T = P), b(P, T);
      });
    }
    function c(S, b) {
      l(S, function(C, E) {
        for (var P = C; P <= E; P++) b(P);
      });
    }
    var u = {}, d = {}, h = /* @__PURE__ */ new WeakMap(), m = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function p(S) {
      var b = h.get(S);
      return b || (b = new e(), c(S.ranges, function(C) {
        return b.add(C);
      }), h.set(S, b)), b;
    }
    var v, x = /* @__PURE__ */ new Map();
    function g(S, b, C) {
      return S[b] ? b : S[C] ? C : function(E) {
        for (var P in E) return P;
      }(S);
    }
    function _(S, b) {
      var C = b;
      if (!S.includes(C)) {
        C = 1 / 0;
        for (var E = 0; E < S.length; E++) Math.abs(S[E] - b) < Math.abs(C - b) && (C = S[E]);
      }
      return C;
    }
    function M(S) {
      return v || (v = /* @__PURE__ */ new Set(), c("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(b) {
        v.add(b);
      })), v.has(S);
    }
    return s.CodePointSet = e, s.clearCache = function() {
      u = {}, d = {};
    }, s.getFontsForString = function(S, b) {
      b === void 0 && (b = {});
      var C, E = b.lang;
      E === void 0 && (E = new RegExp("\\p{Script=Hangul}", "u").test(C = S) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(C) ? "ja" : "en");
      var P = b.category;
      P === void 0 && (P = "sans-serif");
      var T = b.style;
      T === void 0 && (T = "normal");
      var y = b.weight;
      y === void 0 && (y = 400);
      var w = (b.dataUrl || m).replace(/\/$/g, ""), D = /* @__PURE__ */ new Map(), U = new Uint8Array(S.length), R = {}, O = {}, A = new Array(S.length), G = /* @__PURE__ */ new Map(), ue = !1;
      function Q(j) {
        var $ = x.get(j);
        return $ || ($ = fetch(w + "/" + j).then(function(q) {
          if (!q.ok) throw new Error(q.statusText);
          return q.json().then(function(oe) {
            if (!Array.isArray(oe) || oe[0] !== 1) throw new Error("Incorrect schema version; need 1, got " + oe[0]);
            return oe[1];
          });
        }).catch(function(q) {
          if (w !== m) return ue || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + w + '", trying default CDN. ' + q.message), ue = !0), w = m, x.delete(j), Q(j);
          throw q;
        }), x.set(j, $)), $;
      }
      for (var le = function(j) {
        var $ = S.codePointAt(j), q = o($);
        A[j] = q, u[q] || G.has(q) || G.set(q, Q(q).then(function(oe) {
          u[q] = oe;
        })), $ > 65535 && (j++, re = j);
      }, re = 0; re < S.length; re++) le(re);
      return Promise.all(G.values()).then(function() {
        G.clear();
        for (var j = function(q) {
          var oe = S.codePointAt(q), ie = null, ce = u[A[q]], V = void 0;
          for (var Y in ce) {
            var H = O[Y];
            if (H === void 0 && (H = O[Y] = new RegExp(Y).test(E || "en")), H) {
              for (var I in V = Y, ce[Y]) if (a(oe, ce[Y][I])) {
                ie = I;
                break;
              }
              break;
            }
          }
          if (!ie) {
            e: for (var F in ce) if (F !== V) {
              for (var L in ce[F]) if (a(oe, ce[F][L])) {
                ie = L;
                break e;
              }
            }
          }
          ie || (console.debug("No font coverage for U+" + oe.toString(16)), ie = "latin"), A[q] = ie, d[ie] || G.has(ie) || G.set(ie, Q("font-meta/" + ie + ".json").then(function(ee) {
            d[ie] = ee;
          })), oe > 65535 && (q++, $ = q);
        }, $ = 0; $ < S.length; $++) j($);
        return Promise.all(G.values());
      }).then(function() {
        for (var j, $ = null, q = 0; q < S.length; q++) {
          var oe = S.codePointAt(q);
          if ($ && (M(oe) || p($).has(oe))) U[q] = U[q - 1];
          else {
            $ = d[A[q]];
            var ie = R[$.id];
            if (!ie) {
              var ce = $.typeforms, V = g(ce, P, "sans-serif"), Y = g(ce[V], T, "normal"), H = _((j = ce[V]) === null || j === void 0 ? void 0 : j[Y], y);
              ie = R[$.id] = w + "/font-files/" + $.id + "/" + V + "." + Y + "." + H + ".woff";
            }
            var I = D.get(ie);
            I == null && (I = D.size, D.set(ie, I)), U[q] = I;
          }
          oe > 65535 && (q++, U[q] = U[q - 1]);
        }
        return { fontUrls: Array.from(D.keys()), chars: U };
      });
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({});
}
function bN(s, e) {
  const n = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function r(a, l) {
    const c = (u) => {
      console.error(`Failure loading font ${a}`, u);
    };
    try {
      const u = new XMLHttpRequest();
      u.open("get", a, !0), u.responseType = "arraybuffer", u.onload = function() {
        if (u.status >= 400)
          c(new Error(u.statusText));
        else if (u.status > 0)
          try {
            const d = s(u.response);
            d.src = a, l(d);
          } catch (d) {
            c(d);
          }
      }, u.onerror = c, u.send();
    } catch (u) {
      c(u);
    }
  }
  function o(a, l) {
    let c = n[a];
    c ? l(c) : i[a] ? i[a].push(l) : (i[a] = [l], r(a, (u) => {
      u.src = a, n[a] = u, i[a].forEach((d) => d(u)), delete i[a];
    }));
  }
  return function(a, l, {
    lang: c,
    fonts: u = [],
    style: d = "normal",
    weight: h = "normal",
    unicodeFontsURL: m
  } = {}) {
    const p = new Uint8Array(a.length), v = [];
    a.length || M();
    const x = /* @__PURE__ */ new Map(), g = [];
    if (d !== "italic" && (d = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), u && !Array.isArray(u) && (u = [u]), u = u.slice().filter((b) => !b.lang || b.lang.test(c)).reverse(), u.length) {
      let P = 0;
      (function T(y = 0) {
        for (let w = y, D = a.length; w < D; w++) {
          const U = a.codePointAt(w);
          if (P === 1 && v[p[w - 1]].supportsCodePoint(U) || w > 0 && /\s/.test(a[w]))
            p[w] = p[w - 1], P === 2 && (g[g.length - 1][1] = w);
          else
            for (let R = p[w], O = u.length; R <= O; R++)
              if (R === O) {
                const A = P === 2 ? g[g.length - 1] : g[g.length] = [w, w];
                A[1] = w, P = 2;
              } else {
                p[w] = R;
                const { src: A, unicodeRange: G } = u[R];
                if (!G || S(U, G)) {
                  const ue = n[A];
                  if (!ue) {
                    o(A, () => {
                      T(w);
                    });
                    return;
                  }
                  if (ue.supportsCodePoint(U)) {
                    let Q = x.get(ue);
                    typeof Q != "number" && (Q = v.length, v.push(ue), x.set(ue, Q)), p[w] = Q, P = 1;
                    break;
                  }
                }
              }
          U > 65535 && w + 1 < D && (p[w + 1] = p[w], w++, P === 2 && (g[g.length - 1][1] = w));
        }
        _();
      })();
    } else
      g.push([0, a.length - 1]), _();
    function _() {
      if (g.length) {
        const b = g.map((C) => a.substring(C[0], C[1] + 1)).join(`
`);
        e.getFontsForString(b, {
          lang: c || void 0,
          style: d,
          weight: h,
          dataUrl: m
        }).then(({ fontUrls: C, chars: E }) => {
          const P = v.length;
          let T = 0;
          g.forEach((w) => {
            for (let D = 0, U = w[1] - w[0]; D <= U; D++)
              p[w[0] + D] = E[T++] + P;
            T++;
          });
          let y = 0;
          C.forEach((w, D) => {
            o(w, (U) => {
              v[D + P] = U, ++y === C.length && M();
            });
          });
        });
      } else
        M();
    }
    function M() {
      l({
        chars: p,
        fonts: v
      });
    }
    function S(b, C) {
      for (let E = 0; E < C.length; E++) {
        const [P, T = P] = C[E];
        if (P <= b && b <= T)
          return !0;
      }
      return !1;
    }
  };
}
const wN = /* @__PURE__ */ ea({
  name: "FontResolver",
  dependencies: [
    bN,
    _N,
    xN
  ],
  init(s, e, n) {
    return s(e, n());
  }
});
function SN(s, e) {
  const i = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, r = "[^\\S\\u00A0]", o = new RegExp(`${r}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function a({ text: v, lang: x, fonts: g, style: _, weight: M, preResolvedFonts: S, unicodeFontsURL: b }, C) {
    const E = ({ chars: P, fonts: T }) => {
      let y, w;
      const D = [];
      for (let U = 0; U < P.length; U++)
        P[U] !== w ? (w = P[U], D.push(y = { start: U, end: U, fontObj: T[P[U]] })) : y.end = U;
      C(D);
    };
    S ? E(S) : s(
      v,
      E,
      { lang: x, fonts: g, style: _, weight: M, unicodeFontsURL: b }
    );
  }
  function l({
    text: v = "",
    font: x,
    lang: g,
    sdfGlyphSize: _ = 64,
    fontSize: M = 400,
    fontWeight: S = 1,
    fontStyle: b = "normal",
    letterSpacing: C = 0,
    lineHeight: E = "normal",
    maxWidth: P = 1 / 0,
    direction: T,
    textAlign: y = "left",
    textIndent: w = 0,
    whiteSpace: D = "normal",
    overflowWrap: U = "normal",
    anchorX: R = 0,
    anchorY: O = 0,
    metricsOnly: A = !1,
    unicodeFontsURL: G,
    preResolvedFonts: ue = null,
    includeCaretPositions: Q = !1,
    chunkedBoundsSize: le = 8192,
    colorRanges: re = null
  }, j) {
    const $ = h(), q = { fontLoad: 0, typesetting: 0 };
    v.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), v = v.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), M = +M, C = +C, P = +P, E = E || "normal", w = +w, a({
      text: v,
      lang: g,
      style: b,
      weight: S,
      fonts: typeof x == "string" ? [{ src: x }] : x,
      unicodeFontsURL: G,
      preResolvedFonts: ue
    }, (oe) => {
      q.fontLoad = h() - $;
      const ie = isFinite(P);
      let ce = null, V = null, Y = null, H = null, I = null, F = null, L = null, ee = null, Z = 0, k = 0, ne = D !== "nowrap";
      const J = /* @__PURE__ */ new Map(), B = h();
      let X = w, se = 0, z = new m();
      const N = [z];
      oe.forEach((Me) => {
        const { fontObj: Te } = Me, { ascender: Ae, descender: Xe, unitsPerEm: Oe, lineGap: He, capHeight: Ye, xHeight: $e } = Te;
        let Le = J.get(Te);
        if (!Le) {
          const Ne = M / Oe, Re = E === "normal" ? (Ae - Xe + He) * Ne : E * M, Be = (Re - (Ae - Xe) * Ne) / 2, je = Math.min(Re, (Ae - Xe) * Ne), Ge = (Ae + Xe) / 2 * Ne + je / 2;
          Le = {
            index: J.size,
            src: Te.src,
            fontObj: Te,
            fontSizeMult: Ne,
            unitsPerEm: Oe,
            ascender: Ae * Ne,
            descender: Xe * Ne,
            capHeight: Ye * Ne,
            xHeight: $e * Ne,
            lineHeight: Re,
            baseline: -Be - Ae * Ne,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: Ge,
            caretBottom: Ge - je
          }, J.set(Te, Le);
        }
        const { fontSizeMult: nt } = Le, Je = v.slice(Me.start, Me.end + 1);
        let bt, Se;
        Te.forEachGlyph(Je, M, C, (Ne, Re, Be, je) => {
          Re += se, je += Me.start, bt = Re, Se = Ne;
          const Ge = v.charAt(je), ut = Ne.advanceWidth * nt, at = z.count;
          let dt;
          if ("isEmpty" in Ne || (Ne.isWhitespace = !!Ge && new RegExp(r).test(Ge), Ne.canBreakAfter = !!Ge && o.test(Ge), Ne.isEmpty = Ne.xMin === Ne.xMax || Ne.yMin === Ne.yMax || i.test(Ge)), !Ne.isWhitespace && !Ne.isEmpty && k++, ne && ie && !Ne.isWhitespace && Re + ut + X > P && at) {
            if (z.glyphAt(at - 1).glyphObj.canBreakAfter)
              dt = new m(), X = -Re;
            else
              for (let zt = at; zt--; )
                if (zt === 0 && U === "break-word") {
                  dt = new m(), X = -Re;
                  break;
                } else if (z.glyphAt(zt).glyphObj.canBreakAfter) {
                  dt = z.splitAt(zt + 1);
                  const Kt = dt.glyphAt(0).x;
                  X -= Kt;
                  for (let rn = dt.count; rn--; )
                    dt.glyphAt(rn).x -= Kt;
                  break;
                }
            dt && (z.isSoftWrapped = !0, z = dt, N.push(z), Z = P);
          }
          let pt = z.glyphAt(z.count);
          pt.glyphObj = Ne, pt.x = Re + X, pt.y = Be, pt.width = ut, pt.charIndex = je, pt.fontData = Le, Ge === `
` && (z = new m(), N.push(z), X = -(Re + ut + C * M) + w);
        }), se = bt + Se.advanceWidth * nt + C * M;
      });
      let K = 0;
      N.forEach((Me) => {
        let Te = !0;
        for (let Ae = Me.count; Ae--; ) {
          const Xe = Me.glyphAt(Ae);
          Te && !Xe.glyphObj.isWhitespace && (Me.width = Xe.x + Xe.width, Me.width > Z && (Z = Me.width), Te = !1);
          let { lineHeight: Oe, capHeight: He, xHeight: Ye, baseline: $e } = Xe.fontData;
          Oe > Me.lineHeight && (Me.lineHeight = Oe);
          const Le = $e - Me.baseline;
          Le < 0 && (Me.baseline += Le, Me.cap += Le, Me.ex += Le), Me.cap = Math.max(Me.cap, Me.baseline + He), Me.ex = Math.max(Me.ex, Me.baseline + Ye);
        }
        Me.baseline -= K, Me.cap -= K, Me.ex -= K, K += Me.lineHeight;
      });
      let he = 0, me = 0;
      if (R && (typeof R == "number" ? he = -R : typeof R == "string" && (he = -Z * (R === "left" ? 0 : R === "center" ? 0.5 : R === "right" ? 1 : u(R)))), O && (typeof O == "number" ? me = -O : typeof O == "string" && (me = O === "top" ? 0 : O === "top-baseline" ? -N[0].baseline : O === "top-cap" ? -N[0].cap : O === "top-ex" ? -N[0].ex : O === "middle" ? K / 2 : O === "bottom" ? K : O === "bottom-baseline" ? -N[N.length - 1].baseline : u(O) * K)), !A) {
        const Me = e.getEmbeddingLevels(v, T);
        ce = new Uint16Array(k), V = new Uint8Array(k), Y = new Float32Array(k * 2), H = {}, L = [1 / 0, 1 / 0, -1 / 0, -1 / 0], ee = [], Q && (F = new Float32Array(v.length * 4)), re && (I = new Uint8Array(k * 3));
        let Te = 0, Ae = -1, Xe = -1, Oe, He;
        if (N.forEach((Ye, $e) => {
          let { count: Le, width: nt } = Ye;
          if (Le > 0) {
            let Je = 0;
            for (let je = Le; je-- && Ye.glyphAt(je).glyphObj.isWhitespace; )
              Je++;
            let bt = 0, Se = 0;
            if (y === "center")
              bt = (Z - nt) / 2;
            else if (y === "right")
              bt = Z - nt;
            else if (y === "justify" && Ye.isSoftWrapped) {
              let je = 0;
              for (let Ge = Le - Je; Ge--; )
                Ye.glyphAt(Ge).glyphObj.isWhitespace && je++;
              Se = (Z - nt) / je;
            }
            if (Se || bt) {
              let je = 0;
              for (let Ge = 0; Ge < Le; Ge++) {
                let ut = Ye.glyphAt(Ge);
                const at = ut.glyphObj;
                ut.x += bt + je, Se !== 0 && at.isWhitespace && Ge < Le - Je && (je += Se, ut.width += Se);
              }
            }
            const Ne = e.getReorderSegments(
              v,
              Me,
              Ye.glyphAt(0).charIndex,
              Ye.glyphAt(Ye.count - 1).charIndex
            );
            for (let je = 0; je < Ne.length; je++) {
              const [Ge, ut] = Ne[je];
              let at = 1 / 0, dt = -1 / 0;
              for (let pt = 0; pt < Le; pt++)
                if (Ye.glyphAt(pt).charIndex >= Ge) {
                  let zt = pt, Kt = pt;
                  for (; Kt < Le; Kt++) {
                    let rn = Ye.glyphAt(Kt);
                    if (rn.charIndex > ut)
                      break;
                    Kt < Le - Je && (at = Math.min(at, rn.x), dt = Math.max(dt, rn.x + rn.width));
                  }
                  for (let rn = zt; rn < Kt; rn++) {
                    const Bn = Ye.glyphAt(rn);
                    Bn.x = dt - (Bn.x + Bn.width - at);
                  }
                  break;
                }
            }
            let Re;
            const Be = (je) => Re = je;
            for (let je = 0; je < Le; je++) {
              const Ge = Ye.glyphAt(je);
              Re = Ge.glyphObj;
              const ut = Re.index, at = Me.levels[Ge.charIndex] & 1;
              if (at) {
                const dt = e.getMirroredCharacter(v[Ge.charIndex]);
                dt && Ge.fontData.fontObj.forEachGlyph(dt, 0, 0, Be);
              }
              if (Q) {
                const { charIndex: dt, fontData: pt } = Ge, zt = Ge.x + he, Kt = Ge.x + Ge.width + he;
                F[dt * 4] = at ? Kt : zt, F[dt * 4 + 1] = at ? zt : Kt, F[dt * 4 + 2] = Ye.baseline + pt.caretBottom + me, F[dt * 4 + 3] = Ye.baseline + pt.caretTop + me;
                const rn = dt - Ae;
                rn > 1 && d(F, Ae, rn), Ae = dt;
              }
              if (re) {
                const { charIndex: dt } = Ge;
                for (; dt > Xe; )
                  Xe++, re.hasOwnProperty(Xe) && (He = re[Xe]);
              }
              if (!Re.isWhitespace && !Re.isEmpty) {
                const dt = Te++, { fontSizeMult: pt, src: zt, index: Kt } = Ge.fontData, rn = H[zt] || (H[zt] = {});
                rn[ut] || (rn[ut] = {
                  path: Re.path,
                  pathBounds: [Re.xMin, Re.yMin, Re.xMax, Re.yMax]
                });
                const Bn = Ge.x + he, bn = Ge.y + Ye.baseline + me;
                Y[dt * 2] = Bn, Y[dt * 2 + 1] = bn;
                const Kn = Bn + Re.xMin * pt, fi = bn + Re.yMin * pt, pi = Bn + Re.xMax * pt, Vn = bn + Re.yMax * pt;
                Kn < L[0] && (L[0] = Kn), fi < L[1] && (L[1] = fi), pi > L[2] && (L[2] = pi), Vn > L[3] && (L[3] = Vn), dt % le === 0 && (Oe = { start: dt, end: dt, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, ee.push(Oe)), Oe.end++;
                const wn = Oe.rect;
                if (Kn < wn[0] && (wn[0] = Kn), fi < wn[1] && (wn[1] = fi), pi > wn[2] && (wn[2] = pi), Vn > wn[3] && (wn[3] = Vn), ce[dt] = ut, V[dt] = Kt, re) {
                  const si = dt * 3;
                  I[si] = He >> 16 & 255, I[si + 1] = He >> 8 & 255, I[si + 2] = He & 255;
                }
              }
            }
          }
        }), F) {
          const Ye = v.length - Ae;
          Ye > 1 && d(F, Ae, Ye);
        }
      }
      const ge = [];
      J.forEach(({ index: Me, src: Te, unitsPerEm: Ae, ascender: Xe, descender: Oe, lineHeight: He, capHeight: Ye, xHeight: $e }) => {
        ge[Me] = { src: Te, unitsPerEm: Ae, ascender: Xe, descender: Oe, lineHeight: He, capHeight: Ye, xHeight: $e };
      }), q.typesetting = h() - B, j({
        glyphIds: ce,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: V,
        //index into fontData for each glyph
        glyphPositions: Y,
        //x,y of each glyph's origin in layout
        glyphData: H,
        //dict holding data about each glyph appearing in the text
        fontData: ge,
        //data about each font used in the text
        caretPositions: F,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: I,
        //color for each glyph, if color ranges supplied
        chunkedBounds: ee,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: M,
        //calculated em height
        topBaseline: me + N[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          he,
          me - K,
          he + Z,
          me
        ],
        visibleBounds: L,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: q
      });
    });
  }
  function c(v, x) {
    l({ ...v, metricsOnly: !0 }, (g) => {
      const [_, M, S, b] = g.blockBounds;
      x({
        width: S - _,
        height: b - M
      });
    });
  }
  function u(v) {
    let x = v.match(/^([\d.]+)%$/), g = x ? parseFloat(x[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function d(v, x, g) {
    const _ = v[x * 4], M = v[x * 4 + 1], S = v[x * 4 + 2], b = v[x * 4 + 3], C = (M - _) / g;
    for (let E = 0; E < g; E++) {
      const P = (x + E) * 4;
      v[P] = _ + C * E, v[P + 1] = _ + C * (E + 1), v[P + 2] = S, v[P + 3] = b;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function m() {
    this.data = [];
  }
  const p = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return m.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / p.length);
    },
    glyphAt(v) {
      let x = m.flyweight;
      return x.data = this.data, x.index = v, x;
    },
    splitAt(v) {
      let x = new m();
      return x.data = this.data.splice(v * p.length), x;
    }
  }, m.flyweight = p.reduce((v, x, g, _) => (Object.defineProperty(v, x, {
    get() {
      return this.data[this.index * p.length + g];
    },
    set(M) {
      this.data[this.index * p.length + g] = M;
    }
  }), v), { data: null, index: 0 }), {
    typeset: l,
    measure: c
  };
}
const Vr = () => (self.performance || Date).now(), Iu = /* @__PURE__ */ Ly();
let Hv;
function MN(s, e, n, i, r, o, a, l, c, u, d = !0) {
  return d ? EN(s, e, n, i, r, o, a, l, c, u).then(
    null,
    (h) => (Hv || (console.warn("WebGL SDF generation failed, falling back to JS", h), Hv = !0), Wv(s, e, n, i, r, o, a, l, c, u))
  ) : Wv(s, e, n, i, r, o, a, l, c, u);
}
const Vc = [], CN = 5;
let tf = 0;
function Uy() {
  const s = Vr();
  for (; Vc.length && Vr() - s < CN; )
    Vc.shift()();
  tf = Vc.length ? setTimeout(Uy, 0) : 0;
}
const EN = (...s) => new Promise((e, n) => {
  Vc.push(() => {
    const i = Vr();
    try {
      Iu.webgl.generateIntoCanvas(...s), e({ timing: Vr() - i });
    } catch (r) {
      n(r);
    }
  }), tf || (tf = setTimeout(Uy, 0));
}), TN = 4, AN = 2e3, $v = {};
let PN = 0;
function Wv(s, e, n, i, r, o, a, l, c, u) {
  const d = "TroikaTextSDFGenerator_JS_" + PN++ % TN;
  let h = $v[d];
  return h || (h = $v[d] = {
    workerModule: ea({
      name: d,
      workerId: d,
      dependencies: [
        Ly,
        Vr
      ],
      init(m, p) {
        const v = m().javascript.generate;
        return function(...x) {
          const g = p();
          return {
            textureData: v(...x),
            timing: p() - g
          };
        };
      },
      getTransferables(m) {
        return [m.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(s, e, n, i, r, o).then(({ textureData: m, timing: p }) => {
    const v = Vr(), x = new Uint8Array(m.length * 4);
    for (let g = 0; g < m.length; g++)
      x[g * 4 + u] = m[g];
    return Iu.webglUtils.renderImageData(a, x, l, c, s, e, 1 << 3 - u), p += Vr() - v, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      oN(d);
    }, AN)), { timing: p };
  });
}
function RN(s) {
  s._warm || (Iu.webgl.isSupported(s), s._warm = !0);
}
const DN = Iu.webglUtils.resizeWebGLCanvasWithoutClearing, Ia = {
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, kN = /* @__PURE__ */ new Mt();
function yo() {
  return (self.performance || Date).now();
}
const Xv = /* @__PURE__ */ Object.create(null);
function IN(s, e) {
  s = FN({}, s);
  const n = yo(), i = [];
  if (s.font && i.push({ label: "user", src: UN(s.font) }), s.font = i, s.text = "" + s.text, s.sdfGlyphSize = s.sdfGlyphSize || Ia.sdfGlyphSize, s.unicodeFontsURL = s.unicodeFontsURL || Ia.unicodeFontsURL, s.colorRanges != null) {
    let m = {};
    for (let p in s.colorRanges)
      if (s.colorRanges.hasOwnProperty(p)) {
        let v = s.colorRanges[p];
        typeof v != "number" && (v = kN.set(v).getHex()), m[p] = v;
      }
    s.colorRanges = m;
  }
  Object.freeze(s);
  const { textureWidth: r, sdfExponent: o } = Ia, { sdfGlyphSize: a } = s, l = r / a * 4;
  let c = Xv[a];
  if (!c) {
    const m = document.createElement("canvas");
    m.width = r, m.height = a * 256 / l, c = Xv[a] = {
      glyphCount: 0,
      sdfGlyphSize: a,
      sdfCanvas: m,
      sdfTexture: new xn(
        m,
        void 0,
        void 0,
        void 0,
        Bt,
        Bt
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, c.sdfTexture.generateMipmaps = !1, LN(c);
  }
  const { sdfTexture: u, sdfCanvas: d } = c;
  Ny(s).then((m) => {
    const { glyphIds: p, glyphFontIndices: v, fontData: x, glyphPositions: g, fontSize: _, timings: M } = m, S = [], b = new Float32Array(p.length * 4);
    let C = 0, E = 0;
    const P = yo(), T = x.map((R) => {
      let O = c.glyphsByFont.get(R.src);
      return O || c.glyphsByFont.set(R.src, O = /* @__PURE__ */ new Map()), O;
    });
    p.forEach((R, O) => {
      const A = v[O], { src: G, unitsPerEm: ue } = x[A];
      let Q = T[A].get(R);
      if (!Q) {
        const { path: q, pathBounds: oe } = m.glyphData[G][R], ie = Math.max(oe[2] - oe[0], oe[3] - oe[1]) / a * (Ia.sdfMargin * a + 0.5), ce = c.glyphCount++, V = [
          oe[0] - ie,
          oe[1] - ie,
          oe[2] + ie,
          oe[3] + ie
        ];
        T[A].set(R, Q = { path: q, atlasIndex: ce, sdfViewBox: V }), S.push(Q);
      }
      const { sdfViewBox: le } = Q, re = g[E++], j = g[E++], $ = _ / ue;
      b[C++] = re + le[0] * $, b[C++] = j + le[1] * $, b[C++] = re + le[2] * $, b[C++] = j + le[3] * $, p[O] = Q.atlasIndex;
    }), M.quads = (M.quads || 0) + (yo() - P);
    const y = yo();
    M.sdf = {};
    const w = d.height, D = Math.ceil(c.glyphCount / l), U = Math.pow(2, Math.ceil(Math.log2(D * a)));
    U > w && (console.info(`Increasing SDF texture size ${w}->${U}`), DN(d, r, U), u.dispose()), Promise.all(S.map(
      (R) => Oy(R, c, s.gpuAccelerateSDF).then(({ timing: O }) => {
        M.sdf[R.atlasIndex] = O;
      })
    )).then(() => {
      S.length && !c.contextLost && (zy(c), u.needsUpdate = !0), M.sdfTotal = yo() - y, M.total = yo() - n, e(Object.freeze({
        parameters: s,
        sdfTexture: u,
        sdfGlyphSize: a,
        sdfExponent: o,
        glyphBounds: b,
        glyphAtlasIndices: p,
        glyphColors: m.glyphColors,
        caretPositions: m.caretPositions,
        chunkedBounds: m.chunkedBounds,
        ascender: m.ascender,
        descender: m.descender,
        lineHeight: m.lineHeight,
        capHeight: m.capHeight,
        xHeight: m.xHeight,
        topBaseline: m.topBaseline,
        blockBounds: m.blockBounds,
        visibleBounds: m.visibleBounds,
        timings: m.timings
      }));
    });
  }), Promise.resolve().then(() => {
    c.contextLost || RN(d);
  });
}
function Oy({ path: s, atlasIndex: e, sdfViewBox: n }, { sdfGlyphSize: i, sdfCanvas: r, contextLost: o }, a) {
  if (o)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: l, sdfExponent: c } = Ia, u = Math.max(n[2] - n[0], n[3] - n[1]), d = Math.floor(e / 4), h = d % (l / i) * i, m = Math.floor(d / (l / i)) * i, p = e % 4;
  return MN(i, i, s, n, u, c, r, h, m, p, a);
}
function LN(s) {
  const e = s.sdfCanvas;
  e.addEventListener("webglcontextlost", (n) => {
    console.log("Context Lost", n), n.preventDefault(), s.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (n) => {
    console.log("Context Restored", n), s.contextLost = !1;
    const i = [];
    s.glyphsByFont.forEach((r) => {
      r.forEach((o) => {
        i.push(Oy(o, s, !0));
      });
    }), Promise.all(i).then(() => {
      zy(s), s.sdfTexture.needsUpdate = !0;
    });
  });
}
function FN(s, e) {
  for (let n in e)
    e.hasOwnProperty(n) && (s[n] = e[n]);
  return s;
}
let xc;
function UN(s) {
  return xc || (xc = typeof document > "u" ? {} : document.createElement("a")), xc.href = s, xc.href;
}
function zy(s) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: n } = s, { width: i, height: r } = e, o = s.sdfCanvas.getContext("webgl");
    let a = n.image.data;
    (!a || a.length !== i * r * 4) && (a = new Uint8Array(i * r * 4), n.image = { width: i, height: r, data: a }, n.flipY = !1, n.isDataTexture = !0), o.readPixels(0, 0, i, r, o.RGBA, o.UNSIGNED_BYTE, a);
  }
}
const ON = /* @__PURE__ */ ea({
  name: "Typesetter",
  dependencies: [
    SN,
    wN,
    lN
  ],
  init(s, e, n) {
    return s(e, n());
  }
}), Ny = /* @__PURE__ */ ea({
  name: "Typesetter",
  dependencies: [
    ON
  ],
  init(s) {
    return function(e) {
      return new Promise((n) => {
        s.typeset(e, n);
      });
    };
  },
  getTransferables(s) {
    const e = [];
    for (let n in s)
      s[n] && s[n].buffer && e.push(s[n].buffer);
    return e;
  }
});
Ny.onMainThread;
const jv = {};
function zN(s) {
  let e = jv[s];
  return e || (e = jv[s] = new un(1, 1, s, s).translate(0.5, 0.5, 0)), e;
}
const NN = "aTroikaGlyphBounds", Yv = "aTroikaGlyphIndex", BN = "aTroikaGlyphColor";
class VN extends wy {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new wl(), this.boundingBox = new dr();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let n = zN(e);
      ["position", "normal", "uv"].forEach((i) => {
        this.attributes[i] = n.attributes[i].clone();
      }), this.setIndex(n.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, n, i, r, o) {
    this.updateAttributeData(NN, e, 4), this.updateAttributeData(Yv, n, 1), this.updateAttributeData(BN, o, 3), this._blockBounds = i, this._chunkedBounds = r, this.instanceCount = n.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: n, boundingBox: i } = this;
      if (n) {
        const { PI: r, floor: o, min: a, max: l, sin: c, cos: u } = Math, d = r / 2, h = r * 2, m = Math.abs(n), p = e[0] / m, v = e[2] / m, x = o((p + d) / h) !== o((v + d) / h) ? -m : a(c(p) * m, c(v) * m), g = o((p - d) / h) !== o((v - d) / h) ? m : l(c(p) * m, c(v) * m), _ = o((p + r) / h) !== o((v + r) / h) ? m * 2 : l(m - u(p) * m, m - u(v) * m);
        i.min.set(x, e[1], n < 0 ? -_ : 0), i.max.set(g, e[3], n < 0 ? 0 : _);
      } else
        i.min.set(e[0], e[1], 0), i.max.set(e[2], e[3], 0);
      i.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let n = this.getAttribute(Yv).count, i = this._chunkedBounds;
    if (i)
      for (let r = i.length; r--; ) {
        n = i[r].end;
        let o = i[r].rect;
        if (o[1] < e.w && o[3] > e.y && o[0] < e.z && o[2] > e.x)
          break;
      }
    this.instanceCount = n;
  }
  /**
   * Utility for updating instance attributes with automatic resizing
   */
  updateAttributeData(e, n, i) {
    const r = this.getAttribute(e);
    n ? r && r.array.length === n.length ? (r.array.set(n), r.needsUpdate = !0) : (this.setAttribute(e, new Ar(n, i)), delete this._maxInstanceCount, this.dispose()) : r && this.deleteAttribute(e);
  }
}
const GN = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, HN = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, $N = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, WN = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function XN(s) {
  const e = ef(s, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new rt() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new jt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new jt(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new rt() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Mt() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Et() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: GN,
    vertexTransform: HN,
    fragmentDefs: $N,
    fragmentColorTransform: WN,
    customRewriter({ vertexShader: n, fragmentShader: i }) {
      let r = /\buniform\s+vec3\s+diffuse\b/;
      return r.test(i) && (i = i.replace(r, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), r.test(n) || (n = n.replace(
        Fy,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: n, fragmentShader: i };
    }
  });
  return e.transparent = !0, e.forceSinglePass = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const Jf = /* @__PURE__ */ new En({
  color: 16777215,
  side: vn,
  transparent: !0
}), qv = 8421504, Zv = /* @__PURE__ */ new Zt(), bc = /* @__PURE__ */ new de(), $d = /* @__PURE__ */ new de(), ba = [], jN = /* @__PURE__ */ new de(), Wd = "+x+y";
function Kv(s) {
  return Array.isArray(s) ? s[0] : s;
}
let By = () => {
  const s = new Ze(
    new un(1, 1),
    Jf
  );
  return By = () => s, s;
}, Vy = () => {
  const s = new Ze(
    new un(1, 1, 32, 1),
    Jf
  );
  return Vy = () => s, s;
};
const YN = { type: "syncstart" }, qN = { type: "synccomplete" }, Gy = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], ZN = Gy.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class nf extends Ze {
  constructor() {
    const e = new VN();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = qv, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = Wd, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(YN), IN({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (n) => {
      this._isSyncing = !1, this._textRenderInfo = n, this.geometry.updateGlyphs(
        n.glyphBounds,
        n.glyphAtlasIndices,
        n.blockBounds,
        n.chunkedBounds,
        n.glyphColors
      );
      const i = this._queuedSyncs;
      i && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        i.forEach((r) => r && r());
      })), this.dispatchEvent(qN), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, n, i, r, o, a) {
    this.sync(), o.isTroikaTextMaterial && this._prepareForRender(o);
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  /**
   * Create the text derived material from the base material. Can be overridden to use a custom
   * derived material.
   */
  createDerivedMaterial(e) {
    return XN(e);
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const n = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = Jf.clone());
    if ((!e || !e.isDerivedFrom(n)) && (e = this._derivedMaterial = this.createDerivedMaterial(n), n.addEventListener("dispose", function i() {
      n.removeEventListener("dispose", i), e.dispose();
    })), this.hasOutline()) {
      let i = e._outlineMtl;
      return i || (i = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), i.isTextOutlineMaterial = !0, i.depthWrite = !1, i.map = null, e.addEventListener("dispose", function r() {
        e.removeEventListener("dispose", r), i.dispose();
      })), [
        i,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  hasOutline() {
    return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return Kv(this.material).getDepthMaterial();
  }
  set customDepthMaterial(e) {
  }
  get customDistanceMaterial() {
    return Kv(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(e) {
  }
  _prepareForRender(e) {
    const n = e.isTextOutlineMaterial, i = e.uniforms, r = this.textRenderInfo;
    if (r) {
      const { sdfTexture: l, blockBounds: c } = r;
      i.uTroikaSDFTexture.value = l, i.uTroikaSDFTextureSize.value.set(l.image.width, l.image.height), i.uTroikaSDFGlyphSize.value = r.sdfGlyphSize, i.uTroikaSDFExponent.value = r.sdfExponent, i.uTroikaTotalBounds.value.fromArray(c), i.uTroikaUseGlyphColors.value = !n && !!r.glyphColors;
      let u = 0, d = 0, h = 0, m, p, v, x = 0, g = 0;
      if (n) {
        let { outlineWidth: M, outlineOffsetX: S, outlineOffsetY: b, outlineBlur: C, outlineOpacity: E } = this;
        u = this._parsePercent(M) || 0, d = Math.max(0, this._parsePercent(C) || 0), m = E, x = this._parsePercent(S) || 0, g = this._parsePercent(b) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (v = this.strokeColor, i.uTroikaStrokeColor.value.set(v ?? qv), p = this.strokeOpacity, p == null && (p = 1)), m = this.fillOpacity;
      i.uTroikaEdgeOffset.value = u, i.uTroikaPositionOffset.value.set(x, g), i.uTroikaBlurRadius.value = d, i.uTroikaStrokeWidth.value = h, i.uTroikaStrokeOpacity.value = p, i.uTroikaFillOpacity.value = m ?? 1, i.uTroikaCurveRadius.value = this.curveRadius || 0;
      let _ = this.clipRect;
      if (_ && Array.isArray(_) && _.length === 4)
        i.uTroikaClipRect.value.fromArray(_);
      else {
        const M = (this.fontSize || 0.1) * 100;
        i.uTroikaClipRect.value.set(
          c[0] - M,
          c[1] - M,
          c[2] + M,
          c[3] + M
        );
      }
      this.geometry.applyClipRect(i.uTroikaClipRect.value);
    }
    i.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const o = n ? this.outlineColor || 0 : this.color;
    if (o == null)
      delete e.color;
    else {
      const l = e.hasOwnProperty("color") ? e.color : e.color = new Mt();
      (o !== l._input || typeof o == "object") && l.set(l._input = o);
    }
    let a = this.orientation || Wd;
    if (a !== e._orientation) {
      let l = i.uTroikaOrient.value;
      a = a.replace(/[^-+xyz]/g, "");
      let c = a !== Wd && a.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (c) {
        let [, u, d, h, m] = c;
        bc.set(0, 0, 0)[d] = u === "-" ? 1 : -1, $d.set(0, 0, 0)[m] = h === "-" ? -1 : 1, Zv.lookAt(jN, bc.cross($d), $d), l.setFromMatrix4(Zv);
      } else
        l.identity();
      e._orientation = a;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let n = e.match(/^(-?[\d.]+)%$/), i = n ? parseFloat(n[1]) : NaN;
      e = (isNaN(i) ? 0 : i / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, n = new rt()) {
    n.copy(e);
    const i = this.curveRadius;
    return i && (n.x = Math.atan2(e.x, Math.abs(i) - Math.abs(e.z)) * Math.abs(i)), n;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, n = new rt()) {
    return bc.copy(e), this.localPositionToTextCoords(this.worldToLocal(bc), n);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, n) {
    const { textRenderInfo: i, curveRadius: r } = this;
    if (i) {
      const o = i.blockBounds, a = r ? Vy() : By(), l = a.geometry, { position: c, uv: u } = l.attributes;
      for (let d = 0; d < u.count; d++) {
        let h = o[0] + u.getX(d) * (o[2] - o[0]);
        const m = o[1] + u.getY(d) * (o[3] - o[1]);
        let p = 0;
        r && (p = r - Math.cos(h / r) * r, h = Math.sin(h / r) * r), c.setXYZ(d, h, m, p);
      }
      l.boundingSphere = this.geometry.boundingSphere, l.boundingBox = this.geometry.boundingBox, a.matrixWorld = this.matrixWorld, a.material.side = this.material.side, ba.length = 0, a.raycast(e, ba);
      for (let d = 0; d < ba.length; d++)
        ba[d].object = this, n.push(ba[d]);
    }
  }
  copy(e) {
    const n = this.geometry;
    return super.copy(e), this.geometry = n, ZN.forEach((i) => {
      this[i] = e[i];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Gy.forEach((s) => {
  const e = "_private_" + s;
  Object.defineProperty(nf.prototype, s, {
    get() {
      return this[e];
    },
    set(n) {
      n !== this[e] && (this[e] = n, this._needsSync = !0);
    }
  });
});
new dr();
new Mt();
class Jv {
  constructor(e, n = 500) {
    fe(this, "entries", []);
    fe(this, "totalLength", 0);
    this.curve = e, this.build(n);
  }
  build(e) {
    this.entries = [];
    let n = 0, i = this.curve.getPointAt(0);
    for (let r = 0; r <= e; r++) {
      const o = r / e, a = this.curve.getPointAt(o), l = this.curve.getTangentAt(o);
      r > 0 && (n += a.distanceTo(i)), this.entries.push({
        t: o,
        distance: n,
        position: a.clone(),
        tangent: l.clone().normalize()
      }), i = a;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to parameter t
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, i = this.entries.length - 1;
    for (; n < i; ) {
      const l = Math.floor((n + i) / 2);
      this.entries[l].distance < e ? n = l + 1 : i = l;
    }
    const r = this.entries[n], o = this.entries[Math.max(0, n - 1)];
    if (r.distance === o.distance)
      return r.t;
    const a = (e - o.distance) / (r.distance - o.distance);
    return o.t + a * (r.t - o.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e), i = this.curve.getPointAt(n), r = this.curve.getTangentAt(n).normalize(), o = new de(-r.y, r.x, 0).normalize();
    return {
      position: i,
      tangent: r,
      normal: o,
      t: n,
      distance: e
    };
  }
}
class KN {
  constructor() {
    fe(this, "arcLengthTable", null);
    fe(this, "curve", null);
  }
  /**
   * Set the path from control points
   */
  setPath(e, n = !1) {
    var i, r, o, a, l, c, u, d;
    if (e.length < 2) {
      this.curve = null, this.arcLengthTable = null;
      return;
    }
    this.curve = new Vf();
    for (let h = 0; h < e.length - 1; h++) {
      const m = e[h], p = e[h + 1], v = m.depth ?? 0, x = p.depth ?? 0, g = new dl(
        new de(m.x, -m.y, v),
        new de(
          m.x + (((i = m.handleOut) == null ? void 0 : i.x) ?? 0),
          -(m.y + (((r = m.handleOut) == null ? void 0 : r.y) ?? 0)),
          v
        ),
        new de(
          p.x + (((o = p.handleIn) == null ? void 0 : o.x) ?? 0),
          -(p.y + (((a = p.handleIn) == null ? void 0 : a.y) ?? 0)),
          x
        ),
        new de(p.x, -p.y, x)
      );
      this.curve.add(g);
    }
    if (n && e.length > 2) {
      const h = e[e.length - 1], m = e[0], p = h.depth ?? 0, v = m.depth ?? 0, x = new dl(
        new de(h.x, -h.y, p),
        new de(
          h.x + (((l = h.handleOut) == null ? void 0 : l.x) ?? 0),
          -(h.y + (((c = h.handleOut) == null ? void 0 : c.y) ?? 0)),
          p
        ),
        new de(
          m.x + (((u = m.handleIn) == null ? void 0 : u.x) ?? 0),
          -(m.y + (((d = m.handleIn) == null ? void 0 : d.y) ?? 0)),
          v
        ),
        new de(m.x, -m.y, v)
      );
      this.curve.add(x);
    }
    this.arcLengthTable = new Jv(this.curve);
  }
  /**
   * Set path from THREE.js CurvePath directly
   */
  setCurve(e) {
    this.curve = e, this.arcLengthTable = new Jv(e);
  }
  /**
   * Get total path length
   */
  getTotalLength() {
    var e;
    return ((e = this.arcLengthTable) == null ? void 0 : e.totalLength) ?? 0;
  }
  /**
   * Check if path is set
   */
  hasPath() {
    return this.curve !== null && this.arcLengthTable !== null;
  }
  /**
   * Calculate character placements along the path
   *
   * @param characterWidths - Array of character widths in pixels
   * @param config - Text on path configuration
   * @param tracking - Letter spacing in 1/1000 em
   * @param fontSize - Font size for tracking calculation
   * @returns Array of character placements
   */
  calculatePlacements(e, n, i = 0, r = 72) {
    if (!this.arcLengthTable || e.length === 0)
      return [];
    const o = this.arcLengthTable.totalLength, a = [], l = i / 1e3 * r;
    let c = 0;
    for (let p = 0; p < e.length; p++)
      c += e[p], p < e.length - 1 && (c += l);
    const u = o - n.firstMargin - n.lastMargin;
    let d;
    switch (n.align) {
      case "center":
        d = n.firstMargin + (u - c) / 2;
        break;
      case "right":
        d = n.firstMargin + u - c;
        break;
      default:
        d = n.firstMargin;
    }
    const h = n.offset / 100 * u;
    d += h, n.reversed && (d = o - d - c);
    let m = d;
    for (let p = 0; p < e.length; p++) {
      const v = e[p];
      let g = m + v / 2, _ = !0;
      (g < 0 || g > o) && (n.forceAlignment ? g = (g % o + o) % o : (_ = g >= -v && g <= o + v, g = Math.max(0, Math.min(o, g))));
      const M = this.arcLengthTable.getPointAtDistance(g);
      let S;
      if (n.perpendicularToPath) {
        const b = Math.atan2(M.tangent.y, M.tangent.x);
        S = new Mi(0, 0, n.reversed ? b + Math.PI : b);
      } else
        S = new Mi(0, 0, 0);
      a.push({
        index: p,
        position: M.position.clone(),
        rotation: S,
        scale: 1,
        pathDistance: g,
        pathT: M.t,
        visible: _
      }), m += v + l;
    }
    return a;
  }
  /**
   * Get a point on the path at a specific percentage
   * Useful for positioning anchors or debugging
   */
  getPointAtPercent(e) {
    if (!this.arcLengthTable) return null;
    const n = e / 100 * this.arcLengthTable.totalLength;
    return this.arcLengthTable.getPointAtDistance(n);
  }
  /**
   * Get evenly spaced points along the path
   * Useful for path visualization
   */
  getEvenlySpacedPoints(e) {
    if (!this.arcLengthTable || e < 2) return [];
    const n = [], i = this.arcLengthTable.totalLength / (e - 1);
    for (let r = 0; r < e; r++) {
      const o = r * i;
      n.push(this.arcLengthTable.getPointAtDistance(o));
    }
    return n;
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.curve = null, this.arcLengthTable = null;
  }
}
function JN() {
  return {
    pathLayerId: null,
    reversed: !1,
    perpendicularToPath: !0,
    forceAlignment: !1,
    firstMargin: 0,
    lastMargin: 0,
    offset: 0,
    align: "left"
  };
}
class QN extends Yi {
  constructor(n, i) {
    super(n);
    fe(this, "resources");
    // Text rendering
    fe(this, "textMesh");
    fe(this, "perCharacterGroup", null);
    fe(this, "characterMeshes", []);
    // Text data from layer
    fe(this, "textData");
    // Animatable text properties (from layer.properties)
    fe(this, "fontSizeProp");
    fe(this, "trackingProp");
    fe(this, "lineSpacingProp");
    fe(this, "fillColorProp");
    fe(this, "strokeColorProp");
    fe(this, "strokeWidthProp");
    fe(this, "pathOffsetProp");
    fe(this, "firstMarginProp");
    fe(this, "lastMarginProp");
    fe(this, "characterOffsetProp");
    // Per-character animation
    fe(this, "characterTransforms");
    // Path following service
    fe(this, "textOnPath");
    fe(this, "pathConfig");
    fe(this, "pathControlPoints", []);
    fe(this, "pathClosed", !1);
    // Character width cache (recalculated when text/font changes)
    fe(this, "characterWidths", []);
    fe(this, "characterWidthsDirty", !0);
    // Additional evaluator for text-specific properties
    fe(this, "textEvaluator");
    this.resources = i, this.textEvaluator = new Ml(), this.textOnPath = new KN(), this.pathConfig = JN(), this.textData = this.extractTextData(n), this.extractAnimatableProperties(n), this.textMesh = this.createTextMesh(), this.group.add(this.textMesh), (this.textData.perCharacter3D || this.textData.pathLayerId) && this.enablePerCharacter3D(), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract text data from layer, with defaults matching AE
   */
  extractTextData(n) {
    const i = n.data;
    return {
      text: (i == null ? void 0 : i.text) ?? "Text",
      fontFamily: (i == null ? void 0 : i.fontFamily) ?? "Impact",
      fontSize: (i == null ? void 0 : i.fontSize) ?? 72,
      fontWeight: (i == null ? void 0 : i.fontWeight) ?? "400",
      fontStyle: (i == null ? void 0 : i.fontStyle) ?? "normal",
      fill: (i == null ? void 0 : i.fill) ?? "#ffffff",
      stroke: (i == null ? void 0 : i.stroke) ?? "",
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? 0,
      // Character properties
      tracking: (i == null ? void 0 : i.tracking) ?? 0,
      lineSpacing: (i == null ? void 0 : i.lineSpacing) ?? 0,
      lineAnchor: (i == null ? void 0 : i.lineAnchor) ?? 50,
      characterOffset: (i == null ? void 0 : i.characterOffset) ?? 0,
      characterValue: (i == null ? void 0 : i.characterValue) ?? 0,
      blur: (i == null ? void 0 : i.blur) ?? { x: 0, y: 0 },
      // Paragraph (aliases)
      letterSpacing: (i == null ? void 0 : i.letterSpacing) ?? (i == null ? void 0 : i.tracking) ?? 0,
      lineHeight: (i == null ? void 0 : i.lineHeight) ?? (i == null ? void 0 : i.lineSpacing) ?? 1.2,
      textAlign: (i == null ? void 0 : i.textAlign) ?? "left",
      // Path options (full AE parity)
      pathLayerId: (i == null ? void 0 : i.pathLayerId) ?? null,
      pathReversed: (i == null ? void 0 : i.pathReversed) ?? !1,
      pathPerpendicularToPath: (i == null ? void 0 : i.pathPerpendicularToPath) ?? !0,
      pathForceAlignment: (i == null ? void 0 : i.pathForceAlignment) ?? !1,
      pathFirstMargin: (i == null ? void 0 : i.pathFirstMargin) ?? 0,
      pathLastMargin: (i == null ? void 0 : i.pathLastMargin) ?? 0,
      pathOffset: (i == null ? void 0 : i.pathOffset) ?? 0,
      pathAlign: (i == null ? void 0 : i.pathAlign) ?? "left",
      // More Options
      anchorPointGrouping: (i == null ? void 0 : i.anchorPointGrouping) ?? "character",
      groupingAlignment: (i == null ? void 0 : i.groupingAlignment) ?? { x: 0, y: 0 },
      fillAndStroke: (i == null ? void 0 : i.fillAndStroke) ?? "fill-over-stroke",
      interCharacterBlending: (i == null ? void 0 : i.interCharacterBlending) ?? "normal",
      // 3D
      perCharacter3D: (i == null ? void 0 : i.perCharacter3D) ?? !1
    };
  }
  /**
   * Extract animatable properties from layer.properties array
   */
  extractAnimatableProperties(n) {
    if (n.properties) {
      for (const i of n.properties)
        switch (i.name) {
          case "Font Size":
            this.fontSizeProp = i;
            break;
          case "Tracking":
            this.trackingProp = i;
            break;
          case "Line Spacing":
            this.lineSpacingProp = i;
            break;
          case "Fill Color":
            this.fillColorProp = i;
            break;
          case "Stroke Color":
            this.strokeColorProp = i;
            break;
          case "Stroke Width":
            this.strokeWidthProp = i;
            break;
          case "Path Offset":
            this.pathOffsetProp = i;
            break;
          case "First Margin":
            this.firstMarginProp = i;
            break;
          case "Last Margin":
            this.lastMarginProp = i;
            break;
          case "Character Offset":
            this.characterOffsetProp = i;
            break;
        }
      this.syncPathConfig();
    }
  }
  /**
   * Sync path configuration from text data
   */
  syncPathConfig() {
    this.pathConfig.pathLayerId = this.textData.pathLayerId, this.pathConfig.reversed = this.textData.pathReversed, this.pathConfig.perpendicularToPath = this.textData.pathPerpendicularToPath, this.pathConfig.forceAlignment = this.textData.pathForceAlignment, this.pathConfig.firstMargin = this.textData.pathFirstMargin, this.pathConfig.lastMargin = this.textData.pathLastMargin, this.pathConfig.offset = this.textData.pathOffset, this.pathConfig.align = this.textData.pathAlign;
  }
  // ============================================================================
  // TEXT MESH CREATION
  // ============================================================================
  /**
   * Create Troika text mesh with current settings
   */
  createTextMesh() {
    const n = new nf();
    return n.text = this.textData.text, n.font = this.getFontUrl(this.textData.fontFamily) ?? null, n.fontSize = this.textData.fontSize, n.color = this.textData.fill, this.textData.stroke && this.textData.strokeWidth > 0 && (n.outlineWidth = this.textData.strokeWidth / this.textData.fontSize, n.outlineColor = this.textData.stroke), n.letterSpacing = (this.textData.tracking || 0) / 1e3, n.lineHeight = this.textData.lineHeight || 1.2, n.textAlign = this.textData.textAlign, n.anchorX = this.getAnchorX(), n.anchorY = "middle", n.depthOffset = 0, n.renderOrder = 0, n.sync(), n;
  }
  /**
   * Get font URL for Troika
   */
  getFontUrl(n) {
    return [
      "Arial",
      "Helvetica",
      "Times New Roman",
      "Georgia",
      "Verdana",
      "Courier New",
      "Impact",
      "Comic Sans MS",
      "Trebuchet MS",
      "Palatino"
    ].includes(n) ? void 0 : {
      Roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxK.woff2",
      "Open Sans": "https://fonts.gstatic.com/s/opensans/v35/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4gaVI.woff2",
      Lato: "https://fonts.gstatic.com/s/lato/v24/S6uyw4BMUTPHjx4wXg.woff2",
      Montserrat: "https://fonts.gstatic.com/s/montserrat/v26/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Hw5aXo.woff2",
      Oswald: "https://fonts.gstatic.com/s/oswald/v53/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUZiYA.woff2",
      Poppins: "https://fonts.gstatic.com/s/poppins/v21/pxiEyp8kv8JHgFVrJJfecg.woff2"
    }[n];
  }
  /**
   * Get anchor X based on text alignment
   */
  getAnchorX() {
    switch (this.textData.textAlign) {
      case "left":
        return "left";
      case "right":
        return "right";
      default:
        return "center";
    }
  }
  // ============================================================================
  // PATH INTEGRATION
  // ============================================================================
  /**
   * Set the path from SplineLayer control points
   * Called by LayerManager when connecting text to a spline
   */
  setPathFromControlPoints(n, i = !1) {
    this.pathControlPoints = n, this.pathClosed = i, n.length >= 2 ? (this.textOnPath.setPath(n, i), this.perCharacterGroup || this.enablePerCharacter3D(), this.updatePathLayout()) : (this.textOnPath.dispose(), this.resetPathLayout());
  }
  /**
   * Set the path from a THREE.js CurvePath directly
   */
  setPathFromCurve(n) {
    this.textOnPath.setCurve(n), this.perCharacterGroup || this.enablePerCharacter3D(), this.updatePathLayout();
  }
  /**
   * Clear the path reference
   */
  clearPath() {
    this.textData.pathLayerId = null, this.pathConfig.pathLayerId = null, this.textOnPath.dispose(), this.resetPathLayout();
  }
  /**
   * Update character positions along the path
   */
  updatePathLayout() {
    if (!this.textOnPath.hasPath() || !this.perCharacterGroup)
      return;
    this.ensureCharacterWidths();
    const n = this.textOnPath.calculatePlacements(
      this.characterWidths,
      this.pathConfig,
      this.textData.tracking,
      this.textData.fontSize
    );
    this.applyPlacements(n);
  }
  /**
   * Apply character placements to meshes
   */
  applyPlacements(n) {
    for (let i = 0; i < this.characterMeshes.length && i < n.length; i++) {
      const r = this.characterMeshes[i], o = n[i];
      r.position.copy(o.position), r.rotation.copy(o.rotation), r.scale.setScalar(o.scale), r.visible = o.visible;
    }
  }
  /**
   * Reset to horizontal layout (no path)
   */
  resetPathLayout() {
    this.textData.perCharacter3D ? this.createCharacterMeshes() : this.disablePerCharacter3D();
  }
  /**
   * Calculate character widths for path spacing
   */
  ensureCharacterWidths() {
    if (!this.characterWidthsDirty) return;
    this.characterWidths = [];
    const n = this.textData.text, i = this.textData.fontSize * 0.6;
    for (let r = 0; r < n.length; r++) {
      const o = n[r];
      `iIl1|!.,;:'"`.includes(o) ? this.characterWidths.push(i * 0.4) : "mwMW".includes(o) ? this.characterWidths.push(i * 1.3) : o === " " ? this.characterWidths.push(i * 0.5) : this.characterWidths.push(i);
    }
    this.characterWidthsDirty = !1;
  }
  // ============================================================================
  // PER-CHARACTER 3D MODE
  // ============================================================================
  /**
   * Enable per-character mode (for 3D and path following)
   */
  enablePerCharacter3D() {
    this.perCharacterGroup || (this.textMesh.visible = !1, this.perCharacterGroup = new Ai(), this.perCharacterGroup.name = `text_chars_${this.id}`, this.group.add(this.perCharacterGroup), this.createCharacterMeshes());
  }
  /**
   * Disable per-character mode
   */
  disablePerCharacter3D() {
    this.perCharacterGroup && (this.textMesh.visible = !0, this.disposeCharacterMeshes(), this.group.remove(this.perCharacterGroup), this.perCharacterGroup = null);
  }
  /**
   * Create individual character meshes
   */
  createCharacterMeshes() {
    if (!this.perCharacterGroup) return;
    this.disposeCharacterMeshes(), this.characterWidthsDirty = !0;
    const n = this.textData.text;
    let i = 0;
    this.ensureCharacterWidths();
    const r = this.characterWidths.reduce((a, l) => a + l, 0) + (n.length - 1) * (this.textData.tracking / 1e3) * this.textData.fontSize;
    let o = 0;
    switch (this.textData.textAlign) {
      case "center":
        o = -r / 2;
        break;
      case "right":
        o = -r;
        break;
      default:
        o = 0;
    }
    i = o;
    for (let a = 0; a < n.length; a++) {
      const l = n[a], c = new nf();
      c.text = l, c.font = this.getFontUrl(this.textData.fontFamily) ?? null, c.fontSize = this.textData.fontSize, c.color = this.textData.fill, c.anchorX = "center", c.anchorY = "middle", this.textData.stroke && this.textData.strokeWidth > 0 && (c.outlineWidth = this.textData.strokeWidth / this.textData.fontSize, c.outlineColor = this.textData.stroke);
      const u = this.characterWidths[a];
      c.position.x = i + u / 2, c.position.y = 0, c.position.z = 0, i += u + this.textData.tracking / 1e3 * this.textData.fontSize, c.sync(), this.characterMeshes.push(c), this.perCharacterGroup.add(c);
    }
    this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Dispose character meshes
   */
  disposeCharacterMeshes() {
    var n;
    for (const i of this.characterMeshes)
      i.dispose(), (n = this.perCharacterGroup) == null || n.remove(i);
    this.characterMeshes = [];
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setText(n) {
    this.textData.text = n, this.textMesh.text = n, this.textMesh.sync(), this.characterWidthsDirty = !0, this.perCharacterGroup && this.createCharacterMeshes();
  }
  setFontFamily(n) {
    this.textData.fontFamily = n;
    const i = this.getFontUrl(n) ?? null;
    this.textMesh.font = i, this.textMesh.sync(), this.characterWidthsDirty = !0;
    for (const r of this.characterMeshes)
      r.font = i, r.sync();
    this.textOnPath.hasPath() && this.updatePathLayout();
  }
  setFontSize(n) {
    this.textData.fontSize = n, this.textMesh.fontSize = n, this.textMesh.sync(), this.characterWidthsDirty = !0;
    for (const i of this.characterMeshes)
      i.fontSize = n, i.sync();
    this.perCharacterGroup && (this.textOnPath.hasPath() ? this.updatePathLayout() : this.createCharacterMeshes());
  }
  setFillColor(n) {
    this.textData.fill = n, this.textMesh.color = n;
    for (const i of this.characterMeshes)
      i.color = n;
  }
  setStroke(n, i) {
    this.textData.stroke = n, this.textData.strokeWidth = i;
    const r = i / this.textData.fontSize;
    this.textMesh.outlineWidth = r, this.textMesh.outlineColor = n;
    for (const o of this.characterMeshes)
      o.outlineWidth = r, o.outlineColor = n;
  }
  setTracking(n) {
    this.textData.tracking = n, this.textMesh.letterSpacing = n / 1e3, this.textMesh.sync(), this.perCharacterGroup && (this.textOnPath.hasPath() ? this.updatePathLayout() : this.createCharacterMeshes());
  }
  setTextAlign(n) {
    this.textData.textAlign = n, this.textMesh.textAlign = n, this.textMesh.anchorX = this.getAnchorX(), this.textMesh.sync(), this.perCharacterGroup && (this.textOnPath.hasPath() ? (this.pathConfig.align = n, this.updatePathLayout()) : this.createCharacterMeshes());
  }
  /**
   * Set path offset (0-100%)
   * This is the primary animatable property for text-on-path animation
   */
  setPathOffset(n) {
    this.textData.pathOffset = n, this.pathConfig.offset = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set first margin (pixels)
   */
  setFirstMargin(n) {
    this.textData.pathFirstMargin = n, this.pathConfig.firstMargin = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set last margin (pixels)
   */
  setLastMargin(n) {
    this.textData.pathLastMargin = n, this.pathConfig.lastMargin = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set path reversed
   */
  setPathReversed(n) {
    this.textData.pathReversed = n, this.pathConfig.reversed = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set perpendicular to path
   */
  setPerpendicularToPath(n) {
    this.textData.pathPerpendicularToPath = n, this.pathConfig.perpendicularToPath = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set force alignment
   */
  setForceAlignment(n) {
    this.textData.pathForceAlignment = n, this.pathConfig.forceAlignment = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  setAnchorPointGrouping(n) {
    this.textData.anchorPointGrouping = n;
  }
  setFillAndStroke(n) {
    this.textData.fillAndStroke = n;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    var i, r, o, a, l, c, u;
    if ((i = this.fontSizeProp) != null && i.animated) {
      const d = this.textEvaluator.evaluate(this.fontSizeProp, n);
      this.setFontSize(d);
    }
    if ((r = this.trackingProp) != null && r.animated) {
      const d = this.textEvaluator.evaluate(this.trackingProp, n);
      this.setTracking(d);
    }
    if ((o = this.fillColorProp) != null && o.animated) {
      const d = this.textEvaluator.evaluate(this.fillColorProp, n);
      this.setFillColor(d);
    }
    if ((a = this.strokeColorProp) != null && a.animated && this.strokeWidthProp) {
      const d = this.textEvaluator.evaluate(this.strokeColorProp, n), h = this.strokeWidthProp.animated ? this.textEvaluator.evaluate(this.strokeWidthProp, n) : this.textData.strokeWidth;
      this.setStroke(d, h);
    }
    if (this.pathOffsetProp) {
      const d = this.pathOffsetProp.animated ? this.textEvaluator.evaluate(this.pathOffsetProp, n) : this.textData.pathOffset;
      this.setPathOffset(d);
    }
    if ((l = this.firstMarginProp) != null && l.animated) {
      const d = this.textEvaluator.evaluate(this.firstMarginProp, n);
      this.setFirstMargin(d);
    }
    if ((c = this.lastMarginProp) != null && c.animated) {
      const d = this.textEvaluator.evaluate(this.lastMarginProp, n);
      this.setLastMargin(d);
    }
    (u = this.characterTransforms) != null && u.animated && this.perCharacterGroup && this.applyCharacterTransforms(n);
  }
  /**
   * Apply per-character animated transforms (additional offsets)
   */
  applyCharacterTransforms(n) {
    if (!this.characterTransforms) return;
    const i = this.textEvaluator.evaluate(this.characterTransforms, n);
    for (let r = 0; r < this.characterMeshes.length && r < i.length; r++) {
      const o = this.characterMeshes[r], a = i[r];
      o.position.x += a.position.x, o.position.y += a.position.y, o.position.z += a.position.z, o.rotation.x += mn.degToRad(a.rotation.x), o.rotation.y += mn.degToRad(a.rotation.y), o.rotation.z += mn.degToRad(a.rotation.z), o.scale.x *= a.scale.x, o.scale.y *= a.scale.y, o.material && (o.material.opacity *= a.opacity);
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.text !== void 0 && this.setText(i.text), i.fontFamily !== void 0 && this.setFontFamily(i.fontFamily), i.fontSize !== void 0 && this.setFontSize(i.fontSize), i.fill !== void 0 && this.setFillColor(i.fill), (i.stroke !== void 0 || i.strokeWidth !== void 0) && this.setStroke(
      i.stroke ?? this.textData.stroke,
      i.strokeWidth ?? this.textData.strokeWidth
    ), i.tracking !== void 0 && this.setTracking(i.tracking), i.textAlign !== void 0 && this.setTextAlign(i.textAlign), i.pathLayerId !== void 0 && (this.textData.pathLayerId = i.pathLayerId, this.pathConfig.pathLayerId = i.pathLayerId), i.pathOffset !== void 0 && this.setPathOffset(i.pathOffset), i.pathFirstMargin !== void 0 && this.setFirstMargin(i.pathFirstMargin), i.pathLastMargin !== void 0 && this.setLastMargin(i.pathLastMargin), i.pathReversed !== void 0 && this.setPathReversed(i.pathReversed), i.pathPerpendicularToPath !== void 0 && this.setPerpendicularToPath(i.pathPerpendicularToPath), i.pathForceAlignment !== void 0 && this.setForceAlignment(i.pathForceAlignment), i.perCharacter3D !== void 0 && (i.perCharacter3D && !this.perCharacterGroup ? this.enablePerCharacter3D() : !i.perCharacter3D && !this.textOnPath.hasPath() && this.perCharacterGroup && this.disablePerCharacter3D()), i.anchorPointGrouping !== void 0 && this.setAnchorPointGrouping(i.anchorPointGrouping), i.fillAndStroke !== void 0 && this.setFillAndStroke(i.fillAndStroke)), n.properties && this.extractAnimatableProperties(n);
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getTextData() {
    return { ...this.textData };
  }
  getTextBounds() {
    var i;
    const n = (i = this.textMesh.textRenderInfo) == null ? void 0 : i.blockBounds;
    return n ? {
      width: n[2] - n[0],
      height: n[3] - n[1]
    } : { width: 0, height: 0 };
  }
  getPathLength() {
    return this.textOnPath.getTotalLength();
  }
  hasPath() {
    return this.textOnPath.hasPath();
  }
  getTextOnPathService() {
    return this.textOnPath;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.textMesh.dispose(), this.disposeCharacterMeshes(), this.textOnPath.dispose(), this.perCharacterGroup && this.group.remove(this.perCharacterGroup);
  }
}
class e8 extends Yi {
  constructor(n) {
    super(n);
    /** The line mesh for the spline */
    fe(this, "lineMesh", null);
    /** The fill mesh (if closed path with fill) */
    fe(this, "fillMesh", null);
    /** Spline data */
    fe(this, "splineData");
    /** Cached curve for path calculations */
    fe(this, "curve", null);
    this.splineData = this.extractSplineData(n), this.buildSpline(), this.initializeBlendMode();
  }
  /**
   * Extract spline data from layer
   */
  extractSplineData(n) {
    const i = n.data;
    return {
      controlPoints: (i == null ? void 0 : i.controlPoints) ?? [],
      closed: (i == null ? void 0 : i.closed) ?? !1,
      stroke: (i == null ? void 0 : i.stroke) ?? "#00ff00",
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? 2,
      fill: (i == null ? void 0 : i.fill) ?? "",
      pathData: (i == null ? void 0 : i.pathData) ?? ""
    };
  }
  /**
   * Build the Three.js spline from control points
   */
  buildSpline() {
    var a, l, c, u, d, h, m, p;
    this.clearMeshes();
    const n = this.splineData.controlPoints;
    if (n.length < 2) return;
    this.curve = new Vf();
    for (let v = 0; v < n.length - 1; v++) {
      const x = n[v], g = n[v + 1], _ = x.depth ?? 0, M = g.depth ?? 0, S = new dl(
        new de(x.x, -x.y, _),
        new de(
          x.x + (((a = x.handleOut) == null ? void 0 : a.x) ?? 0),
          -(x.y + (((l = x.handleOut) == null ? void 0 : l.y) ?? 0)),
          _
        ),
        new de(
          g.x + (((c = g.handleIn) == null ? void 0 : c.x) ?? 0),
          -(g.y + (((u = g.handleIn) == null ? void 0 : u.y) ?? 0)),
          M
        ),
        new de(g.x, -g.y, M)
      );
      this.curve.add(S);
    }
    if (this.splineData.closed && n.length > 2) {
      const v = n[n.length - 1], x = n[0], g = v.depth ?? 0, _ = x.depth ?? 0, M = new dl(
        new de(v.x, -v.y, g),
        new de(
          v.x + (((d = v.handleOut) == null ? void 0 : d.x) ?? 0),
          -(v.y + (((h = v.handleOut) == null ? void 0 : h.y) ?? 0)),
          g
        ),
        new de(
          x.x + (((m = x.handleIn) == null ? void 0 : m.x) ?? 0),
          -(x.y + (((p = x.handleIn) == null ? void 0 : p.y) ?? 0)),
          _
        ),
        new de(x.x, -x.y, _)
      );
      this.curve.add(M);
    }
    const i = this.curve.getPoints(n.length * 20), r = new Vt().setFromPoints(i), o = new ji({
      color: this.splineData.stroke,
      linewidth: this.splineData.strokeWidth,
      transparent: !0
    });
    this.lineMesh = new ln(r, o), this.lineMesh.name = `spline_line_${this.id}`, this.group.add(this.lineMesh), this.splineData.fill && this.splineData.closed && this.createFill(i);
  }
  /**
   * Create fill mesh for closed paths
   */
  createFill(n) {
    if (n.length < 3) return;
    const i = new gy();
    i.moveTo(n[0].x, n[0].y);
    for (let a = 1; a < n.length; a++)
      i.lineTo(n[a].x, n[a].y);
    i.closePath();
    const r = new $f(i), o = new En({
      color: this.splineData.fill,
      transparent: !0,
      side: vn,
      depthWrite: !1
    });
    this.fillMesh = new Ze(r, o), this.fillMesh.name = `spline_fill_${this.id}`, this.fillMesh.position.z = -0.1, this.group.add(this.fillMesh);
  }
  /**
   * Clear existing meshes
   */
  clearMeshes() {
    this.lineMesh && (this.group.remove(this.lineMesh), this.lineMesh.geometry.dispose(), this.lineMesh.material.dispose(), this.lineMesh = null), this.fillMesh && (this.group.remove(this.fillMesh), this.fillMesh.geometry.dispose(), this.fillMesh.material.dispose(), this.fillMesh = null), this.curve = null;
  }
  // ============================================================================
  // PATH UTILITIES
  // ============================================================================
  /**
   * Get a point on the path at parameter t (0-1)
   */
  getPointAt(n) {
    return this.curve ? this.curve.getPointAt(Math.max(0, Math.min(1, n))) : null;
  }
  /**
   * Get the tangent at parameter t (0-1)
   */
  getTangentAt(n) {
    return this.curve ? this.curve.getTangentAt(Math.max(0, Math.min(1, n))) : null;
  }
  /**
   * Get the total length of the path
   */
  getLength() {
    return this.curve ? this.curve.getLength() : 0;
  }
  /**
   * Get point and rotation for placing objects along path
   */
  getTransformAt(n) {
    const i = this.getPointAt(n), r = this.getTangentAt(n);
    if (!i || !r) return null;
    const o = Math.atan2(r.y, r.x) * (180 / Math.PI);
    return { position: i, rotation: o };
  }
  /**
   * Get the underlying curve for advanced operations
   */
  getCurve() {
    return this.curve;
  }
  // ============================================================================
  // PROPERTY SETTERS
  // ============================================================================
  /**
   * Set stroke color
   */
  setStroke(n) {
    this.splineData.stroke = n, this.lineMesh && this.lineMesh.material.color.set(n);
  }
  /**
   * Set stroke width
   */
  setStrokeWidth(n) {
    this.splineData.strokeWidth = n, this.lineMesh && (this.lineMesh.material.linewidth = n);
  }
  /**
   * Set fill color
   */
  setFill(n) {
    if (this.splineData.fill = n, this.fillMesh)
      this.fillMesh.material.color.set(n);
    else if (n && this.splineData.closed && this.curve) {
      const i = this.curve.getPoints(this.splineData.controlPoints.length * 20);
      this.createFill(i);
    }
  }
  /**
   * Update control points
   */
  setControlPoints(n) {
    this.splineData.controlPoints = n, this.buildSpline();
  }
  /**
   * Set closed state
   */
  setClosed(n) {
    this.splineData.closed !== n && (this.splineData.closed = n, this.buildSpline());
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
  }
  onUpdate(n) {
    const i = n.data;
    if (i) {
      let r = !1;
      i.controlPoints !== void 0 && (this.splineData.controlPoints = i.controlPoints, r = !0), i.closed !== void 0 && i.closed !== this.splineData.closed && (this.splineData.closed = i.closed, r = !0), i.stroke !== void 0 && this.setStroke(i.stroke), i.strokeWidth !== void 0 && this.setStrokeWidth(i.strokeWidth), i.fill !== void 0 && this.setFill(i.fill), r && this.buildSpline();
    }
  }
  onDispose() {
    this.clearMeshes();
  }
}
const ys = 16, t8 = 50;
function Qv(s) {
  return {
    id: s || `emitter_${Date.now()}`,
    name: "Emitter",
    enabled: !0,
    position: { x: 0.5, y: 0.5, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    shape: { type: "point" },
    emissionRate: 100,
    emissionRateVariance: 0,
    burstCount: 0,
    burstInterval: 0,
    initialSpeed: 200,
    speedVariance: 50,
    inheritEmitterVelocity: 0,
    initialSize: 10,
    sizeVariance: 2,
    initialMass: 1,
    massVariance: 0,
    lifetime: 120,
    lifetimeVariance: 20,
    initialRotation: 0,
    rotationVariance: 360,
    initialAngularVelocity: 0,
    angularVelocityVariance: 0,
    colorStart: [1, 1, 1, 1],
    colorEnd: [1, 1, 1, 0],
    colorVariance: 0,
    emissionDirection: { x: 0, y: -1, z: 0 },
    emissionSpread: 30,
    burstOnBeat: !1,
    beatEmissionMultiplier: 5
  };
}
function n8(s, e) {
  const n = {
    id: e || `force_${Date.now()}`,
    name: s.charAt(0).toUpperCase() + s.slice(1),
    type: s,
    enabled: !0,
    strength: 100,
    position: { x: 0.5, y: 0.5, z: 0 },
    falloffStart: 0,
    falloffEnd: 500,
    falloffType: "linear"
  };
  switch (s) {
    case "gravity":
      n.direction = { x: 0, y: 1, z: 0 }, n.strength = 98;
      break;
    case "vortex":
      n.vortexAxis = { x: 0, y: 0, z: 1 }, n.inwardForce = 20;
      break;
    case "turbulence":
      n.noiseScale = 5e-3, n.noiseSpeed = 0.5, n.noiseOctaves = 3, n.noiseLacunarity = 2, n.noiseGain = 0.5;
      break;
    case "drag":
      n.linearDrag = 0.1, n.quadraticDrag = 0.01;
      break;
    case "wind":
      n.windDirection = { x: 1, y: 0, z: 0 }, n.gustStrength = 50, n.gustFrequency = 0.1;
      break;
    case "lorenz":
      n.lorenzSigma = 10, n.lorenzRho = 28, n.lorenzBeta = 2.667;
      break;
  }
  return n;
}
function Hy() {
  return {
    maxParticles: 1e5,
    simulationSpace: "world",
    deltaTimeMode: "variable",
    fixedDeltaTime: 1 / 60,
    timeScale: 1,
    warmupFrames: 0,
    emitters: [],
    forceFields: [],
    subEmitters: [],
    lifetimeModulation: {},
    render: {
      mode: "billboard",
      sortByDepth: !0,
      depthWrite: !1,
      depthTest: !0,
      blendMode: "normal",
      stretchFactor: 1,
      minStretch: 1,
      maxStretch: 4,
      trailLength: 0,
      trailSegments: 8,
      trailWidthStart: 1,
      trailWidthEnd: 0,
      trailFadeMode: "both",
      texture: {},
      shadow: {
        castShadows: !1,
        receiveShadows: !1,
        shadowSoftness: 1,
        shadowBias: 1e-3,
        aoEnabled: !1,
        aoRadius: 10,
        aoIntensity: 0.5,
        aoSamples: 8
      },
      lighting: {
        receiveLighting: !1,
        roughness: 0.5,
        metalness: 0,
        emissiveIntensity: 0,
        subsurfaceScattering: !1,
        subsurfaceColor: [1, 0.5, 0.5],
        subsurfaceRadius: 1
      },
      motionBlur: !1,
      motionBlurSamples: 4,
      motionBlurStrength: 0.5,
      lodEnabled: !1,
      lodDistances: [100, 500, 1e3],
      lodSizeMultipliers: [1, 0.5, 0.25]
    },
    audioBindings: [],
    spatialHashCellSize: t8,
    updateFrequency: 1,
    cullOffscreen: !0
  };
}
class eg {
  constructor(e = {}) {
    fe(this, "config");
    fe(this, "gl", null);
    fe(this, "renderer", null);
    // Double-buffered particle data
    fe(this, "particleBufferA");
    fe(this, "particleBufferB");
    fe(this, "currentBuffer", "A");
    // WebGL resources
    fe(this, "transformFeedbackProgram", null);
    fe(this, "renderProgram", null);
    fe(this, "vaoA", null);
    fe(this, "vaoB", null);
    fe(this, "particleVboA", null);
    fe(this, "particleVboB", null);
    fe(this, "transformFeedbackA", null);
    fe(this, "transformFeedbackB", null);
    // Three.js integration
    fe(this, "particleMesh", null);
    fe(this, "instancedGeometry", null);
    fe(this, "material", null);
    // Textures for modulation curves
    fe(this, "sizeOverLifetimeTexture", null);
    fe(this, "opacityOverLifetimeTexture", null);
    fe(this, "colorOverLifetimeTexture", null);
    // Emitter state
    fe(this, "emitters", /* @__PURE__ */ new Map());
    fe(this, "forceFields", /* @__PURE__ */ new Map());
    fe(this, "subEmitters", /* @__PURE__ */ new Map());
    // Runtime state
    fe(this, "state", {
      particleCount: 0,
      activeEmitters: 0,
      simulationTime: 0,
      frameCount: 0,
      updateTimeMs: 0,
      renderTimeMs: 0,
      gpuMemoryBytes: 0,
      currentAudioFeatures: /* @__PURE__ */ new Map()
    });
    // Audio reactivity
    fe(this, "audioFeatures", /* @__PURE__ */ new Map());
    // Spatial hash for neighbor queries (flocking)
    fe(this, "spatialHash", /* @__PURE__ */ new Map());
    // Event system
    fe(this, "eventHandlers", /* @__PURE__ */ new Map());
    // Pool of free particle indices
    fe(this, "freeIndices", []);
    fe(this, "nextParticleIndex", 0);
    // Random number generator with seed
    fe(this, "rng");
    this.config = { ...Hy(), ...e };
    const n = this.config.maxParticles * ys;
    this.particleBufferA = new Float32Array(n), this.particleBufferB = new Float32Array(n);
    for (let i = this.config.maxParticles - 1; i >= 0; i--)
      this.freeIndices.push(i);
    this.rng = this.createSeededRandom(this.config.randomSeed ?? Date.now()), this.config.emitters.forEach((i) => this.addEmitter(i)), this.config.forceFields.forEach((i) => this.addForceField(i)), this.config.subEmitters.forEach((i) => this.addSubEmitter(i));
  }
  // ============================================================================
  // Initialization
  // ============================================================================
  /**
   * Initialize GPU resources. Must be called before simulation.
   */
  initialize(e) {
    if (this.renderer = e, this.gl = e.getContext(), !this.gl)
      throw new Error("WebGL2 context required for GPU particle system");
    this.createModulationTextures(), this.createParticleMesh(), this.state.gpuMemoryBytes = this.config.maxParticles * ys * 4 * 2;
  }
  /**
   * Create textures for lifetime modulation curves
   */
  createModulationTextures() {
    const n = new Float32Array(256);
    this.sampleModulationCurve(this.config.lifetimeModulation.sizeOverLifetime, n), this.sizeOverLifetimeTexture = new $a(
      n,
      256,
      1,
      Qc,
      di
    ), this.sizeOverLifetimeTexture.needsUpdate = !0;
    const i = new Float32Array(256);
    this.sampleModulationCurve(this.config.lifetimeModulation.opacityOverLifetime, i), this.opacityOverLifetimeTexture = new $a(
      i,
      256,
      1,
      Qc,
      di
    ), this.opacityOverLifetimeTexture.needsUpdate = !0;
    const r = this.config.lifetimeModulation.colorOverLifetime || [
      { time: 0, color: [1, 1, 1, 1] },
      { time: 1, color: [1, 1, 1, 1] }
    ], o = new Float32Array(256 * 4);
    for (let a = 0; a < 256; a++) {
      const l = a / 255, c = this.sampleColorGradient(r, l);
      o[a * 4] = c[0], o[a * 4 + 1] = c[1], o[a * 4 + 2] = c[2], o[a * 4 + 3] = c[3];
    }
    this.colorOverLifetimeTexture = new $a(
      o,
      256,
      1,
      Un,
      di
    ), this.colorOverLifetimeTexture.needsUpdate = !0;
  }
  /**
   * Sample a modulation curve into a float array
   */
  sampleModulationCurve(e, n) {
    const i = n.length;
    if (!e) {
      n.fill(1);
      return;
    }
    for (let r = 0; r < i; r++) {
      const o = r / (i - 1);
      n[r] = this.evaluateModulationCurve(e, o);
    }
  }
  /**
   * Evaluate a modulation curve at time t
   */
  evaluateModulationCurve(e, n) {
    switch (e.type) {
      case "constant":
        return e.value;
      case "linear":
        return e.start + (e.end - e.start) * n;
      case "curve": {
        const i = e.points;
        if (i.length === 0) return 1;
        if (i.length === 1) return i[0].value;
        let r = i[0], o = i[i.length - 1];
        for (let p = 0; p < i.length - 1; p++)
          if (n >= i[p].time && n <= i[p + 1].time) {
            r = i[p], o = i[p + 1];
            break;
          }
        const a = (n - r.time) / (o.time - r.time), l = a * a, c = l * a, u = 2 * c - 3 * l + 1, d = -2 * c + 3 * l, h = c - 2 * l + a, m = c - l;
        return u * r.value + d * o.value + h * (r.outTangent ?? 0) + m * (o.inTangent ?? 0);
      }
      case "random":
        return e.min + this.rng() * (e.max - e.min);
      case "randomCurve": {
        const i = this.evaluateModulationCurve(e.minCurve, n), r = this.evaluateModulationCurve(e.maxCurve, n);
        return i + this.rng() * (r - i);
      }
      default:
        return 1;
    }
  }
  /**
   * Sample color gradient at time t
   */
  sampleColorGradient(e, n) {
    if (e.length === 0) return [1, 1, 1, 1];
    if (e.length === 1) return e[0].color;
    let i = e[0], r = e[e.length - 1];
    for (let a = 0; a < e.length - 1; a++)
      if (n >= e[a].time && n <= e[a + 1].time) {
        i = e[a], r = e[a + 1];
        break;
      }
    const o = (n - i.time) / (r.time - i.time);
    return [
      i.color[0] + (r.color[0] - i.color[0]) * o,
      i.color[1] + (r.color[1] - i.color[1]) * o,
      i.color[2] + (r.color[2] - i.color[2]) * o,
      i.color[3] + (r.color[3] - i.color[3]) * o
    ];
  }
  /**
   * Create the Three.js mesh for particle rendering
   */
  createParticleMesh() {
    const e = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      1
    ]), n = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1
    ]);
    this.instancedGeometry = new wy(), this.instancedGeometry.setAttribute("position", new Si(e, 2)), this.instancedGeometry.setAttribute("uv", new Si(n, 2));
    const i = new Ar(
      new Float32Array(this.config.maxParticles * 3),
      3
    ), r = new Ar(
      new Float32Array(this.config.maxParticles * 3),
      3
    ), o = new Ar(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), a = new Ar(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), l = new Ar(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), c = new Ar(
      new Float32Array(this.config.maxParticles * 4),
      4
    );
    i.setUsage(eo), r.setUsage(eo), o.setUsage(eo), a.setUsage(eo), l.setUsage(eo), c.setUsage(eo), this.instancedGeometry.setAttribute("i_position", i), this.instancedGeometry.setAttribute("i_velocity", r), this.instancedGeometry.setAttribute("i_life", o), this.instancedGeometry.setAttribute("i_physical", a), this.instancedGeometry.setAttribute("i_rotation", l), this.instancedGeometry.setAttribute("i_color", c), this.material = new zn({
      vertexShader: this.getVertexShader(),
      fragmentShader: this.getFragmentShader(),
      uniforms: this.createUniforms(),
      transparent: !0,
      depthWrite: this.config.render.depthWrite,
      depthTest: this.config.render.depthTest,
      blending: this.getThreeBlending()
    }), this.particleMesh = new Ze(this.instancedGeometry, this.material), this.particleMesh.frustumCulled = !1;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    this.emitters.set(e.id, {
      ...e,
      accumulator: 0,
      velocity: new de()
    }), this.state.activeEmitters = this.emitters.size;
  }
  updateEmitter(e, n) {
    const i = this.emitters.get(e);
    i && Object.assign(i, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.state.activeEmitters = this.emitters.size;
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  // ============================================================================
  // Force Field Management
  // ============================================================================
  addForceField(e) {
    this.forceFields.set(e.id, e);
  }
  updateForceField(e, n) {
    const i = this.forceFields.get(e);
    i && Object.assign(i, n);
  }
  removeForceField(e) {
    this.forceFields.delete(e);
  }
  // ============================================================================
  // Sub-Emitter Management
  // ============================================================================
  addSubEmitter(e) {
    this.subEmitters.set(e.id, e);
  }
  removeSubEmitter(e) {
    this.subEmitters.delete(e);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  /**
   * Step the particle simulation forward
   */
  step(e) {
    var r;
    const n = performance.now(), i = this.config.deltaTimeMode === "fixed" ? this.config.fixedDeltaTime : e * this.config.timeScale;
    this.emitParticles(i), this.updatePhysics(i), this.processSubEmitters(), (r = this.config.flocking) != null && r.enabled && (this.updateSpatialHash(), this.applyFlocking(i)), this.applyAudioModulation(), this.updateInstanceBuffers(), this.state.simulationTime += i, this.state.frameCount++, this.state.updateTimeMs = performance.now() - n;
  }
  /**
   * Emit particles from all active emitters
   */
  emitParticles(e) {
    for (const n of this.emitters.values()) {
      if (!n.enabled) continue;
      let i = n.emissionRate;
      const r = this.getAudioModulation("emitter", n.id, "emissionRate");
      if (r !== void 0 && (i *= r), n.burstOnBeat && this.audioFeatures.get("beat") === 1) {
        const o = Math.floor(n.burstCount * n.beatEmissionMultiplier);
        for (let a = 0; a < o; a++)
          this.spawnParticle(n);
      }
      for (n.accumulator += i * e; n.accumulator >= 1; )
        this.spawnParticle(n), n.accumulator -= 1;
    }
  }
  /**
   * Spawn a single particle from an emitter
   */
  spawnParticle(e) {
    if (this.freeIndices.length === 0) {
      let d = 0, h = 0;
      const m = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
      for (let p = 0; p < this.config.maxParticles; p++) {
        const v = m[p * ys + 6];
        v > h && (h = v, d = p);
      }
      this.freeIndices.push(d);
    }
    const n = this.freeIndices.pop(), i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, r = n * ys, o = this.getEmitterPosition(e), a = this.getEmissionDirection(e), l = e.initialSpeed + (this.rng() - 0.5) * 2 * e.speedVariance, c = e.velocity.clone().multiplyScalar(e.inheritEmitterVelocity);
    i[r + 0] = o.x, i[r + 1] = o.y, i[r + 2] = o.z, i[r + 3] = a.x * l + c.x, i[r + 4] = a.y * l + c.y, i[r + 5] = a.z * l + c.z, i[r + 6] = 0, i[r + 7] = e.lifetime + (this.rng() - 0.5) * 2 * e.lifetimeVariance, i[r + 8] = e.initialMass + (this.rng() - 0.5) * 2 * e.massVariance, i[r + 9] = e.initialSize + (this.rng() - 0.5) * 2 * e.sizeVariance, i[r + 10] = e.initialRotation + this.rng() * e.rotationVariance, i[r + 11] = e.initialAngularVelocity + (this.rng() - 0.5) * 2 * e.angularVelocityVariance;
    const u = this.rng() * e.colorVariance;
    return i[r + 12] = e.colorStart[0] + (e.colorEnd[0] - e.colorStart[0]) * u, i[r + 13] = e.colorStart[1] + (e.colorEnd[1] - e.colorStart[1]) * u, i[r + 14] = e.colorStart[2] + (e.colorEnd[2] - e.colorStart[2]) * u, i[r + 15] = e.colorStart[3], this.state.particleCount++, this.emit("particleBirth", { index: n, emitterId: e.id }), n;
  }
  /**
   * Get spawn position based on emitter shape
   */
  getEmitterPosition(e) {
    const n = e.shape, i = new de(e.position.x, e.position.y, e.position.z);
    switch (n.type) {
      case "point":
        return i;
      case "circle": {
        const r = this.rng() * Math.PI * 2;
        let o = n.radius ?? 50;
        return n.emitFromEdge || (o *= Math.sqrt(this.rng())), i.add(new de(
          Math.cos(r) * o,
          Math.sin(r) * o,
          0
        ));
      }
      case "sphere": {
        const r = this.rng() * Math.PI * 2, o = Math.acos(2 * this.rng() - 1);
        let a = n.radius ?? 50;
        return n.emitFromEdge || (a *= Math.cbrt(this.rng())), i.add(new de(
          Math.sin(o) * Math.cos(r) * a,
          Math.sin(o) * Math.sin(r) * a,
          Math.cos(o) * a
        ));
      }
      case "box": {
        const r = n.boxSize ?? { x: 100, y: 100, z: 100 };
        return i.add(new de(
          (this.rng() - 0.5) * r.x,
          (this.rng() - 0.5) * r.y,
          (this.rng() - 0.5) * r.z
        ));
      }
      case "line": {
        const r = n.lineStart ?? { x: -50, y: 0, z: 0 }, o = n.lineEnd ?? { x: 50, y: 0, z: 0 }, a = this.rng();
        return i.add(new de(
          r.x + (o.x - r.x) * a,
          r.y + (o.y - r.y) * a,
          r.z + (o.z - r.z) * a
        ));
      }
      case "cone": {
        const r = this.rng() * Math.PI * 2, o = this.rng(), a = o * (n.coneRadius ?? 50), l = o * (n.coneLength ?? 100);
        return i.add(new de(
          Math.cos(r) * a,
          l,
          Math.sin(r) * a
        ));
      }
      case "image": {
        if (!n.imageData) return i;
        const { width: r, height: o, data: a } = n.imageData, l = n.emissionThreshold ?? 0.1;
        for (let c = 0; c < 100; c++) {
          const u = Math.floor(this.rng() * r), d = Math.floor(this.rng() * o), h = (d * r + u) * 4;
          if (a[h + 3] / 255 > l)
            return i.add(new de(
              u - r / 2,
              -(d - o / 2),
              // Flip Y for screen coords
              0
            ));
        }
        return i;
      }
      case "depthEdge": {
        if (!n.depthData || !n.imageData) return i;
        const { width: r, height: o } = n.imageData, a = n.depthData, l = n.emissionThreshold ?? 0.05;
        for (let c = 0; c < 100; c++) {
          const u = Math.floor(this.rng() * (r - 2)) + 1, d = Math.floor(this.rng() * (o - 2)) + 1, h = d * r + u, m = a[h], p = a[h - 1], v = a[h + 1], x = a[h - r], g = a[h + r], _ = Math.abs(v - p), M = Math.abs(g - x);
          if (Math.sqrt(_ * _ + M * M) > l) {
            const b = m * 500;
            return i.add(new de(
              u - r / 2,
              -(d - o / 2),
              // Flip Y for screen coords
              b
            ));
          }
        }
        return i;
      }
      default:
        return i;
    }
  }
  /**
   * Get emission direction based on emitter settings
   */
  getEmissionDirection(e) {
    const n = new de(
      e.emissionDirection.x,
      e.emissionDirection.y,
      e.emissionDirection.z
    ).normalize();
    if (e.emissionSpread <= 0)
      return n;
    const i = e.emissionSpread * Math.PI / 180, r = this.rng() * Math.PI * 2, o = Math.acos(1 - this.rng() * (1 - Math.cos(i))), a = Math.abs(n.y) < 0.99 ? new de(0, 1, 0) : new de(1, 0, 0), l = new de().crossVectors(a, n).normalize(), c = new de().crossVectors(n, l);
    return new de().addScaledVector(n, Math.cos(o)).addScaledVector(l, Math.sin(o) * Math.cos(r)).addScaledVector(c, Math.sin(o) * Math.sin(r)).normalize();
  }
  /**
   * Update particle physics (CPU implementation)
   */
  updatePhysics(e) {
    const n = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const r = i * ys, o = n[r + 6], a = n[r + 7];
      if (a <= 0 || o >= a) continue;
      let l = n[r + 0], c = n[r + 1], u = n[r + 2], d = n[r + 3], h = n[r + 4], m = n[r + 5];
      const p = n[r + 8];
      let v = 0, x = 0, g = 0;
      for (const T of this.forceFields.values()) {
        if (!T.enabled) continue;
        const y = this.calculateForceField(T, l, c, u, d, h, m, p);
        v += y.x, x += y.y, g += y.z;
      }
      const _ = v / Math.max(p, 0.1), M = x / Math.max(p, 0.1), S = g / Math.max(p, 0.1);
      d += _ * e, h += M * e, m += S * e, l += d * e, c += h * e, u += m * e;
      const b = o / a, C = this.evaluateModulationCurve(
        this.config.lifetimeModulation.sizeOverLifetime || { type: "constant", value: 1 },
        b
      ), E = this.evaluateModulationCurve(
        this.config.lifetimeModulation.opacityOverLifetime || { type: "constant", value: 1 },
        b
      ), P = n[r + 10] + n[r + 11] * e;
      n[r + 0] = l, n[r + 1] = c, n[r + 2] = u, n[r + 3] = d, n[r + 4] = h, n[r + 5] = m, n[r + 6] = o + e, n[r + 9] *= C, n[r + 10] = P, n[r + 15] *= E, o + e >= a && (this.freeIndices.push(i), this.state.particleCount--, this.emit("particleDeath", { index: i }));
    }
  }
  /**
   * Calculate force from a force field
   */
  calculateForceField(e, n, i, r, o, a, l, c) {
    var g, _, M, S, b, C, E, P, T;
    const u = new de(), d = n - e.position.x, h = i - e.position.y, m = r - e.position.z, p = Math.sqrt(d * d + h * h + m * m);
    let v = 1;
    if (p > e.falloffStart) {
      const y = Math.min((p - e.falloffStart) / (e.falloffEnd - e.falloffStart), 1);
      switch (e.falloffType) {
        case "linear":
          v = 1 - y;
          break;
        case "quadratic":
          v = 1 - y * y;
          break;
        case "exponential":
          v = Math.exp(-y * 3);
          break;
        case "smoothstep":
          v = 1 - (3 * y * y - 2 * y * y * y);
          break;
      }
    }
    const x = e.strength * v;
    switch (e.type) {
      case "gravity":
        u.set(
          (((g = e.direction) == null ? void 0 : g.x) ?? 0) * x,
          (((_ = e.direction) == null ? void 0 : _.y) ?? 1) * x,
          (((M = e.direction) == null ? void 0 : M.z) ?? 0) * x
        );
        break;
      case "point":
        if (p > 1e-3) {
          const y = new de(-d, -h, -m).normalize();
          u.copy(y).multiplyScalar(x / c);
        }
        break;
      case "vortex":
        if (p > 1e-3) {
          const y = new de(
            ((S = e.vortexAxis) == null ? void 0 : S.x) ?? 0,
            ((b = e.vortexAxis) == null ? void 0 : b.y) ?? 0,
            ((C = e.vortexAxis) == null ? void 0 : C.z) ?? 1
          ).normalize(), w = new de(d, h, m), D = new de().crossVectors(y, w).normalize(), U = w.normalize().multiplyScalar(-(e.inwardForce ?? 0));
          u.copy(D).multiplyScalar(x).add(U);
        }
        break;
      case "turbulence": {
        const y = e.noiseScale ?? 0.01, w = e.noiseSpeed ?? 0.5, D = this.state.simulationTime * w, U = Math.sin(n * y + D) * Math.cos(i * y * 1.3) * x, R = Math.sin(i * y + D * 1.1) * Math.cos(r * y * 1.2) * x, O = Math.sin(r * y + D * 0.9) * Math.cos(n * y * 1.1) * x;
        u.set(U, R, O);
        break;
      }
      case "drag": {
        const y = Math.sqrt(o * o + a * a + l * l);
        if (y > 1e-3) {
          const w = (e.linearDrag ?? 0.1) * y + (e.quadraticDrag ?? 0.01) * y * y;
          u.set(-o, -a, -l).normalize().multiplyScalar(-w * x);
        }
        break;
      }
      case "wind": {
        const y = new de(
          ((E = e.windDirection) == null ? void 0 : E.x) ?? 1,
          ((P = e.windDirection) == null ? void 0 : P.y) ?? 0,
          ((T = e.windDirection) == null ? void 0 : T.z) ?? 0
        ).normalize(), w = Math.sin(this.state.simulationTime * (e.gustFrequency ?? 0.5)) * (e.gustStrength ?? 0);
        u.copy(y).multiplyScalar(x + w);
        break;
      }
      case "lorenz": {
        const y = e.lorenzSigma ?? 10, w = e.lorenzRho ?? 28, D = e.lorenzBeta ?? 2.667;
        u.set(
          y * (h - d),
          d * (w - m) - h,
          d * h - D * m
        ).multiplyScalar(x * 0.01);
        break;
      }
    }
    return u;
  }
  /**
   * Process sub-emitter triggers
   */
  processSubEmitters() {
  }
  /**
   * Update spatial hash for neighbor queries
   */
  updateSpatialHash() {
    this.spatialHash.clear();
    const e = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, n = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const r = i * ys;
      if (e[r + 7] <= 0) continue;
      const a = e[r + 0], l = e[r + 1], c = e[r + 2], u = Math.floor(a / n), d = Math.floor(l / n), h = Math.floor(c / n), m = `${u},${d},${h}`;
      this.spatialHash.has(m) || this.spatialHash.set(m, []), this.spatialHash.get(m).push(i);
    }
  }
  /**
   * Apply flocking behaviors
   */
  applyFlocking(e) {
    const n = this.config.flocking;
    if (!(n != null && n.enabled)) return;
    const i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, r = this.config.spatialHashCellSize;
    for (let o = 0; o < this.config.maxParticles; o++) {
      const a = o * ys;
      if (i[a + 7] <= 0) continue;
      const c = i[a + 0], u = i[a + 1], d = i[a + 2], h = Math.floor(c / r), m = Math.floor(u / r), p = Math.floor(d / r), v = new de(), x = new de(), g = new de();
      let _ = 0, M = 0, S = 0;
      for (let E = h - 1; E <= h + 1; E++)
        for (let P = m - 1; P <= m + 1; P++)
          for (let T = p - 1; T <= p + 1; T++) {
            const y = this.spatialHash.get(`${E},${P},${T}`);
            if (y)
              for (const w of y) {
                if (w === o) continue;
                const D = w * ys, U = i[D + 0], R = i[D + 1], O = i[D + 2], A = c - U, G = u - R, ue = d - O, Q = Math.sqrt(A * A + G * G + ue * ue);
                Q < n.separationRadius && Q > 0 && (v.add(new de(A, G, ue).divideScalar(Q)), _++), Q < n.alignmentRadius && (x.add(new de(
                  i[D + 3],
                  i[D + 4],
                  i[D + 5]
                )), M++), Q < n.cohesionRadius && (g.add(new de(U, R, O)), S++);
              }
          }
      _ > 0 && v.divideScalar(_).normalize().multiplyScalar(n.separationWeight), M > 0 && x.divideScalar(M).normalize().multiplyScalar(n.alignmentWeight), S > 0 && (g.divideScalar(S), g.sub(new de(c, u, d)).normalize().multiplyScalar(n.cohesionWeight));
      const b = v.add(x).add(g);
      b.length() > n.maxForce && b.normalize().multiplyScalar(n.maxForce), i[a + 3] += b.x * e, i[a + 4] += b.y * e, i[a + 5] += b.z * e;
      const C = Math.sqrt(
        i[a + 3] ** 2 + i[a + 4] ** 2 + i[a + 5] ** 2
      );
      if (C > n.maxSpeed) {
        const E = n.maxSpeed / C;
        i[a + 3] *= E, i[a + 4] *= E, i[a + 5] *= E;
      }
    }
  }
  /**
   * Apply audio modulation to parameters
   */
  applyAudioModulation() {
    for (const e of this.config.audioBindings) {
      const r = ((this.audioFeatures.get(e.feature) ?? 0) - e.min) / (e.max - e.min);
      let o = e.outputMin + r * (e.outputMax - e.outputMin);
      if (e.curve === "exponential" ? o = e.outputMin + Math.pow(r, 2) * (e.outputMax - e.outputMin) : e.curve === "logarithmic" && (o = e.outputMin + Math.sqrt(r) * (e.outputMax - e.outputMin)), e.target === "emitter") {
        const a = this.emitters.get(e.targetId);
        a && (a[e.parameter] = o);
      } else if (e.target === "forceField") {
        const a = this.forceFields.get(e.targetId);
        a && (a[e.parameter] = o);
      }
    }
  }
  /**
   * Get audio modulation for a specific parameter
   */
  getAudioModulation(e, n, i) {
    for (const r of this.config.audioBindings)
      if (r.target === e && r.targetId === n && r.parameter === i) {
        const a = ((this.audioFeatures.get(r.feature) ?? 0) - r.min) / (r.max - r.min);
        return r.outputMin + a * (r.outputMax - r.outputMin);
      }
  }
  /**
   * Update instance buffer attributes for rendering
   */
  updateInstanceBuffers() {
    if (!this.instancedGeometry) return;
    const e = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, n = this.instancedGeometry.getAttribute("i_position"), i = this.instancedGeometry.getAttribute("i_velocity"), r = this.instancedGeometry.getAttribute("i_life"), o = this.instancedGeometry.getAttribute("i_physical"), a = this.instancedGeometry.getAttribute("i_rotation"), l = this.instancedGeometry.getAttribute("i_color");
    for (let c = 0; c < this.config.maxParticles; c++) {
      const u = c * ys;
      n.setXYZ(c, e[u + 0], e[u + 1], e[u + 2]), i.setXYZ(c, e[u + 3], e[u + 4], e[u + 5]), r.setXY(c, e[u + 6], e[u + 7]), o.setXY(c, e[u + 8], e[u + 9]), a.setXY(c, e[u + 10], e[u + 11]), l.setXYZW(c, e[u + 12], e[u + 13], e[u + 14], e[u + 15]);
    }
    n.needsUpdate = !0, i.needsUpdate = !0, r.needsUpdate = !0, o.needsUpdate = !0, a.needsUpdate = !0, l.needsUpdate = !0;
  }
  // ============================================================================
  // Audio Integration
  // ============================================================================
  /**
   * Set audio feature value
   */
  setAudioFeature(e, n) {
    this.audioFeatures.set(e, n), this.state.currentAudioFeatures.set(e, n);
  }
  /**
   * Trigger beat event
   */
  triggerBeat() {
    this.audioFeatures.set("beat", 1), requestAnimationFrame(() => {
      this.audioFeatures.set("beat", 0);
    });
  }
  /**
   * Trigger burst on all beat-enabled emitters
   */
  triggerBurst(e) {
    if (e) {
      const n = this.emitters.get(e);
      if (n)
        for (let i = 0; i < n.burstCount; i++)
          this.spawnParticle(n);
    } else
      for (const n of this.emitters.values())
        if (n.burstOnBeat && n.enabled)
          for (let i = 0; i < n.burstCount; i++)
            this.spawnParticle(n);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  /**
   * Get the Three.js mesh for adding to scene
   */
  getMesh() {
    return this.particleMesh;
  }
  /**
   * Get vertex shader code
   */
  getVertexShader() {
    return `
      precision highp float;

      attribute vec2 position;
      attribute vec2 uv;

      attribute vec3 i_position;
      attribute vec3 i_velocity;
      attribute vec2 i_life;
      attribute vec2 i_physical;
      attribute vec2 i_rotation;
      attribute vec4 i_color;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      uniform vec3 cameraPosition;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      void main() {
        // Skip dead particles
        if (i_life.y <= 0.0 || i_life.x >= i_life.y) {
          gl_Position = vec4(0.0, 0.0, -1000.0, 1.0);
          return;
        }

        float size = i_physical.y;
        float rotation = i_rotation.x;
        float lifeRatio = i_life.x / i_life.y;

        // Billboard facing camera
        vec3 cameraRight = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
        vec3 cameraUp = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

        // Apply rotation
        float cosR = cos(rotation);
        float sinR = sin(rotation);
        vec2 rotatedPos = vec2(
          position.x * cosR - position.y * sinR,
          position.x * sinR + position.y * cosR
        );

        vec3 vertexPos = i_position
          + cameraRight * rotatedPos.x * size
          + cameraUp * rotatedPos.y * size;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPos, 1.0);

        vUv = uv;
        vColor = i_color;
        vLifeRatio = lifeRatio;
      }
    `;
  }
  /**
   * Get fragment shader code
   */
  getFragmentShader() {
    return `
      precision highp float;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      uniform sampler2D diffuseMap;
      uniform int hasDiffuseMap;
      uniform int proceduralShape;

      float proceduralAlpha(vec2 uv, int shape) {
        vec2 centered = uv * 2.0 - 1.0;
        float dist = length(centered);

        if (shape == 1) {
          return 1.0 - smoothstep(0.8, 1.0, dist);
        } else if (shape == 2) {
          return smoothstep(0.5, 0.6, dist) * (1.0 - smoothstep(0.9, 1.0, dist));
        }

        return 1.0;
      }

      void main() {
        vec4 texColor = vec4(1.0);

        if (hasDiffuseMap == 1) {
          texColor = texture2D(diffuseMap, vUv);
        } else if (proceduralShape > 0) {
          float alpha = proceduralAlpha(vUv, proceduralShape);
          texColor = vec4(1.0, 1.0, 1.0, alpha);
        }

        vec4 finalColor = texColor * vColor;

        if (finalColor.a < 0.01) discard;

        gl_FragColor = finalColor;
      }
    `;
  }
  /**
   * Create shader uniforms
   */
  createUniforms() {
    return {
      diffuseMap: { value: null },
      hasDiffuseMap: { value: 0 },
      proceduralShape: { value: 1 }
      // Circle by default
    };
  }
  /**
   * Get Three.js blending mode
   */
  getThreeBlending() {
    switch (this.config.render.blendMode) {
      case "additive":
        return al;
      case "multiply":
        return Io;
      case "screen":
        return Rr;
      default:
        return Gi;
    }
  }
  // ============================================================================
  // Event System
  // ============================================================================
  on(e, n) {
    this.eventHandlers.has(e) || this.eventHandlers.set(e, /* @__PURE__ */ new Set()), this.eventHandlers.get(e).add(n);
  }
  off(e, n) {
    var i;
    (i = this.eventHandlers.get(e)) == null || i.delete(n);
  }
  emit(e, n) {
    var r;
    const i = {
      type: e,
      timestamp: performance.now(),
      data: n
    };
    (r = this.eventHandlers.get(e)) == null || r.forEach((o) => o(i));
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  /**
   * Create seeded random number generator
   */
  createSeededRandom(e) {
    let n = e;
    return () => (n = n * 1103515245 + 12345 & 2147483647, n / 2147483647);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Get current configuration (emitters and force fields)
   */
  getConfig() {
    return {
      emitters: Array.from(this.emitters.values()).map((n) => {
        const { accumulator: i, velocity: r, ...o } = n;
        return o;
      }),
      forceFields: Array.from(this.forceFields.values())
    };
  }
  /**
   * Reset the particle system
   */
  reset() {
    this.particleBufferA.fill(0), this.particleBufferB.fill(0), this.freeIndices = [];
    for (let e = this.config.maxParticles - 1; e >= 0; e--)
      this.freeIndices.push(e);
    this.state.particleCount = 0, this.state.simulationTime = 0, this.state.frameCount = 0, this.spatialHash.clear();
  }
  /**
   * Dispose all resources
   */
  dispose() {
    var e, n, i, r, o;
    (e = this.instancedGeometry) == null || e.dispose(), (n = this.material) == null || n.dispose(), (i = this.sizeOverLifetimeTexture) == null || i.dispose(), (r = this.opacityOverLifetimeTexture) == null || r.dispose(), (o = this.colorOverLifetimeTexture) == null || o.dispose(), this.emitters.clear(), this.forceFields.clear(), this.subEmitters.clear(), this.eventHandlers.clear();
  }
}
class i8 extends Yi {
  constructor(n) {
    super(n);
    /** The GPU particle system instance */
    fe(this, "particleSystem");
    /** Particle system configuration */
    fe(this, "systemConfig");
    /** Whether the system has been initialized with a renderer */
    fe(this, "initialized", !1);
    /** Stored renderer reference for reinitialization */
    fe(this, "rendererRef", null);
    /** Composition FPS for time calculation */
    fe(this, "fps", 60);
    /** Performance stats */
    fe(this, "stats", {
      particleCount: 0,
      updateTimeMs: 0,
      renderTimeMs: 0
    });
    this.systemConfig = this.buildSystemConfig(n), this.particleSystem = new eg(this.systemConfig), this.initializeBlendMode();
  }
  /**
   * Build GPUParticleSystemConfig from layer data
   */
  buildSystemConfig(n) {
    const i = n.data, r = Hy();
    if (!i)
      return r.emitters = [Qv("default")], r;
    if (i.systemConfig) {
      if (r.maxParticles = i.systemConfig.maxParticles ?? 1e5, r.timeScale = 1, i.systemConfig.gravity !== 0 && r.forceFields.push({
        id: "global_gravity",
        name: "Gravity",
        type: "gravity",
        enabled: !0,
        strength: i.systemConfig.gravity * 10,
        position: { x: 0, y: 0, z: 0 },
        falloffStart: 0,
        falloffEnd: 1e4,
        falloffType: "none",
        direction: { x: 0, y: 1, z: 0 }
      }), i.systemConfig.windStrength !== 0) {
        const o = (i.systemConfig.windDirection ?? 0) * Math.PI / 180;
        r.forceFields.push({
          id: "global_wind",
          name: "Wind",
          type: "wind",
          enabled: !0,
          strength: i.systemConfig.windStrength,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          windDirection: {
            x: Math.cos(o),
            y: Math.sin(o),
            z: 0
          },
          gustStrength: i.systemConfig.windStrength * 0.3,
          gustFrequency: 0.1
        });
      }
      if (i.systemConfig.friction > 0 && r.forceFields.push({
        id: "global_drag",
        name: "Friction",
        type: "drag",
        enabled: !0,
        strength: 1,
        position: { x: 0, y: 0, z: 0 },
        falloffStart: 0,
        falloffEnd: 1e4,
        falloffType: "none",
        linearDrag: i.systemConfig.friction,
        quadraticDrag: i.systemConfig.friction * 0.1
      }), i.systemConfig.turbulenceFields)
        for (const o of i.systemConfig.turbulenceFields)
          o.enabled && r.forceFields.push({
            id: o.id,
            name: "Turbulence",
            type: "turbulence",
            enabled: !0,
            strength: o.strength,
            position: { x: 0, y: 0, z: 0 },
            falloffStart: 0,
            falloffEnd: 1e4,
            falloffType: "none",
            noiseScale: o.scale,
            noiseSpeed: o.evolutionSpeed,
            noiseOctaves: 3,
            noiseLacunarity: 2,
            noiseGain: 0.5
          });
    }
    if (i.emitters)
      for (const o of i.emitters) {
        if (!o.enabled) continue;
        const a = (o.direction ?? 0) * Math.PI / 180, l = {
          id: o.id,
          name: o.name,
          enabled: !0,
          position: { x: o.x, y: o.y, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          shape: { type: "point" },
          emissionRate: o.emissionRate,
          emissionRateVariance: 0,
          burstCount: o.burstCount,
          burstInterval: 0,
          initialSpeed: o.speed,
          speedVariance: o.speedVariance,
          inheritEmitterVelocity: 0,
          initialSize: o.size,
          sizeVariance: o.sizeVariance,
          initialMass: 1,
          massVariance: 0,
          lifetime: o.particleLifetime,
          lifetimeVariance: o.lifetimeVariance,
          initialRotation: 0,
          rotationVariance: 360,
          initialAngularVelocity: 0,
          angularVelocityVariance: 0,
          colorStart: [
            o.color[0] / 255,
            o.color[1] / 255,
            o.color[2] / 255,
            1
          ],
          colorEnd: [
            o.color[0] / 255,
            o.color[1] / 255,
            o.color[2] / 255,
            0
          ],
          colorVariance: 0,
          emissionDirection: {
            x: Math.cos(a),
            y: Math.sin(a),
            z: 0
          },
          emissionSpread: o.spread,
          burstOnBeat: o.burstOnBeat,
          beatEmissionMultiplier: 5
        };
        r.emitters.push(l);
      }
    if (i.gravityWells)
      for (const o of i.gravityWells)
        o.enabled && r.forceFields.push({
          id: o.id,
          name: o.name,
          type: "point",
          enabled: !0,
          strength: o.strength,
          position: { x: o.x, y: o.y, z: 0 },
          falloffStart: 0,
          falloffEnd: o.radius,
          falloffType: o.falloff === "linear" ? "linear" : o.falloff === "quadratic" ? "quadratic" : "none"
        });
    if (i.vortices)
      for (const o of i.vortices)
        o.enabled && r.forceFields.push({
          id: o.id,
          name: o.name,
          type: "vortex",
          enabled: !0,
          strength: o.strength * o.rotationSpeed,
          position: { x: o.x, y: o.y, z: 0 },
          falloffStart: 0,
          falloffEnd: o.radius,
          falloffType: "linear",
          vortexAxis: { x: 0, y: 0, z: 1 },
          inwardForce: o.inwardPull
        });
    if (i.modulations) {
      const o = i.modulations.filter((l) => l.property === "size");
      if (o.length > 0) {
        const l = o[0];
        r.lifetimeModulation.sizeOverLifetime = {
          type: "linear",
          start: l.startValue / 100,
          end: l.endValue / 100
        };
      }
      const a = i.modulations.filter((l) => l.property === "opacity");
      if (a.length > 0) {
        const l = a[0];
        r.lifetimeModulation.opacityOverLifetime = {
          type: "linear",
          start: l.startValue / 100,
          end: l.endValue / 100
        };
      }
    }
    return i.renderOptions && (r.render.blendMode = i.renderOptions.blendMode ?? "normal", r.render.motionBlur = i.renderOptions.motionBlur ?? !1, r.render.motionBlurStrength = i.renderOptions.motionBlurStrength ?? 0.5, r.render.motionBlurSamples = i.renderOptions.motionBlurSamples ?? 4, i.renderOptions.renderTrails && (r.render.mode = "trail", r.render.trailLength = i.renderOptions.trailLength, r.render.trailWidthEnd = 1 - (i.renderOptions.trailOpacityFalloff ?? 0.8)), r.render.texture.proceduralType = i.renderOptions.particleShape === "star" ? "star" : i.renderOptions.particleShape === "square" ? "square" : "circle"), r;
  }
  /**
   * Initialize the particle system with a WebGL renderer
   */
  initializeWithRenderer(n) {
    if (this.initialized) return;
    this.rendererRef = n, this.particleSystem.initialize(n), this.initialized = !0;
    const i = this.particleSystem.getMesh();
    i && this.group.add(i);
  }
  /**
   * Set renderer for lazy initialization
   */
  setRenderer(n) {
    this.rendererRef = n, this.initialized || this.initializeWithRenderer(n);
  }
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(n) {
    this.fps = n;
  }
  // ============================================================================
  // EMITTER MANAGEMENT
  // ============================================================================
  /**
   * Add a new emitter
   */
  addEmitter(n) {
    const i = Qv();
    return n && Object.assign(i, n), this.particleSystem.addEmitter(i), i.id;
  }
  /**
   * Update an emitter
   */
  updateEmitter(n, i) {
    this.particleSystem.updateEmitter(n, i);
  }
  /**
   * Remove an emitter
   */
  removeEmitter(n) {
    this.particleSystem.removeEmitter(n);
  }
  // ============================================================================
  // FORCE FIELD MANAGEMENT
  // ============================================================================
  /**
   * Add a force field
   */
  addForceField(n, i) {
    const r = n8(n);
    return i && Object.assign(r, i), this.particleSystem.addForceField(r), r.id;
  }
  /**
   * Update a force field
   */
  updateForceField(n, i) {
    this.particleSystem.updateForceField(n, i);
  }
  /**
   * Remove a force field
   */
  removeForceField(n) {
    this.particleSystem.removeForceField(n);
  }
  // ============================================================================
  // AUDIO REACTIVITY
  // ============================================================================
  /**
   * Set audio feature value for reactivity
   */
  setAudioFeature(n, i) {
    this.particleSystem.setAudioFeature(n, i);
  }
  /**
   * Trigger a beat event (causes burst on beat-enabled emitters)
   */
  triggerBeat() {
    this.particleSystem.triggerBeat();
  }
  /**
   * Trigger a burst emission
   */
  triggerBurst(n) {
    this.particleSystem.triggerBurst(n);
  }
  // ============================================================================
  // SIMULATION
  // ============================================================================
  /**
   * Step the particle simulation
   */
  step(n) {
    if (!this.initialized) return;
    this.particleSystem.step(n);
    const i = this.particleSystem.getState();
    this.stats.particleCount = i.particleCount, this.stats.updateTimeMs = i.updateTimeMs, this.stats.renderTimeMs = i.renderTimeMs;
  }
  /**
   * Get current performance stats
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Reset the particle system
   */
  reset() {
    this.particleSystem.reset();
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    const i = 1 / this.fps;
    this.applyAudioReactivity(), this.step(i);
  }
  /**
   * Apply audio-reactive values to particle system emitters and force fields
   */
  applyAudioReactivity() {
    const n = this.getAudioReactiveValue("particle.emissionRate"), i = this.getAudioReactiveValue("particle.speed"), r = this.getAudioReactiveValue("particle.size"), o = this.getAudioReactiveValue("particle.gravity"), a = this.getAudioReactiveValue("particle.windStrength");
    if (n !== 0 && this.particleSystem.setAudioFeature("amplitude", n), i !== 0 || r !== 0 || n !== 0) {
      const l = this.particleSystem.getConfig().emitters;
      for (const c of l)
        i !== 0 && this.particleSystem.updateEmitter(c.id, {
          initialSpeed: c.initialSpeed * (0.5 + i)
        }), r !== 0 && this.particleSystem.updateEmitter(c.id, {
          initialSize: c.initialSize * (0.5 + r)
        });
    }
    if (o !== 0 || a !== 0) {
      const l = this.particleSystem.getConfig().forceFields;
      for (const c of l)
        c.type === "gravity" && o !== 0 && this.particleSystem.updateForceField(c.id, {
          strength: c.strength * (0.5 + o)
        }), c.type === "wind" && a !== 0 && this.particleSystem.updateForceField(c.id, {
          strength: c.strength * (0.5 + a)
        });
    }
  }
  onUpdate(n) {
    if (n.data) {
      const r = this.particleSystem.getMesh();
      r && this.group.remove(r), this.systemConfig = this.buildSystemConfig({
        ...n,
        id: this.id,
        type: "particles"
      }), this.particleSystem.dispose(), this.particleSystem = new eg(this.systemConfig), this.rendererRef && (this.initialized = !1, this.initializeWithRenderer(this.rendererRef));
    }
  }
  onDispose() {
    this.particleSystem.dispose();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying particle system for advanced operations
   */
  getParticleSystem() {
    return this.particleSystem;
  }
  /**
   * Get current particle count
   */
  getParticleCount() {
    return this.particleSystem.getState().particleCount;
  }
  /**
   * Check if system is initialized
   */
  isInitialized() {
    return this.initialized;
  }
}
class s8 extends Yi {
  constructor(n) {
    super(n);
    // Precomp data
    fe(this, "precompData");
    // Render context (provided by LayerManager)
    fe(this, "renderContext", null);
    // Display mesh
    fe(this, "mesh", null);
    fe(this, "material", null);
    // Cached render texture
    fe(this, "renderTexture", null);
    // Animation evaluator for time remap
    fe(this, "precompEvaluator");
    // Cached composition reference
    fe(this, "cachedComposition", null);
    // Parent composition FPS for frame rate conversion
    fe(this, "parentFPS", 30);
    this.precompEvaluator = new Ml(), this.precompData = this.extractPrecompData(n), this.createMesh(), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract precomp data with defaults
   */
  extractPrecompData(n) {
    const i = n.data;
    return {
      compositionId: (i == null ? void 0 : i.compositionId) ?? "",
      timeRemapEnabled: (i == null ? void 0 : i.timeRemapEnabled) ?? !1,
      timeRemap: i == null ? void 0 : i.timeRemap,
      collapseTransformations: (i == null ? void 0 : i.collapseTransformations) ?? !1,
      overrideFrameRate: (i == null ? void 0 : i.overrideFrameRate) ?? !1,
      frameRate: i == null ? void 0 : i.frameRate
    };
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const n = new un(1, 1);
    this.material = new En({
      color: 4473924,
      transparent: !0,
      side: vn
    }), this.mesh = new Ze(n, this.material), this.mesh.name = `precomp_${this.id}`, this.group.add(this.mesh);
  }
  // ============================================================================
  // RENDER CONTEXT
  // ============================================================================
  /**
   * Set the render context (required for precomp rendering)
   * Called by LayerManager after creation
   */
  setRenderContext(n) {
    this.renderContext = n, this.loadComposition();
  }
  /**
   * Set parent composition FPS for frame rate conversion
   */
  setFPS(n) {
    this.parentFPS = n;
  }
  /**
   * Load and cache the referenced composition
   */
  loadComposition() {
    !this.renderContext || !this.precompData.compositionId || (this.cachedComposition = this.renderContext.getComposition(
      this.precompData.compositionId
    ), this.cachedComposition && this.resizeMesh(
      this.cachedComposition.settings.width,
      this.cachedComposition.settings.height
    ));
  }
  /**
   * Resize mesh to match composition dimensions
   */
  resizeMesh(n, i) {
    this.mesh && (this.mesh.geometry.dispose(), this.mesh.geometry = new un(n, i));
  }
  // ============================================================================
  // TIME CALCULATION
  // ============================================================================
  /**
   * Calculate the frame in the nested composition
   * based on parent frame and time remapping
   */
  calculateNestedFrame(n) {
    if (!this.cachedComposition) return 0;
    if (this.precompData.timeRemapEnabled && this.precompData.timeRemap) {
      const i = this.precompData.timeRemap.animated ? this.precompEvaluator.evaluate(this.precompData.timeRemap, n) : this.precompData.timeRemap.value, r = this.precompData.overrideFrameRate && this.precompData.frameRate ? this.precompData.frameRate : this.cachedComposition.settings.fps;
      return Math.floor(i * r);
    }
    if (this.precompData.overrideFrameRate && this.precompData.frameRate) {
      const i = this.parentFPS, r = this.precompData.frameRate;
      return Math.floor(n * (r / i));
    }
    return n;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    if (!this.renderContext || !this.cachedComposition)
      return;
    const i = this.calculateNestedFrame(n), r = Math.max(
      0,
      Math.min(i, this.cachedComposition.settings.frameCount - 1)
    );
    this.renderTexture = this.renderContext.renderComposition(
      this.precompData.compositionId,
      r
    ), this.material && (this.renderTexture ? (this.material.map = this.renderTexture, this.material.color.setHex(16777215)) : (this.material.map = null, this.material.color.setHex(4473924)), this.material.needsUpdate = !0);
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Set the source composition
   */
  setComposition(n) {
    this.precompData.compositionId = n, this.loadComposition();
  }
  /**
   * Enable/disable time remapping
   */
  setTimeRemapEnabled(n) {
    this.precompData.timeRemapEnabled = n;
  }
  /**
   * Set time remap property
   */
  setTimeRemap(n) {
    this.precompData.timeRemap = n;
  }
  /**
   * Enable/disable collapse transformations
   */
  setCollapseTransformations(n) {
    this.precompData.collapseTransformations = n;
  }
  /**
   * Override frame rate
   */
  setFrameRateOverride(n, i) {
    this.precompData.overrideFrameRate = n, this.precompData.frameRate = i;
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.compositionId !== void 0 && this.setComposition(i.compositionId), i.timeRemapEnabled !== void 0 && this.setTimeRemapEnabled(i.timeRemapEnabled), i.timeRemap !== void 0 && this.setTimeRemap(i.timeRemap), i.collapseTransformations !== void 0 && this.setCollapseTransformations(i.collapseTransformations), (i.overrideFrameRate !== void 0 || i.frameRate !== void 0) && this.setFrameRateOverride(
      i.overrideFrameRate ?? this.precompData.overrideFrameRate,
      i.frameRate ?? this.precompData.frameRate
    ));
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  /**
   * Get precomp data
   */
  getPrecompData() {
    return { ...this.precompData };
  }
  /**
   * Get referenced composition
   */
  getComposition() {
    return this.cachedComposition;
  }
  /**
   * Get composition ID
   */
  getCompositionId() {
    return this.precompData.compositionId;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.material && this.material.dispose(), this.mesh && (this.mesh.geometry.dispose(), this.group.remove(this.mesh)), this.renderTexture = null, this.cachedComposition = null;
  }
}
class r8 extends Yi {
  constructor(n) {
    super(n);
    // Camera data reference
    fe(this, "cameraData");
    // Callbacks to store
    fe(this, "cameraGetter");
    fe(this, "cameraAtFrameGetter");
    fe(this, "cameraUpdater");
    // Track current frame for interpolation
    fe(this, "currentFrame", 0);
    // Visual wireframe (shown in editor)
    fe(this, "wireframe", null);
    fe(this, "wireframeVisible", !0);
    // Frustum visualization
    fe(this, "frustumHelper", null);
    fe(this, "showFrustum", !0);
    // Track last camera state for frustum updates
    fe(this, "lastFrustumState", null);
    this.threeD = !0, this.cameraData = this.extractCameraData(n), this.createWireframe();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract camera layer data with defaults
   */
  extractCameraData(n) {
    const i = n.data;
    return {
      cameraId: (i == null ? void 0 : i.cameraId) ?? "",
      isActiveCamera: (i == null ? void 0 : i.isActiveCamera) ?? !1
    };
  }
  /**
   * Set callbacks to access Camera3D data from store
   */
  setCameraCallbacks(n, i, r) {
    this.cameraGetter = n, this.cameraUpdater = i, this.cameraAtFrameGetter = r;
  }
  // ============================================================================
  // WIREFRAME VISUALIZATION
  // ============================================================================
  /**
   * Create camera wireframe indicator
   */
  createWireframe() {
    this.wireframe = new Ai(), this.wireframe.name = `camera_wireframe_${this.id}`;
    const n = this.cameraData.isActiveCamera ? 43775 : 16755200, i = 40, r = new pn(i, i * 0.6, i * 0.8), o = new En({
      color: n,
      wireframe: !0,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), a = new Ze(r, o);
    this.wireframe.add(a);
    const l = new Gf(i * 0.3, i * 0.6, 8), c = new En({
      color: n,
      wireframe: !0,
      transparent: !0,
      opacity: 0.6,
      depthTest: !1
    }), u = new Ze(l, c);
    u.rotation.x = Math.PI / 2, u.position.z = i * 0.7, this.wireframe.add(u);
    const d = new un(i * 0.8, i * 0.5), h = new En({
      color: n,
      transparent: !0,
      opacity: 0.2,
      side: vn,
      depthTest: !1
    }), m = new Ze(d, h);
    m.position.z = -i * 0.4, this.wireframe.add(m);
    const p = [
      new de(0, i * 0.4, 0),
      new de(0, i * 0.7, 0),
      new de(-i * 0.1, i * 0.55, 0),
      new de(0, i * 0.7, 0),
      new de(i * 0.1, i * 0.55, 0)
    ], v = new Vt().setFromPoints(p), x = new ji({
      color: 65280,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), g = new ln(v, x);
    this.wireframe.add(g), this.group.add(this.wireframe), this.wireframe.renderOrder = 998;
  }
  /**
   * Create frustum visualization
   */
  createFrustum() {
    const n = this.getCamera();
    if (!n) return;
    this.frustumHelper = new Ai(), this.frustumHelper.name = `camera_frustum_${this.id}`;
    const i = this.cameraData.isActiveCamera ? 43775 : 16755200, r = n.nearClip, o = Math.min(n.farClip, 2e3), a = n.angleOfView * (Math.PI / 180), l = 16 / 9, c = 2 * Math.tan(a / 2) * r, u = c * l, d = 2 * Math.tan(a / 2) * o, h = d * l, m = new ji({
      color: i,
      transparent: !0,
      opacity: 0.3,
      depthTest: !1
    }), p = new de(-u / 2, c / 2, r), v = new de(u / 2, c / 2, r), x = new de(-u / 2, -c / 2, r), g = new de(u / 2, -c / 2, r), _ = new de(-h / 2, d / 2, o), M = new de(h / 2, d / 2, o), S = new de(-h / 2, -d / 2, o), b = new de(h / 2, -d / 2, o), C = new Vt().setFromPoints([
      p,
      v,
      g,
      x,
      p
    ]);
    this.frustumHelper.add(new ln(C, m));
    const E = new Vt().setFromPoints([
      _,
      M,
      b,
      S,
      _
    ]);
    this.frustumHelper.add(new ln(E, m));
    const P = [
      [p, _],
      [v, M],
      [x, S],
      [g, b]
    ];
    for (const [T, y] of P) {
      const w = new Vt().setFromPoints([T, y]);
      this.frustumHelper.add(new ln(w, m));
    }
    this.group.add(this.frustumHelper), this.frustumHelper.renderOrder = 997, this.frustumHelper.visible = this.showFrustum;
  }
  /**
   * Update wireframe color based on active state
   */
  updateWireframeColor() {
    if (!this.wireframe) return;
    const n = this.cameraData.isActiveCamera ? 43775 : 16755200;
    this.wireframe.traverse((i) => {
      if (i instanceof Ze || i instanceof ln) {
        const r = i.material;
        if (r.color.getHex() === 65280) return;
        r.color.setHex(n);
      }
    });
  }
  // ============================================================================
  // CAMERA ACCESS
  // ============================================================================
  /**
   * Get the linked Camera3D object (base, without interpolation)
   */
  getCamera() {
    return !this.cameraGetter || !this.cameraData.cameraId ? null : this.cameraGetter(this.cameraData.cameraId);
  }
  /**
   * Get the camera with keyframe interpolation applied at the current frame
   */
  getCameraAtCurrentFrame() {
    return this.cameraData.cameraId ? this.cameraAtFrameGetter ? this.cameraAtFrameGetter(this.cameraData.cameraId, this.currentFrame) : this.getCamera() : null;
  }
  /**
   * Get camera ID
   */
  getCameraId() {
    return this.cameraData.cameraId;
  }
  /**
   * Check if this is the active camera
   */
  isActiveCamera() {
    return this.cameraData.isActiveCamera;
  }
  /**
   * Set as active camera
   */
  setActiveCamera(n) {
    this.cameraData.isActiveCamera = n, this.updateWireframeColor(), this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum(), this.createFrustum());
  }
  // ============================================================================
  // VISIBILITY CONTROLS
  // ============================================================================
  /**
   * Set wireframe visibility
   */
  setWireframeVisible(n) {
    this.wireframeVisible = n, this.wireframe && (this.wireframe.visible = n);
  }
  /**
   * Set frustum visibility
   */
  setFrustumVisible(n) {
    this.showFrustum = n, this.frustumHelper && (this.frustumHelper.visible = n);
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    this.currentFrame = n;
    const i = this.getCameraAtCurrentFrame();
    if (!i) return;
    this.group.position.set(
      i.position.x,
      i.position.y,
      i.position.z
    );
    const r = Math.PI / 180;
    if (i.type === "two-node" && i.pointOfInterest) {
      const l = new de(
        i.pointOfInterest.x,
        i.pointOfInterest.y,
        i.pointOfInterest.z
      );
      this.group.lookAt(l), this.group.rotation.z += i.zRotation * r;
    } else
      this.group.rotation.set(
        (i.orientation.x + i.xRotation) * r,
        (i.orientation.y + i.yRotation) * r,
        (i.orientation.z + i.zRotation) * r,
        "YXZ"
        // Standard After Effects rotation order
      );
    const o = {
      fov: i.angleOfView,
      near: i.nearClip,
      far: i.farClip
    };
    (!this.lastFrustumState || this.lastFrustumState.fov !== o.fov || this.lastFrustumState.near !== o.near || this.lastFrustumState.far !== o.far) && (this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum()), this.createFrustum(), this.lastFrustumState = o);
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.cameraId !== void 0 && (this.cameraData.cameraId = i.cameraId, this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum()), this.createFrustum()), i.isActiveCamera !== void 0 && this.setActiveCamera(i.isActiveCamera));
  }
  // ============================================================================
  // EXPORT HELPERS
  // ============================================================================
  /**
   * Get camera transform data for export/render
   * Returns position, rotation, and lens data at current frame (with interpolation)
   */
  getExportData() {
    const n = this.getCameraAtCurrentFrame();
    return n ? {
      position: { ...n.position },
      rotation: {
        x: n.orientation.x + n.xRotation,
        y: n.orientation.y + n.yRotation,
        z: n.orientation.z + n.zRotation
      },
      fov: n.angleOfView,
      focalLength: n.focalLength,
      nearClip: n.nearClip,
      farClip: n.farClip
    } : null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  disposeWireframe() {
    this.wireframe && (this.wireframe.traverse((n) => {
      (n instanceof Ze || n instanceof ln) && (n.geometry.dispose(), n.material.dispose());
    }), this.wireframe.clear(), this.wireframe = null);
  }
  disposeFrustum() {
    this.frustumHelper && (this.frustumHelper.traverse((n) => {
      n instanceof ln && (n.geometry.dispose(), n.material.dispose());
    }), this.frustumHelper.clear(), this.frustumHelper = null);
  }
  onDispose() {
    this.disposeWireframe(), this.disposeFrustum();
  }
}
class o8 extends Yi {
  constructor(n) {
    super(n);
    fe(this, "light");
    fe(this, "helper", null);
    fe(this, "lightData");
    this.lightData = this.extractLightData(n), this.light = this.createLight(), this.group.add(this.light), this.createHelper(), this.initializeBlendMode();
  }
  /**
   * Extract light data from layer object
   */
  extractLightData(n) {
    const i = n.data;
    return {
      lightType: (i == null ? void 0 : i.lightType) ?? "point",
      color: (i == null ? void 0 : i.color) ?? "#ffffff",
      intensity: (i == null ? void 0 : i.intensity) ?? 100,
      radius: (i == null ? void 0 : i.radius) ?? 500,
      falloff: (i == null ? void 0 : i.falloff) ?? "none",
      falloffDistance: (i == null ? void 0 : i.falloffDistance) ?? 500,
      castShadows: (i == null ? void 0 : i.castShadows) ?? !1,
      shadowDarkness: (i == null ? void 0 : i.shadowDarkness) ?? 100,
      shadowDiffusion: (i == null ? void 0 : i.shadowDiffusion) ?? 0,
      coneAngle: (i == null ? void 0 : i.coneAngle) ?? 90,
      coneFeather: (i == null ? void 0 : i.coneFeather) ?? 50,
      animatedIntensity: i == null ? void 0 : i.animatedIntensity,
      animatedConeAngle: i == null ? void 0 : i.animatedConeAngle,
      animatedColor: i == null ? void 0 : i.animatedColor
    };
  }
  /**
   * Create the Three.js light based on type
   */
  createLight() {
    const n = new Mt(this.lightData.color), i = this.lightData.intensity / 100;
    switch (this.lightData.lightType) {
      case "point": {
        const r = new ya(n, i);
        return r.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance, r.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1, this.configureShadows(r), r;
      }
      case "spot": {
        const r = new js(n, i);
        return r.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance, r.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1, r.angle = mn.degToRad((this.lightData.coneAngle ?? 90) / 2), r.penumbra = (this.lightData.coneFeather ?? 50) / 100, this.configureShadows(r), r;
      }
      case "parallel": {
        const r = new To(n, i);
        return this.configureShadows(r), r;
      }
      case "ambient":
        return new by(n, i);
      default:
        return Ti.warn(`LightLayer: Unknown light type: ${this.lightData.lightType}, defaulting to point`), new ya(n, i);
    }
  }
  /**
   * Configure shadow settings for shadow-capable lights
   */
  configureShadows(n) {
    n.castShadow = this.lightData.castShadows, n.castShadow && (n.shadow.mapSize.width = 1024, n.shadow.mapSize.height = 1024, n.shadow.bias = -1e-4 * (100 - this.lightData.shadowDarkness) / 100, n.shadow.radius = 1 + this.lightData.shadowDiffusion / 10, (n instanceof js || n instanceof To) && (n.shadow.camera.near = 1, n.shadow.camera.far = this.lightData.falloffDistance * 2));
  }
  /**
   * Create helper visualization for the editor
   */
  createHelper() {
    switch (this.helper && (this.group.remove(this.helper), this.helper.dispose && this.helper.dispose()), this.lightData.lightType) {
      case "point": {
        const n = new pv(this.light, this.lightData.radius / 10);
        this.helper = n, this.group.add(n);
        break;
      }
      case "spot": {
        const n = new uc(this.light);
        this.helper = n, this.group.add(n);
        break;
      }
      case "parallel": {
        const n = new gv(this.light, 50);
        this.helper = n, this.group.add(n);
        break;
      }
    }
  }
  /**
   * Update light type (requires recreating the light)
   */
  setLightType(n) {
    n !== this.lightData.lightType && (this.lightData.lightType = n, this.group.remove(this.light), this.light.dispose && this.light.dispose(), this.light = this.createLight(), this.group.add(this.light), this.createHelper());
  }
  /**
   * Set light color
   */
  setColor(n) {
    this.lightData.color = n, this.light.color.set(n);
  }
  /**
   * Set light intensity
   */
  setIntensity(n) {
    this.lightData.intensity = n, this.light.intensity = n / 100;
  }
  /**
   * Set falloff distance
   */
  setFalloffDistance(n) {
    this.lightData.falloffDistance = n, (this.light instanceof ya || this.light instanceof js) && (this.light.distance = this.lightData.falloff === "none" ? 0 : n);
  }
  /**
   * Set cone angle (spot lights only)
   */
  setConeAngle(n) {
    this.light instanceof js && (this.lightData.coneAngle = n, this.light.angle = mn.degToRad(n / 2), this.helper instanceof uc && this.helper.update());
  }
  /**
   * Set cone feather (spot lights only)
   */
  setConeFeather(n) {
    this.light instanceof js && (this.lightData.coneFeather = n, this.light.penumbra = n / 100);
  }
  /**
   * Toggle shadow casting
   */
  setCastShadows(n) {
    this.lightData.castShadows = n, (this.light instanceof ya || this.light instanceof js || this.light instanceof To) && (this.light.castShadow = n);
  }
  /**
   * Get the underlying Three.js light
   */
  getLight() {
    return this.light;
  }
  /**
   * Get light data
   */
  getLightData() {
    return { ...this.lightData };
  }
  /**
   * Show/hide editor helper
   */
  setHelperVisible(n) {
    this.helper && (this.helper.visible = n);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    var i, r, o;
    if ((i = this.lightData.animatedIntensity) != null && i.animated) {
      const a = this.evaluator.evaluate(this.lightData.animatedIntensity, n);
      this.light.intensity = a / 100;
    }
    if ((r = this.lightData.animatedConeAngle) != null && r.animated && this.light instanceof js) {
      const a = this.evaluator.evaluate(this.lightData.animatedConeAngle, n);
      this.light.angle = mn.degToRad(a / 2), this.helper instanceof uc && this.helper.update();
    }
    if ((o = this.lightData.animatedColor) != null && o.animated) {
      const a = this.evaluator.evaluate(this.lightData.animatedColor, n);
      this.light.color.set(a), this.helper && (this.helper instanceof pv ? this.helper.update() : this.helper instanceof uc ? this.helper.update() : this.helper instanceof gv && this.helper.update());
    }
  }
  onUpdate(n) {
    const i = n.data;
    i && (i.lightType !== void 0 && i.lightType !== this.lightData.lightType && this.setLightType(i.lightType), i.color !== void 0 && this.setColor(i.color), i.intensity !== void 0 && this.setIntensity(i.intensity), i.falloffDistance !== void 0 && this.setFalloffDistance(i.falloffDistance), i.falloff !== void 0 && (this.lightData.falloff = i.falloff, this.setFalloffDistance(this.lightData.falloffDistance)), i.coneAngle !== void 0 && this.setConeAngle(i.coneAngle), i.coneFeather !== void 0 && this.setConeFeather(i.coneFeather), i.castShadows !== void 0 && this.setCastShadows(i.castShadows), (i.shadowDarkness !== void 0 || i.shadowDiffusion !== void 0) && (this.lightData.shadowDarkness = i.shadowDarkness ?? this.lightData.shadowDarkness, this.lightData.shadowDiffusion = i.shadowDiffusion ?? this.lightData.shadowDiffusion, (this.light instanceof ya || this.light instanceof js || this.light instanceof To) && this.configureShadows(this.light)), i.animatedIntensity !== void 0 && (this.lightData.animatedIntensity = i.animatedIntensity), i.animatedConeAngle !== void 0 && (this.lightData.animatedConeAngle = i.animatedConeAngle), i.animatedColor !== void 0 && (this.lightData.animatedColor = i.animatedColor));
  }
  onDispose() {
    this.light.dispose && this.light.dispose(), this.helper && this.helper.dispose && this.helper.dispose();
  }
}
const a8 = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`, l8 = `
  uniform sampler2D sourceTexture;
  uniform sampler2D depthTexture;
  uniform float depthScale;
  uniform float focusDepth;
  uniform vec2 offset;
  uniform float zoom;
  uniform float rotation;
  uniform float edgeDilation;
  uniform float time;

  varying vec2 vUv;

  // Rotate UV around center
  vec2 rotateUV(vec2 uv, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    uv -= 0.5;
    uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
    uv += 0.5;
    return uv;
  }

  void main() {
    // Sample depth at current UV
    float depth = texture2D(depthTexture, vUv).r;

    // Calculate displacement based on depth
    // Objects at focusDepth have no displacement
    float depthDiff = depth - focusDepth;
    float displacement = depthDiff * depthScale;

    // Apply zoom (perspective effect - closer objects move more)
    vec2 zoomedUV = (vUv - 0.5) / zoom + 0.5;

    // Apply rotation
    vec2 rotatedUV = rotateUV(zoomedUV, rotation);

    // Apply offset with depth-based parallax
    vec2 parallaxOffset = offset * (1.0 + displacement);
    vec2 finalUV = rotatedUV + parallaxOffset;

    // Edge handling - dilate edges slightly
    vec2 edgeUV = finalUV;
    if (edgeDilation > 0.0) {
      // Simple edge stretch when outside [0,1] range
      if (finalUV.x < 0.0) edgeUV.x = finalUV.x * (1.0 - edgeDilation);
      if (finalUV.x > 1.0) edgeUV.x = 1.0 - (1.0 - finalUV.x) * (1.0 - edgeDilation);
      if (finalUV.y < 0.0) edgeUV.y = finalUV.y * (1.0 - edgeDilation);
      if (finalUV.y > 1.0) edgeUV.y = 1.0 - (1.0 - finalUV.y) * (1.0 - edgeDilation);
    }

    // Clamp to valid range (or could use mirror/repeat)
    finalUV = clamp(edgeUV, 0.0, 1.0);

    // Sample source with displaced UVs
    vec4 color = texture2D(sourceTexture, finalUV);

    // Handle edges - fade out pixels that would be outside the source
    float edgeFade = 1.0;
    float edgeThreshold = 0.01;
    if (edgeUV.x < edgeThreshold || edgeUV.x > 1.0 - edgeThreshold ||
        edgeUV.y < edgeThreshold || edgeUV.y > 1.0 - edgeThreshold) {
      edgeFade = 0.0;
    }

    gl_FragColor = vec4(color.rgb, color.a * edgeFade);
  }
`;
class c8 extends Yi {
  constructor(n, i) {
    super(n);
    fe(this, "resources");
    // Textures
    fe(this, "sourceTexture", null);
    fe(this, "depthTexture", null);
    // Mesh and material
    fe(this, "mesh");
    fe(this, "geometry");
    fe(this, "material");
    // Layer data
    fe(this, "depthflowData");
    // Dimensions
    fe(this, "width", 1920);
    fe(this, "height", 1080);
    // Animation state
    fe(this, "animationTime", 0);
    this.resources = i, this.depthflowData = this.extractDepthflowData(n), this.geometry = new un(this.width, this.height), this.material = new zn({
      uniforms: {
        sourceTexture: { value: null },
        depthTexture: { value: null },
        depthScale: { value: this.depthflowData.config.depthScale },
        focusDepth: { value: this.depthflowData.config.focusDepth },
        offset: { value: new rt(0, 0) },
        zoom: { value: this.depthflowData.config.zoom },
        rotation: { value: this.depthflowData.config.rotation },
        edgeDilation: { value: this.depthflowData.config.edgeDilation },
        time: { value: 0 }
      },
      vertexShader: a8,
      fragmentShader: l8,
      transparent: !0,
      side: vn,
      depthWrite: !1
    }), this.mesh = new Ze(this.geometry, this.material), this.mesh.name = `depthflow_${this.id}`, this.group.add(this.mesh), this.loadTextures(), this.initializeBlendMode();
  }
  /**
   * Extract depthflow data with defaults
   */
  extractDepthflowData(n) {
    var r, o, a, l, c, u, d, h, m, p, v, x, g, _;
    const i = n.data;
    return {
      sourceLayerId: (i == null ? void 0 : i.sourceLayerId) ?? "",
      depthLayerId: (i == null ? void 0 : i.depthLayerId) ?? "",
      config: {
        preset: ((r = i == null ? void 0 : i.config) == null ? void 0 : r.preset) ?? "static",
        zoom: ((o = i == null ? void 0 : i.config) == null ? void 0 : o.zoom) ?? 1,
        offsetX: ((a = i == null ? void 0 : i.config) == null ? void 0 : a.offsetX) ?? 0,
        offsetY: ((l = i == null ? void 0 : i.config) == null ? void 0 : l.offsetY) ?? 0,
        rotation: ((c = i == null ? void 0 : i.config) == null ? void 0 : c.rotation) ?? 0,
        depthScale: ((u = i == null ? void 0 : i.config) == null ? void 0 : u.depthScale) ?? 0.1,
        focusDepth: ((d = i == null ? void 0 : i.config) == null ? void 0 : d.focusDepth) ?? 0.5,
        dollyZoom: ((h = i == null ? void 0 : i.config) == null ? void 0 : h.dollyZoom) ?? 0,
        orbitRadius: ((m = i == null ? void 0 : i.config) == null ? void 0 : m.orbitRadius) ?? 0.1,
        orbitSpeed: ((p = i == null ? void 0 : i.config) == null ? void 0 : p.orbitSpeed) ?? 1,
        swingAmplitude: ((v = i == null ? void 0 : i.config) == null ? void 0 : v.swingAmplitude) ?? 0.05,
        swingFrequency: ((x = i == null ? void 0 : i.config) == null ? void 0 : x.swingFrequency) ?? 1,
        edgeDilation: ((g = i == null ? void 0 : i.config) == null ? void 0 : g.edgeDilation) ?? 0,
        inpaintEdges: ((_ = i == null ? void 0 : i.config) == null ? void 0 : _.inpaintEdges) ?? !1
      },
      animatedZoom: i == null ? void 0 : i.animatedZoom,
      animatedOffsetX: i == null ? void 0 : i.animatedOffsetX,
      animatedOffsetY: i == null ? void 0 : i.animatedOffsetY,
      animatedRotation: i == null ? void 0 : i.animatedRotation,
      animatedDepthScale: i == null ? void 0 : i.animatedDepthScale
    };
  }
  /**
   * Load source and depth textures from referenced layers
   */
  async loadTextures() {
    if (this.depthflowData.sourceLayerId) {
      const n = await this.loadTextureFromLayer(this.depthflowData.sourceLayerId);
      n && (this.sourceTexture = n, this.material.uniforms.sourceTexture.value = n, n.image && this.setDimensions(n.image.width, n.image.height));
    }
    if (this.depthflowData.depthLayerId) {
      const n = await this.loadTextureFromLayer(this.depthflowData.depthLayerId);
      n && (this.depthTexture = n, this.material.uniforms.depthTexture.value = n);
    }
  }
  /**
   * Load texture from a layer (image layer asset)
   */
  async loadTextureFromLayer(n) {
    const i = this.resources.getLayerTexture(n);
    return i || (Ti.warn(`DepthflowLayer: Could not load texture for layer ${n}`), null);
  }
  /**
   * Set mesh dimensions
   */
  setDimensions(n, i) {
    n === this.width && i === this.height || (this.width = n, this.height = i, this.geometry.dispose(), this.geometry = new un(n, i), this.mesh.geometry = this.geometry);
  }
  /**
   * Set source layer
   */
  async setSourceLayer(n) {
    var r;
    this.depthflowData.sourceLayerId = n;
    const i = await this.loadTextureFromLayer(n);
    i && ((r = this.sourceTexture) == null || r.dispose(), this.sourceTexture = i, this.material.uniforms.sourceTexture.value = i);
  }
  /**
   * Set depth layer
   */
  async setDepthLayer(n) {
    var r;
    this.depthflowData.depthLayerId = n;
    const i = await this.loadTextureFromLayer(n);
    i && ((r = this.depthTexture) == null || r.dispose(), this.depthTexture = i, this.material.uniforms.depthTexture.value = i);
  }
  /**
   * Update config values
   */
  updateConfig(n) {
    Object.assign(this.depthflowData.config, n), n.depthScale !== void 0 && (this.material.uniforms.depthScale.value = n.depthScale), n.focusDepth !== void 0 && (this.material.uniforms.focusDepth.value = n.focusDepth), n.zoom !== void 0 && (this.material.uniforms.zoom.value = n.zoom), n.rotation !== void 0 && (this.material.uniforms.rotation.value = mn.degToRad(n.rotation)), n.edgeDilation !== void 0 && (this.material.uniforms.edgeDilation.value = n.edgeDilation);
  }
  /**
   * Calculate preset-based animation values
   */
  calculatePresetValues(n, i = 30) {
    const r = this.depthflowData.config, o = this.outPoint - this.inPoint, a = o > 0 ? (n - this.inPoint) / o : 0, l = n / i;
    let c = r.zoom, u = r.offsetX, d = r.offsetY, h = r.rotation;
    switch (r.preset) {
      case "static":
        break;
      case "zoom_in":
        c = 1 + a * 0.5;
        break;
      case "zoom_out":
        c = 1.5 - a * 0.5;
        break;
      case "dolly_zoom_in":
        c = 1 + a * 0.5, this.material.uniforms.depthScale.value = r.depthScale * (1 + r.dollyZoom * a);
        break;
      case "dolly_zoom_out":
        c = 1.5 - a * 0.5, this.material.uniforms.depthScale.value = r.depthScale * (1 + r.dollyZoom * (1 - a));
        break;
      case "pan_left":
        u = a * 0.2;
        break;
      case "pan_right":
        u = -a * 0.2;
        break;
      case "pan_up":
        d = a * 0.2;
        break;
      case "pan_down":
        d = -a * 0.2;
        break;
      case "circle_cw":
        u = Math.sin(a * Math.PI * 2) * r.orbitRadius, d = Math.cos(a * Math.PI * 2) * r.orbitRadius;
        break;
      case "circle_ccw":
        u = -Math.sin(a * Math.PI * 2) * r.orbitRadius, d = Math.cos(a * Math.PI * 2) * r.orbitRadius;
        break;
      case "horizontal_swing":
        u = Math.sin(l * r.swingFrequency * Math.PI * 2) * r.swingAmplitude;
        break;
      case "vertical_swing":
        d = Math.sin(l * r.swingFrequency * Math.PI * 2) * r.swingAmplitude;
        break;
    }
    return { zoom: c, offsetX: u, offsetY: d, rotation: h };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    this.depthflowData.config;
    const i = this.calculatePresetValues(n);
    let r = i.zoom, o = i.offsetX, a = i.offsetY, l = i.rotation;
    this.depthflowData.animatedZoom && (r = this.evaluator.evaluate(this.depthflowData.animatedZoom, n)), this.depthflowData.animatedOffsetX && (o = this.evaluator.evaluate(this.depthflowData.animatedOffsetX, n)), this.depthflowData.animatedOffsetY && (a = this.evaluator.evaluate(this.depthflowData.animatedOffsetY, n)), this.depthflowData.animatedRotation && (l = this.evaluator.evaluate(this.depthflowData.animatedRotation, n)), this.depthflowData.animatedDepthScale && (this.material.uniforms.depthScale.value = this.evaluator.evaluate(
      this.depthflowData.animatedDepthScale,
      n
    )), r = this.getDrivenOrBase("depthflow.zoom", r), o = this.getDrivenOrBase("depthflow.offsetX", o), a = this.getDrivenOrBase("depthflow.offsetY", a), l = this.getDrivenOrBase("depthflow.rotation", l), this.material.uniforms.zoom.value = r, this.material.uniforms.offset.value.set(o, a), this.material.uniforms.rotation.value = mn.degToRad(l), this.material.uniforms.time.value = n / 30, this.material.needsUpdate = !0;
  }
  onUpdate(n) {
    const i = n.data;
    i && (i.sourceLayerId !== void 0 && i.sourceLayerId !== this.depthflowData.sourceLayerId && this.setSourceLayer(i.sourceLayerId), i.depthLayerId !== void 0 && i.depthLayerId !== this.depthflowData.depthLayerId && this.setDepthLayer(i.depthLayerId), i.config && this.updateConfig(i.config), i.animatedZoom !== void 0 && (this.depthflowData.animatedZoom = i.animatedZoom), i.animatedOffsetX !== void 0 && (this.depthflowData.animatedOffsetX = i.animatedOffsetX), i.animatedOffsetY !== void 0 && (this.depthflowData.animatedOffsetY = i.animatedOffsetY), i.animatedRotation !== void 0 && (this.depthflowData.animatedRotation = i.animatedRotation), i.animatedDepthScale !== void 0 && (this.depthflowData.animatedDepthScale = i.animatedDepthScale));
  }
  onDispose() {
    var n, i;
    (n = this.sourceTexture) == null || n.dispose(), (i = this.depthTexture) == null || i.dispose(), this.geometry.dispose(), this.material.dispose();
  }
}
class u8 {
  constructor(e, n) {
    fe(this, "scene");
    fe(this, "resources");
    fe(this, "layers");
    // Callbacks
    fe(this, "onVideoMetadataLoaded");
    fe(this, "precompRenderContext", null);
    fe(this, "cameraGetter");
    fe(this, "cameraAtFrameGetter");
    fe(this, "cameraUpdater");
    // Renderer reference for particle systems
    fe(this, "rendererRef", null);
    // Composition FPS for particle timing
    fe(this, "compositionFPS", 60);
    // Camera reference for particles
    fe(this, "cameraRef", null);
    // Audio reactive callback
    fe(this, "audioReactiveGetter", null);
    this.scene = e, this.resources = n, this.layers = /* @__PURE__ */ new Map();
  }
  // ============================================================================
  // CALLBACKS
  // ============================================================================
  /**
   * Set callback for when a video layer loads its metadata
   * Used by the store to auto-resize composition based on video duration
   */
  setVideoMetadataCallback(e) {
    this.onVideoMetadataLoaded = e;
  }
  /**
   * Set the precomp render context
   * This allows precomp layers to render nested compositions
   */
  setPrecompRenderContext(e) {
    this.precompRenderContext = e;
    for (const n of this.layers.values())
      n.type === "precomp" && n.setRenderContext(e);
  }
  /**
   * Set camera callbacks for CameraLayer access to store
   */
  setCameraCallbacks(e, n, i) {
    this.cameraGetter = e, this.cameraUpdater = n, this.cameraAtFrameGetter = i;
    for (const r of this.layers.values())
      r.type === "camera" && r.setCameraCallbacks(e, n, i);
  }
  /**
   * Set renderer for particle layers
   * Must be called to enable GPU particle rendering
   */
  setRenderer(e) {
    this.rendererRef = e;
    for (const n of this.layers.values())
      n.type === "particles" && n.setRenderer(e);
  }
  /**
   * Set composition FPS for timing calculations
   */
  setCompositionFPS(e) {
    this.compositionFPS = e;
    for (const n of this.layers.values())
      n.type === "particles" && n.setFPS(e), n.type === "video" && n.setFPS(e), n.type === "precomp" && n.setFPS(e);
  }
  /**
   * Set camera reference for particle systems
   * Used for camera-relative effects (soft particles, depth culling)
   */
  setCamera(e) {
    this.cameraRef = e;
  }
  /**
   * Get camera reference
   */
  getCamera() {
    return this.cameraRef;
  }
  // ============================================================================
  // LAYER CREATION
  // ============================================================================
  /**
   * Create a new layer from layer data
   */
  create(e) {
    if (this.layers.has(e.id))
      return Ti.warn(`LayerManager: Layer ${e.id} already exists, updating instead`), this.update(e.id, e), this.layers.get(e.id);
    const n = this.createLayerInstance(e);
    if (this.layers.set(e.id, n), this.setupLayerCallbacks(n, e), e.parentId) {
      const i = this.layers.get(e.parentId);
      i && n.setParent(i);
    }
    return n.hasParent() || this.scene.addToComposition(n.getObject()), n;
  }
  /**
   * Set up type-specific callbacks after layer creation
   */
  setupLayerCallbacks(e, n) {
    if (e.type === "video" && this.onVideoMetadataLoaded && e.setMetadataCallback((r) => {
      this.onVideoMetadataLoaded(n.id, r);
    }), e.type === "precomp" && this.precompRenderContext && e.setRenderContext(this.precompRenderContext), e.type === "camera" && this.cameraGetter && this.cameraUpdater && e.setCameraCallbacks(this.cameraGetter, this.cameraUpdater, this.cameraAtFrameGetter), e.type === "particles") {
      const i = e;
      this.rendererRef && i.setRenderer(this.rendererRef), i.setFPS(this.compositionFPS);
    }
    e.type === "video" && e.setFPS(this.compositionFPS), e.type === "precomp" && e.setFPS(this.compositionFPS);
  }
  /**
   * Create the appropriate layer instance based on type
   */
  createLayerInstance(e) {
    switch (e.type) {
      case "image":
        return new eN(e, this.resources);
      case "solid":
        return new tN(e);
      case "null":
        return new Ov(e);
      case "text":
        return new QN(e, this.resources);
      case "spline":
        return new e8(e);
      case "particles":
        return new i8(e);
      case "video":
        return new BE(e, this.resources);
      case "precomp":
        return new s8(e);
      case "camera":
        return new r8(e);
      case "light":
        return new o8(e);
      case "depthflow":
        return new c8(e, this.resources);
      default:
        return Ti.warn(`LayerManager: Unknown layer type: ${e.type}, creating NullLayer`), new Ov(e);
    }
  }
  // ============================================================================
  // LAYER UPDATES
  // ============================================================================
  /**
   * Update a layer's properties
   */
  update(e, n) {
    const i = this.layers.get(e);
    if (!i) {
      Ti.warn(`LayerManager: Layer ${e} not found for update`);
      return;
    }
    i.update(n);
  }
  /**
   * Batch update multiple layers
   */
  batchUpdate(e) {
    for (const { id: n, properties: i } of e)
      this.update(n, i);
  }
  // ============================================================================
  // LAYER REMOVAL
  // ============================================================================
  /**
   * Remove a layer by ID
   */
  remove(e) {
    const n = this.layers.get(e);
    if (!n) {
      Ti.warn(`LayerManager: Layer ${e} not found for removal`);
      return;
    }
    this.scene.removeFromComposition(n.getObject()), n.dispose(), this.layers.delete(e);
  }
  /**
   * Remove multiple layers
   */
  removeMultiple(e) {
    for (const n of e)
      this.remove(n);
  }
  /**
   * Remove all layers
   */
  removeAll() {
    for (const [e, n] of this.layers)
      this.scene.removeFromComposition(n.getObject()), n.dispose();
    this.layers.clear();
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all layers at a given frame
   * @param frame - The frame number
   * @param audioReactiveGetter - Optional callback to get audio reactive values
   */
  evaluateFrame(e, n) {
    this.updateTextPathConnections();
    const i = n ?? this.audioReactiveGetter;
    for (const r of this.layers.values()) {
      if (i) {
        const o = i(r.id, e);
        o.size > 0 && r.setAudioReactiveValues(o);
      }
      r.evaluateFrame(e);
    }
    this.scene.sortByZ();
  }
  /**
   * Set the audio reactive getter callback
   */
  setAudioReactiveCallback(e) {
    this.audioReactiveGetter = e;
  }
  /**
   * Set driven values for a specific layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(e, n) {
    const i = this.layers.get(e);
    i && i.setDrivenValues(n);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(e) {
    const n = this.layers.get(e);
    n && n.clearDrivenValues();
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    for (const e of this.layers.values())
      e.clearDrivenValues();
  }
  /**
   * Update text layer connections to spline paths
   * Called before frame evaluation to ensure paths are current
   */
  updateTextPathConnections() {
    for (const e of this.layers.values())
      if (e.type === "text") {
        const n = e, i = n.getTextData();
        if (i.pathLayerId) {
          const r = this.layers.get(i.pathLayerId);
          if (r && r.type === "spline") {
            const o = r.getCurve();
            o && n.setPathFromCurve(o);
          }
        }
      }
  }
  /**
   * Connect a text layer to a spline path
   */
  connectTextToPath(e, n) {
    const i = this.layers.get(e);
    if (!i || i.type !== "text") {
      Ti.warn(`LayerManager: Text layer ${e} not found`);
      return;
    }
    if (!n) {
      i.clearPath();
      return;
    }
    const r = this.layers.get(n);
    if (!r || r.type !== "spline") {
      Ti.warn(`LayerManager: Spline layer ${n} not found`);
      return;
    }
    const o = r.getCurve();
    o && i.setPathFromCurve(o);
  }
  // ============================================================================
  // LAYER ACCESS
  // ============================================================================
  /**
   * Get a layer's Three.js object
   */
  getObject(e) {
    var n;
    return ((n = this.layers.get(e)) == null ? void 0 : n.getObject()) ?? null;
  }
  /**
   * Get a layer instance
   */
  getLayer(e) {
    return this.layers.get(e) ?? null;
  }
  /**
   * Get all layer IDs
   */
  getLayerIds() {
    return Array.from(this.layers.keys());
  }
  /**
   * Get all layers of a specific type
   */
  getLayersByType(e) {
    return Array.from(this.layers.values()).filter(
      (n) => n.type === e
    );
  }
  /**
   * Check if a layer exists
   */
  hasLayer(e) {
    return this.layers.has(e);
  }
  /**
   * Get layer count
   */
  getLayerCount() {
    return this.layers.size;
  }
  // ============================================================================
  // LAYER ORDERING
  // ============================================================================
  /**
   * Reorder layers in the scene based on their Z positions
   */
  reorderLayers() {
    this.scene.sortByZ();
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Rebuild the parenting hierarchy for all layers
   * Call this after batch-adding layers to ensure proper parent-child relationships
   */
  rebuildParentHierarchy() {
    for (const e of this.layers.values())
      if (e.hasParent()) {
        const n = e.getParent();
        n && n.getObject().remove(e.getObject());
      }
    for (const e of this.layers.values()) {
      const n = e.getParentId();
      if (n) {
        const i = this.layers.get(n);
        i ? e.setParent(i) : (e.setParent(null), this.scene.addToComposition(e.getObject()));
      }
    }
  }
  /**
   * Set parent for a layer
   */
  setLayerParent(e, n) {
    const i = this.layers.get(e);
    if (i) {
      if (i.hasParent()) {
        const r = i.getParent();
        r && r.getObject().remove(i.getObject());
      } else
        this.scene.removeFromComposition(i.getObject());
      if (n) {
        const r = this.layers.get(n);
        r ? i.setParent(r) : (i.setParent(null), this.scene.addToComposition(i.getObject()));
      } else
        i.setParent(null), this.scene.addToComposition(i.getObject());
    }
  }
  /**
   * Move a layer to a specific Z position
   */
  setLayerZ(e, n) {
    const i = this.layers.get(e);
    i && (i.getObject().position.z = n, this.scene.sortByZ());
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setLayerVisible(e, n) {
    const i = this.layers.get(e);
    i && i.setVisible(n);
  }
  /**
   * Toggle layer visibility
   */
  toggleLayerVisible(e) {
    const n = this.layers.get(e);
    if (n) {
      const i = !n.getObject().visible;
      return n.setVisible(i), i;
    }
    return !1;
  }
  /**
   * Solo a layer (hide all others)
   */
  soloLayer(e) {
    for (const [n, i] of this.layers)
      i.setVisible(n === e);
  }
  /**
   * Unsolo all layers (show all)
   */
  unsoloAll() {
    for (const e of this.layers.values())
      e.setVisible(!0);
  }
  // ============================================================================
  // SELECTION
  // ============================================================================
  /**
   * Get layers at a screen position
   */
  getLayersAtPosition(e, n, i) {
    const r = new jf(), o = new rt(e, n);
    r.setFromCamera(o, i);
    const a = this.scene.raycastComposition(r), l = /* @__PURE__ */ new Set();
    for (const c of a) {
      let u = c.object;
      for (; u; ) {
        if (u.userData.layerId) {
          l.add(u.userData.layerId);
          break;
        }
        u = u.parent;
      }
    }
    return Array.from(l).map((c) => this.layers.get(c)).filter((c) => c !== void 0);
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all layers and resources
   */
  dispose() {
    for (const e of this.layers.values())
      this.scene.removeFromComposition(e.getObject()), e.dispose();
    this.layers.clear();
  }
}
class d8 {
  constructor(e, n) {
    /** The main camera */
    fe(this, "camera");
    /** Keyframe evaluator for animations */
    fe(this, "evaluator");
    /** Composition dimensions */
    fe(this, "width");
    fe(this, "height");
    /** Animation properties */
    fe(this, "positionProp");
    fe(this, "targetProp");
    fe(this, "fovProp");
    /** Current target position (for lookAt) */
    fe(this, "target");
    // ============================================================================
    // VIEWPORT ZOOM/PAN
    // ============================================================================
    /** Pan offset for viewport navigation */
    fe(this, "panOffset", new rt(0, 0));
    fe(this, "zoomLevel", 1);
    this.width = e, this.height = n, this.evaluator = new Ml(), this.camera = new ui(
      50,
      // Field of view
      e / n,
      // Aspect ratio
      0.1,
      // Near plane
      1e4
      // Far plane
    );
    const i = mn.degToRad(this.camera.fov), r = n / 2 / Math.tan(i / 2);
    this.camera.position.set(e / 2, -n / 2, r), this.target = new de(e / 2, -n / 2, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // POSITION & ORIENTATION
  // ============================================================================
  /**
   * Set camera position
   * Note: Y is negated for screen coordinates (Y down)
   */
  setPosition(e, n, i) {
    this.camera.position.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera position (in screen coordinates)
   */
  getPosition() {
    return {
      x: this.camera.position.x,
      y: -this.camera.position.y,
      // Convert back to screen coords
      z: this.camera.position.z
    };
  }
  /**
   * Set camera target (look-at point)
   * Note: Y is negated for screen coordinates
   */
  setTarget(e, n, i) {
    this.target.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera target (in screen coordinates)
   */
  getTarget() {
    return {
      x: this.target.x,
      y: -this.target.y,
      z: this.target.z
    };
  }
  /**
   * Set camera rotation directly (Euler angles in degrees)
   */
  setRotation(e, n, i) {
    this.camera.rotation.set(
      mn.degToRad(e),
      mn.degToRad(n),
      mn.degToRad(i)
    ), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // PROJECTION
  // ============================================================================
  /**
   * Set field of view (in degrees)
   */
  setFOV(e) {
    this.camera.fov = mn.clamp(e, 1, 179), this.camera.updateProjectionMatrix();
  }
  /**
   * Get field of view
   */
  getFOV() {
    return this.camera.fov;
  }
  /**
   * Set near and far planes
   */
  setClipPlanes(e, n) {
    this.camera.near = Math.max(1e-3, e), this.camera.far = Math.max(this.camera.near + 1, n), this.camera.updateProjectionMatrix();
  }
  /**
   * Set zoom level for viewport navigation
   * This adjusts the camera's effective view without changing FOV
   */
  setZoom(e) {
    this.zoomLevel = Math.max(0.1, Math.min(10, e)), this.updateCameraForViewport();
  }
  /**
   * Get current zoom level
   */
  getZoom() {
    return this.zoomLevel;
  }
  /**
   * Set pan offset for viewport navigation
   */
  setPan(e, n) {
    this.panOffset.set(e, n), this.updateCameraForViewport();
  }
  /**
   * Get current pan offset
   */
  getPan() {
    return { x: this.panOffset.x, y: this.panOffset.y };
  }
  /**
   * Update camera position based on zoom and pan
   */
  updateCameraForViewport() {
    const e = mn.degToRad(this.camera.fov), i = this.height / 2 / Math.tan(e / 2) / this.zoomLevel, r = this.width / 2 - this.panOffset.x / this.zoomLevel, o = this.height / 2 - this.panOffset.y / this.zoomLevel;
    this.camera.position.set(r, -o, i), this.target.set(r, -o, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Set animated properties for keyframe evaluation
   */
  setAnimationProperties(e) {
    this.positionProp = e.position, this.targetProp = e.target, this.fovProp = e.fov;
  }
  /**
   * Clear animation properties
   */
  clearAnimationProperties() {
    this.positionProp = void 0, this.targetProp = void 0, this.fovProp = void 0;
  }
  /**
   * Evaluate animated properties at a given frame
   */
  evaluateFrame(e) {
    if (this.positionProp) {
      const n = this.evaluator.evaluate(this.positionProp, e);
      this.setPosition(n.x, n.y, n.z ?? this.camera.position.z);
    }
    if (this.targetProp) {
      const n = this.evaluator.evaluate(this.targetProp, e);
      this.setTarget(n.x, n.y, n.z ?? 0);
    }
    if (this.fovProp) {
      const n = this.evaluator.evaluate(this.fovProp, e);
      this.setFOV(n);
    }
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize camera for new viewport dimensions
   */
  resize(e, n) {
    this.width = e, this.height = n, this.camera.aspect = e / n, this.camera.updateProjectionMatrix();
    const i = mn.degToRad(this.camera.fov), r = n / 2 / Math.tan(i / 2);
    this.camera.position.x = e / 2, this.camera.position.y = -n / 2, this.camera.position.z = r, this.target.set(e / 2, -n / 2, 0), this.camera.lookAt(this.target);
  }
  // ============================================================================
  // COORDINATE CONVERSION
  // ============================================================================
  /**
   * Convert screen coordinates to world position at a given Z depth
   */
  screenToWorld(e, n, i = 0) {
    const r = e / this.width * 2 - 1, o = -(n / this.height) * 2 + 1, a = new de(r, o, 0.5);
    a.unproject(this.camera);
    const l = a.sub(this.camera.position).normalize(), c = (i - this.camera.position.z) / l.z;
    return this.camera.position.clone().add(l.multiplyScalar(c));
  }
  /**
   * Convert world position to screen coordinates
   */
  worldToScreen(e, n, i = 0) {
    const r = new de(e, -n, i);
    return r.project(this.camera), {
      x: (r.x + 1) / 2 * this.width,
      y: (-r.y + 1) / 2 * this.height
    };
  }
  // ============================================================================
  // STATE
  // ============================================================================
  /**
   * Get the Three.js camera object directly
   */
  getCamera() {
    return this.camera;
  }
  /**
   * Get complete camera state
   */
  getState() {
    return {
      position: this.getPosition(),
      target: this.getTarget(),
      fov: this.camera.fov,
      near: this.camera.near,
      far: this.camera.far
    };
  }
  /**
   * Set complete camera state
   */
  setState(e) {
    e.position && this.setPosition(e.position.x, e.position.y, e.position.z), e.target && this.setTarget(e.target.x, e.target.y, e.target.z), e.fov !== void 0 && this.setFOV(e.fov), (e.near !== void 0 || e.far !== void 0) && this.setClipPlanes(
      e.near ?? this.camera.near,
      e.far ?? this.camera.far
    );
  }
  /**
   * Reset camera to default position for current composition size
   */
  reset() {
    const e = mn.degToRad(50), n = this.height / 2 / Math.tan(e / 2);
    this.camera.fov = 50, this.camera.position.set(this.width / 2, -this.height / 2, n), this.target.set(this.width / 2, -this.height / 2, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ORTHOGRAPHIC
  // ============================================================================
  /**
   * Create an orthographic camera for 2D rendering
   */
  createOrthographic() {
    const e = new Eu(
      0,
      // Left
      this.width,
      // Right
      0,
      // Top (in screen coords)
      -this.height,
      // Bottom
      0.1,
      // Near
      1e4
      // Far
    );
    return e.position.set(0, 0, 1e3), e.lookAt(0, 0, 0), e;
  }
}
class h8 {
  constructor() {
    // Texture cache (keyed by URL or ID)
    fe(this, "textures");
    // Geometry cache (keyed by type and parameters)
    fe(this, "geometries");
    // Material cache (keyed by configuration hash)
    fe(this, "materials");
    // Texture loader
    fe(this, "textureLoader");
    // Asset getter callback (set by WeylEngine)
    fe(this, "assetGetter");
    // Statistics
    fe(this, "stats", {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    });
    this.textures = /* @__PURE__ */ new Map(), this.geometries = /* @__PURE__ */ new Map(), this.materials = /* @__PURE__ */ new Map(), this.textureLoader = new _E(), this.initializeCommonGeometries();
  }
  // ============================================================================
  // ASSET ACCESS
  // ============================================================================
  /**
   * Set the asset getter callback
   * Called by WeylEngine to provide access to project assets
   */
  setAssetGetter(e) {
    this.assetGetter = e;
  }
  /**
   * Get an asset reference by ID
   * Returns undefined if asset not found or getter not set
   */
  getAsset(e) {
    var n;
    return (n = this.assetGetter) == null ? void 0 : n.call(this, e);
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Pre-create commonly used geometries
   */
  initializeCommonGeometries() {
    const e = new un(1, 1, 1, 1);
    this.geometries.set("plane:1:1", e);
    const n = new un(2, 2, 1, 1);
    this.geometries.set("quad:fullscreen", n);
  }
  // ============================================================================
  // TEXTURE MANAGEMENT
  // ============================================================================
  /**
   * Load a texture from URL
   */
  async loadTexture(e, n) {
    const i = this.getTextureCacheKey(e, n), r = this.textures.get(i);
    return r ? (this.stats.texturesFromCache++, r) : new Promise((o, a) => {
      this.textureLoader.load(
        e,
        (l) => {
          this.applyTextureOptions(l, n), this.textures.set(i, l), this.stats.texturesLoaded++, o(l);
        },
        void 0,
        // Progress callback
        (l) => {
          ol.error("ResourceManager: Failed to load texture:", e, l), a(l);
        }
      );
    });
  }
  /**
   * Create texture from ImageData
   */
  createTextureFromImageData(e, n, i) {
    const r = this.textures.get(n);
    if (r instanceof $a)
      return r.image = e, r.needsUpdate = !0, r;
    const o = new $a(
      e.data,
      e.width,
      e.height,
      Un,
      Xi
    );
    return this.applyTextureOptions(o, i), o.needsUpdate = !0, this.textures.set(n, o), this.stats.texturesLoaded++, o;
  }
  /**
   * Create texture from canvas
   */
  createTextureFromCanvas(e, n, i) {
    const r = this.textures.get(n);
    if (r instanceof Qm)
      return r.needsUpdate = !0, r;
    const o = new Qm(e);
    return this.applyTextureOptions(o, i), this.textures.set(n, o), this.stats.texturesLoaded++, o;
  }
  /**
   * Get a cached texture
   */
  getTexture(e) {
    return this.textures.get(e);
  }
  /**
   * Apply options to a texture
   */
  applyTextureOptions(e, n) {
    if (!n) {
      e.minFilter = Bt, e.magFilter = Bt, e.generateMipmaps = !1, e.colorSpace = dn;
      return;
    }
    n.wrapS !== void 0 && (e.wrapS = n.wrapS), n.wrapT !== void 0 && (e.wrapT = n.wrapT), n.minFilter !== void 0 && (e.minFilter = n.minFilter), n.magFilter !== void 0 && (e.magFilter = n.magFilter), n.generateMipmaps !== void 0 && (e.generateMipmaps = n.generateMipmaps), n.flipY !== void 0 && (e.flipY = n.flipY), n.colorSpace !== void 0 && (e.colorSpace = n.colorSpace);
  }
  /**
   * Generate cache key for texture
   */
  getTextureCacheKey(e, n) {
    return n ? `${e}:${JSON.stringify(n)}` : e;
  }
  /**
   * Release a texture
   */
  releaseTexture(e) {
    const n = this.textures.get(e);
    n && (n.dispose(), this.textures.delete(e));
  }
  /**
   * Get texture for a layer by its ID
   * Looks up the layer's asset and returns its texture if cached
   */
  getLayerTexture(e) {
    const n = `layer:${e}`, i = this.textures.get(n);
    return i || null;
  }
  /**
   * Cache a texture for a layer
   */
  setLayerTexture(e, n) {
    const i = `layer:${e}`;
    this.textures.set(i, n);
  }
  // ============================================================================
  // GEOMETRY MANAGEMENT
  // ============================================================================
  /**
   * Get a plane geometry (cached)
   */
  getPlaneGeometry(e = 1, n = 1) {
    const i = `plane:${e}:${n}`;
    let r = this.geometries.get(i);
    return r ? (this.stats.geometriesFromCache++, r) : (r = new un(e, n, 1, 1), this.geometries.set(i, r), this.stats.geometriesCreated++, r);
  }
  /**
   * Get a circle geometry (cached)
   */
  getCircleGeometry(e = 1, n = 32) {
    const i = `circle:${e}:${n}`;
    let r = this.geometries.get(i);
    return r ? (this.stats.geometriesFromCache++, r) : (r = new Au(e, n), this.geometries.set(i, r), this.stats.geometriesCreated++, r);
  }
  /**
   * Get a box geometry (cached)
   */
  getBoxGeometry(e = 1, n = 1, i = 1) {
    const r = `box:${e}:${n}:${i}`;
    let o = this.geometries.get(r);
    return o ? (this.stats.geometriesFromCache++, o) : (o = new pn(e, n, i), this.geometries.set(r, o), this.stats.geometriesCreated++, o);
  }
  /**
   * Get the fullscreen quad geometry
   */
  getFullscreenQuad() {
    return this.geometries.get("quad:fullscreen");
  }
  // ============================================================================
  // MATERIAL MANAGEMENT
  // ============================================================================
  /**
   * Get or create a basic material
   */
  getBasicMaterial(e) {
    const n = `basic:${JSON.stringify(e)}`;
    let i = this.materials.get(n);
    return i || (i = new En({
      color: e.color ?? 16777215,
      transparent: e.transparent ?? !0,
      opacity: e.opacity ?? 1,
      map: e.map,
      side: e.side ?? vn
    }), this.materials.set(n, i), i);
  }
  /**
   * Create a non-cached material (for layers with unique properties)
   */
  createMaterial(e) {
    switch (e) {
      case "basic":
        return new En({
          transparent: !0,
          side: vn
        });
      case "standard":
        return new pE({
          transparent: !0,
          side: vn
        });
      case "shader":
        return new zn();
      default:
        return new En();
    }
  }
  // ============================================================================
  // STATISTICS
  // ============================================================================
  /**
   * Get resource statistics
   */
  getStats() {
    return {
      textureCount: this.textures.size,
      geometryCount: this.geometries.size,
      materialCount: this.materials.size,
      ...this.stats
    };
  }
  /**
   * Reset statistics
   */
  resetStats() {
    this.stats = {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all cached resources
   */
  dispose() {
    for (const e of this.textures.values())
      e.dispose();
    this.textures.clear();
    for (const e of this.geometries.values())
      e.dispose();
    this.geometries.clear();
    for (const e of this.materials.values())
      e.dispose();
    this.materials.clear();
  }
  /**
   * Clear unused resources (call periodically)
   */
  clearUnused() {
    ol.debug("ResourceManager: Resource stats:", this.getStats());
  }
}
class f8 {
  constructor() {
    // Frame timing
    fe(this, "frameCount", 0);
    fe(this, "lastTime", 0);
    fe(this, "frameTimes", []);
    fe(this, "maxFrameTimes", 60);
    // FPS calculation
    fe(this, "fps", 0);
    fe(this, "fpsUpdateInterval", 500);
    // ms
    fe(this, "lastFpsUpdate", 0);
    fe(this, "framesInInterval", 0);
    // Frame start time (for measuring frame duration)
    fe(this, "frameStartTime", 0);
    // Last captured stats
    fe(this, "lastStats", {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    });
    this.lastTime = performance.now(), this.lastFpsUpdate = this.lastTime;
  }
  /**
   * Call at the beginning of each frame
   */
  beginFrame() {
    this.frameStartTime = performance.now();
  }
  /**
   * Call at the end of each frame
   */
  endFrame(e) {
    const n = performance.now(), i = n - this.frameStartTime;
    this.frameTimes.push(i), this.frameTimes.length > this.maxFrameTimes && this.frameTimes.shift(), this.frameCount++, this.framesInInterval++;
    const r = n - this.lastFpsUpdate;
    r >= this.fpsUpdateInterval && (this.fps = Math.round(this.framesInInterval * 1e3 / r), this.framesInInterval = 0, this.lastFpsUpdate = n);
    const o = e.info, a = performance.memory, l = (a == null ? void 0 : a.usedJSHeapSize) ?? 0, c = this.frameTimes.length > 0 ? this.frameTimes.reduce((u, d) => u + d, 0) / this.frameTimes.length : 0;
    return this.lastStats = {
      fps: this.fps,
      frameTime: Math.round(c * 100) / 100,
      drawCalls: o.render.calls,
      triangles: o.render.triangles,
      textures: o.memory.textures,
      geometries: o.memory.geometries,
      memoryUsed: l
    }, this.lastTime = n, this.lastStats;
  }
  /**
   * Get the last captured stats
   */
  getStats() {
    return { ...this.lastStats };
  }
  /**
   * Get current FPS
   */
  getFPS() {
    return this.fps;
  }
  /**
   * Get average frame time in ms
   */
  getAverageFrameTime() {
    return this.frameTimes.length === 0 ? 0 : this.frameTimes.reduce((e, n) => e + n, 0) / this.frameTimes.length;
  }
  /**
   * Get min/max frame times
   */
  getFrameTimeRange() {
    return this.frameTimes.length === 0 ? { min: 0, max: 0 } : {
      min: Math.min(...this.frameTimes),
      max: Math.max(...this.frameTimes)
    };
  }
  /**
   * Get frame time history
   */
  getFrameTimeHistory() {
    return [...this.frameTimes];
  }
  /**
   * Get total frame count
   */
  getFrameCount() {
    return this.frameCount;
  }
  /**
   * Reset all statistics
   */
  reset() {
    this.frameCount = 0, this.frameTimes = [], this.fps = 0, this.framesInInterval = 0, this.lastTime = performance.now(), this.lastFpsUpdate = this.lastTime, this.lastStats = {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    };
  }
  /**
   * Check if performance is degraded
   */
  isPerformanceDegraded(e = 30) {
    return this.fps > 0 && this.fps < e;
  }
  /**
   * Get performance report as string
   */
  getReport() {
    const e = this.lastStats, n = this.getFrameTimeRange();
    return [
      `FPS: ${e.fps}`,
      `Frame Time: ${e.frameTime.toFixed(2)}ms (min: ${n.min.toFixed(2)}, max: ${n.max.toFixed(2)})`,
      `Draw Calls: ${e.drawCalls}`,
      `Triangles: ${e.triangles.toLocaleString()}`,
      `Textures: ${e.textures}`,
      `Geometries: ${e.geometries}`,
      `Memory: ${(e.memoryUsed / 1024 / 1024).toFixed(2)} MB`
    ].join(`
`);
  }
}
class p8 {
  constructor(e) {
    // Core subsystems
    fe(this, "scene");
    fe(this, "renderer");
    fe(this, "layers");
    fe(this, "camera");
    fe(this, "resources");
    fe(this, "performance");
    // State
    fe(this, "state");
    fe(this, "animationFrameId", null);
    // Background and overlay images
    fe(this, "backgroundImage", null);
    fe(this, "depthMapMesh", null);
    fe(this, "depthMapSettings", { colormap: "viridis", opacity: 0.5, visible: !1 });
    // Viewport transform for pan/zoom
    fe(this, "viewportTransform", [1, 0, 0, 1, 0, 0]);
    // Render mode
    fe(this, "renderMode", "color");
    // Audio reactivity
    fe(this, "audioReactiveGetter", null);
    // Transform controls for layer manipulation
    fe(this, "transformControls", null);
    fe(this, "selectedLayerId", null);
    fe(this, "transformMode", "translate");
    // Transform change callback
    fe(this, "onTransformChange", null);
    // Event system
    fe(this, "eventHandlers");
    // Configuration
    fe(this, "config");
    // Active camera tracking
    fe(this, "activeCameraGetter");
    fe(this, "activeCameraId", null);
    this.validateConfig(e), this.config = {
      canvas: e.canvas,
      width: e.width,
      height: e.height,
      compositionWidth: e.compositionWidth ?? e.width,
      compositionHeight: e.compositionHeight ?? e.height,
      pixelRatio: e.pixelRatio ?? Math.min(window.devicePixelRatio, 2),
      antialias: e.antialias ?? !0,
      alpha: e.alpha ?? !0,
      backgroundColor: e.backgroundColor ?? null,
      debug: e.debug ?? !1,
      powerPreference: e.powerPreference ?? "high-performance"
    }, this.state = {
      currentFrame: 0,
      isRendering: !1,
      isDisposed: !1,
      viewport: {
        width: this.config.width,
        height: this.config.height
      }
    }, this.eventHandlers = /* @__PURE__ */ new Map(), this.resources = new h8(), this.scene = new B6(this.config.backgroundColor), this.camera = new d8(this.config.width, this.config.height), this.renderer = new Q6({
      canvas: this.config.canvas,
      width: this.config.width,
      height: this.config.height,
      pixelRatio: this.config.pixelRatio,
      antialias: this.config.antialias,
      alpha: this.config.alpha
    }, this.scene, this.camera), this.layers = new u8(this.scene, this.resources), this.performance = new f8(), this.scene.setCompositionSize(
      this.config.compositionWidth,
      this.config.compositionHeight
    ), this.setupContextLossHandling(), this.config.debug && ts.debug("Initialized", this.config);
  }
  // ============================================================================
  // CONFIGURATION VALIDATION
  // ============================================================================
  validateConfig(e) {
    if (!(e.canvas instanceof HTMLCanvasElement))
      throw new Error("WeylEngine requires a valid HTMLCanvasElement");
    if (e.width <= 0 || e.height <= 0)
      throw new Error("WeylEngine requires positive width and height");
    if (e.width > 8192 || e.height > 8192)
      throw new Error("WeylEngine maximum dimension is 8192 pixels");
  }
  // ============================================================================
  // LAYER MANAGEMENT
  // ============================================================================
  /**
   * Add a layer to the composition
   * @param layerData - The layer data from the project schema
   */
  addLayer(e) {
    this.assertNotDisposed(), this.layers.create(e), this.emit("layerAdded", { layerId: e.id }), this.config.debug && ts.debug("Layer added:", e.id, e.type);
  }
  /**
   * Update a layer's properties
   * @param layerId - The layer ID to update
   * @param properties - Partial layer properties to update
   */
  updateLayer(e, n) {
    this.assertNotDisposed(), this.layers.update(e, n), this.emit("layerUpdated", { layerId: e, properties: n });
  }
  /**
   * Remove a layer from the composition
   * @param layerId - The layer ID to remove
   */
  removeLayer(e) {
    this.assertNotDisposed(), this.layers.remove(e), this.emit("layerRemoved", { layerId: e }), this.config.debug && ts.debug("Layer removed:", e);
  }
  /**
   * Get all layer IDs currently in the composition
   */
  getLayerIds() {
    return this.layers.getLayerIds();
  }
  /**
   * Get the Three.js object for a layer (for advanced manipulation)
   * @param layerId - The layer ID
   */
  getLayerObject(e) {
    return this.layers.getObject(e);
  }
  /**
   * Sync all layers from store data
   * @param layers - Array of layer data from store
   */
  syncLayers(e) {
    this.assertNotDisposed();
    const n = new Set(this.layers.getLayerIds()), i = new Set(e.map((r) => r.id));
    for (const r of n)
      i.has(r) || this.layers.remove(r);
    for (const r of e)
      n.has(r.id) ? this.layers.update(r.id, r) : this.layers.create(r);
  }
  // ============================================================================
  // CALLBACKS & INTEGRATION
  // ============================================================================
  /**
   * Set the asset getter callback for ResourceManager
   * This allows layers to access project assets
   * @param getter - Function that retrieves assets by ID
   */
  setAssetGetter(e) {
    this.resources.setAssetGetter(e);
  }
  /**
   * Set the video metadata callback for LayerManager
   * Called when a video layer finishes loading its metadata
   * @param callback - Function called with layer ID and video metadata
   */
  setVideoMetadataCallback(e) {
    this.layers.setVideoMetadataCallback(e);
  }
  /**
   * Set the precomp render context for LayerManager
   * Allows precomp layers to render nested compositions
   * @param context - Render context with composition access
   */
  setPrecompRenderContext(e) {
    this.layers.setPrecompRenderContext(e);
  }
  /**
   * Set camera callbacks for LayerManager
   * Allows camera layers to access Camera3D data from store
   * @param getter - Function to get Camera3D by ID
   * @param updater - Function to update Camera3D properties
   * @param atFrameGetter - Function to get Camera3D with keyframe interpolation at a specific frame
   */
  setCameraCallbacks(e, n, i) {
    this.layers.setCameraCallbacks(e, n, i), this.activeCameraGetter = e;
  }
  /**
   * Set the active camera layer that drives the render view
   * @param cameraLayerId - The camera layer ID, or null to use default camera
   */
  setActiveCameraLayer(e) {
    this.activeCameraId = e;
  }
  /**
   * Sync render camera from active CameraLayer
   * Called during frame evaluation to update the actual render camera
   */
  syncActiveCamera() {
    if (!this.activeCameraId || !this.activeCameraGetter)
      return;
    const e = this.layers.getLayer(this.activeCameraId);
    if (!e || e.type !== "camera")
      return;
    const n = e, i = n.getExportData();
    if (!i)
      return;
    this.camera.setPosition(i.position.x, i.position.y, i.position.z), this.camera.setRotation(i.rotation.x, i.rotation.y, i.rotation.z), this.camera.setFOV(i.fov), this.camera.setClipPlanes(i.nearClip, i.farClip);
    const r = n.getCameraAtCurrentFrame();
    r && r.depthOfField && this.setDOFFromCamera(r.depthOfField);
  }
  /**
   * Set composition FPS for particle timing
   * @param fps - Frames per second
   */
  setCompositionFPS(e) {
    this.layers.setCompositionFPS(e);
  }
  /**
   * Initialize particle systems with WebGL renderer
   * Must be called after engine initialization to enable GPU particles
   */
  initializeParticleSystems() {
    this.layers.setRenderer(this.renderer.getWebGLRenderer()), this.layers.setCamera(this.camera.camera);
  }
  /**
   * Get the current camera position (for particle systems, etc.)
   * Returns world-space position of the active camera
   */
  getCameraPosition() {
    return this.camera.camera.position.clone();
  }
  /**
   * Get the camera's projection and view matrices
   * Useful for depth calculations and screen-space effects
   */
  getCameraMatrices() {
    const e = this.camera.camera;
    return {
      projectionMatrix: e.projectionMatrix.clone(),
      viewMatrix: e.matrixWorldInverse.clone(),
      projectionMatrixInverse: e.projectionMatrixInverse.clone()
    };
  }
  // ============================================================================
  // PROPERTY DRIVERS (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values for a layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(e, n) {
    this.layers.setLayerDrivenValues(e, n);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(e) {
    this.layers.clearLayerDrivenValues(e);
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    this.layers.clearAllDrivenValues();
  }
  /**
   * Get the Three.js camera directly (for advanced use)
   */
  getCamera() {
    return this.camera.camera;
  }
  // ============================================================================
  // ANIMATION & TIMELINE
  // ============================================================================
  /**
   * Set the current frame for animation evaluation
   * @param frame - The frame number (0-indexed)
   */
  setFrame(e) {
    this.assertNotDisposed(), this.state.currentFrame = e, this.layers.evaluateFrame(e, this.audioReactiveGetter), this.syncActiveCamera(), this.activeCameraId || this.camera.evaluateFrame(e);
  }
  /**
   * Set the audio reactive getter callback
   * This callback will be called during frame evaluation to get audio-modulated values
   */
  setAudioReactiveCallback(e) {
    this.audioReactiveGetter = e, this.layers.setAudioReactiveCallback(e);
  }
  /**
   * Get the current frame
   */
  getCurrentFrame() {
    return this.state.currentFrame;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.assertNotDisposed(), this.performance.beginFrame(), this.emit("frameStart", { frame: this.state.currentFrame }), this.renderer.render(), this.emit("frameEnd", { frame: this.state.currentFrame }), this.performance.endFrame(this.renderer.getWebGLRenderer());
  }
  /**
   * Start continuous rendering loop
   */
  startRenderLoop() {
    if (this.assertNotDisposed(), this.animationFrameId !== null)
      return;
    this.state.isRendering = !0;
    const e = () => {
      !this.state.isRendering || this.state.isDisposed || (this.render(), this.animationFrameId = requestAnimationFrame(e));
    };
    this.animationFrameId = requestAnimationFrame(e);
  }
  /**
   * Stop continuous rendering loop
   */
  stopRenderLoop() {
    this.state.isRendering = !1, this.animationFrameId !== null && (cancelAnimationFrame(this.animationFrameId), this.animationFrameId = null);
  }
  /**
   * Check if render loop is active
   */
  isRenderLoopActive() {
    return this.state.isRendering;
  }
  // ============================================================================
  // VIEWPORT
  // ============================================================================
  /**
   * Resize the viewport
   * @param width - New viewport width in pixels
   * @param height - New viewport height in pixels
   * @param compositionWidth - Optional new composition width
   * @param compositionHeight - Optional new composition height
   */
  resize(e, n, i, r) {
    if (this.assertNotDisposed(), e <= 0 || n <= 0) {
      ts.warn("Invalid resize dimensions:", e, n);
      return;
    }
    this.state.viewport = { width: e, height: n }, this.renderer.resize(e, n);
    const o = i ?? e, a = r ?? n;
    this.camera.resize(o, a), this.emit("resize", { width: e, height: n, compositionWidth: i, compositionHeight: r });
  }
  /**
   * Get current viewport dimensions
   */
  getViewport() {
    return { ...this.state.viewport };
  }
  // ============================================================================
  // CAMERA
  // ============================================================================
  /**
   * Get the camera controller for advanced camera manipulation
   */
  getCameraController() {
    return this.camera;
  }
  /**
   * Set camera position
   */
  setCameraPosition(e, n, i) {
    this.camera.setPosition(e, n, i);
  }
  /**
   * Set camera target (look-at point)
   */
  setCameraTarget(e, n, i) {
    this.camera.setTarget(e, n, i);
  }
  /**
   * Set camera field of view
   */
  setCameraFOV(e) {
    this.camera.setFOV(e);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field from Camera3D DOF settings
   * @param dof - Camera3D.depthOfField settings
   */
  setDOFFromCamera(e) {
    this.renderer.setDOF({
      enabled: e.enabled,
      focusDistance: e.focusDistance,
      // Convert aperture to BokehPass scale (smaller = more blur)
      aperture: e.aperture * 1e-4,
      maxBlur: e.blurLevel * 0.02
    });
  }
  /**
   * Enable or disable DOF
   */
  setDOFEnabled(e) {
    this.renderer.setDOFEnabled(e);
  }
  /**
   * Set DOF focus distance
   * @param distance - Focus distance in world units
   */
  setDOFFocusDistance(e) {
    this.renderer.setFocusDistance(e);
  }
  /**
   * Set DOF aperture
   * @param aperture - Aperture value (higher = more blur)
   */
  setDOFAperture(e) {
    this.renderer.setAperture(e * 1e-4);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return this.renderer.getDOF();
  }
  // ============================================================================
  // VIEWPORT TRANSFORM (PAN/ZOOM)
  // ============================================================================
  /**
   * Set the viewport transform for pan/zoom operations
   * @param transform - [scaleX, skewX, skewY, scaleY, translateX, translateY]
   */
  setViewportTransform(e) {
    this.viewportTransform = [...e];
    const n = e[0], i = e[4], r = e[5];
    this.camera.setZoom(n), this.camera.setPan(i, r);
  }
  /**
   * Get the current viewport transform
   */
  getViewportTransform() {
    return [...this.viewportTransform];
  }
  // ============================================================================
  // BACKGROUND & OVERLAYS
  // ============================================================================
  /**
   * Set a background image for the composition
   * @param image - HTMLImageElement to use as background
   */
  setBackgroundImage(e) {
    this.assertNotDisposed(), this.backgroundImage && (this.scene.removeFromComposition(this.backgroundImage), this.backgroundImage.geometry.dispose(), this.backgroundImage.material.dispose());
    const n = new xn(e);
    n.needsUpdate = !0, n.colorSpace = dn;
    const i = new un(e.width, e.height), r = new En({
      map: n,
      transparent: !0,
      depthWrite: !1
    });
    this.backgroundImage = new Ze(i, r), this.backgroundImage.position.set(e.width / 2, e.height / 2, -1e3), this.backgroundImage.userData.isBackground = !0, this.scene.addToComposition(this.backgroundImage);
  }
  /**
   * Set the depth map overlay
   * @param image - HTMLImageElement containing depth data
   * @param options - Display options
   */
  setDepthMap(e, n) {
    this.assertNotDisposed(), this.depthMapSettings = {
      colormap: n.colormap ?? this.depthMapSettings.colormap,
      opacity: n.opacity ?? this.depthMapSettings.opacity,
      visible: n.visible ?? this.depthMapSettings.visible
    }, this.depthMapMesh && (this.scene.removeFromComposition(this.depthMapMesh), this.depthMapMesh.geometry.dispose(), this.depthMapMesh.material.dispose());
    const i = new xn(e);
    i.needsUpdate = !0;
    const r = this.createColormapMaterial(i, this.depthMapSettings), o = new un(e.width, e.height);
    this.depthMapMesh = new Ze(o, r), this.depthMapMesh.position.set(e.width / 2, e.height / 2, -999), this.depthMapMesh.visible = this.depthMapSettings.visible, this.depthMapMesh.userData.isDepthOverlay = !0, this.scene.addToComposition(this.depthMapMesh);
  }
  /**
   * Create a colormap shader material for depth visualization
   */
  createColormapMaterial(e, n) {
    const i = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `, r = `
      uniform sampler2D depthMap;
      uniform float opacity;
      uniform int colormap;
      varying vec2 vUv;

      vec3 viridis(float t) {
        const vec3 c0 = vec3(0.267, 0.004, 0.329);
        const vec3 c1 = vec3(0.282, 0.140, 0.458);
        const vec3 c2 = vec3(0.253, 0.265, 0.529);
        const vec3 c3 = vec3(0.191, 0.407, 0.556);
        const vec3 c4 = vec3(0.127, 0.566, 0.551);
        const vec3 c5 = vec3(0.208, 0.718, 0.472);
        const vec3 c6 = vec3(0.565, 0.843, 0.262);
        const vec3 c7 = vec3(0.993, 0.906, 0.144);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      vec3 plasma(float t) {
        const vec3 c0 = vec3(0.050, 0.030, 0.528);
        const vec3 c1 = vec3(0.327, 0.012, 0.615);
        const vec3 c2 = vec3(0.534, 0.054, 0.553);
        const vec3 c3 = vec3(0.716, 0.215, 0.475);
        const vec3 c4 = vec3(0.863, 0.395, 0.362);
        const vec3 c5 = vec3(0.958, 0.590, 0.233);
        const vec3 c6 = vec3(0.995, 0.812, 0.166);
        const vec3 c7 = vec3(0.940, 0.975, 0.131);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      void main() {
        float depth = texture2D(depthMap, vUv).r;
        vec3 color;

        if (colormap == 0) {
          color = viridis(depth);
        } else if (colormap == 1) {
          color = plasma(depth);
        } else {
          color = vec3(depth);
        }

        gl_FragColor = vec4(color, opacity);
      }
    `, o = n.colormap === "viridis" ? 0 : n.colormap === "plasma" ? 1 : 2;
    return new zn({
      uniforms: {
        depthMap: { value: e },
        opacity: { value: n.opacity },
        colormap: { value: o }
      },
      vertexShader: i,
      fragmentShader: r,
      transparent: !0,
      depthWrite: !1
    });
  }
  /**
   * Set depth overlay visibility
   */
  setDepthOverlayVisible(e) {
    this.depthMapSettings.visible = e, this.depthMapMesh && (this.depthMapMesh.visible = e);
  }
  /**
   * Set depth colormap
   */
  setDepthColormap(e) {
    if (this.depthMapSettings.colormap = e, this.depthMapMesh) {
      const n = this.depthMapMesh.material, i = e === "viridis" ? 0 : e === "plasma" ? 1 : 2;
      n.uniforms.colormap.value = i;
    }
  }
  /**
   * Set depth overlay opacity
   */
  setDepthOpacity(e) {
    if (this.depthMapSettings.opacity = e, this.depthMapMesh) {
      const n = this.depthMapMesh.material;
      n.uniforms.opacity.value = e;
    }
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(e) {
    this.renderMode = e, this.renderer.setRenderMode(e);
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast to find layers at a normalized screen position
   * @param x - Normalized X coordinate (-1 to 1)
   * @param y - Normalized Y coordinate (-1 to 1)
   * @returns Layer ID if hit, null otherwise
   */
  raycastLayers(e, n) {
    const i = new jf(), r = new rt(e, n);
    i.setFromCamera(r, this.camera.getCamera());
    const o = this.scene.raycastComposition(i);
    for (const a of o) {
      let l = a.object;
      for (; l; ) {
        if (l.userData.layerId)
          return l.userData.layerId;
        if (l.userData.isBackground || l.userData.isDepthOverlay)
          break;
        l = l.parent;
      }
    }
    return null;
  }
  // ============================================================================
  // TRANSFORM CONTROLS
  // ============================================================================
  /**
   * Initialize transform controls for layer manipulation
   */
  initializeTransformControls() {
    if (this.assertNotDisposed(), this.transformControls)
      return;
    const e = this.camera.getCamera(), n = this.renderer.getDomElement();
    this.transformControls = new D6(e, n), this.transformControls.setMode(this.transformMode), this.transformControls.setSpace("world"), this.transformControls.setSize(1), this.scene.addUIElement(this.transformControls), this.transformControls.addEventListener("change", () => {
      if (!this.transformControls || !this.selectedLayerId) return;
      const i = this.transformControls.object;
      if (!i) return;
      const r = {
        position: {
          x: i.position.x,
          y: i.position.y,
          z: i.position.z
        },
        rotationX: mn.radToDeg(i.rotation.x),
        rotationY: mn.radToDeg(i.rotation.y),
        rotationZ: mn.radToDeg(i.rotation.z),
        scale: {
          x: i.scale.x * 100,
          // Convert back to percentage
          y: i.scale.y * 100,
          z: i.scale.z * 100
        }
      };
      r.rotation = r.rotationZ, this.onTransformChange && this.onTransformChange(this.selectedLayerId, r);
    }), this.transformControls.addEventListener("dragging-changed", (i) => {
      this.emit("transform-dragging", { dragging: i.value });
    }), this.transformControls.addEventListener("mouseUp", () => {
      this.emit("transform-end", { layerId: this.selectedLayerId });
    });
  }
  /**
   * Set transform change callback
   * Called whenever a layer is transformed via the controls
   */
  setTransformChangeCallback(e) {
    this.onTransformChange = e;
  }
  /**
   * Select a layer and attach transform controls
   * @param layerId - Layer ID to select, or null to deselect
   */
  selectLayer(e) {
    if (this.assertNotDisposed(), this.transformControls || this.initializeTransformControls(), this.selectedLayerId && this.transformControls && this.transformControls.detach(), this.selectedLayerId = e, !e || !this.transformControls)
      return;
    const n = this.getLayerObject(e);
    n && this.transformControls.attach(n);
  }
  /**
   * Get the currently selected layer ID
   */
  getSelectedLayerId() {
    return this.selectedLayerId;
  }
  /**
   * Set the transform mode
   * @param mode - 'translate' | 'rotate' | 'scale'
   */
  setTransformMode(e) {
    this.transformMode = e, this.transformControls && this.transformControls.setMode(e);
  }
  /**
   * Get the current transform mode
   */
  getTransformMode() {
    return this.transformMode;
  }
  /**
   * Set transform controls visibility
   */
  setTransformControlsVisible(e) {
    this.transformControls && (this.transformControls.visible = e, this.transformControls.enabled = e);
  }
  /**
   * Check if transform controls are dragging
   */
  isTransformDragging() {
    var e;
    return ((e = this.transformControls) == null ? void 0 : e.dragging) ?? !1;
  }
  // ============================================================================
  // RENDER LOOP ALIASES
  // ============================================================================
  /**
   * Alias for startRenderLoop
   */
  start() {
    this.startRenderLoop();
  }
  /**
   * Alias for stopRenderLoop
   */
  stop() {
    this.stopRenderLoop();
  }
  // ============================================================================
  // FRAME CAPTURE & EXPORT
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    this.assertNotDisposed();
    const e = this.renderer.captureFrame();
    return {
      imageData: e,
      width: e.width,
      height: e.height,
      format: "rgba"
    };
  }
  /**
   * Capture the current frame as a Blob
   * @param format - Image format ('png' | 'jpeg' | 'webp')
   * @param quality - Quality for lossy formats (0-1)
   */
  async captureFrameAsBlob(e = "png", n = 0.95) {
    this.assertNotDisposed();
    const { imageData: i, width: r, height: o } = this.captureFrame(), a = new OffscreenCanvas(r, o);
    return a.getContext("2d").putImageData(i, 0, 0), a.convertToBlob({
      type: `image/${e}`,
      quality: n
    });
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    this.assertNotDisposed();
    const e = this.renderer.captureDepth(), n = this.camera.getState();
    return {
      depthBuffer: e,
      width: this.state.viewport.width,
      height: this.state.viewport.height,
      near: n.near,
      far: n.far
    };
  }
  // ============================================================================
  // PERFORMANCE
  // ============================================================================
  /**
   * Get current performance statistics
   */
  getPerformanceStats() {
    return this.performance.getStats();
  }
  /**
   * Reset performance statistics
   */
  resetPerformanceStats() {
    this.performance.reset();
  }
  // ============================================================================
  // EVENTS
  // ============================================================================
  /**
   * Subscribe to engine events
   * @param type - Event type to listen for
   * @param handler - Event handler function
   */
  on(e, n) {
    this.eventHandlers.has(e) || this.eventHandlers.set(e, /* @__PURE__ */ new Set()), this.eventHandlers.get(e).add(n);
  }
  /**
   * Unsubscribe from engine events
   * @param type - Event type
   * @param handler - Event handler to remove
   */
  off(e, n) {
    var i;
    (i = this.eventHandlers.get(e)) == null || i.delete(n);
  }
  emit(e, n) {
    var r;
    const i = {
      type: e,
      timestamp: performance.now(),
      data: n
    };
    (r = this.eventHandlers.get(e)) == null || r.forEach((o) => {
      try {
        o(i);
      } catch (a) {
        ts.error(`Event handler error for ${e}:`, a);
      }
    });
  }
  // ============================================================================
  // CONTEXT LOSS HANDLING
  // ============================================================================
  setupContextLossHandling() {
    const e = this.config.canvas;
    e.addEventListener("webglcontextlost", (n) => {
      n.preventDefault(), this.stopRenderLoop(), this.emit("contextLost", null), ts.warn("WebGL context lost");
    }), e.addEventListener("webglcontextrestored", () => {
      this.emit("contextRestored", null), ts.info("WebGL context restored");
    });
  }
  // ============================================================================
  // STATE & UTILITIES
  // ============================================================================
  /**
   * Get current engine state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if the engine has been disposed
   */
  isDisposed() {
    return this.state.isDisposed;
  }
  assertNotDisposed() {
    if (this.state.isDisposed)
      throw new Error("WeylEngine has been disposed");
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all engine resources
   * After calling dispose(), the engine cannot be used again.
   */
  dispose() {
    this.state.isDisposed || (this.stopRenderLoop(), this.layers.dispose(), this.renderer.dispose(), this.scene.dispose(), this.resources.dispose(), this.eventHandlers.clear(), this.state.isDisposed = !0, this.emit("dispose", null), this.config.debug && ts.debug("Disposed"));
  }
}
const m8 = { class: "spline-editor" }, v8 = ["viewBox"], g8 = ["x1", "y1", "x2", "y2"], y8 = ["x1", "y1", "x2", "y2"], _8 = ["cx", "cy", "onMousedown"], x8 = ["cx", "cy", "onMousedown"], b8 = ["cx", "cy", "onMousedown"], w8 = ["cx", "cy"], S8 = /* @__PURE__ */ Ot({
  __name: "SplineEditor",
  props: {
    layerId: {},
    canvasWidth: {},
    canvasHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated"],
  setup(s, { expose: e, emit: n }) {
    const i = s, r = n, o = sn(), a = we(null), l = we(null), c = we(null), u = Ie(() => {
      if (!i.layerId) return [];
      const M = o.layers.find((b) => b.id === i.layerId);
      return !M || M.type !== "spline" || !M.data ? [] : M.data.controlPoints || [];
    });
    function d(M, S) {
      const b = i.viewportTransform, C = (M - b[4]) / b[0], E = (S - b[5]) / b[3];
      return { x: C, y: E };
    }
    function h(M) {
      const b = M.currentTarget.getBoundingClientRect(), C = M.clientX - b.left, E = M.clientY - b.top;
      return d(C, E);
    }
    function m(M) {
      if (!i.isPenMode) return;
      const S = h(M);
      if (i.layerId) {
        const b = o.layers.find((C) => C.id === i.layerId);
        if (b && b.type === "spline") {
          const C = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: S.x,
            y: S.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          o.addSplineControlPoint(i.layerId, C), a.value = C.id, c.value = {
            type: "handleOut",
            pointId: C.id,
            startX: S.x,
            startY: S.y
          }, r("pointAdded", C), r("pathUpdated");
        }
      }
    }
    function p(M) {
      var b;
      const S = h(M);
      if (i.isPenMode && (l.value = S), c.value && i.layerId) {
        const C = o.layers.find((T) => T.id === i.layerId);
        if (!C || C.type !== "spline") return;
        const P = (b = C.data.controlPoints) == null ? void 0 : b.find((T) => T.id === c.value.pointId);
        if (!P) return;
        if (c.value.type === "point") {
          const T = S.x - P.x, y = S.y - P.y, w = { x: S.x, y: S.y };
          P.handleIn && (w.handleIn = { x: P.handleIn.x + T, y: P.handleIn.y + y }), P.handleOut && (w.handleOut = { x: P.handleOut.x + T, y: P.handleOut.y + y }), o.updateSplineControlPoint(i.layerId, P.id, w), r("pointMoved", P.id, S.x, S.y);
        } else if (c.value.type === "handleIn") {
          const T = { handleIn: { x: S.x, y: S.y } };
          if (P.type === "smooth") {
            const y = S.x - P.x, w = S.y - P.y;
            T.handleOut = { x: P.x - y, y: P.y - w };
          }
          o.updateSplineControlPoint(i.layerId, P.id, T), r("handleMoved", P.id, "in", S.x, S.y);
        } else if (c.value.type === "handleOut") {
          const T = { handleOut: { x: S.x, y: S.y } };
          if (P.type === "smooth") {
            const y = S.x - P.x, w = S.y - P.y;
            T.handleIn = { x: P.x - y, y: P.y - w };
          }
          o.updateSplineControlPoint(i.layerId, P.id, T), r("handleMoved", P.id, "out", S.x, S.y);
        }
        r("pathUpdated");
      }
    }
    function v() {
      var M;
      if (c.value && i.layerId) {
        const S = o.layers.find((b) => b.id === i.layerId);
        if (S && S.type === "spline") {
          const C = (M = S.data.controlPoints) == null ? void 0 : M.find((E) => E.id === c.value.pointId);
          if (C && C.handleOut) {
            const E = C.handleOut.x - C.x, P = C.handleOut.y - C.y;
            Math.sqrt(E * E + P * P) > 5 ? o.updateSplineControlPoint(i.layerId, C.id, {
              type: "smooth",
              handleIn: { x: C.x - E, y: C.y - P }
            }) : o.updateSplineControlPoint(i.layerId, C.id, {
              handleOut: null
            });
          }
        }
        c.value = null, r("pathUpdated");
      }
    }
    function x(M, S) {
      if (a.value = M, !i.isPenMode) {
        const b = h(S);
        c.value = {
          type: "point",
          pointId: M,
          startX: b.x,
          startY: b.y
        };
      }
    }
    function g(M, S, b) {
      const C = h(b);
      c.value = {
        type: S === "in" ? "handleIn" : "handleOut",
        pointId: M,
        startX: C.x,
        startY: C.y
      };
    }
    function _(M) {
      if ((M.key === "Delete" || M.key === "Backspace") && a.value && i.layerId) {
        const S = o.layers.find((b) => b.id === i.layerId);
        if (S && S.type === "spline") {
          const b = a.value;
          o.deleteSplineControlPoint(i.layerId, b), r("pointDeleted", b), r("pathUpdated"), a.value = null;
        }
      }
    }
    return _n(() => {
      window.addEventListener("keydown", _);
    }), Nn(() => {
      window.removeEventListener("keydown", _);
    }), e({
      selectedPointId: a,
      clearSelection: () => {
        a.value = null;
      }
    }), (M, S) => (te(), ae("div", m8, [
      (te(), ae("svg", {
        class: "control-overlay",
        viewBox: `0 0 ${s.canvasWidth} ${s.canvasHeight}`,
        onMousedown: m,
        onMousemove: p,
        onMouseup: v,
        onMouseleave: v
      }, [
        (te(!0), ae(qe, null, ot(u.value, (b) => (te(), ae(qe, {
          key: `handles-${b.id}`
        }, [
          b.handleIn && a.value === b.id ? (te(), ae("line", {
            key: 0,
            x1: b.x,
            y1: b.y,
            x2: b.handleIn.x,
            y2: b.handleIn.y,
            class: "handle-line"
          }, null, 8, g8)) : Pe("", !0),
          b.handleOut && a.value === b.id ? (te(), ae("line", {
            key: 1,
            x1: b.x,
            y1: b.y,
            x2: b.handleOut.x,
            y2: b.handleOut.y,
            class: "handle-line"
          }, null, 8, y8)) : Pe("", !0)
        ], 64))), 128)),
        (te(!0), ae(qe, null, ot(u.value, (b) => {
          var C, E;
          return te(), ae(qe, {
            key: `handle-points-${b.id}`
          }, [
            b.handleIn && a.value === b.id ? (te(), ae("circle", {
              key: 0,
              cx: b.handleIn.x,
              cy: b.handleIn.y,
              r: "4",
              class: Fe(["handle-point", { active: ((C = c.value) == null ? void 0 : C.type) === "handleIn" && c.value.pointId === b.id }]),
              onMousedown: _t((P) => g(b.id, "in", P), ["stop"])
            }, null, 42, _8)) : Pe("", !0),
            b.handleOut && a.value === b.id ? (te(), ae("circle", {
              key: 1,
              cx: b.handleOut.x,
              cy: b.handleOut.y,
              r: "4",
              class: Fe(["handle-point", { active: ((E = c.value) == null ? void 0 : E.type) === "handleOut" && c.value.pointId === b.id }]),
              onMousedown: _t((P) => g(b.id, "out", P), ["stop"])
            }, null, 42, x8)) : Pe("", !0)
          ], 64);
        }), 128)),
        (te(!0), ae(qe, null, ot(u.value, (b) => (te(), ae("circle", {
          key: `point-${b.id}`,
          cx: b.x,
          cy: b.y,
          r: "6",
          class: Fe(["control-point", {
            selected: a.value === b.id,
            corner: b.type === "corner",
            smooth: b.type === "smooth"
          }]),
          onMousedown: _t((C) => x(b.id, C), ["stop"])
        }, null, 42, b8))), 128)),
        l.value && s.isPenMode ? (te(), ae("circle", {
          key: 0,
          cx: l.value.x,
          cy: l.value.y,
          r: "4",
          class: "preview-point"
        }, null, 8, w8)) : Pe("", !0)
      ], 40, v8))
    ]));
  }
}), M8 = /* @__PURE__ */ Gt(S8, [["__scopeId", "data-v-55bdee8d"]]), C8 = {
  key: 1,
  class: "overlay-controls"
}, E8 = { class: "render-mode-controls" }, T8 = {
  key: 2,
  class: "transform-mode-controls"
}, A8 = {
  key: 3,
  class: "performance-overlay"
}, P8 = {
  key: 4,
  class: "loading-overlay"
}, R8 = /* @__PURE__ */ Ot({
  __name: "ThreeCanvas",
  setup(s, { expose: e }) {
    const n = sn(), i = we(null), r = we(null), o = we(null), a = U1(null), l = we(!1), c = we(1), u = we(800), d = we(600), h = we(!1), m = we("viridis"), p = we(50), v = we("color"), x = we(!1), g = we({
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    }), _ = we([1, 0, 0, 1, 0, 0]), M = we("translate"), S = Ie(() => n.depthMap !== null), b = Ie(() => n.currentTool === "pen"), C = Ie(() => {
      const V = n.selectedLayer;
      if ((V == null ? void 0 : V.type) === "spline")
        return V.id;
      if (b.value) {
        const Y = n.layers.filter((H) => H.type === "spline");
        return Y.length > 0 ? Y[Y.length - 1].id : null;
      }
      return null;
    }), E = Ie(() => _.value);
    _n(async () => {
      if (!r.value || !i.value) return;
      const V = i.value, Y = V.getBoundingClientRect();
      u.value = Y.width, d.value = Y.height;
      const H = {
        canvas: r.value,
        width: Y.width,
        height: Y.height,
        compositionWidth: n.width || 1920,
        compositionHeight: n.height || 1080,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        // Cap at 2 for performance
        antialias: !0,
        alpha: !0,
        powerPreference: "high-performance"
      };
      try {
        l.value = !0, a.value = new p8(H), a.value.setAssetGetter((F) => n.assets[F]), a.value.setVideoMetadataCallback((F, L) => {
          n.onVideoMetadataLoaded(F, L);
        }), a.value.setCameraCallbacks(
          (F) => n.getCamera(F),
          (F, L) => n.updateCamera(F, L),
          (F, L) => n.getCameraAtFrame(F, L)
        ), a.value.setPrecompRenderContext({
          renderComposition: (F, L) => (n.getComposition(F) && console.log("[ThreeCanvas] Precomp render requested:", F, "frame:", L), null),
          getComposition: (F) => n.getComposition(F)
        }), a.value.setAudioReactiveCallback(
          (F, L) => n.getAudioReactiveValuesForLayer(F, L)
        ), a.value.initializeTransformControls(), a.value.setTransformChangeCallback((F, L) => {
          A(F, L);
        }), a.value.initializeParticleSystems(), a.value.setCompositionFPS(n.fps || 60), a.value.start(), await Pi(), T(), n.initializePropertyDriverSystem(), a.value.setFrame(n.currentFrame), R(), new ResizeObserver(ue).observe(V), Q();
      } catch (I) {
        console.error("[ThreeCanvas] Failed to initialize engine:", I);
      } finally {
        l.value = !1;
      }
      P();
    }), Nn(() => {
      a.value && (a.value.stop(), a.value.dispose(), a.value = null);
    });
    function P() {
      Ft(
        () => n.layers,
        () => {
          T(), a.value && a.value.setFrame(n.currentFrame);
        },
        { deep: !0 }
      ), Ft(
        () => n.currentFrame,
        (V) => {
          a.value && (y(), a.value.setFrame(V));
        }
      ), Ft(
        () => [n.width, n.height],
        ([V, Y]) => {
          a.value && (a.value.resize(u.value, d.value, V, Y), Q());
        }
      ), Ft(
        () => n.sourceImage,
        async (V) => {
          a.value && V && await w(V);
        },
        { immediate: !0 }
      ), Ft(
        () => n.depthMap,
        async (V) => {
          a.value && V && await D(V);
        },
        { immediate: !0 }
      ), Ft(
        () => {
          var V;
          return (V = a.value) == null ? void 0 : V.getPerformanceStats();
        },
        (V) => {
          V && (g.value = V);
        }
      ), Ft(
        () => n.activeCameraId,
        (V) => {
          if (!a.value) return;
          if (!V) {
            a.value.setActiveCameraLayer(null);
            return;
          }
          const Y = n.layers.find(
            (H) => {
              var I;
              return H.type === "camera" && ((I = H.data) == null ? void 0 : I.cameraId) === V;
            }
          );
          Y && a.value.setActiveCameraLayer(Y.id);
        },
        { immediate: !0 }
      ), Ft(
        () => n.selectedLayerIds,
        (V) => {
          if (!a.value) return;
          const Y = V.length > 0 ? V[0] : null;
          a.value.selectLayer(Y);
        },
        { deep: !0 }
      );
    }
    function T() {
      if (!a.value) return;
      const V = new Set(a.value.getLayerIds()), Y = new Set(n.layers.map((H) => H.id));
      for (const H of V)
        Y.has(H) || a.value.removeLayer(H);
      for (const H of n.layers)
        V.has(H.id) ? a.value.updateLayer(H.id, H) : a.value.addLayer(H);
    }
    function y() {
      if (a.value) {
        a.value.clearAllDrivenValues();
        for (const V of n.layers) {
          const Y = n.getDrivenValuesForLayer(V.id);
          Y.size > 0 && a.value.setLayerDrivenValues(V.id, Y);
        }
      }
    }
    async function w(V) {
      if (a.value)
        try {
          l.value = !0;
          const Y = await U(V);
          a.value.setBackgroundImage(Y);
        } catch (Y) {
          console.error("[ThreeCanvas] Failed to load source image:", Y);
        } finally {
          l.value = !1;
        }
    }
    async function D(V) {
      if (a.value)
        try {
          const Y = await U(V);
          a.value.setDepthMap(Y, {
            colormap: m.value,
            opacity: p.value / 100,
            visible: h.value
          });
        } catch (Y) {
          console.error("[ThreeCanvas] Failed to load depth map:", Y);
        }
    }
    function U(V) {
      return new Promise((Y, H) => {
        const I = new Image();
        I.crossOrigin = "anonymous", I.onload = () => Y(I), I.onerror = H, I.src = V.startsWith("data:") ? V : `data:image/png;base64,${V}`;
      });
    }
    function R() {
      const V = i.value, Y = r.value;
      if (!V || !Y) return;
      let H = !1, I = !1, F = 0, L = 0, ee = 0, Z = 1;
      V.addEventListener("mousedown", (k) => {
        k.button === 1 && k.preventDefault();
      }), V.addEventListener("auxclick", (k) => {
        k.button === 1 && k.preventDefault();
      }), Y.addEventListener("wheel", (k) => {
        k.preventDefault();
        const ne = k.deltaY;
        let J = c.value * (ne > 0 ? 0.9 : 1.1);
        J = Math.min(Math.max(J, 0.1), 10);
        const B = Y.getBoundingClientRect(), X = k.clientX - B.left, se = k.clientY - B.top, z = J / c.value;
        _.value[4] = X - z * (X - _.value[4]), _.value[5] = se - z * (se - _.value[5]), _.value[0] = J, _.value[3] = J, c.value = J, a.value && a.value.setViewportTransform(_.value);
      }, { passive: !1 }), Y.addEventListener("mousedown", (k) => {
        var J, B;
        const ne = n.currentTool;
        if (k.button === 1 || ne === "hand" || k.button === 0 && k.altKey) {
          H = !0, F = k.clientX, L = k.clientY, Y.style.cursor = "grabbing", k.preventDefault();
          return;
        }
        if (ne === "zoom") {
          if (k.shiftKey) {
            const X = Math.max(c.value * 0.7, 0.1);
            c.value = X, _.value[0] = X, _.value[3] = X, a.value && a.value.setViewportTransform(_.value);
          } else
            I = !0, ee = k.clientY, Z = c.value;
          return;
        }
        if (ne === "text") {
          const X = Y.getBoundingClientRect(), se = O(k.clientX - X.left, k.clientY - X.top), z = n.createLayer("text");
          (J = z.transform) != null && J.position && (z.transform.position.value = { x: se.x, y: se.y, z: 0 }), n.updateLayer(z.id, {
            transform: {
              ...z.transform,
              position: {
                ...z.transform.position,
                value: { x: se.x, y: se.y, z: 0 }
              }
            }
          }), n.selectLayer(z.id), n.setTool("select");
          return;
        }
        if (ne === "select" && k.button === 0) {
          if ((B = a.value) != null && B.isTransformDragging())
            return;
          const X = Y.getBoundingClientRect(), se = (k.clientX - X.left) / X.width * 2 - 1, z = -((k.clientY - X.top) / X.height) * 2 + 1;
          if (a.value) {
            const N = a.value.raycastLayers(se, z);
            N ? (n.selectLayer(N), a.value.selectLayer(N)) : (n.clearSelection(), a.value.selectLayer(null));
          }
        }
      }), Y.addEventListener("mousemove", (k) => {
        if (H) {
          const J = k.clientX - F, B = k.clientY - L;
          _.value[4] += J, _.value[5] += B, F = k.clientX, L = k.clientY, a.value && a.value.setViewportTransform(_.value);
          return;
        }
        if (I) {
          const B = 1 + (ee - k.clientY) * 0.01, X = Math.max(0.1, Math.min(10, Z * B));
          c.value = X, _.value[0] = X, _.value[3] = X, a.value && a.value.setViewportTransform(_.value);
          return;
        }
        const ne = n.currentTool;
        ne === "hand" ? Y.style.cursor = "grab" : ne === "zoom" ? Y.style.cursor = "zoom-in" : ne === "text" ? Y.style.cursor = "text" : ne === "pen" ? Y.style.cursor = "crosshair" : Y.style.cursor = "default";
      }), Y.addEventListener("mouseup", () => {
        H && (H = !1, Y.style.cursor = n.currentTool === "hand" ? "grab" : "default"), I && (I = !1);
      }), Y.addEventListener("mouseleave", () => {
        H = !1, I = !1;
      });
    }
    function O(V, Y) {
      const H = _.value;
      return {
        x: (V - H[4]) / H[0],
        y: (Y - H[5]) / H[3]
      };
    }
    function A(V, Y) {
      var F, L, ee, Z;
      const H = n.layers.find((k) => k.id === V);
      if (!H) return;
      const I = {};
      Y.position && H.transform && (I.transform = {
        ...H.transform,
        position: {
          ...H.transform.position,
          value: {
            x: Y.position.x,
            y: Y.position.y,
            z: Y.position.z ?? ((L = (F = H.transform.position) == null ? void 0 : F.value) == null ? void 0 : L.z) ?? 0
          }
        }
      }), H.threeD ? (Y.rotationX !== void 0 || Y.rotationY !== void 0 || Y.rotationZ !== void 0) && (!I.transform && H.transform && (I.transform = { ...H.transform }), I.transform && (Y.rotationX !== void 0 && (I.transform.rotationX = { ...H.transform.rotationX, value: Y.rotationX }), Y.rotationY !== void 0 && (I.transform.rotationY = { ...H.transform.rotationY, value: Y.rotationY }), Y.rotationZ !== void 0 && (I.transform.rotationZ = { ...H.transform.rotationZ, value: Y.rotationZ }))) : Y.rotation !== void 0 && H.transform && (I.transform || (I.transform = { ...H.transform }), I.transform.rotation = { ...H.transform.rotation, value: Y.rotation }), Y.scale && H.transform && (I.transform || (I.transform = { ...H.transform }), I.transform.scale = {
        ...H.transform.scale,
        value: {
          x: Y.scale.x,
          y: Y.scale.y,
          z: Y.scale.z ?? ((Z = (ee = H.transform.scale) == null ? void 0 : ee.value) == null ? void 0 : Z.z) ?? 100
        }
      }), Object.keys(I).length > 0 && n.updateLayer(V, I);
    }
    function G(V) {
      M.value = V, a.value && a.value.setTransformMode(V);
    }
    function ue(V) {
      for (const Y of V) {
        const { width: H, height: I } = Y.contentRect;
        H > 0 && I > 0 && (u.value = H, d.value = I, a.value && a.value.resize(H, I));
      }
    }
    function Q() {
      const V = i.value;
      if (!V || !a.value) return;
      const Y = n.width || 1920, H = n.height || 1080, I = V.getBoundingClientRect(), F = 60, L = (I.width - F * 2) / Y, ee = (I.height - F * 2) / H, Z = Math.min(L, ee, 1);
      _.value = [
        Z,
        0,
        0,
        Z,
        (I.width - Y * Z) / 2,
        (I.height - H * Z) / 2
      ], c.value = Z, a.value.setViewportTransform(_.value);
    }
    function le(V) {
      v.value = V, a.value && a.value.setRenderMode(V);
    }
    function re(V) {
      if (!C.value) {
        const Y = n.createLayer("spline");
        n.selectLayer(Y.id);
      }
    }
    function j() {
      T();
    }
    function $() {
      const V = Math.min(c.value * 1.2, 10);
      c.value = V, _.value[0] = V, _.value[3] = V, a.value && a.value.setViewportTransform(_.value);
    }
    function q() {
      const V = Math.max(c.value * 0.8, 0.1);
      c.value = V, _.value[0] = V, _.value[3] = V, a.value && a.value.setViewportTransform(_.value);
    }
    function oe() {
      Q();
    }
    async function ie() {
      if (!a.value) return null;
      const V = a.value.captureFrame();
      if (!(V != null && V.imageData)) return null;
      const Y = document.createElement("canvas");
      Y.width = V.width, Y.height = V.height;
      const H = Y.getContext("2d");
      return H ? (H.putImageData(V.imageData, 0, 0), Y.toDataURL("image/png")) : null;
    }
    async function ce() {
      if (!a.value) return null;
      const V = a.value.captureDepth();
      if (!(V != null && V.depthBuffer)) return null;
      const Y = document.createElement("canvas");
      Y.width = V.width, Y.height = V.height;
      const H = Y.getContext("2d");
      if (!H) return null;
      const I = H.createImageData(V.width, V.height);
      for (let F = 0; F < V.depthBuffer.length; F++) {
        const L = Math.floor(V.depthBuffer[F] * 255), ee = F * 4;
        I.data[ee] = L, I.data[ee + 1] = L, I.data[ee + 2] = L, I.data[ee + 3] = 255;
      }
      return H.putImageData(I, 0, 0), Y.toDataURL("image/png");
    }
    return Ft(h, (V) => {
      a.value && a.value.setDepthOverlayVisible(V);
    }), Ft(m, (V) => {
      a.value && a.value.setDepthColormap(V);
    }), Ft(p, (V) => {
      a.value && a.value.setDepthOpacity(V / 100);
    }), e({
      engine: a,
      fitToView: oe,
      zoomIn: $,
      zoomOut: q,
      zoom: c,
      captureFrame: ie,
      captureDepth: ce,
      showPerformance: x,
      performanceStats: g,
      renderMode: v,
      setRenderMode: le,
      transformMode: M,
      setTransformModeTo: G
    }), (V, Y) => (te(), ae("div", {
      class: "three-canvas",
      ref_key: "containerRef",
      ref: i
    }, [
      f("canvas", {
        ref_key: "canvasRef",
        ref: r
      }, null, 512),
      C.value || b.value ? (te(), St(M8, {
        key: 0,
        layerId: C.value,
        canvasWidth: u.value,
        canvasHeight: d.value,
        zoom: c.value,
        viewportTransform: E.value,
        isPenMode: b.value,
        onPointAdded: re,
        onPathUpdated: j,
        ref_key: "splineEditorRef",
        ref: o
      }, null, 8, ["layerId", "canvasWidth", "canvasHeight", "zoom", "viewportTransform", "isPenMode"])) : Pe("", !0),
      S.value ? (te(), ae("div", C8, [
        f("label", null, [
          st(f("input", {
            type: "checkbox",
            "onUpdate:modelValue": Y[0] || (Y[0] = (H) => h.value = H)
          }, null, 512), [
            [xi, h.value]
          ]),
          Y[9] || (Y[9] = ct(" Depth Overlay ", -1))
        ]),
        st(f("select", {
          "onUpdate:modelValue": Y[1] || (Y[1] = (H) => m.value = H),
          class: "colormap-select"
        }, [...Y[10] || (Y[10] = [
          f("option", { value: "viridis" }, "Viridis", -1),
          f("option", { value: "plasma" }, "Plasma", -1),
          f("option", { value: "grayscale" }, "Grayscale", -1)
        ])], 512), [
          [Cn, m.value]
        ]),
        st(f("input", {
          type: "range",
          min: "0",
          max: "100",
          "onUpdate:modelValue": Y[2] || (Y[2] = (H) => p.value = H),
          class: "opacity-slider"
        }, null, 512), [
          [
            Ut,
            p.value,
            void 0,
            { number: !0 }
          ]
        ])
      ])) : Pe("", !0),
      f("div", E8, [
        f("button", {
          class: Fe({ active: v.value === "color" }),
          onClick: Y[3] || (Y[3] = (H) => le("color")),
          title: "Color View"
        }, [...Y[11] || (Y[11] = [
          f("i", { class: "pi pi-image" }, null, -1)
        ])], 2),
        f("button", {
          class: Fe({ active: v.value === "depth" }),
          onClick: Y[4] || (Y[4] = (H) => le("depth")),
          title: "Depth View"
        }, [...Y[12] || (Y[12] = [
          f("i", { class: "pi pi-box" }, null, -1)
        ])], 2),
        f("button", {
          class: Fe({ active: v.value === "normal" }),
          onClick: Y[5] || (Y[5] = (H) => le("normal")),
          title: "Normal View"
        }, [...Y[13] || (Y[13] = [
          f("i", { class: "pi pi-compass" }, null, -1)
        ])], 2)
      ]),
      Ve(n).selectedLayerIds.length > 0 ? (te(), ae("div", T8, [
        f("button", {
          class: Fe({ active: M.value === "translate" }),
          onClick: Y[6] || (Y[6] = (H) => G("translate")),
          title: "Move (V)"
        }, [...Y[14] || (Y[14] = [
          f("i", { class: "pi pi-arrows-alt" }, null, -1)
        ])], 2),
        f("button", {
          class: Fe({ active: M.value === "rotate" }),
          onClick: Y[7] || (Y[7] = (H) => G("rotate")),
          title: "Rotate (R)"
        }, [...Y[15] || (Y[15] = [
          f("i", { class: "pi pi-sync" }, null, -1)
        ])], 2),
        f("button", {
          class: Fe({ active: M.value === "scale" }),
          onClick: Y[8] || (Y[8] = (H) => G("scale")),
          title: "Scale (S)"
        }, [...Y[16] || (Y[16] = [
          f("i", { class: "pi pi-expand" }, null, -1)
        ])], 2)
      ])) : Pe("", !0),
      x.value ? (te(), ae("div", A8, [
        f("span", null, "FPS: " + xe(g.value.fps), 1),
        f("span", null, "Draw: " + xe(g.value.drawCalls), 1),
        f("span", null, "Tris: " + xe(g.value.triangles), 1)
      ])) : Pe("", !0),
      l.value ? (te(), ae("div", P8, [...Y[17] || (Y[17] = [
        f("div", { class: "loading-spinner" }, null, -1),
        f("span", null, "Loading...", -1)
      ])])) : Pe("", !0)
    ], 512));
  }
}), D8 = /* @__PURE__ */ Gt(R8, [["__scopeId", "data-v-354ad1da"]]), k8 = { class: "prop-wrapper" }, I8 = { class: "prop-content" }, L8 = { class: "prop-name" }, F8 = { class: "prop-inputs" }, U8 = {
  key: 0,
  class: "vec-item"
}, O8 = {
  key: 1,
  class: "color-input-wrapper"
}, z8 = ["value"], N8 = { class: "color-hex" }, B8 = { class: "vec-item" }, V8 = { class: "vec-item" }, G8 = ["onMousedown", "onDblclick", "onContextmenu"], H8 = /* @__PURE__ */ Ot({
  __name: "PropertyTrack",
  props: ["name", "property", "layerId", "propertyPath", "layoutMode", "pixelsPerFrame", "gridStyle"],
  emits: ["selectKeyframe", "deleteKeyframe", "moveKeyframe"],
  setup(s, { emit: e }) {
    const n = s, i = sn(), r = we(/* @__PURE__ */ new Set()), o = we(null), a = we(!1), l = we(0), c = we(0), u = we({
      visible: !1,
      x: 0,
      y: 0,
      keyframe: null
    }), d = Ie(() => ({
      left: `${u.value.x}px`,
      top: `${u.value.y}px`
    })), h = Ie(() => {
      const U = Math.min(l.value, c.value), R = Math.abs(c.value - l.value);
      return {
        left: `${U}px`,
        width: `${R}px`
      };
    }), m = Ie(() => {
      var U;
      return (U = n.property.keyframes) == null ? void 0 : U.some((R) => R.frame === i.currentFrame);
    }), p = Ie(() => i.selectedPropertyPath === n.propertyPath);
    function v() {
      i.setPropertyAnimated(n.layerId, n.propertyPath, !n.property.animated);
    }
    function x() {
      i.addKeyframe(n.layerId, n.propertyPath, n.property.value);
    }
    function g(U) {
      i.setPropertyValue(n.layerId, n.propertyPath, U);
    }
    function _(U, R) {
      const O = { ...n.property.value, [U]: R };
      i.setPropertyValue(n.layerId, n.propertyPath, O);
    }
    function M() {
      i.selectProperty(n.propertyPath);
    }
    function S(U) {
      const R = U.currentTarget.getBoundingClientRect(), O = U.clientX - R.left;
      a.value = !0, l.value = O, c.value = O, U.shiftKey || r.value.clear();
      const A = (ue) => {
        const Q = ue.clientX - R.left;
        c.value = Math.max(0, Q);
        const le = Math.min(l.value, c.value) / n.pixelsPerFrame, re = Math.max(l.value, c.value) / n.pixelsPerFrame;
        ue.shiftKey || r.value.clear();
        for (const j of n.property.keyframes || [])
          j.frame >= le && j.frame <= re && r.value.add(j.id);
      }, G = (ue) => {
        if (a.value = !1, Math.abs(c.value - l.value) < 5) {
          const le = Math.round(l.value / n.pixelsPerFrame);
          i.setFrame(Math.max(0, Math.min(i.frameCount - 1, le)));
        }
        window.removeEventListener("mousemove", A), window.removeEventListener("mouseup", G);
      };
      window.addEventListener("mousemove", A), window.addEventListener("mouseup", G);
    }
    function b(U, R) {
      U.shiftKey ? r.value.has(R.id) ? r.value.delete(R.id) : r.value.add(R.id) : (r.value.clear(), r.value.add(R.id));
      const O = U.clientX, A = R.frame, G = (Q) => {
        const le = Q.clientX - O, re = Math.round(le / n.pixelsPerFrame);
        let j = Math.max(0, Math.min(i.frameCount - 1, A + re));
        if (!Q.altKey && i.snapConfig.enabled) {
          const $ = qf(j, i.snapConfig, n.pixelsPerFrame, {
            layers: i.layers,
            selectedLayerId: n.layerId,
            currentFrame: i.currentFrame,
            audioAnalysis: i.audioAnalysis,
            peakData: i.peakData
          });
          $ && (j = $.frame);
        }
        j !== R.frame && i.moveKeyframe(n.layerId, n.propertyPath, R.id, j);
      }, ue = () => {
        window.removeEventListener("mousemove", G), window.removeEventListener("mouseup", ue);
      };
      window.addEventListener("mousemove", G), window.addEventListener("mouseup", ue);
    }
    function C(U) {
      i.removeKeyframe(n.layerId, n.propertyPath, U), r.value.delete(U);
    }
    function E(U, R) {
      var A;
      r.value.has(R.id) || (r.value.clear(), r.value.add(R.id));
      const O = (A = o.value) == null ? void 0 : A.getBoundingClientRect();
      O && (u.value = {
        visible: !0,
        x: U.clientX - O.left,
        y: U.clientY - O.top,
        keyframe: R
      });
    }
    function P() {
      u.value.visible = !1, u.value.keyframe = null;
    }
    function T(U) {
      for (const R of r.value)
        i.setKeyframeInterpolation(n.layerId, n.propertyPath, R, U);
      P();
    }
    function y() {
      u.value.keyframe && i.setFrame(u.value.keyframe.frame), P();
    }
    function w() {
      for (const U of r.value)
        i.removeKeyframe(n.layerId, n.propertyPath, U);
      r.value.clear(), P();
    }
    function D(U) {
      u.value.visible && P();
    }
    return _n(() => {
      document.addEventListener("click", D);
    }), Nn(() => {
      document.removeEventListener("click", D);
    }), (U, R) => {
      var O, A, G, ue;
      return te(), ae("div", k8, [
        s.layoutMode === "sidebar" ? (te(), ae("div", {
          key: 0,
          class: Fe(["prop-sidebar", { selected: p.value }]),
          style: yt(s.gridStyle),
          onClick: M
        }, [
          R[10] || (R[10] = f("div", { class: "indent-spacer" }, null, -1)),
          f("div", {
            class: "icon-box",
            onClick: _t(x, ["stop"])
          }, [
            f("span", {
              class: Fe(["kf-btn", { active: m.value }])
            }, "", 2)
          ]),
          f("div", {
            class: "icon-box",
            onClick: _t(v, ["stop"])
          }, [
            f("span", {
              class: Fe(["stopwatch", { active: s.property.animated }])
            }, "", 2)
          ]),
          f("div", I8, [
            f("span", L8, xe(s.name), 1),
            f("div", F8, [
              s.name === "Z Position" ? (te(), ae("div", U8, [
                R[7] || (R[7] = f("span", { class: "label z-label" }, "Z", -1)),
                ze(et, {
                  modelValue: ((O = s.property.value) == null ? void 0 : O.z) ?? 0,
                  "onUpdate:modelValue": R[0] || (R[0] = (Q) => _("z", Q))
                }, null, 8, ["modelValue"])
              ])) : s.property.type === "color" ? (te(), ae("div", O8, [
                f("input", {
                  type: "color",
                  value: s.property.value,
                  onInput: R[1] || (R[1] = (Q) => g(Q.target.value))
                }, null, 40, z8),
                f("span", N8, xe(s.property.value), 1)
              ])) : typeof s.property.value == "object" ? (te(), ae(qe, { key: 2 }, [
                f("div", B8, [
                  R[8] || (R[8] = f("span", { class: "label x-label" }, "X", -1)),
                  ze(et, {
                    modelValue: s.property.value.x,
                    "onUpdate:modelValue": R[2] || (R[2] = (Q) => _("x", Q))
                  }, null, 8, ["modelValue"])
                ]),
                f("div", V8, [
                  R[9] || (R[9] = f("span", { class: "label y-label" }, "Y", -1)),
                  ze(et, {
                    modelValue: s.property.value.y,
                    "onUpdate:modelValue": R[3] || (R[3] = (Q) => _("y", Q))
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : typeof s.property.value == "number" ? (te(), St(et, {
                key: 3,
                modelValue: s.property.value,
                "onUpdate:modelValue": g,
                precision: 1
              }, null, 8, ["modelValue"])) : Pe("", !0)
            ])
          ])
        ], 6)) : (te(), ae("div", {
          key: 1,
          class: "prop-track",
          onMousedown: S,
          ref_key: "trackRef",
          ref: o
        }, [
          a.value ? (te(), ae("div", {
            key: 0,
            class: "selection-box",
            style: yt(h.value)
          }, null, 4)) : Pe("", !0),
          (te(!0), ae(qe, null, ot(s.property.keyframes, (Q) => (te(), ae("div", {
            key: Q.id,
            class: Fe(["keyframe", { selected: r.value.has(Q.id), [Q.interpolation || "linear"]: !0 }]),
            style: yt({ left: `${Q.frame * s.pixelsPerFrame}px` }),
            onMousedown: _t((le) => b(le, Q), ["stop"]),
            onDblclick: _t((le) => C(Q.id), ["stop"]),
            onContextmenu: _t((le) => E(le, Q), ["prevent", "stop"])
          }, null, 46, G8))), 128)),
          u.value.visible ? (te(), ae("div", {
            key: 1,
            class: "keyframe-context-menu",
            style: yt(d.value)
          }, [
            R[16] || (R[16] = f("div", { class: "menu-header" }, "Interpolation", -1)),
            f("div", {
              class: Fe(["menu-item", { active: ((A = u.value.keyframe) == null ? void 0 : A.interpolation) === "linear" }]),
              onClick: R[4] || (R[4] = (Q) => T("linear"))
            }, [...R[11] || (R[11] = [
              f("span", { class: "icon" }, "", -1),
              ct(" Linear ", -1)
            ])], 2),
            f("div", {
              class: Fe(["menu-item", { active: ((G = u.value.keyframe) == null ? void 0 : G.interpolation) === "bezier" }]),
              onClick: R[5] || (R[5] = (Q) => T("bezier"))
            }, [...R[12] || (R[12] = [
              f("span", { class: "icon" }, "", -1),
              ct(" Bezier ", -1)
            ])], 2),
            f("div", {
              class: Fe(["menu-item", { active: ((ue = u.value.keyframe) == null ? void 0 : ue.interpolation) === "hold" }]),
              onClick: R[6] || (R[6] = (Q) => T("hold"))
            }, [...R[13] || (R[13] = [
              f("span", { class: "icon" }, "", -1),
              ct(" Hold ", -1)
            ])], 2),
            R[17] || (R[17] = f("div", { class: "menu-divider" }, null, -1)),
            f("div", {
              class: "menu-item",
              onClick: y
            }, [...R[14] || (R[14] = [
              f("span", { class: "icon" }, "", -1),
              ct(" Go to Frame ", -1)
            ])]),
            f("div", {
              class: "menu-item delete",
              onClick: w
            }, [...R[15] || (R[15] = [
              f("span", { class: "icon" }, "", -1),
              ct(" Delete ", -1)
            ])])
          ], 4)) : Pe("", !0)
        ], 544))
      ]);
    };
  }
}), tg = /* @__PURE__ */ Gt(H8, [["__scopeId", "data-v-32aca4cb"]]), $8 = {
  key: 0,
  class: "track-wrapper"
}, W8 = { class: "arrow" }, X8 = { class: "layer-id" }, j8 = { class: "type-icon" }, Y8 = {
  key: 0,
  class: "name-text"
}, q8 = { class: "col-mode" }, Z8 = ["value"], K8 = { class: "col-parent" }, J8 = ["value"], Q8 = ["value"], eB = {
  key: 0,
  class: "children-container"
}, tB = ["onMousedown"], nB = { class: "arrow-col" }, iB = { class: "arrow" }, sB = { class: "group-label" }, rB = { key: 0 }, oB = {
  key: 0,
  class: "children-container"
}, aB = { key: 0 }, lB = /* @__PURE__ */ Ot({
  __name: "EnhancedLayerTrack",
  props: ["layer", "index", "layoutMode", "isExpandedExternal", "allLayers", "frameCount", "pixelsPerFrame", "gridStyle"],
  emits: ["toggleExpand", "select", "updateLayer"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = we(!1), a = Ie(() => n.isExpandedExternal ?? o.value), l = Ie(() => r.selectedLayerIds.includes(n.layer.id)), c = we(["Transform", "Text", "More Options"]), u = we(!1), d = we(""), h = we(null), m = we(!1), p = we(0), v = we(0), x = Ie(() => {
      var ie;
      return ((ie = n.allLayers) == null ? void 0 : ie.filter((ce) => ce.id !== n.layer.id)) || [];
    }), g = Ie(() => {
      const ie = {}, ce = n.layer.transform, V = [], Y = (H, I, F) => {
        F && V.push({ path: H, name: I, property: F });
      };
      return Y("transform.anchorPoint", "Anchor Point", ce.anchorPoint), Y("transform.position", "Position", ce.position), n.layer.threeD && V.push({
        path: "transform.position.z",
        name: "Z Position",
        property: ce.position
        // Pass full position property, PropertyTrack handles .z
      }), Y("transform.scale", "Scale", ce.scale), n.layer.threeD ? (ce.orientation && V.push({ path: "transform.orientation", name: "Orientation", property: ce.orientation }), ce.rotationX && V.push({ path: "transform.rotationX", name: "X Rotation", property: ce.rotationX }), ce.rotationY && V.push({ path: "transform.rotationY", name: "Y Rotation", property: ce.rotationY }), ce.rotationZ && V.push({ path: "transform.rotationZ", name: "Z Rotation", property: ce.rotationZ })) : ce.rotation && V.push({ path: "transform.rotation", name: "Rotation", property: ce.rotation }), n.layer.opacity && V.push({ path: "opacity", name: "Opacity", property: n.layer.opacity }), ie.Transform = V, n.layer.properties && n.layer.properties.forEach((H) => {
        const I = H.group || "Properties";
        ie[I] || (ie[I] = []), ie[I].push({ path: H.name, name: H.name, property: H });
      }), ie;
    }), _ = Ie(() => {
      const ie = n.pixelsPerFrame || 10;
      return { left: `${n.layer.inPoint * ie}px`, width: `${(n.layer.outPoint - n.layer.inPoint + 1) * ie}px` };
    });
    function M() {
      i("select", n.layer.id);
    }
    function S() {
      i("toggleExpand", n.layer.id, !a.value);
    }
    function b(ie) {
      c.value.includes(ie) ? c.value = c.value.filter((ce) => ce !== ie) : c.value.push(ie);
    }
    function C(ie) {
      return { text: "T", solid: "", camera: "" }[ie] || "";
    }
    function E() {
      u.value = !0, d.value = n.layer.name, Pi(() => {
        var ie;
        return (ie = h.value) == null ? void 0 : ie.focus();
      });
    }
    function P() {
      i("updateLayer", n.layer.id, { name: d.value }), u.value = !1;
    }
    function T(ie) {
      i("updateLayer", n.layer.id, { parentId: ie.target.value || null });
    }
    function y(ie) {
      i("updateLayer", n.layer.id, { blendMode: ie.target.value });
    }
    function w() {
    }
    function D() {
      i("updateLayer", n.layer.id, { visible: !n.layer.visible });
    }
    function U() {
      i("updateLayer", n.layer.id, { locked: !n.layer.locked });
    }
    function R() {
    }
    function O() {
      const ie = r.getActiveComp();
      if (!ie) return;
      const ce = {
        anchorPoint: { x: ie.settings.width / 2, y: ie.settings.height / 2 },
        position: { x: ie.settings.width / 2, y: ie.settings.height / 2, z: 0 },
        scale: { x: 100, y: 100 },
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        orientation: { x: 0, y: 0, z: 0 },
        opacity: 100
      }, V = n.layer.transform;
      V.anchorPoint && (V.anchorPoint.value = { ...ce.anchorPoint }), V.position && (V.position.value = n.layer.threeD ? { ...ce.position } : { x: ce.position.x, y: ce.position.y }), V.scale && (V.scale.value = { x: ce.scale.x, y: ce.scale.y }), V.rotation && (V.rotation.value = ce.rotation), V.rotationX && (V.rotationX.value = ce.rotationX), V.rotationY && (V.rotationY.value = ce.rotationY), V.rotationZ && (V.rotationZ.value = ce.rotationZ), V.orientation && (V.orientation.value = { ...ce.orientation }), n.layer.opacity && (n.layer.opacity.value = ce.opacity), r.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), console.log("[EnhancedLayerTrack] Reset transform for layer:", n.layer.name);
    }
    function A(ie) {
      p.value = ie.clientX, v.value = ie.clientY, m.value = !0, l.value || i("select", n.layer.id);
    }
    function G() {
      m.value = !1;
    }
    function ue() {
      r.duplicateLayer(n.layer.id), G();
    }
    function Q() {
      G(), Pi(() => {
        u.value = !0, d.value = n.layer.name, Pi(() => {
          var ie;
          return (ie = h.value) == null ? void 0 : ie.focus();
        });
      });
    }
    function le() {
      i("updateLayer", n.layer.id, { visible: !n.layer.visible }), G();
    }
    function re() {
      i("updateLayer", n.layer.id, { locked: !n.layer.locked }), G();
    }
    function j() {
      r.toggleLayer3D(n.layer.id), G();
    }
    function $() {
      r.selectLayer(n.layer.id), r.precomposeSelectedLayers(n.layer.name + " Precomp"), G();
    }
    function q() {
      r.deleteLayer(n.layer.id), G();
    }
    function oe(ie) {
      m.value && G();
    }
    return _n(() => {
      document.addEventListener("click", oe);
    }), Nn(() => {
      document.removeEventListener("click", oe);
    }), (ie, ce) => s.layer ? (te(), ae("div", $8, [
      s.layoutMode === "sidebar" ? (te(), ae(qe, { key: 0 }, [
        f("div", {
          class: Fe(["sidebar-row", { selected: l.value }]),
          style: yt(s.gridStyle),
          onMousedown: M,
          onContextmenu: _t(A, ["prevent"])
        }, [
          f("div", {
            class: "arrow-col",
            onMousedown: _t(S, ["stop"])
          }, [
            f("span", W8, xe(a.value ? "" : ""), 1)
          ], 32),
          f("div", {
            class: "label-box",
            onMousedown: _t(R, ["stop"]),
            style: yt({ background: s.layer.labelColor || "#999" })
          }, null, 36),
          f("div", X8, xe(s.index), 1),
          f("div", {
            class: "icon-col",
            onMousedown: _t(D, ["stop"])
          }, xe(s.layer.visible ? "" : ""), 33),
          f("div", {
            class: "icon-col",
            onMousedown: _t(U, ["stop"])
          }, xe(s.layer.locked ? "" : ""), 33),
          f("div", {
            class: Fe(["icon-col cube-icon", { active: s.layer.threeD }]),
            onMousedown: ce[0] || (ce[0] = _t((V) => Ve(r).toggleLayer3D(s.layer.id), ["stop"]))
          }, "", 34),
          f("div", {
            class: "layer-name-col",
            onDblclick: _t(E, ["stop"])
          }, [
            f("span", j8, xe(C(s.layer.type)), 1),
            u.value ? st((te(), ae("input", {
              key: 1,
              "onUpdate:modelValue": ce[1] || (ce[1] = (V) => d.value = V),
              onBlur: P,
              onKeydown: rl(P, ["enter"]),
              class: "rename-input",
              ref_key: "renameInput",
              ref: h
            }, null, 544)), [
              [Ut, d.value]
            ]) : (te(), ae("span", Y8, xe(s.layer.name), 1))
          ], 32),
          f("div", q8, [
            f("select", {
              value: s.layer.blendMode,
              class: "mini-select",
              onChange: y,
              onMousedown: ce[2] || (ce[2] = _t(() => {
              }, ["stop"]))
            }, [...ce[5] || (ce[5] = [
              as('<optgroup label="Normal" data-v-fb7680b0><option value="normal" data-v-fb7680b0>Normal</option><option value="dissolve" data-v-fb7680b0>Dissolve</option></optgroup><optgroup label="Darken" data-v-fb7680b0><option value="darken" data-v-fb7680b0>Darken</option><option value="multiply" data-v-fb7680b0>Multiply</option><option value="colorBurn" data-v-fb7680b0>Color Burn</option><option value="linearBurn" data-v-fb7680b0>Linear Burn</option></optgroup><optgroup label="Lighten" data-v-fb7680b0><option value="add" data-v-fb7680b0>Add</option><option value="lighten" data-v-fb7680b0>Lighten</option><option value="screen" data-v-fb7680b0>Screen</option><option value="colorDodge" data-v-fb7680b0>Color Dodge</option><option value="linearDodge" data-v-fb7680b0>Linear Dodge</option></optgroup><optgroup label="Contrast" data-v-fb7680b0><option value="overlay" data-v-fb7680b0>Overlay</option><option value="softLight" data-v-fb7680b0>Soft Light</option><option value="hardLight" data-v-fb7680b0>Hard Light</option><option value="vividLight" data-v-fb7680b0>Vivid Light</option><option value="linearLight" data-v-fb7680b0>Linear Light</option><option value="pinLight" data-v-fb7680b0>Pin Light</option><option value="hardMix" data-v-fb7680b0>Hard Mix</option></optgroup><optgroup label="Inversion" data-v-fb7680b0><option value="difference" data-v-fb7680b0>Difference</option><option value="exclusion" data-v-fb7680b0>Exclusion</option><option value="subtract" data-v-fb7680b0>Subtract</option><option value="divide" data-v-fb7680b0>Divide</option></optgroup><optgroup label="Component" data-v-fb7680b0><option value="hue" data-v-fb7680b0>Hue</option><option value="saturation" data-v-fb7680b0>Saturation</option><option value="color" data-v-fb7680b0>Color</option><option value="luminosity" data-v-fb7680b0>Luminosity</option></optgroup>', 6)
            ])], 40, Z8)
          ]),
          f("div", K8, [
            f("select", {
              value: s.layer.parentId || "",
              class: "mini-select",
              onChange: T,
              onMousedown: ce[3] || (ce[3] = _t(() => {
              }, ["stop"]))
            }, [
              ce[6] || (ce[6] = f("option", { value: "" }, "None", -1)),
              (te(!0), ae(qe, null, ot(x.value, (V) => (te(), ae("option", {
                key: V.id,
                value: V.id
              }, xe(V.index), 9, Q8))), 128))
            ], 40, J8)
          ])
        ], 38),
        a.value ? (te(), ae("div", eB, [
          (te(!0), ae(qe, null, ot(g.value, (V, Y) => (te(), ae("div", {
            key: Y,
            class: "property-group"
          }, [
            f("div", {
              class: "group-header sidebar-row",
              style: yt(s.gridStyle),
              onMousedown: _t((H) => b(Y), ["stop"])
            }, [
              f("div", nB, [
                f("span", iB, xe(c.value.includes(Y) ? "" : ""), 1)
              ]),
              f("div", sB, [
                ct(xe(Y) + " ", 1),
                Y === "Transform" ? (te(), ae("span", {
                  key: 0,
                  class: "reset-link",
                  onClick: _t(O, ["stop"])
                }, "Reset")) : Pe("", !0)
              ])
            ], 44, tB),
            c.value.includes(Y) ? (te(), ae("div", rB, [
              (te(!0), ae(qe, null, ot(V, (H) => (te(), St(tg, {
                key: H.path,
                layerId: s.layer.id,
                propertyPath: H.path,
                name: H.name,
                property: H.property,
                layoutMode: "sidebar",
                gridStyle: s.gridStyle,
                pixelsPerFrame: s.pixelsPerFrame
              }, null, 8, ["layerId", "propertyPath", "name", "property", "gridStyle", "pixelsPerFrame"]))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : Pe("", !0)
      ], 64)) : (te(), ae(qe, { key: 1 }, [
        f("div", {
          class: "layer-row track-bg",
          onMousedown: M
        }, [
          f("div", {
            class: "duration-bar",
            style: yt(_.value),
            onMousedown: _t(w, ["stop"])
          }, [
            f("div", {
              class: "bar-fill",
              style: yt({ background: s.layer.labelColor || "#777" })
            }, null, 4)
          ], 36)
        ], 32),
        a.value ? (te(), ae("div", oB, [
          (te(!0), ae(qe, null, ot(g.value, (V, Y) => (te(), ae("div", {
            key: Y,
            class: "property-group"
          }, [
            ce[7] || (ce[7] = f("div", { class: "group-header track-bg" }, null, -1)),
            c.value.includes(Y) ? (te(), ae("div", aB, [
              (te(!0), ae(qe, null, ot(V, (H) => (te(), St(tg, {
                key: H.path,
                layerId: s.layer.id,
                propertyPath: H.path,
                name: H.name,
                property: H.property,
                layoutMode: "track",
                pixelsPerFrame: s.pixelsPerFrame
              }, null, 8, ["layerId", "propertyPath", "name", "property", "pixelsPerFrame"]))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : Pe("", !0)
      ], 64)),
      (te(), St(Uo, { to: "body" }, [
        m.value ? (te(), ae("div", {
          key: 0,
          class: "layer-context-menu",
          style: yt({ left: p.value + "px", top: v.value + "px" }),
          onClick: ce[4] || (ce[4] = _t(() => {
          }, ["stop"]))
        }, [
          f("button", { onClick: ue }, "Duplicate Layer"),
          f("button", { onClick: Q }, "Rename"),
          ce[8] || (ce[8] = f("hr", null, null, -1)),
          f("button", { onClick: le }, xe(s.layer.visible ? "Hide" : "Show") + " Layer", 1),
          f("button", { onClick: re }, xe(s.layer.locked ? "Unlock" : "Lock") + " Layer", 1),
          f("button", { onClick: j }, xe(s.layer.threeD ? "Make 2D" : "Make 3D"), 1),
          ce[9] || (ce[9] = f("hr", null, null, -1)),
          f("button", { onClick: $ }, "Pre-compose..."),
          ce[10] || (ce[10] = f("hr", null, null, -1)),
          f("button", {
            onClick: q,
            class: "danger"
          }, "Delete Layer")
        ], 4)) : Pe("", !0)
      ]))
    ])) : Pe("", !0);
  }
}), ng = /* @__PURE__ */ Gt(lB, [["__scopeId", "data-v-fb7680b0"]]), cB = { class: "composition-tabs" }, uB = { class: "tabs-container" }, dB = ["onClick", "onDblclick", "onContextmenu"], hB = {
  key: 0,
  class: "precomp-icon",
  title: "Pre-composition"
}, fB = {
  key: 1,
  class: "tab-name"
}, pB = {
  key: 2,
  class: "tab-name"
}, mB = { class: "tab-info" }, vB = ["onClick"], gB = ["disabled"], yB = ["disabled"], _B = /* @__PURE__ */ Ot({
  __name: "CompositionTabs",
  emits: ["newComposition"],
  setup(s, { emit: e }) {
    const n = e, i = sn(), r = we(null), o = we(""), a = we(null), l = we({
      visible: !1,
      x: 0,
      y: 0,
      comp: null
    }), c = Ie(() => i.openCompositions), u = Ie(() => i.activeCompositionId), d = Ie(() => i.project.mainCompositionId);
    function h(y) {
      i.switchComposition(y);
    }
    function m(y) {
      i.closeCompositionTab(y);
    }
    function p(y) {
      const w = y.settings;
      return `${w.width}x${w.height} ${w.fps}fps`;
    }
    function v(y) {
      r.value = y.id, o.value = y.name, Pi(() => {
        var w, D;
        (w = a.value) == null || w.focus(), (D = a.value) == null || D.select();
      });
    }
    function x() {
      r.value && o.value.trim() && i.renameComposition(r.value, o.value.trim()), r.value = null, o.value = "";
    }
    function g() {
      r.value = null, o.value = "";
    }
    function _(y, w) {
      l.value = {
        visible: !0,
        x: y.clientX,
        y: y.clientY,
        comp: w
      };
    }
    function M() {
      l.value.visible = !1, l.value.comp = null;
    }
    function S() {
      l.value.comp && v(l.value.comp), M();
    }
    function b() {
      if (l.value.comp) {
        const y = l.value.comp, w = i.createComposition(
          `${y.name} Copy`,
          y.settings,
          y.isPrecomp
        );
        console.log("[CompositionTabs] Duplicated:", w.name);
      }
      M();
    }
    function C() {
      l.value.comp && i.switchComposition(l.value.comp.id), M();
    }
    function E() {
      l.value.comp && (i.project.mainCompositionId = l.value.comp.id, console.log("[CompositionTabs] Set main composition:", l.value.comp.name)), M();
    }
    function P() {
      l.value.comp && l.value.comp.id !== d.value && i.deleteComposition(l.value.comp.id), M();
    }
    function T() {
      l.value.visible && M();
    }
    return _n(() => {
      document.addEventListener("click", T);
    }), Nn(() => {
      document.removeEventListener("click", T);
    }), (y, w) => {
      var D, U;
      return te(), ae("div", cB, [
        f("div", uB, [
          (te(!0), ae(qe, null, ot(c.value, (R) => (te(), ae("div", {
            key: R.id,
            class: Fe(["tab", {
              active: R.id === u.value,
              precomp: R.isPrecomp
            }]),
            onClick: (O) => h(R.id),
            onDblclick: (O) => v(R),
            onContextmenu: _t((O) => _(O, R), ["prevent"])
          }, [
            R.isPrecomp ? (te(), ae("span", hB, "")) : Pe("", !0),
            r.value === R.id ? (te(), ae("span", fB, [
              st(f("input", {
                ref_for: !0,
                ref_key: "renameInput",
                ref: a,
                "onUpdate:modelValue": w[0] || (w[0] = (O) => o.value = O),
                type: "text",
                class: "rename-input",
                onBlur: x,
                onKeydown: [
                  rl(x, ["enter"]),
                  rl(g, ["escape"])
                ],
                onClick: w[1] || (w[1] = _t(() => {
                }, ["stop"]))
              }, null, 544), [
                [Ut, o.value]
              ])
            ])) : (te(), ae("span", pB, xe(R.name), 1)),
            f("span", mB, xe(p(R)), 1),
            c.value.length > 1 ? (te(), ae("button", {
              key: 3,
              class: "close-btn",
              onClick: _t((O) => m(R.id), ["stop"]),
              title: "Close tab"
            }, "  ", 8, vB)) : Pe("", !0)
          ], 42, dB))), 128)),
          f("button", {
            class: "new-comp-btn",
            onClick: w[2] || (w[2] = (R) => n("newComposition")),
            title: "New Composition (Ctrl+K)"
          }, " + ")
        ]),
        (te(), St(Uo, { to: "body" }, [
          l.value.visible ? (te(), ae("div", {
            key: 0,
            class: "context-menu",
            style: yt({ left: l.value.x + "px", top: l.value.y + "px" }),
            onClick: w[3] || (w[3] = _t(() => {
            }, ["stop"]))
          }, [
            f("button", { onClick: S }, "Rename"),
            f("button", { onClick: b }, "Duplicate"),
            f("button", { onClick: C }, "Open in New Tab"),
            w[4] || (w[4] = f("hr", null, null, -1)),
            f("button", {
              onClick: E,
              disabled: ((D = l.value.comp) == null ? void 0 : D.id) === d.value
            }, " Set as Main Composition ", 8, gB),
            w[5] || (w[5] = f("hr", null, null, -1)),
            f("button", {
              onClick: P,
              disabled: ((U = l.value.comp) == null ? void 0 : U.id) === d.value,
              class: "danger"
            }, " Delete Composition ", 8, yB)
          ], 4)) : Pe("", !0)
        ]))
      ]);
    };
  }
}), xB = /* @__PURE__ */ Gt(_B, [["__scopeId", "data-v-c032dfe4"]]), bB = { class: "timeline-header" }, wB = { class: "header-left" }, SB = { class: "timecode" }, MB = { class: "frame-display" }, CB = ["value"], EB = { class: "fps-label" }, TB = { class: "header-center" }, AB = {
  key: 0,
  class: "add-layer-menu"
}, PB = { class: "tool-group" }, RB = ["disabled"], DB = { class: "header-right" }, kB = { class: "timeline-content" }, IB = /* @__PURE__ */ Ot({
  __name: "TimelinePanel",
  emits: ["openCompositionSettings"],
  setup(s, { emit: e }) {
    const n = e, i = sn(), r = we(10), o = we(450), a = we({}), l = we(!1), c = we(null), u = we(null), d = we(null), h = we(null), m = we(null), p = we(null);
    let v = !1, x = !1;
    const g = we(1e3), _ = Ie(() => i.layers || []), M = Ie(() => i.currentFrame * r.value), S = Ie(() => {
      const $ = i.frameCount * r.value;
      return Math.max($, g.value) + "px";
    }), b = Ie(() => ({
      display: "grid",
      gridTemplateColumns: "24px 24px 30px 24px 24px 24px 1fr 70px 70px",
      alignItems: "center",
      height: "32px",
      width: "100%",
      boxSizing: "border-box"
    }));
    function C() {
      l.value = !l.value;
    }
    function E($) {
      $ === "text" ? i.createTextLayer() : $ === "video" ? i.createLayer("video") : $ === "camera" ? i.createCameraLayer() : i.createLayer($), l.value = !1;
    }
    function P($) {
      i.selectLayer($);
    }
    function T($, q) {
      i.updateLayer($, q);
    }
    function y() {
      i.selectedLayerIds.forEach(($) => i.deleteLayer($));
    }
    function w($) {
      i.setFrame(parseInt($.target.value) || 0);
    }
    function D() {
      i.togglePlayback();
    }
    function U($, q) {
      a.value[$] = q;
    }
    function R($) {
      const q = i.fps, oe = Math.floor($ / q), ie = Math.floor($ % q), ce = oe % 60, V = Math.floor(oe / 60) % 60, Y = Math.floor(oe / 3600), H = (I, F = 2) => String(I).padStart(F, "0");
      return `${H(Y)};${H(V)};${H(ce)};${H(ie)}`;
    }
    function O() {
      const $ = d.value;
      if (!$) return;
      const q = $.getContext("2d");
      if (!q) return;
      const oe = i.frameCount * r.value, ie = Math.max(oe, g.value);
      $.width = ie, $.height = 30, q.fillStyle = "#222", q.fillRect(0, 0, $.width, $.height), q.strokeStyle = "#666", q.fillStyle = "#aaa", q.font = "11px sans-serif";
      const ce = r.value;
      let V, Y;
      ce >= 20 ? (V = 1, Y = 0) : ce >= 10 ? (V = 5, Y = 1) : ce >= 5 ? (V = 10, Y = 5) : ce >= 2 ? (V = 20, Y = 10) : ce >= 1 ? (V = 50, Y = 25) : ce >= 0.5 ? (V = 100, Y = 50) : (V = 200, Y = 0);
      for (let H = 0; H <= i.frameCount; H++) {
        const I = H * ce;
        if (H % V === 0) {
          q.strokeStyle = "#888", q.beginPath(), q.moveTo(I, 12), q.lineTo(I, 30), q.stroke();
          const F = String(H), L = q.measureText(F), ee = (H + V) * ce, Z = L.width + 20;
          (ee - I >= Z || H === 0 || H >= i.frameCount - V) && (q.fillStyle = "#ccc", q.fillText(F, I + 3, 10));
        } else Y > 0 && H % Y === 0 && (q.strokeStyle = "#555", q.beginPath(), q.moveTo(I, 22), q.lineTo(I, 30), q.stroke());
      }
      q.strokeStyle = "#444", q.beginPath(), q.moveTo(0, 29.5), q.lineTo($.width, 29.5), q.stroke();
    }
    function A($) {
      var ie, ce;
      const q = d.value.getBoundingClientRect();
      (ie = p.value) != null && ie.scrollLeft || (ce = m.value) != null && ce.scrollLeft;
      const oe = (V) => {
        var F, L;
        const Y = ((F = p.value) == null ? void 0 : F.scrollLeft) || ((L = m.value) == null ? void 0 : L.scrollLeft) || 0, H = V.clientX - q.left + Y;
        let I = Math.max(0, Math.min(i.frameCount - 1, H / r.value));
        if (!V.altKey && i.snapConfig.enabled) {
          const ee = qf(Math.round(I), i.snapConfig, r.value, {
            layers: i.layers,
            audioAnalysis: i.audioAnalysis,
            peakData: i.peakData
          });
          ee && (I = ee.frame);
        }
        i.setFrame(Math.round(I));
      };
      oe($), window.addEventListener("mousemove", oe), window.addEventListener("mouseup", () => window.removeEventListener("mousemove", oe), { once: !0 });
    }
    function G($) {
      const q = $.clientX, oe = o.value, ie = (ce) => {
        o.value = Math.max(300, oe + (ce.clientX - q));
      };
      window.addEventListener("mousemove", ie), window.addEventListener("mouseup", () => window.removeEventListener("mousemove", ie), { once: !0 });
    }
    function ue($) {
      if (x) return;
      v = !0;
      const q = $.target;
      m.value && (m.value.scrollTop = q.scrollTop), requestAnimationFrame(() => {
        v = !1;
      });
    }
    function Q($) {
      const q = $.target;
      v || (x = !0, h.value && (h.value.scrollTop = q.scrollTop), requestAnimationFrame(() => {
        x = !1;
      })), p.value && (p.value.scrollLeft = q.scrollLeft);
    }
    function le($) {
      const q = $.target;
      m.value && (m.value.scrollLeft = q.scrollLeft);
    }
    function re($) {
      if (!($.target instanceof HTMLInputElement || $.target instanceof HTMLTextAreaElement) && ($.code === "Space" && ($.preventDefault(), D()), ($.code === "Delete" || $.code === "Backspace") && ($.preventDefault(), y()), ($.ctrlKey || $.metaKey) && $.code === "KeyC" && ($.preventDefault(), i.copySelectedLayers()), ($.ctrlKey || $.metaKey) && $.code === "KeyX" && ($.preventDefault(), i.cutSelectedLayers()), ($.ctrlKey || $.metaKey) && $.code === "KeyV" && ($.preventDefault(), i.pasteLayers()), ($.ctrlKey || $.metaKey) && $.code === "KeyA" && ($.preventDefault(), i.selectedLayerIds = i.layers.map((q) => q.id)), ($.ctrlKey || $.metaKey) && $.code === "KeyD")) {
        $.preventDefault();
        for (const q of i.selectedLayerIds)
          i.duplicateLayer(q);
      }
    }
    let j = null;
    return _n(() => {
      window.addEventListener("mousedown", (q) => {
        c.value && !c.value.contains(q.target) && (l.value = !1);
      });
      const $ = m.value || u.value;
      $ && (j = new ResizeObserver((q) => {
        for (const oe of q)
          g.value = oe.contentRect.width, O();
      }), j.observe($)), setTimeout(O, 100);
    }), Nn(() => {
      j && j.disconnect();
    }), Ft(() => [S.value, r.value, i.frameCount], () => Pi(O)), ($, q) => (te(), ae("div", {
      class: "timeline-panel",
      tabindex: "0",
      onKeydown: re
    }, [
      ze(xB, {
        onNewComposition: q[0] || (q[0] = (oe) => n("openCompositionSettings"))
      }),
      f("div", bB, [
        f("div", wB, [
          f("span", SB, xe(R(Ve(i).currentFrame)), 1),
          f("div", MB, [
            f("input", {
              type: "number",
              value: Ve(i).currentFrame,
              onChange: w,
              class: "frame-input"
            }, null, 40, CB),
            f("span", EB, xe(Ve(i).fps) + " fps", 1)
          ])
        ]),
        f("div", TB, [
          f("div", {
            class: "tool-group add-layer-wrapper",
            ref_key: "addLayerContainer",
            ref: c
          }, [
            f("button", {
              class: Fe(["add-layer-btn", { active: l.value }]),
              onMousedown: _t(C, ["stop", "prevent"])
            }, [...q[9] || (q[9] = [
              f("span", { class: "icon" }, "+", -1),
              ct(" Layer ", -1)
            ])], 34),
            l.value ? (te(), ae("div", AB, [
              f("button", {
                onMousedown: q[1] || (q[1] = (oe) => E("solid"))
              }, [...q[10] || (q[10] = [
                f("span", { class: "icon" }, "", -1),
                ct(" Solid", -1)
              ])], 32),
              f("button", {
                onMousedown: q[2] || (q[2] = (oe) => E("text"))
              }, [...q[11] || (q[11] = [
                f("span", { class: "icon" }, "T", -1),
                ct(" Text", -1)
              ])], 32),
              f("button", {
                onMousedown: q[3] || (q[3] = (oe) => E("spline"))
              }, [...q[12] || (q[12] = [
                f("span", { class: "icon" }, "~", -1),
                ct(" Shape", -1)
              ])], 32),
              f("button", {
                onMousedown: q[4] || (q[4] = (oe) => E("null"))
              }, [...q[13] || (q[13] = [
                f("span", { class: "icon" }, "", -1),
                ct(" Null", -1)
              ])], 32),
              f("button", {
                onMousedown: q[5] || (q[5] = (oe) => E("camera"))
              }, [...q[14] || (q[14] = [
                f("span", { class: "icon" }, "", -1),
                ct(" Camera", -1)
              ])], 32),
              f("button", {
                onMousedown: q[6] || (q[6] = (oe) => E("light"))
              }, [...q[15] || (q[15] = [
                f("span", { class: "icon" }, "", -1),
                ct(" Light", -1)
              ])], 32),
              f("button", {
                onMousedown: q[7] || (q[7] = (oe) => E("video"))
              }, [...q[16] || (q[16] = [
                f("span", { class: "icon" }, "", -1),
                ct(" Video", -1)
              ])], 32)
            ])) : Pe("", !0)
          ], 512),
          f("div", PB, [
            f("button", {
              class: "delete-btn",
              onClick: y,
              disabled: Ve(i).selectedLayerIds.length === 0
            }, "", 8, RB)
          ])
        ]),
        f("div", DB, [
          st(f("input", {
            type: "range",
            min: "0.1",
            max: "50",
            step: "0.1",
            "onUpdate:modelValue": q[8] || (q[8] = (oe) => r.value = oe),
            class: "zoom-slider",
            title: "Zoom Timeline"
          }, null, 512), [
            [
              Ut,
              r.value,
              void 0,
              { number: !0 }
            ]
          ])
        ])
      ]),
      f("div", kB, [
        f("div", {
          class: "timeline-sidebar",
          style: yt({ width: o.value + "px" })
        }, [
          q[17] || (q[17] = as('<div class="sidebar-header-row" data-v-0c0bcb17><div class="col-header col-arrow" data-v-0c0bcb17></div><div class="col-header col-name" data-v-0c0bcb17>Layer Name</div><div class="col-header col-mode" data-v-0c0bcb17>Mode</div><div class="col-header col-parent" data-v-0c0bcb17>Parent</div></div>', 1)),
          f("div", {
            class: "sidebar-scroll-area",
            ref_key: "sidebarScrollRef",
            ref: h,
            onScroll: ue
          }, [
            (te(!0), ae(qe, null, ot(_.value, (oe, ie) => (te(), St(ng, {
              key: oe.id,
              layer: oe,
              index: ie + 1,
              layoutMode: "sidebar",
              isExpandedExternal: a.value[oe.id],
              allLayers: Ve(i).layers,
              gridStyle: b.value,
              onToggleExpand: U,
              onSelect: P,
              onUpdateLayer: T
            }, null, 8, ["layer", "index", "isExpandedExternal", "allLayers", "gridStyle"]))), 128))
          ], 544)
        ], 4),
        f("div", {
          class: "sidebar-resizer",
          onMousedown: G
        }, null, 32),
        f("div", {
          class: "track-viewport",
          ref_key: "trackViewportRef",
          ref: u
        }, [
          f("div", {
            class: "ruler-scroll-wrapper",
            onScroll: le,
            ref_key: "rulerScrollRef",
            ref: p
          }, [
            f("div", {
              class: "time-ruler",
              style: yt({ width: S.value }),
              onMousedown: A
            }, [
              f("canvas", {
                ref_key: "rulerCanvas",
                ref: d,
                height: "30"
              }, null, 512),
              f("div", {
                class: "playhead-head",
                style: yt({ left: M.value + "px" })
              }, null, 4),
              f("div", {
                class: "playhead-hit-area",
                style: yt({ left: M.value + "px" }),
                onMousedown: _t(A, ["stop"])
              }, null, 36)
            ], 36)
          ], 544),
          f("div", {
            class: "track-scroll-area",
            ref_key: "trackScrollRef",
            ref: m,
            onScroll: Q
          }, [
            f("div", {
              class: "layer-bars-container",
              style: yt({ width: S.value })
            }, [
              q[18] || (q[18] = f("div", { class: "grid-background" }, null, -1)),
              (te(!0), ae(qe, null, ot(_.value, (oe) => (te(), St(ng, {
                key: oe.id,
                layer: oe,
                layoutMode: "track",
                frameCount: Ve(i).frameCount,
                pixelsPerFrame: r.value,
                isExpandedExternal: a.value[oe.id],
                onSelect: P,
                onUpdateLayer: T
              }, null, 8, ["layer", "frameCount", "pixelsPerFrame", "isExpandedExternal"]))), 128)),
              f("div", {
                class: "playhead-line",
                style: yt({ left: M.value + "px" })
              }, null, 4)
            ], 4)
          ], 544)
        ], 512)
      ])
    ], 32));
  }
}), ig = /* @__PURE__ */ Gt(IB, [["__scopeId", "data-v-0c0bcb17"]]), LB = { class: "graph-editor" }, FB = { class: "graph-header" }, UB = { class: "mode-toggle" }, OB = { class: "preset-buttons" }, zB = ["onClick", "title"], NB = { class: "toolbar" }, BB = { class: "graph-content" }, VB = { class: "property-list" }, GB = { class: "property-list-header" }, HB = ["title"], $B = ["onClick"], WB = ["onClick"], XB = { class: "property-name" }, jB = {
  key: 0,
  class: "keyframe-count"
}, YB = {
  key: 0,
  class: "dimension-toggles"
}, qB = ["onClick"], ZB = {
  key: 0,
  class: "no-properties"
}, KB = { class: "graph-main" }, JB = ["viewBox"], QB = ["onMousedown"], eV = ["x", "y", "fill", "transform"], tV = {
  key: 1,
  class: "bezier-handles"
}, nV = {
  key: 0,
  class: "handle out-handle"
}, iV = ["x1", "y1", "x2", "y2"], sV = ["cx", "cy", "onMousedown"], rV = {
  key: 1,
  class: "handle in-handle"
}, oV = ["x1", "y1", "x2", "y2"], aV = ["cx", "cy", "onMousedown"], lV = ["x1", "x2", "y2"], cV = {
  key: 0,
  class: "keyframe-info-panel"
}, uV = { class: "info-row" }, dV = ["value"], hV = { class: "info-row" }, fV = ["value"], pV = { class: "info-row" }, mV = ["value"], vV = ["disabled"], gV = ["disabled"], yV = ["disabled"], _V = /* @__PURE__ */ Ot({
  __name: "GraphEditor",
  emits: ["close"],
  setup(s, { emit: e }) {
    const n = e, i = sn(), r = we(null), o = we(null), a = we(null), l = we(null), c = we(null), u = we(null), d = we(400), h = we(200), m = we("value"), p = Gr({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    }), v = we([]), x = we([]), g = we({}), _ = we([]), M = we(null), S = we(null), b = we(null), C = we(null), E = we(null), P = we(!1), T = we(!0), y = { top: 10, right: 10, bottom: 10, left: 10 }, w = {
      Position: "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      Scale: "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      Rotation: "#bb8fce",
      Opacity: "#f8b739",
      default: "#7c9cff"
    }, D = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ], U = Ie(() => {
      const pe = i.selectedLayer;
      if (!pe) return [];
      const _e = [];
      return _e.push(pe.transform.position), _e.push(pe.transform.scale), _e.push(pe.transform.rotation), _e.push(pe.opacity), _e.push(...pe.properties), _e;
    }), R = Ie(() => U.value.filter(
      (pe) => x.value.includes(pe.id) && pe.animated
    )), O = Ie(() => U.value.every((pe) => x.value.includes(pe.id))), A = Ie(() => G(i.currentFrame));
    function G(pe) {
      const _e = d.value - y.left - y.right, Ee = (pe - p.frameStart) / (p.frameEnd - p.frameStart);
      return y.left + Ee * _e;
    }
    function ue(pe) {
      const _e = d.value - y.left - y.right, Ee = (pe - y.left) / _e;
      return p.frameStart + Ee * (p.frameEnd - p.frameStart);
    }
    function Q(pe) {
      const _e = h.value - y.top - y.bottom, Ee = (pe - p.valueMin) / (p.valueMax - p.valueMin);
      return h.value - y.bottom - Ee * _e;
    }
    function le(pe) {
      const _e = h.value - y.top - y.bottom, Ee = (h.value - y.bottom - pe) / _e;
      return p.valueMin + Ee * (p.valueMax - p.valueMin);
    }
    function re(pe) {
      return G(pe.frame);
    }
    function j(pe, _e) {
      const Ee = typeof _e.value == "number" ? _e.value : typeof _e.value == "object" ? _e.value.x ?? _e.value : 0;
      return Q(Ee);
    }
    function $(pe) {
      if (!pe) return 0;
      const _e = pe.keyframe.value;
      return typeof _e == "number" ? _e : typeof _e == "object" ? _e.x ?? 0 : 0;
    }
    function q(pe, _e) {
      const Ee = pe.keyframes[_e];
      if (!Ee || !Ee.outHandle.enabled) return G(Ee.frame);
      const Ue = Ee.frame + Ee.outHandle.frame;
      return G(Ue);
    }
    function oe(pe, _e) {
      const Ee = pe.keyframes[_e];
      if (!Ee || !Ee.outHandle.enabled) return Q(V(Ee.value));
      const Ue = V(Ee.value) + Ee.outHandle.value;
      return Q(Ue);
    }
    function ie(pe, _e) {
      const Ee = pe.keyframes[_e];
      if (!Ee || !Ee.inHandle.enabled) return G(Ee.frame);
      const Ue = Ee.frame + Ee.inHandle.frame;
      return G(Ue);
    }
    function ce(pe, _e) {
      const Ee = pe.keyframes[_e];
      if (!Ee || !Ee.inHandle.enabled) return Q(V(Ee.value));
      const Ue = V(Ee.value) + Ee.inHandle.value;
      return Q(Ue);
    }
    function V(pe) {
      return typeof pe == "number" ? pe : typeof pe == "object" ? pe.x ?? pe.y ?? pe.z ?? 0 : 0;
    }
    function Y(pe) {
      const _e = U.value.find((Ee) => Ee.id === pe);
      return _e ? w[_e.name] ?? w.default : w.default;
    }
    function H(pe) {
      return pe.frame >= p.frameStart && pe.frame <= p.frameEnd;
    }
    function I(pe, _e) {
      return _.value.some((Ee) => Ee.propId === pe && Ee.index === _e);
    }
    function F(pe, _e) {
      if (!pe.animated || pe.keyframes.length === 0) return !1;
      const Ee = pe.keyframes[0].value;
      return typeof Ee == "object" && _e in Ee;
    }
    function L(pe) {
      const _e = v.value.indexOf(pe);
      _e === -1 ? v.value.push(pe) : v.value.splice(_e, 1);
    }
    function ee(pe) {
      const _e = x.value.indexOf(pe);
      _e === -1 ? x.value.push(pe) : x.value.splice(_e, 1), J();
    }
    function Z() {
      O.value ? x.value = [] : x.value = U.value.map((pe) => pe.id), J();
    }
    function k(pe, _e) {
      g.value[pe] || (g.value[pe] = []);
      const Ee = g.value[pe], Ue = Ee.indexOf(_e);
      Ue === -1 ? Ee.push(_e) : Ee.splice(Ue, 1);
    }
    function ne() {
      const pe = R.value;
      if (pe.length === 0) return;
      let _e = 1 / 0, Ee = -1 / 0, Ue = 1 / 0, W = -1 / 0;
      for (const Ce of pe)
        for (const be of Ce.keyframes) {
          _e = Math.min(_e, be.frame), Ee = Math.max(Ee, be.frame);
          const ke = V(be.value);
          Ue = Math.min(Ue, ke), W = Math.max(W, ke);
        }
      const ve = (Ee - _e) * 0.1 || 10, ye = (W - Ue) * 0.1 || 10;
      p.frameStart = _e - ve, p.frameEnd = Ee + ve, p.valueMin = Ue - ye, p.valueMax = W + ye;
    }
    function J() {
      ne();
    }
    function B() {
      T.value = !T.value;
    }
    function X(pe) {
      return _.value.length === 0 || !ru[pe] ? !1 : pe === "linear" ? _.value.every((Ee) => Ee.keyframe.interpolation === "linear") : _.value.every((Ee) => Ee.keyframe.interpolation === "bezier");
    }
    function se(pe) {
      const _e = ru[pe];
      if (!_e) return;
      const Ee = i.selectedLayer;
      if (Ee) {
        for (const Ue of _.value) {
          const W = U.value.find((Qe) => Qe.id === Ue.propId);
          if (!W) continue;
          const ve = Ae(W), ye = Ue.index, Ce = ye > 0 ? W.keyframes[ye - 1] : null, be = ye < W.keyframes.length - 1 ? W.keyframes[ye + 1] : null, ke = Ce ? Ue.keyframe.frame - Ce.frame : 10, De = be ? be.frame - Ue.keyframe.frame : 10;
          if (pe === "linear")
            i.setKeyframeInterpolation(Ee.id, ve, Ue.keyframe.id, "linear"), Ue.keyframe.interpolation = "linear", Ue.keyframe.outHandle = { frame: De * 0.33, value: 0, enabled: !1 }, Ue.keyframe.inHandle = { frame: -ke * 0.33, value: 0, enabled: !1 };
          else {
            const Qe = {
              frame: _e.outHandle.x * De,
              value: 0,
              // Would need value delta for proper curve
              enabled: !0
            }, it = {
              frame: -_e.inHandle.x * ke,
              value: 0,
              // Would need value delta for proper curve
              enabled: !0
            };
            i.setKeyframeInterpolation(Ee.id, ve, Ue.keyframe.id, "bezier"), i.setKeyframeHandle(Ee.id, ve, Ue.keyframe.id, "out", Qe), i.setKeyframeHandle(Ee.id, ve, Ue.keyframe.id, "in", it), Ue.keyframe.interpolation = "bezier", Ue.keyframe.outHandle = Qe, Ue.keyframe.inHandle = it;
          }
        }
        at();
      }
    }
    function z(pe) {
      var W;
      const _e = (W = r.value) == null ? void 0 : W.getBoundingClientRect();
      if (!_e) return;
      const Ee = pe.clientX - _e.left, Ue = pe.clientY - _e.top;
      pe.button === 1 || pe.button === 0 && pe.altKey ? S.value = { type: "pan", startX: Ee, startY: Ue } : pe.button === 0 && (pe.shiftKey || (_.value = []), b.value = { x: Ee, y: Ue, width: 0, height: 0 }, S.value = { type: "select", startX: Ee, startY: Ue });
    }
    function N(pe) {
      var W;
      const _e = (W = r.value) == null ? void 0 : W.getBoundingClientRect();
      if (!_e) return;
      const Ee = pe.clientX - _e.left, Ue = pe.clientY - _e.top;
      if (me(Ee, Ue), !!S.value)
        if (S.value.type === "pan") {
          const ve = Ee - (S.value.startX ?? 0), ye = Ue - (S.value.startY ?? 0), Ce = d.value - y.left - y.right, be = h.value - y.top - y.bottom, ke = -ve / Ce * (p.frameEnd - p.frameStart), De = ye / be * (p.valueMax - p.valueMin);
          p.frameStart += ke, p.frameEnd += ke, p.valueMin += De, p.valueMax += De, S.value.startX = Ee, S.value.startY = Ue, at();
        } else if (S.value.type === "select" && b.value) {
          const ve = S.value.startX ?? 0, ye = S.value.startY ?? 0;
          b.value = {
            x: Math.min(Ee, ve),
            y: Math.min(Ue, ye),
            width: Math.abs(Ee - ve),
            height: Math.abs(Ue - ye)
          };
        } else S.value.type === "keyframe" ? Te(Ee, Ue) : (S.value.type === "outHandle" || S.value.type === "inHandle") && He(Ee, Ue);
    }
    function K() {
      var pe;
      ((pe = S.value) == null ? void 0 : pe.type) === "select" && b.value && Me(), S.value = null, b.value = null;
    }
    function he(pe) {
      var Ce;
      pe.preventDefault();
      const _e = (Ce = r.value) == null ? void 0 : Ce.getBoundingClientRect();
      if (!_e) return;
      const Ee = pe.clientX - _e.left, Ue = pe.deltaY > 0 ? 1.1 : 0.9, W = ue(Ee), ve = W - (W - p.frameStart) * Ue, ye = W + (p.frameEnd - W) * Ue;
      if (pe.shiftKey)
        p.frameStart = ve, p.frameEnd = ye;
      else {
        p.frameStart = ve, p.frameEnd = ye;
        const be = pe.clientY - _e.top, ke = le(be);
        p.valueMin = ke - (ke - p.valueMin) * Ue, p.valueMax = ke + (p.valueMax - ke) * Ue;
      }
      at();
    }
    function me(pe, _e) {
      M.value = null;
      for (const Ee of R.value)
        for (let Ue = 0; Ue < Ee.keyframes.length; Ue++) {
          const W = Ee.keyframes[Ue], ve = re(W), ye = j(Ee, W);
          if (Math.sqrt((pe - ve) ** 2 + (_e - ye) ** 2) < 10) {
            M.value = { propId: Ee.id, index: Ue };
            return;
          }
        }
    }
    function ge(pe, _e, Ee) {
      const Ue = U.value.find((ve) => ve.id === pe);
      if (!Ue) return;
      const W = Ue.keyframes[_e];
      Ee.shiftKey || (_.value = []), I(pe, _e) || _.value.push({ propId: pe, index: _e, keyframe: W }), S.value = { type: "keyframe", propId: pe, index: _e };
    }
    function Me() {
      if (!b.value) return;
      const pe = b.value;
      for (const _e of R.value)
        for (let Ee = 0; Ee < _e.keyframes.length; Ee++) {
          const Ue = _e.keyframes[Ee], W = re(Ue), ve = j(_e, Ue);
          W >= pe.x && W <= pe.x + pe.width && ve >= pe.y && ve <= pe.y + pe.height && (I(_e.id, Ee) || _.value.push({ propId: _e.id, index: Ee, keyframe: Ue }));
        }
    }
    function Te(pe, _e) {
      const Ee = Math.round(ue(pe)), Ue = le(_e), W = i.selectedLayer;
      if (W) {
        if (_.value.length > 0) {
          const ve = _.value[0], ye = U.value.find((ke) => ke.id === ve.propId);
          if (!ye) return;
          const Ce = P.value ? Math.round(Ee / 5) * 5 : Ee;
          typeof ve.keyframe.value == "number" || ve.keyframe.value;
          const be = Ae(ye);
          i.updateKeyframe(W.id, be, ve.keyframe.id, {
            frame: Ce,
            value: typeof ve.keyframe.value == "number" ? Ue : void 0
          }), ve.keyframe.frame = Ce, typeof ve.keyframe.value == "number" && (ve.keyframe.value = Ue);
        }
        at();
      }
    }
    function Ae(pe) {
      const _e = pe.name.toLowerCase();
      return _e === "position" ? "transform.position" : _e === "scale" ? "transform.scale" : _e === "rotation" ? "transform.rotation" : _e === "opacity" ? "opacity" : _e === "anchor point" ? "transform.anchorPoint" : pe.id;
    }
    function Xe(pe, _e, Ee, Ue) {
      S.value = { type: pe, propId: _e, index: Ee }, document.addEventListener("mousemove", Oe), document.addEventListener("mouseup", $e);
    }
    function Oe(pe) {
      var W;
      const _e = (W = r.value) == null ? void 0 : W.getBoundingClientRect();
      if (!_e || !S.value) return;
      const Ee = pe.clientX - _e.left, Ue = pe.clientY - _e.top;
      He(Ee, Ue);
    }
    function He(pe, _e) {
      if (!S.value || !S.value.propId) return;
      const Ee = i.selectedLayer;
      if (!Ee) return;
      const Ue = U.value.find((ke) => ke.id === S.value.propId);
      if (!Ue) return;
      const W = S.value.index, ve = Ue.keyframes[W];
      if (!ve) return;
      const ye = ue(pe), Ce = le(_e), be = Ae(Ue);
      if (S.value.type === "outHandle") {
        const ke = Ue.keyframes[W + 1];
        let De = ye - ve.frame;
        ke ? De = Math.max(0, Math.min(ke.frame - ve.frame, De)) : De = Math.max(0, De);
        const Qe = Ce - V(ve.value), it = {
          frame: De,
          value: Qe,
          enabled: !0
        };
        i.setKeyframeHandle(Ee.id, be, ve.id, "out", it), ve.outHandle = it, ve.interpolation = "bezier", Ye(ve, "out", be);
      } else if (S.value.type === "inHandle") {
        const ke = Ue.keyframes[W - 1];
        let De = ye - ve.frame;
        ke ? De = Math.min(0, Math.max(ke.frame - ve.frame, De)) : De = Math.min(0, De);
        const Qe = Ce - V(ve.value), it = {
          frame: De,
          value: Qe,
          enabled: !0
        };
        i.setKeyframeHandle(Ee.id, be, ve.id, "in", it), ve.inHandle = it, Ye(ve, "in", be);
      }
      at();
    }
    function Ye(pe, _e, Ee) {
      if (!pe.controlMode || pe.controlMode === "corner")
        return;
      const Ue = i.selectedLayer;
      if (Ue && (pe.controlMode === "symmetric" && (_e === "in" ? (pe.outHandle.frame = -pe.inHandle.frame, pe.outHandle.value = -pe.inHandle.value, pe.outHandle.enabled = pe.inHandle.enabled, i.setKeyframeHandle(Ue.id, Ee, pe.id, "out", { ...pe.outHandle })) : (pe.inHandle.frame = -pe.outHandle.frame, pe.inHandle.value = -pe.outHandle.value, pe.inHandle.enabled = pe.outHandle.enabled, i.setKeyframeHandle(Ue.id, Ee, pe.id, "in", { ...pe.inHandle }))), pe.controlMode === "smooth")) {
        const W = _e === "in" ? pe.inHandle : pe.outHandle, ve = _e === "in" ? pe.outHandle : pe.inHandle, ye = _e === "in" ? "out" : "in";
        if (W.frame !== 0 || W.value !== 0) {
          const be = Math.atan2(W.value, W.frame) + Math.PI, ke = Math.hypot(ve.frame, ve.value);
          ve.frame = Math.cos(be) * ke, ve.value = Math.sin(be) * ke, i.setKeyframeHandle(Ue.id, Ee, pe.id, ye, { ...ve });
        }
      }
    }
    function $e() {
      S.value = null, document.removeEventListener("mousemove", Oe), document.removeEventListener("mouseup", $e);
    }
    function Le(pe) {
      C.value = { x: pe.offsetX, y: pe.offsetY };
    }
    function nt() {
      if (!C.value) return;
      const pe = i.selectedLayer;
      if (!pe) return;
      const _e = Math.round(ue(C.value.x)), Ee = le(C.value.y);
      if (R.value.length > 0) {
        const Ue = R.value[0], W = Ae(Ue), ve = typeof Ue.value == "number" ? Ee : { x: Ee, y: Ee };
        i.addKeyframe(pe.id, W, ve, _e), at();
      }
      C.value = null;
    }
    function Je() {
      const pe = i.selectedLayer;
      if (pe) {
        for (const _e of _.value) {
          const Ee = U.value.find((Ue) => Ue.id === _e.propId);
          if (Ee) {
            const Ue = Ae(Ee);
            i.removeKeyframe(pe.id, Ue, _e.keyframe.id);
          }
        }
        _.value = [], at();
      }
    }
    function bt() {
      E.value = _.value.map((pe) => ({ ...pe.keyframe }));
    }
    function Se() {
      var W, ve;
      if (!E.value || R.value.length === 0) return;
      const pe = i.selectedLayer;
      if (!pe) return;
      const _e = R.value[0], Ee = Ae(_e), Ue = i.currentFrame - E.value[0].frame;
      for (const ye of E.value) {
        const Ce = ye.frame + Ue, be = i.addKeyframe(pe.id, Ee, ye.value, Ce);
        be && (ye.interpolation !== "linear" && i.setKeyframeInterpolation(pe.id, Ee, be.id, ye.interpolation), (W = ye.inHandle) != null && W.enabled && i.setKeyframeHandle(pe.id, Ee, be.id, "in", ye.inHandle), (ve = ye.outHandle) != null && ve.enabled && i.setKeyframeHandle(pe.id, Ee, be.id, "out", ye.outHandle));
      }
      at();
    }
    function Ne() {
      _.value = [];
      for (const pe of R.value)
        for (let _e = 0; _e < pe.keyframes.length; _e++)
          _.value.push({ propId: pe.id, index: _e, keyframe: pe.keyframes[_e] });
    }
    function Re() {
      const pe = [];
      for (const _e of R.value)
        for (let Ee = 0; Ee < _e.keyframes.length; Ee++)
          I(_e.id, Ee) || pe.push({ propId: _e.id, index: Ee, keyframe: _e.keyframes[Ee] });
      _.value = pe;
    }
    function Be(pe) {
      const _e = parseInt(pe.target.value);
      _.value.length > 0 && !isNaN(_e) && (_.value[0].keyframe.frame = _e, at());
    }
    function je(pe) {
      const _e = parseFloat(pe.target.value);
      if (_.value.length > 0 && !isNaN(_e)) {
        const Ee = _.value[0].keyframe;
        typeof Ee.value == "number" ? Ee.value = _e : typeof Ee.value == "object" && (Ee.value.x = _e), at();
      }
    }
    function Ge(pe) {
      const _e = pe.target.value;
      _.value.length > 0 && (_.value[0].keyframe.interpolation = _e, at());
    }
    function ut(pe) {
      var W;
      const _e = (W = l.value) == null ? void 0 : W.getBoundingClientRect();
      if (!_e) return;
      const Ee = pe.clientX - _e.left, Ue = Math.round(ue(Ee));
      i.setFrame(Ue);
    }
    function at() {
      dt(), rn(), Bn();
    }
    function dt() {
      const pe = r.value;
      if (!pe) return;
      const _e = pe.getContext("2d");
      if (_e) {
        pe.width = d.value, pe.height = h.value, _e.fillStyle = "#1a1a1a", _e.fillRect(0, 0, d.value, h.value), pt(_e);
        for (const Ee of R.value)
          Kt(_e, Ee);
      }
    }
    function pt(pe) {
      const _e = d.value - y.left - y.right, Ee = h.value - y.top - y.bottom;
      pe.strokeStyle = "#2a2a2a", pe.lineWidth = 1;
      const Ue = p.frameEnd - p.frameStart, W = zt(Ue, _e, 50), ve = p.valueMax - p.valueMin, ye = zt(ve, Ee, 30), Ce = Math.ceil(p.frameStart / W) * W;
      for (let ke = Ce; ke <= p.frameEnd; ke += W) {
        const De = G(ke);
        pe.beginPath(), pe.moveTo(De, y.top), pe.lineTo(De, h.value - y.bottom), pe.stroke();
      }
      const be = Math.ceil(p.valueMin / ye) * ye;
      for (let ke = be; ke <= p.valueMax; ke += ye) {
        const De = Q(ke);
        pe.beginPath(), pe.moveTo(y.left, De), pe.lineTo(d.value - y.right, De), pe.stroke();
      }
      if (pe.strokeStyle = "#3a3a3a", pe.lineWidth = 1, p.frameStart <= 0 && p.frameEnd >= 0) {
        const ke = G(0);
        pe.beginPath(), pe.moveTo(ke, y.top), pe.lineTo(ke, h.value - y.bottom), pe.stroke();
      }
      if (p.valueMin <= 0 && p.valueMax >= 0) {
        const ke = Q(0);
        pe.beginPath(), pe.moveTo(y.left, ke), pe.lineTo(d.value - y.right, ke), pe.stroke();
      }
    }
    function zt(pe, _e, Ee) {
      const Ue = pe * Ee / _e, W = Math.pow(10, Math.floor(Math.log10(Ue))), ve = Ue / W;
      return ve <= 1 ? W : ve <= 2 ? 2 * W : ve <= 5 ? 5 * W : 10 * W;
    }
    function Kt(pe, _e) {
      if (_e.keyframes.length < 2) return;
      const Ee = Y(_e.id);
      for (let Ue = 0; Ue < 2; Ue++) {
        Ue === 0 ? (pe.strokeStyle = "#000", pe.lineWidth = 4) : (pe.strokeStyle = Ee, pe.lineWidth = 2), pe.beginPath();
        let W = !1;
        for (let ve = 0; ve < _e.keyframes.length - 1; ve++) {
          const ye = _e.keyframes[ve], Ce = _e.keyframes[ve + 1];
          if (Ce.frame < p.frameStart || ye.frame > p.frameEnd) continue;
          const be = re(ye), ke = j(_e, ye), De = re(Ce), Qe = j(_e, Ce);
          if (W || (pe.moveTo(be, ke), W = !0), ye.interpolation === "hold")
            pe.lineTo(De, ke), pe.lineTo(De, Qe);
          else if (ye.interpolation === "linear" || !ye.outHandle.enabled && !Ce.inHandle.enabled)
            pe.lineTo(De, Qe);
          else {
            const it = G(ye.frame + ye.outHandle.frame), mt = Q(V(ye.value) + ye.outHandle.value), gt = G(Ce.frame + Ce.inHandle.frame), lt = Q(V(Ce.value) + Ce.inHandle.value);
            pe.bezierCurveTo(it, mt, gt, lt, De, Qe);
          }
        }
        pe.stroke();
      }
    }
    function rn() {
      var Ce;
      const pe = l.value;
      if (!pe) return;
      const _e = (Ce = a.value) == null ? void 0 : Ce.getBoundingClientRect();
      if (!_e) return;
      pe.width = _e.width, pe.height = 24;
      const Ee = pe.getContext("2d");
      if (!Ee) return;
      Ee.fillStyle = "#252525", Ee.fillRect(0, 0, pe.width, pe.height);
      const Ue = p.frameEnd - p.frameStart, W = zt(Ue, pe.width, 60);
      Ee.fillStyle = "#888", Ee.font = "10px system-ui", Ee.textAlign = "center";
      const ve = Math.ceil(p.frameStart / W) * W;
      for (let be = ve; be <= p.frameEnd; be += W) {
        const ke = G(be);
        Ee.fillText(be.toString(), ke, 16), Ee.strokeStyle = "#444", Ee.beginPath(), Ee.moveTo(ke, 20), Ee.lineTo(ke, 24), Ee.stroke();
      }
      const ye = G(i.currentFrame);
      Ee.fillStyle = "#ff4444", Ee.beginPath(), Ee.moveTo(ye - 5, 0), Ee.lineTo(ye + 5, 0), Ee.lineTo(ye, 8), Ee.closePath(), Ee.fill();
    }
    function Bn() {
      var ye;
      const pe = u.value;
      if (!pe) return;
      const _e = (ye = c.value) == null ? void 0 : ye.getBoundingClientRect();
      if (!_e) return;
      pe.width = 40, pe.height = _e.height;
      const Ee = pe.getContext("2d");
      if (!Ee) return;
      Ee.fillStyle = "#252525", Ee.fillRect(0, 0, pe.width, pe.height);
      const Ue = p.valueMax - p.valueMin, W = zt(Ue, pe.height, 30);
      Ee.fillStyle = "#888", Ee.font = "10px system-ui", Ee.textAlign = "right";
      const ve = Math.ceil(p.valueMin / W) * W;
      for (let Ce = ve; Ce <= p.valueMax; Ce += W) {
        const be = Q(Ce);
        Ee.fillText(Ce.toFixed(0), 36, be + 4);
      }
    }
    function bn(pe = "both") {
      for (const _e of _.value) {
        const Ee = U.value.find((De) => De.id === _e.propId);
        if (!Ee) continue;
        const Ue = _e.keyframe, W = _e.index, ve = W > 0 ? Ee.keyframes[W - 1] : null, ye = W < Ee.keyframes.length - 1 ? Ee.keyframes[W + 1] : null, Ce = ve ? Ue.frame - ve.frame : 10, be = ye ? ye.frame - Ue.frame : 10, ke = 0.3333;
        (pe === "both" || pe === "in") && (Ue.inHandle = {
          frame: -Ce * ke,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), (pe === "both" || pe === "out") && (Ue.outHandle = {
          frame: be * ke,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), Ue.interpolation = "bezier", Ue.controlMode = "smooth";
      }
      at();
    }
    function Kn() {
      const pe = i.currentFrame, _e = [];
      for (const Ue of R.value)
        for (const W of Ue.keyframes)
          _e.includes(W.frame) || _e.push(W.frame);
      _e.sort((Ue, W) => Ue - W);
      const Ee = [..._e].reverse().find((Ue) => Ue < pe);
      Ee !== void 0 && i.setFrame(Ee);
    }
    function fi() {
      const pe = i.currentFrame, _e = [];
      for (const Ue of R.value)
        for (const W of Ue.keyframes)
          _e.includes(W.frame) || _e.push(W.frame);
      _e.sort((Ue, W) => Ue - W);
      const Ee = _e.find((Ue) => Ue > pe);
      Ee !== void 0 && i.setFrame(Ee);
    }
    function pi(pe) {
      if (pe.key === "F9") {
        pe.preventDefault(), pe.ctrlKey && pe.shiftKey ? bn("out") : pe.shiftKey ? bn("in") : bn("both");
        return;
      }
      if (pe.key.toLowerCase() === "j") {
        pe.preventDefault(), Kn();
        return;
      }
      if (pe.key.toLowerCase() === "k") {
        pe.preventDefault(), fi();
        return;
      }
      if (pe.key === "Delete" || pe.key === "Backspace") {
        pe.preventDefault(), Je();
        return;
      }
      if (pe.key.toLowerCase() === "f" && !pe.ctrlKey) {
        pe.preventDefault(), pe.shiftKey ? ne() : _.value.length > 0 ? Vn() : ne();
        return;
      }
      if (pe.key === "=" || pe.key === "+") {
        pe.preventDefault(), wn();
        return;
      }
      if (pe.key === "-" || pe.key === "_") {
        pe.preventDefault(), si();
        return;
      }
    }
    function Vn() {
      if (_.value.length === 0) {
        ne();
        return;
      }
      let pe = 1 / 0, _e = -1 / 0, Ee = 1 / 0, Ue = -1 / 0;
      for (const ye of _.value) {
        pe = Math.min(pe, ye.keyframe.frame), _e = Math.max(_e, ye.keyframe.frame);
        const Ce = V(ye.keyframe.value);
        Ee = Math.min(Ee, Ce), Ue = Math.max(Ue, Ce);
      }
      const W = (_e - pe) * 0.1 || 10, ve = (Ue - Ee) * 0.1 || 10;
      p.frameStart = pe - W, p.frameEnd = _e + W, p.valueMin = Ee - ve, p.valueMax = Ue + ve, at();
    }
    function wn() {
      const pe = (p.frameStart + p.frameEnd) / 2, _e = p.frameEnd - p.frameStart;
      p.frameStart = pe - _e * 0.4, p.frameEnd = pe + _e * 0.4, at();
    }
    function si() {
      const pe = (p.frameStart + p.frameEnd) / 2, _e = p.frameEnd - p.frameStart;
      p.frameStart = pe - _e * 0.6, p.frameEnd = pe + _e * 0.6, at();
    }
    let ki = null;
    return _n(() => {
      o.value && (ki = new ResizeObserver((pe) => {
        for (const _e of pe)
          d.value = _e.contentRect.width, h.value = _e.contentRect.height, at();
      }), ki.observe(o.value)), x.value = U.value.filter((pe) => pe.animated).map((pe) => pe.id), window.addEventListener("keydown", pi), ne(), at();
    }), Nn(() => {
      ki == null || ki.disconnect(), window.removeEventListener("keydown", pi);
    }), Ft([() => i.currentFrame, x, m], () => {
      at();
    }), Ft(U, () => {
      ne(), at();
    }, { deep: !0 }), (pe, _e) => {
      var Ee, Ue;
      return te(), ae("div", LB, [
        f("div", FB, [
          _e[9] || (_e[9] = f("span", { class: "graph-title" }, "Graph Editor", -1)),
          f("div", UB, [
            f("button", {
              class: Fe({ active: m.value === "value" }),
              onClick: _e[0] || (_e[0] = (W) => m.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            f("button", {
              class: Fe({ active: m.value === "speed" }),
              onClick: _e[1] || (_e[1] = (W) => m.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          f("div", OB, [
            (te(), ae(qe, null, ot(D, (W) => f("button", {
              key: W.key,
              class: Fe(["preset-btn", { active: X(W.key) }]),
              onClick: (ve) => se(W.key),
              title: W.label
            }, xe(W.shortLabel), 11, zB)), 64))
          ]),
          f("div", NB, [
            f("button", {
              onClick: ne,
              title: "Fit to View"
            }, [..._e[5] || (_e[5] = [
              f("span", { class: "icon" }, "[ ]", -1)
            ])]),
            f("button", {
              onClick: B,
              class: Fe({ active: T.value }),
              title: "Auto-select Nearby Keyframes"
            }, [..._e[6] || (_e[6] = [
              f("span", { class: "icon" }, "A", -1)
            ])], 2),
            f("button", {
              onClick: _e[2] || (_e[2] = (W) => P.value = !P.value),
              class: Fe({ active: P.value }),
              title: "Snap to Grid"
            }, [..._e[7] || (_e[7] = [
              f("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          f("button", {
            class: "close-btn",
            onClick: _e[3] || (_e[3] = (W) => n("close"))
          }, [..._e[8] || (_e[8] = [
            f("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        f("div", BB, [
          f("div", VB, [
            f("div", GB, [
              _e[10] || (_e[10] = ct(" Properties ", -1)),
              f("button", {
                class: "toggle-all-btn",
                onClick: Z,
                title: O.value ? "Hide All" : "Show All"
              }, xe(O.value ? "Hide" : "Show"), 9, HB)
            ]),
            (te(!0), ae(qe, null, ot(U.value, (W) => (te(), ae("div", {
              key: W.id,
              class: Fe(["property-item", {
                selected: v.value.includes(W.id),
                animated: W.animated
              }])
            }, [
              f("div", {
                class: "property-row",
                onClick: (ve) => L(W.id)
              }, [
                f("span", {
                  class: Fe(["visibility-toggle", { visible: x.value.includes(W.id) }]),
                  onClick: _t((ve) => ee(W.id), ["stop"])
                }, null, 10, WB),
                f("span", {
                  class: "property-color",
                  style: yt({ background: Y(W.id) })
                }, null, 4),
                f("span", XB, xe(W.name), 1),
                W.animated ? (te(), ae("span", jB, xe(W.keyframes.length), 1)) : Pe("", !0)
              ], 8, $B),
              W.name === "Position" || W.name === "Scale" ? (te(), ae("div", YB, [
                (te(), ae(qe, null, ot(["x", "y", "z"], (ve) => {
                  var ye;
                  return f("button", {
                    key: ve,
                    class: Fe({
                      active: (ye = g.value[W.id]) == null ? void 0 : ye.includes(ve),
                      hasValue: F(W, ve)
                    }),
                    onClick: (Ce) => k(W.id, ve)
                  }, xe(ve.toUpperCase()), 11, qB);
                }), 64))
              ])) : Pe("", !0)
            ], 2))), 128)),
            U.value.length === 0 ? (te(), ae("div", ZB, " No animated properties ")) : Pe("", !0)
          ]),
          f("div", KB, [
            f("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: a
            }, [
              f("canvas", {
                ref_key: "timeRulerCanvas",
                ref: l,
                onClick: ut
              }, null, 512)
            ], 512),
            f("div", {
              class: "graph-canvas-container",
              ref_key: "canvasContainerRef",
              ref: o
            }, [
              f("canvas", {
                ref_key: "canvasRef",
                ref: r,
                onMousedown: z,
                onMousemove: N,
                onMouseup: K,
                onMouseleave: K,
                onWheel: he,
                onContextmenu: _t(Le, ["prevent"])
              }, null, 544),
              b.value ? (te(), ae("div", {
                key: 0,
                class: "selection-box",
                style: yt({
                  left: b.value.x + "px",
                  top: b.value.y + "px",
                  width: b.value.width + "px",
                  height: b.value.height + "px"
                })
              }, null, 4)) : Pe("", !0),
              (te(), ae("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${d.value} ${h.value}`
              }, [
                (te(!0), ae(qe, null, ot(R.value, (W) => (te(), ae("g", {
                  key: W.id,
                  class: "property-handles"
                }, [
                  (te(!0), ae(qe, null, ot(W.keyframes, (ve, ye) => {
                    var Ce, be, ke, De, Qe, it, mt, gt;
                    return te(), ae(qe, { key: ye }, [
                      H(ve) ? (te(), ae("g", {
                        key: 0,
                        class: Fe(["keyframe-marker", {
                          selected: I(W.id, ye),
                          hovered: ((Ce = M.value) == null ? void 0 : Ce.propId) === W.id && ((be = M.value) == null ? void 0 : be.index) === ye
                        }]),
                        onMousedown: _t((lt) => ge(W.id, ye, lt), ["stop"])
                      }, [
                        f("rect", {
                          x: re(ve) - 5,
                          y: j(W, ve) - 5,
                          width: "10",
                          height: "10",
                          fill: Y(W.id),
                          "transform-origin": "center",
                          transform: `rotate(45, ${re(ve)}, ${j(W, ve)})`
                        }, null, 8, eV)
                      ], 42, QB)) : Pe("", !0),
                      I(W.id, ye) && ve.interpolation !== "hold" ? (te(), ae("g", tV, [
                        W.keyframes[ye + 1] && (ve.outHandle.enabled || ve.interpolation === "bezier") ? (te(), ae("g", nV, [
                          f("line", {
                            x1: re(ve),
                            y1: j(W, ve),
                            x2: q(W, ye),
                            y2: oe(W, ye),
                            class: "handle-line"
                          }, null, 8, iV),
                          f("circle", {
                            cx: q(W, ye),
                            cy: oe(W, ye),
                            r: "5",
                            class: Fe(["handle-point", { dragging: ((ke = S.value) == null ? void 0 : ke.type) === "outHandle" && ((De = S.value) == null ? void 0 : De.propId) === W.id && ((Qe = S.value) == null ? void 0 : Qe.index) === ye }]),
                            onMousedown: _t((lt) => Xe("outHandle", W.id, ye), ["stop"])
                          }, null, 42, sV)
                        ])) : Pe("", !0),
                        ye > 0 && (ve.inHandle.enabled || ve.interpolation === "bezier") ? (te(), ae("g", rV, [
                          f("line", {
                            x1: re(ve),
                            y1: j(W, ve),
                            x2: ie(W, ye),
                            y2: ce(W, ye),
                            class: "handle-line"
                          }, null, 8, oV),
                          f("circle", {
                            cx: ie(W, ye),
                            cy: ce(W, ye),
                            r: "5",
                            class: Fe(["handle-point", { dragging: ((it = S.value) == null ? void 0 : it.type) === "inHandle" && ((mt = S.value) == null ? void 0 : mt.propId) === W.id && ((gt = S.value) == null ? void 0 : gt.index) === ye }]),
                            onMousedown: _t((lt) => Xe("inHandle", W.id, ye), ["stop"])
                          }, null, 42, aV)
                        ])) : Pe("", !0)
                      ])) : Pe("", !0)
                    ], 64);
                  }), 128))
                ]))), 128)),
                f("line", {
                  x1: A.value,
                  y1: 0,
                  x2: A.value,
                  y2: h.value,
                  class: "current-time-line"
                }, null, 8, lV)
              ], 8, JB))
            ], 512),
            f("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: c
            }, [
              f("canvas", {
                ref_key: "valueAxisCanvas",
                ref: u
              }, null, 512)
            ], 512)
          ])
        ]),
        _.value.length > 0 ? (te(), ae("div", cV, [
          f("div", uV, [
            _e[11] || (_e[11] = f("span", { class: "info-label" }, "Frame:", -1)),
            f("input", {
              type: "number",
              value: (Ee = _.value[0]) == null ? void 0 : Ee.keyframe.frame,
              onChange: Be,
              class: "info-input"
            }, null, 40, dV)
          ]),
          f("div", hV, [
            _e[12] || (_e[12] = f("span", { class: "info-label" }, "Value:", -1)),
            f("input", {
              type: "number",
              value: $(_.value[0]),
              onChange: je,
              class: "info-input",
              step: "0.1"
            }, null, 40, fV)
          ]),
          f("div", pV, [
            _e[14] || (_e[14] = f("span", { class: "info-label" }, "Interpolation:", -1)),
            f("select", {
              value: (Ue = _.value[0]) == null ? void 0 : Ue.keyframe.interpolation,
              onChange: Ge,
              class: "info-select"
            }, [..._e[13] || (_e[13] = [
              f("option", { value: "linear" }, "Linear", -1),
              f("option", { value: "bezier" }, "Bezier", -1),
              f("option", { value: "hold" }, "Hold", -1)
            ])], 40, mV)
          ])
        ])) : Pe("", !0),
        C.value ? (te(), ae("div", {
          key: 1,
          class: "context-menu",
          style: yt({ left: C.value.x + "px", top: C.value.y + "px" }),
          onClick: _e[4] || (_e[4] = (W) => C.value = null)
        }, [
          f("button", { onClick: nt }, "Add Keyframe"),
          f("button", {
            onClick: Je,
            disabled: _.value.length === 0
          }, "Delete Keyframe(s)", 8, vV),
          _e[15] || (_e[15] = f("hr", null, null, -1)),
          f("button", {
            onClick: bt,
            disabled: _.value.length === 0
          }, "Copy", 8, gV),
          f("button", {
            onClick: Se,
            disabled: !E.value
          }, "Paste", 8, yV),
          _e[16] || (_e[16] = f("hr", null, null, -1)),
          f("button", { onClick: Ne }, "Select All"),
          f("button", { onClick: Re }, "Invert Selection")
        ], 4)) : Pe("", !0)
      ]);
    };
  }
}), xV = /* @__PURE__ */ Gt(_V, [["__scopeId", "data-v-70deec8d"]]), { abs: wa, cos: _s, sin: _o, acos: bV, atan2: Sa, sqrt: qs, pow: Ei } = Math;
function Ma(s) {
  return s < 0 ? -Ei(-s, 1 / 3) : Ei(s, 1 / 3);
}
const $y = Math.PI, wc = 2 * $y, Zs = $y / 2, wV = 1e-6, Xd = Number.MAX_SAFE_INTEGER || 9007199254740991, jd = Number.MIN_SAFE_INTEGER || -9007199254740991, SV = { x: 0, y: 0, z: 0 }, Ke = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(s, e) {
    const n = e(s);
    let i = n.x * n.x + n.y * n.y;
    return typeof n.z < "u" && (i += n.z * n.z), qs(i);
  },
  compute: function(s, e, n) {
    if (s === 0)
      return e[0].t = 0, e[0];
    const i = e.length - 1;
    if (s === 1)
      return e[i].t = 1, e[i];
    const r = 1 - s;
    let o = e;
    if (i === 0)
      return e[0].t = s, e[0];
    if (i === 1) {
      const l = {
        x: r * o[0].x + s * o[1].x,
        y: r * o[0].y + s * o[1].y,
        t: s
      };
      return n && (l.z = r * o[0].z + s * o[1].z), l;
    }
    if (i < 4) {
      let l = r * r, c = s * s, u, d, h, m = 0;
      i === 2 ? (o = [o[0], o[1], o[2], SV], u = l, d = r * s * 2, h = c) : i === 3 && (u = l * r, d = l * s * 3, h = r * c * 3, m = s * c);
      const p = {
        x: u * o[0].x + d * o[1].x + h * o[2].x + m * o[3].x,
        y: u * o[0].y + d * o[1].y + h * o[2].y + m * o[3].y,
        t: s
      };
      return n && (p.z = u * o[0].z + d * o[1].z + h * o[2].z + m * o[3].z), p;
    }
    const a = JSON.parse(JSON.stringify(e));
    for (; a.length > 1; ) {
      for (let l = 0; l < a.length - 1; l++)
        a[l] = {
          x: a[l].x + (a[l + 1].x - a[l].x) * s,
          y: a[l].y + (a[l + 1].y - a[l].y) * s
        }, typeof a[l].z < "u" && (a[l].z = a[l].z + (a[l + 1].z - a[l].z) * s);
      a.splice(a.length - 1, 1);
    }
    return a[0].t = s, a[0];
  },
  computeWithRatios: function(s, e, n, i) {
    const r = 1 - s, o = n, a = e;
    let l = o[0], c = o[1], u = o[2], d = o[3], h;
    if (l *= r, c *= s, a.length === 2)
      return h = l + c, {
        x: (l * a[0].x + c * a[1].x) / h,
        y: (l * a[0].y + c * a[1].y) / h,
        z: i ? (l * a[0].z + c * a[1].z) / h : !1,
        t: s
      };
    if (l *= r, c *= 2 * r, u *= s * s, a.length === 3)
      return h = l + c + u, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x) / h,
        y: (l * a[0].y + c * a[1].y + u * a[2].y) / h,
        z: i ? (l * a[0].z + c * a[1].z + u * a[2].z) / h : !1,
        t: s
      };
    if (l *= r, c *= 1.5 * r, u *= 3 * r, d *= s * s * s, a.length === 4)
      return h = l + c + u + d, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x + d * a[3].x) / h,
        y: (l * a[0].y + c * a[1].y + u * a[2].y + d * a[3].y) / h,
        z: i ? (l * a[0].z + c * a[1].z + u * a[2].z + d * a[3].z) / h : !1,
        t: s
      };
  },
  derive: function(s, e) {
    const n = [];
    for (let i = s, r = i.length, o = r - 1; r > 1; r--, o--) {
      const a = [];
      for (let l = 0, c; l < o; l++)
        c = {
          x: o * (i[l + 1].x - i[l].x),
          y: o * (i[l + 1].y - i[l].y)
        }, e && (c.z = o * (i[l + 1].z - i[l].z)), a.push(c);
      n.push(a), i = a;
    }
    return n;
  },
  between: function(s, e, n) {
    return e <= s && s <= n || Ke.approximately(s, e) || Ke.approximately(s, n);
  },
  approximately: function(s, e, n) {
    return wa(s - e) <= (n || wV);
  },
  length: function(s) {
    const n = Ke.Tvalues.length;
    let i = 0;
    for (let r = 0, o; r < n; r++)
      o = 0.5 * Ke.Tvalues[r] + 0.5, i += Ke.Cvalues[r] * Ke.arcfn(o, s);
    return 0.5 * i;
  },
  map: function(s, e, n, i, r) {
    const o = n - e, a = r - i, l = s - e, c = l / o;
    return i + a * c;
  },
  lerp: function(s, e, n) {
    const i = {
      x: e.x + s * (n.x - e.x),
      y: e.y + s * (n.y - e.y)
    };
    return e.z !== void 0 && n.z !== void 0 && (i.z = e.z + s * (n.z - e.z)), i;
  },
  pointToString: function(s) {
    let e = s.x + "/" + s.y;
    return typeof s.z < "u" && (e += "/" + s.z), e;
  },
  pointsToString: function(s) {
    return "[" + s.map(Ke.pointToString).join(", ") + "]";
  },
  copy: function(s) {
    return JSON.parse(JSON.stringify(s));
  },
  angle: function(s, e, n) {
    const i = e.x - s.x, r = e.y - s.y, o = n.x - s.x, a = n.y - s.y, l = i * a - r * o, c = i * o + r * a;
    return Sa(l, c);
  },
  // round as string, to avoid rounding errors
  round: function(s, e) {
    const n = "" + s, i = n.indexOf(".");
    return parseFloat(n.substring(0, i + 1 + e));
  },
  dist: function(s, e) {
    const n = s.x - e.x, i = s.y - e.y;
    return qs(n * n + i * i);
  },
  closest: function(s, e) {
    let n = Ei(2, 63), i, r;
    return s.forEach(function(o, a) {
      r = Ke.dist(e, o), r < n && (n = r, i = a);
    }), { mdist: n, mpos: i };
  },
  abcratio: function(s, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof s > "u")
      s = 0.5;
    else if (s === 0 || s === 1)
      return s;
    const n = Ei(s, e) + Ei(1 - s, e), i = n - 1;
    return wa(i / n);
  },
  projectionratio: function(s, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof s > "u")
      s = 0.5;
    else if (s === 0 || s === 1)
      return s;
    const n = Ei(1 - s, e), i = Ei(s, e) + n;
    return n / i;
  },
  lli8: function(s, e, n, i, r, o, a, l) {
    const c = (s * i - e * n) * (r - a) - (s - n) * (r * l - o * a), u = (s * i - e * n) * (o - l) - (e - i) * (r * l - o * a), d = (s - n) * (o - l) - (e - i) * (r - a);
    return d == 0 ? !1 : { x: c / d, y: u / d };
  },
  lli4: function(s, e, n, i) {
    const r = s.x, o = s.y, a = e.x, l = e.y, c = n.x, u = n.y, d = i.x, h = i.y;
    return Ke.lli8(r, o, a, l, c, u, d, h);
  },
  lli: function(s, e) {
    return Ke.lli4(s, s.c, e, e.c);
  },
  makeline: function(s, e) {
    return new Wy(
      s.x,
      s.y,
      (s.x + e.x) / 2,
      (s.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(s) {
    let e = Xd, n = Xd, i = jd, r = jd;
    return s.forEach(function(o) {
      const a = o.bbox();
      e > a.x.min && (e = a.x.min), n > a.y.min && (n = a.y.min), i < a.x.max && (i = a.x.max), r < a.y.max && (r = a.y.max);
    }), {
      x: { min: e, mid: (e + i) / 2, max: i, size: i - e },
      y: { min: n, mid: (n + r) / 2, max: r, size: r - n }
    };
  },
  shapeintersections: function(s, e, n, i, r) {
    if (!Ke.bboxoverlap(e, i)) return [];
    const o = [], a = [s.startcap, s.forward, s.back, s.endcap], l = [n.startcap, n.forward, n.back, n.endcap];
    return a.forEach(function(c) {
      c.virtual || l.forEach(function(u) {
        if (u.virtual) return;
        const d = c.intersects(u, r);
        d.length > 0 && (d.c1 = c, d.c2 = u, d.s1 = s, d.s2 = n, o.push(d));
      });
    }), o;
  },
  makeshape: function(s, e, n) {
    const i = e.points.length, r = s.points.length, o = Ke.makeline(e.points[i - 1], s.points[0]), a = Ke.makeline(s.points[r - 1], e.points[0]), l = {
      startcap: o,
      forward: s,
      back: e,
      endcap: a,
      bbox: Ke.findbbox([o, s, e, a])
    };
    return l.intersections = function(c) {
      return Ke.shapeintersections(
        l,
        l.bbox,
        c,
        c.bbox,
        n
      );
    }, l;
  },
  getminmax: function(s, e, n) {
    if (!n) return { min: 0, max: 0 };
    let i = Xd, r = jd, o, a;
    n.indexOf(0) === -1 && (n = [0].concat(n)), n.indexOf(1) === -1 && n.push(1);
    for (let l = 0, c = n.length; l < c; l++)
      o = n[l], a = s.get(o), a[e] < i && (i = a[e]), a[e] > r && (r = a[e]);
    return { min: i, mid: (i + r) / 2, max: r, size: r - i };
  },
  align: function(s, e) {
    const n = e.p1.x, i = e.p1.y, r = -Sa(e.p2.y - i, e.p2.x - n), o = function(a) {
      return {
        x: (a.x - n) * _s(r) - (a.y - i) * _o(r),
        y: (a.x - n) * _o(r) + (a.y - i) * _s(r)
      };
    };
    return s.map(o);
  },
  roots: function(s, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const n = s.length - 1, i = Ke.align(s, e), r = function(P) {
      return 0 <= P && P <= 1;
    };
    if (n === 2) {
      const P = i[0].y, T = i[1].y, y = i[2].y, w = P - 2 * T + y;
      if (w !== 0) {
        const D = -qs(T * T - P * y), U = -P + T, R = -(D + U) / w, O = -(-D + U) / w;
        return [R, O].filter(r);
      } else if (T !== y && w === 0)
        return [(2 * T - y) / (2 * T - 2 * y)].filter(r);
      return [];
    }
    const o = i[0].y, a = i[1].y, l = i[2].y, c = i[3].y;
    let u = -o + 3 * a - 3 * l + c, d = 3 * o - 6 * a + 3 * l, h = -3 * o + 3 * a, m = o;
    if (Ke.approximately(u, 0)) {
      if (Ke.approximately(d, 0))
        return Ke.approximately(h, 0) ? [] : [-m / h].filter(r);
      const P = qs(h * h - 4 * d * m), T = 2 * d;
      return [(P - h) / T, (-h - P) / T].filter(r);
    }
    d /= u, h /= u, m /= u;
    const p = (3 * h - d * d) / 3, v = p / 3, x = (2 * d * d * d - 9 * d * h + 27 * m) / 27, g = x / 2, _ = g * g + v * v * v;
    let M, S, b, C, E;
    if (_ < 0) {
      const P = -p / 3, T = P * P * P, y = qs(T), w = -x / (2 * y), D = w < -1 ? -1 : w > 1 ? 1 : w, U = bV(D), R = Ma(y), O = 2 * R;
      return b = O * _s(U / 3) - d / 3, C = O * _s((U + wc) / 3) - d / 3, E = O * _s((U + 2 * wc) / 3) - d / 3, [b, C, E].filter(r);
    } else {
      if (_ === 0)
        return M = g < 0 ? Ma(-g) : -Ma(g), b = 2 * M - d / 3, C = -M - d / 3, [b, C].filter(r);
      {
        const P = qs(_);
        return M = Ma(-g + P), S = Ma(g + P), [M - S - d / 3].filter(r);
      }
    }
  },
  droots: function(s) {
    if (s.length === 3) {
      const e = s[0], n = s[1], i = s[2], r = e - 2 * n + i;
      if (r !== 0) {
        const o = -qs(n * n - e * i), a = -e + n, l = -(o + a) / r, c = -(-o + a) / r;
        return [l, c];
      } else if (n !== i && r === 0)
        return [(2 * n - i) / (2 * (n - i))];
      return [];
    }
    if (s.length === 2) {
      const e = s[0], n = s[1];
      return e !== n ? [e / (e - n)] : [];
    }
    return [];
  },
  curvature: function(s, e, n, i, r) {
    let o, a, l, c, u = 0, d = 0;
    const h = Ke.compute(s, e), m = Ke.compute(s, n), p = h.x * h.x + h.y * h.y;
    if (i ? (o = qs(
      Ei(h.y * m.z - m.y * h.z, 2) + Ei(h.z * m.x - m.z * h.x, 2) + Ei(h.x * m.y - m.x * h.y, 2)
    ), a = Ei(p + h.z * h.z, 3 / 2)) : (o = h.x * m.y - h.y * m.x, a = Ei(p, 3 / 2)), o === 0 || a === 0)
      return { k: 0, r: 0 };
    if (u = o / a, d = a / o, !r) {
      const v = Ke.curvature(s - 1e-3, e, n, i, !0).k, x = Ke.curvature(s + 1e-3, e, n, i, !0).k;
      c = (x - u + (u - v)) / 2, l = (wa(x - u) + wa(u - v)) / 2;
    }
    return { k: u, r: d, dk: c, adk: l };
  },
  inflections: function(s) {
    if (s.length < 4) return [];
    const e = Ke.align(s, { p1: s[0], p2: s.slice(-1)[0] }), n = e[2].x * e[1].y, i = e[3].x * e[1].y, r = e[1].x * e[2].y, o = e[3].x * e[2].y, a = 18 * (-3 * n + 2 * i + 3 * r - o), l = 18 * (3 * n - i - 3 * r), c = 18 * (r - n);
    if (Ke.approximately(a, 0)) {
      if (!Ke.approximately(l, 0)) {
        let m = -c / l;
        if (0 <= m && m <= 1) return [m];
      }
      return [];
    }
    const u = 2 * a;
    if (Ke.approximately(u, 0)) return [];
    const d = l * l - 4 * a * c;
    if (d < 0) return [];
    const h = Math.sqrt(d);
    return [(h - l) / u, -(l + h) / u].filter(function(m) {
      return 0 <= m && m <= 1;
    });
  },
  bboxoverlap: function(s, e) {
    const n = ["x", "y"], i = n.length;
    for (let r = 0, o, a, l, c; r < i; r++)
      if (o = n[r], a = s[o].mid, l = e[o].mid, c = (s[o].size + e[o].size) / 2, wa(a - l) >= c) return !1;
    return !0;
  },
  expandbox: function(s, e) {
    e.x.min < s.x.min && (s.x.min = e.x.min), e.y.min < s.y.min && (s.y.min = e.y.min), e.z && e.z.min < s.z.min && (s.z.min = e.z.min), e.x.max > s.x.max && (s.x.max = e.x.max), e.y.max > s.y.max && (s.y.max = e.y.max), e.z && e.z.max > s.z.max && (s.z.max = e.z.max), s.x.mid = (s.x.min + s.x.max) / 2, s.y.mid = (s.y.min + s.y.max) / 2, s.z && (s.z.mid = (s.z.min + s.z.max) / 2), s.x.size = s.x.max - s.x.min, s.y.size = s.y.max - s.y.min, s.z && (s.z.size = s.z.max - s.z.min);
  },
  pairiteration: function(s, e, n) {
    const i = s.bbox(), r = e.bbox(), o = 1e5, a = n || 0.5;
    if (i.x.size + i.y.size < a && r.x.size + r.y.size < a)
      return [
        (o * (s._t1 + s._t2) / 2 | 0) / o + "/" + (o * (e._t1 + e._t2) / 2 | 0) / o
      ];
    let l = s.split(0.5), c = e.split(0.5), u = [
      { left: l.left, right: c.left },
      { left: l.left, right: c.right },
      { left: l.right, right: c.right },
      { left: l.right, right: c.left }
    ];
    u = u.filter(function(h) {
      return Ke.bboxoverlap(h.left.bbox(), h.right.bbox());
    });
    let d = [];
    return u.length === 0 || (u.forEach(function(h) {
      d = d.concat(
        Ke.pairiteration(h.left, h.right, a)
      );
    }), d = d.filter(function(h, m) {
      return d.indexOf(h) === m;
    })), d;
  },
  getccenter: function(s, e, n) {
    const i = e.x - s.x, r = e.y - s.y, o = n.x - e.x, a = n.y - e.y, l = i * _s(Zs) - r * _o(Zs), c = i * _o(Zs) + r * _s(Zs), u = o * _s(Zs) - a * _o(Zs), d = o * _o(Zs) + a * _s(Zs), h = (s.x + e.x) / 2, m = (s.y + e.y) / 2, p = (e.x + n.x) / 2, v = (e.y + n.y) / 2, x = h + l, g = m + c, _ = p + u, M = v + d, S = Ke.lli8(h, m, x, g, p, v, _, M), b = Ke.dist(S, s);
    let C = Sa(s.y - S.y, s.x - S.x), E = Sa(e.y - S.y, e.x - S.x), P = Sa(n.y - S.y, n.x - S.x), T;
    return C < P ? ((C > E || E > P) && (C += wc), C > P && (T = P, P = C, C = T)) : P < E && E < C ? (T = P, P = C, C = T) : P += wc, S.s = C, S.e = P, S.r = b, S;
  },
  numberSort: function(s, e) {
    return s - e;
  }
};
class Ka {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return Ke.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, n) {
      return e + n;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var n = e[0].bbox(), i = 1; i < e.length; i++)
      Ke.expandbox(n, e[i].bbox());
    return n;
  }
  offset(e) {
    const n = [];
    return this.curves.forEach(function(i) {
      n.push(...i.offset(e));
    }), new Ka(n);
  }
}
const { abs: Ca, min: sg, max: rg, cos: MV, sin: CV, acos: EV, sqrt: Ea } = Math, TV = Math.PI;
let Wy = class fn {
  constructor(e) {
    let n = e && e.forEach ? e : Array.from(arguments).slice(), i = !1;
    if (typeof n[0] == "object") {
      i = n.length;
      const p = [];
      n.forEach(function(v) {
        ["x", "y", "z"].forEach(function(x) {
          typeof v[x] < "u" && p.push(v[x]);
        });
      }), n = p;
    }
    let r = !1;
    const o = n.length;
    if (i) {
      if (i > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        r = !0;
      }
    } else if (o !== 6 && o !== 8 && o !== 9 && o !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const a = this._3d = !r && (o === 9 || o === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let p = 0, v = a ? 3 : 2; p < o; p += v) {
      var c = {
        x: n[p],
        y: n[p + 1]
      };
      a && (c.z = n[p + 2]), l.push(c);
    }
    const u = this.order = l.length - 1, d = this.dims = ["x", "y"];
    a && d.push("z"), this.dimlen = d.length;
    const h = Ke.align(l, { p1: l[0], p2: l[u] }), m = Ke.dist(l[0], l[u]);
    this._linear = h.reduce((p, v) => p + Ca(v.y), 0) < m / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, n, i, r) {
    if (typeof r > "u" && (r = 0.5), r === 0)
      return new fn(n, n, i);
    if (r === 1)
      return new fn(e, n, n);
    const o = fn.getABC(2, e, n, i, r);
    return new fn(e, o.A, i);
  }
  static cubicFromPoints(e, n, i, r, o) {
    typeof r > "u" && (r = 0.5);
    const a = fn.getABC(3, e, n, i, r);
    typeof o > "u" && (o = Ke.dist(n, a.C));
    const l = o * (1 - r) / r, c = Ke.dist(e, i), u = (i.x - e.x) / c, d = (i.y - e.y) / c, h = o * u, m = o * d, p = l * u, v = l * d, x = { x: n.x - h, y: n.y - m }, g = { x: n.x + p, y: n.y + v }, _ = a.A, M = { x: _.x + (x.x - _.x) / (1 - r), y: _.y + (x.y - _.y) / (1 - r) }, S = { x: _.x + (g.x - _.x) / r, y: _.y + (g.y - _.y) / r }, b = { x: e.x + (M.x - e.x) / r, y: e.y + (M.y - e.y) / r }, C = {
      x: i.x + (S.x - i.x) / (1 - r),
      y: i.y + (S.y - i.y) / (1 - r)
    };
    return new fn(e, b, C, i);
  }
  static getUtils() {
    return Ke;
  }
  getUtils() {
    return fn.getUtils();
  }
  static get PolyBezier() {
    return Ka;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return Ke.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, n = e[0].x, i = e[0].y, r = ["M", n, i, this.order === 2 ? "Q" : "C"];
    for (let o = 1, a = e.length; o < a; o++)
      r.push(e[o].x), r.push(e[o].y);
    return r.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, n) {
      return "" + n + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = Ke.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, n = Ke.angle(e[0], e[this.order], e[1]);
    this.clockwise = n > 0;
  }
  length() {
    return Ke.length(this.derivative.bind(this));
  }
  static getABC(e = 2, n, i, r, o = 0.5) {
    const a = Ke.projectionratio(o, e), l = 1 - a, c = {
      x: a * n.x + l * r.x,
      y: a * n.y + l * r.y
    }, u = Ke.abcratio(o, e);
    return { A: {
      x: i.x + (i.x - c.x) / u,
      y: i.y + (i.y - c.y) / u
    }, B: i, C: c, S: n, E: r };
  }
  getABC(e, n) {
    n = n || this.get(e);
    let i = this.points[0], r = this.points[this.order];
    return fn.getABC(this.order, i, n, r, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let n = 0, i, r; n < e; n++)
      r = n / (e - 1), i = this.compute(r), i.t = r, this._lut.push(i);
    return this._lut;
  }
  on(e, n) {
    n = n || 5;
    const i = this.getLUT(), r = [];
    for (let o = 0, a, l = 0; o < i.length; o++)
      a = i[o], Ke.dist(a, e) < n && (r.push(a), l += o / i.length);
    return r.length ? t /= r.length : !1;
  }
  project(e) {
    const n = this.getLUT(), i = n.length - 1, r = Ke.closest(n, e), o = r.mpos, a = (o - 1) / i, l = (o + 1) / i, c = 0.1 / i;
    let u = r.mdist, d = a, h = d, m;
    u += 1;
    for (let p; d < l + c; d += c)
      m = this.compute(d), p = Ke.dist(e, m), p < u && (u = p, h = d);
    return h = h < 0 ? 0 : h > 1 ? 1 : h, m = this.compute(h), m.t = h, m.d = u, m;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? Ke.computeWithRatios(e, this.points, this.ratios, this._3d) : Ke.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, n = [e[0]], i = e.length;
    for (let r = 1, o, a; r < i; r++)
      o = e[r], a = e[r - 1], n[r] = {
        x: (i - r) / i * o.x + r / i * a.x,
        y: (i - r) / i * o.y + r / i * a.y
      };
    return n[i] = e[i - 1], new fn(n);
  }
  derivative(e) {
    return Ke.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return Ke.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new fn(Ke.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return Ke.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return Ke.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const n = this.derivative(e), i = Ea(n.x * n.x + n.y * n.y);
    return { t: e, x: -n.y / i, y: n.x / i };
  }
  __normal3(e) {
    const n = this.derivative(e), i = this.derivative(e + 0.01), r = Ea(n.x * n.x + n.y * n.y + n.z * n.z), o = Ea(i.x * i.x + i.y * i.y + i.z * i.z);
    n.x /= r, n.y /= r, n.z /= r, i.x /= o, i.y /= o, i.z /= o;
    const a = {
      x: i.y * n.z - i.z * n.y,
      y: i.z * n.x - i.x * n.z,
      z: i.x * n.y - i.y * n.x
    }, l = Ea(a.x * a.x + a.y * a.y + a.z * a.z);
    a.x /= l, a.y /= l, a.z /= l;
    const c = [
      a.x * a.x,
      a.x * a.y - a.z,
      a.x * a.z + a.y,
      a.x * a.y + a.z,
      a.y * a.y,
      a.y * a.z - a.x,
      a.x * a.z - a.y,
      a.y * a.z + a.x,
      a.z * a.z
    ];
    return {
      t: e,
      x: c[0] * n.x + c[1] * n.y + c[2] * n.z,
      y: c[3] * n.x + c[4] * n.y + c[5] * n.z,
      z: c[6] * n.x + c[7] * n.y + c[8] * n.z
    };
  }
  hull(e) {
    let n = this.points, i = [], r = [], o = 0;
    for (r[o++] = n[0], r[o++] = n[1], r[o++] = n[2], this.order === 3 && (r[o++] = n[3]); n.length > 1; ) {
      i = [];
      for (let a = 0, l, c = n.length - 1; a < c; a++)
        l = Ke.lerp(e, n[a], n[a + 1]), r[o++] = l, i.push(l);
      n = i;
    }
    return r;
  }
  split(e, n) {
    if (e === 0 && n)
      return this.split(n).left;
    if (n === 1)
      return this.split(e).right;
    const i = this.hull(e), r = {
      left: this.order === 2 ? new fn([i[0], i[3], i[5]]) : new fn([i[0], i[4], i[7], i[9]]),
      right: this.order === 2 ? new fn([i[5], i[4], i[2]]) : new fn([i[9], i[8], i[6], i[3]]),
      span: i
    };
    return r.left._t1 = Ke.map(0, 0, 1, this._t1, this._t2), r.left._t2 = Ke.map(e, 0, 1, this._t1, this._t2), r.right._t1 = Ke.map(e, 0, 1, this._t1, this._t2), r.right._t2 = Ke.map(1, 0, 1, this._t1, this._t2), n ? (n = Ke.map(n, e, 1, 0, 1), r.right.split(n).left) : r;
  }
  extrema() {
    const e = {};
    let n = [];
    return this.dims.forEach(
      (function(i) {
        let r = function(a) {
          return a[i];
        }, o = this.dpoints[0].map(r);
        e[i] = Ke.droots(o), this.order === 3 && (o = this.dpoints[1].map(r), e[i] = e[i].concat(Ke.droots(o))), e[i] = e[i].filter(function(a) {
          return a >= 0 && a <= 1;
        }), n = n.concat(e[i].sort(Ke.numberSort));
      }).bind(this)
    ), e.values = n.sort(Ke.numberSort).filter(function(i, r) {
      return n.indexOf(i) === r;
    }), e;
  }
  bbox() {
    const e = this.extrema(), n = {};
    return this.dims.forEach(
      (function(i) {
        n[i] = Ke.getminmax(this, i, e[i]);
      }).bind(this)
    ), n;
  }
  overlaps(e) {
    const n = this.bbox(), i = e.bbox();
    return Ke.bboxoverlap(n, i);
  }
  offset(e, n) {
    if (typeof n < "u") {
      const i = this.get(e), r = this.normal(e), o = {
        c: i,
        n: r,
        x: i.x + r.x * n,
        y: i.y + r.y * n
      };
      return this._3d && (o.z = i.z + r.z * n), o;
    }
    if (this._linear) {
      const i = this.normal(0), r = this.points.map(function(o) {
        const a = {
          x: o.x + e * i.x,
          y: o.y + e * i.y
        };
        return o.z && i.z && (a.z = o.z + e * i.z), a;
      });
      return [new fn(r)];
    }
    return this.reduce().map(function(i) {
      return i._linear ? i.offset(e)[0] : i.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const r = Ke.angle(this.points[0], this.points[3], this.points[1]), o = Ke.angle(this.points[0], this.points[3], this.points[2]);
      if (r > 0 && o < 0 || r < 0 && o > 0) return !1;
    }
    const e = this.normal(0), n = this.normal(1);
    let i = e.x * n.x + e.y * n.y;
    return this._3d && (i += e.z * n.z), Ca(EV(i)) < TV / 3;
  }
  reduce() {
    let e, n = 0, i = 0, r = 0.01, o, a = [], l = [], c = this.extrema().values;
    for (c.indexOf(0) === -1 && (c = [0].concat(c)), c.indexOf(1) === -1 && c.push(1), n = c[0], e = 1; e < c.length; e++)
      i = c[e], o = this.split(n, i), o._t1 = n, o._t2 = i, a.push(o), n = i;
    return a.forEach(function(u) {
      for (n = 0, i = 0; i <= 1; )
        for (i = n + r; i <= 1 + r; i += r)
          if (o = u.split(n, i), !o.simple()) {
            if (i -= r, Ca(n - i) < r)
              return [];
            o = u.split(n, i), o._t1 = Ke.map(n, 0, 1, u._t1, u._t2), o._t2 = Ke.map(i, 0, 1, u._t1, u._t2), l.push(o), n = i;
            break;
          }
      n < 1 && (o = u.split(n, 1), o._t1 = Ke.map(n, 0, 1, u._t1, u._t2), o._t2 = u._t2, l.push(o));
    }), l;
  }
  translate(e, n, i) {
    i = typeof i == "number" ? i : n;
    const r = this.order;
    let o = this.points.map((a, l) => (1 - l / r) * n + l / r * i);
    return new fn(
      this.points.map((a, l) => ({
        x: a.x + e.x * o[l],
        y: a.y + e.y * o[l]
      }))
    );
  }
  scale(e) {
    const n = this.order;
    let i = !1;
    if (typeof e == "function" && (i = e), i && n === 2)
      return this.raise().scale(i);
    const r = this.clockwise, o = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        i ? i(0) : e,
        i ? i(1) : e
      );
    const a = i ? i(0) : e, l = i ? i(1) : e, c = [this.offset(0, 10), this.offset(1, 10)], u = [], d = Ke.lli4(c[0], c[0].c, c[1], c[1].c);
    if (!d)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(h) {
      const m = u[h * n] = Ke.copy(o[h * n]);
      m.x += (h ? l : a) * c[h].n.x, m.y += (h ? l : a) * c[h].n.y;
    }), i ? ([0, 1].forEach(function(h) {
      if (!(n === 2 && h)) {
        var m = o[h + 1], p = {
          x: m.x - d.x,
          y: m.y - d.y
        }, v = i ? i((h + 1) / n) : e;
        i && !r && (v = -v);
        var x = Ea(p.x * p.x + p.y * p.y);
        p.x /= x, p.y /= x, u[h + 1] = {
          x: m.x + v * p.x,
          y: m.y + v * p.y
        };
      }
    }), new fn(u)) : ([0, 1].forEach((h) => {
      if (n === 2 && h) return;
      const m = u[h * n], p = this.derivative(h), v = { x: m.x + p.x, y: m.y + p.y };
      u[h + 1] = Ke.lli4(m, v, d, o[h + 1]);
    }), new fn(u));
  }
  outline(e, n, i, r) {
    if (n = n === void 0 ? e : n, this._linear) {
      const C = this.normal(0), E = this.points[0], P = this.points[this.points.length - 1];
      let T, y, w;
      i === void 0 && (i = e, r = n), T = { x: E.x + C.x * e, y: E.y + C.y * e }, w = { x: P.x + C.x * i, y: P.y + C.y * i }, y = { x: (T.x + w.x) / 2, y: (T.y + w.y) / 2 };
      const D = [T, y, w];
      T = { x: E.x - C.x * n, y: E.y - C.y * n }, w = { x: P.x - C.x * r, y: P.y - C.y * r }, y = { x: (T.x + w.x) / 2, y: (T.y + w.y) / 2 };
      const U = [w, y, T], R = Ke.makeline(U[2], D[0]), O = Ke.makeline(D[2], U[0]), A = [R, new fn(D), O, new fn(U)];
      return new Ka(A);
    }
    const o = this.reduce(), a = o.length, l = [];
    let c = [], u, d = 0, h = this.length();
    const m = typeof i < "u" && typeof r < "u";
    function p(C, E, P, T, y) {
      return function(w) {
        const D = T / P, U = (T + y) / P, R = E - C;
        return Ke.map(w, 0, 1, C + D * R, C + U * R);
      };
    }
    o.forEach(function(C) {
      const E = C.length();
      m ? (l.push(
        C.scale(p(e, i, h, d, E))
      ), c.push(
        C.scale(p(-n, -r, h, d, E))
      )) : (l.push(C.scale(e)), c.push(C.scale(-n))), d += E;
    }), c = c.map(function(C) {
      return u = C.points, u[3] ? C.points = [u[3], u[2], u[1], u[0]] : C.points = [u[2], u[1], u[0]], C;
    }).reverse();
    const v = l[0].points[0], x = l[a - 1].points[l[a - 1].points.length - 1], g = c[a - 1].points[c[a - 1].points.length - 1], _ = c[0].points[0], M = Ke.makeline(g, v), S = Ke.makeline(x, _), b = [M].concat(l).concat([S]).concat(c);
    return new Ka(b);
  }
  outlineshapes(e, n, i) {
    n = n || e;
    const r = this.outline(e, n).curves, o = [];
    for (let a = 1, l = r.length; a < l / 2; a++) {
      const c = Ke.makeshape(
        r[a],
        r[l - a],
        i
      );
      c.startcap.virtual = a > 1, c.endcap.virtual = a < l / 2 - 1, o.push(c);
    }
    return o;
  }
  intersects(e, n) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof fn && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      n
    )) : this.selfintersects(n);
  }
  lineIntersects(e) {
    const n = sg(e.p1.x, e.p2.x), i = sg(e.p1.y, e.p2.y), r = rg(e.p1.x, e.p2.x), o = rg(e.p1.y, e.p2.y);
    return Ke.roots(this.points, e).filter((a) => {
      var l = this.get(a);
      return Ke.between(l.x, n, r) && Ke.between(l.y, i, o);
    });
  }
  selfintersects(e) {
    const n = this.reduce(), i = n.length - 2, r = [];
    for (let o = 0, a, l, c; o < i; o++)
      l = n.slice(o, o + 1), c = n.slice(o + 2), a = this.curveintersects(l, c, e), r.push(...a);
    return r;
  }
  curveintersects(e, n, i) {
    const r = [];
    e.forEach(function(a) {
      n.forEach(function(l) {
        a.overlaps(l) && r.push({ left: a, right: l });
      });
    });
    let o = [];
    return r.forEach(function(a) {
      const l = Ke.pairiteration(
        a.left,
        a.right,
        i
      );
      l.length > 0 && (o = o.concat(l));
    }), o;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, n, i, r) {
    const o = (r - i) / 4, a = this.get(i + o), l = this.get(r - o), c = Ke.dist(e, n), u = Ke.dist(e, a), d = Ke.dist(e, l);
    return Ca(u - c) + Ca(d - c);
  }
  _iterate(e, n) {
    let i = 0, r = 1, o;
    do {
      o = 0, r = 1;
      let a = this.get(i), l, c, u, d, h = !1, m = !1, p, v = r, x = 1;
      do
        if (m = h, d = u, v = (i + r) / 2, l = this.get(v), c = this.get(r), u = Ke.getccenter(a, l, c), u.interval = {
          start: i,
          end: r
        }, h = this._error(u, a, i, r) <= e, p = m && !h, p || (x = r), h) {
          if (r >= 1) {
            if (u.interval.end = x = 1, d = u, r > 1) {
              let _ = {
                x: u.x + u.r * MV(u.e),
                y: u.y + u.r * CV(u.e)
              };
              u.e += Ke.angle({ x: u.x, y: u.y }, _, this.get(1));
            }
            break;
          }
          r = r + (r - i) / 2;
        } else
          r = v;
      while (!p && o++ < 100);
      if (o >= 100)
        break;
      d = d || u, n.push(d), i = x;
    } while (r < 1);
    return n;
  }
};
const AV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bezier: Wy
}, Symbol.toStringTag, { value: "Module" })), og = AV;
class PV {
  /**
   * @param curve - Bezier.js curve instance
   * @param resolution - Number of samples for LUT (higher = more accurate)
   */
  constructor(e, n = 1e3) {
    fe(this, "curve");
    fe(this, "lut");
    fe(this, "totalLength");
    this.curve = e, this.lut = [], this.totalLength = 0, this.buildLUT(n);
  }
  /**
   * Build the arc length lookup table
   */
  buildLUT(e) {
    let n = 0, i = this.curve.get(0);
    for (let r = 0; r <= e; r++) {
      const o = r / e, a = this.curve.get(o);
      if (r > 0) {
        const l = a.x - i.x, c = a.y - i.y;
        n += Math.sqrt(l * l + c * c);
      }
      this.lut.push({
        t: o,
        length: n
      }), i = a;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, i = this.lut.length - 1;
    for (; n < i; ) {
      const l = Math.floor((n + i) / 2);
      this.lut[l].length < e ? n = l + 1 : i = l;
    }
    const r = this.lut[n], o = this.lut[Math.max(0, n - 1)];
    if (r.length === o.length)
      return r.t;
    const a = (e - o.length) / (r.length - o.length);
    return o.t + a * (r.t - o.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e);
    return {
      point: this.curve.get(n),
      tangent: this.curve.derivative(n),
      t: n
    };
  }
  /**
   * Get evenly spaced points along the curve
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(e) {
    const n = [], i = this.totalLength / (e - 1);
    for (let r = 0; r < e; r++) {
      const o = r * i;
      n.push(this.getPointAtDistance(o));
    }
    return n;
  }
}
function RV(s) {
  if (!s || s.length < 2)
    return null;
  let e = null;
  for (const n of s) {
    const [i, ...r] = n;
    if (i === "M")
      e = { x: r[0], y: r[1] };
    else {
      if (i === "C" && e)
        return new og(
          e.x,
          e.y,
          r[0],
          r[1],
          // control point 1
          r[2],
          r[3],
          // control point 2
          r[4],
          r[5]
          // end point
        );
      if (i === "Q" && e)
        return new og(
          e.x,
          e.y,
          r[0],
          r[1],
          // control point
          r[2],
          r[3]
          // end point
        );
    }
  }
  return null;
}
const Xy = /* @__PURE__ */ Math.sqrt(3), DV = 0.5 * (Xy - 1), Ta = (3 - Xy) / 6, ag = (s) => Math.floor(s) | 0, lg = /* @__PURE__ */ new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
function kV(s = Math.random) {
  const e = IV(s), n = new Float64Array(e).map((r) => lg[r % 12 * 2]), i = new Float64Array(e).map((r) => lg[r % 12 * 2 + 1]);
  return function(o, a) {
    let l = 0, c = 0, u = 0;
    const d = (o + a) * DV, h = ag(o + d), m = ag(a + d), p = (h + m) * Ta, v = h - p, x = m - p, g = o - v, _ = a - x;
    let M, S;
    g > _ ? (M = 1, S = 0) : (M = 0, S = 1);
    const b = g - M + Ta, C = _ - S + Ta, E = g - 1 + 2 * Ta, P = _ - 1 + 2 * Ta, T = h & 255, y = m & 255;
    let w = 0.5 - g * g - _ * _;
    if (w >= 0) {
      const R = T + e[y], O = n[R], A = i[R];
      w *= w, l = w * w * (O * g + A * _);
    }
    let D = 0.5 - b * b - C * C;
    if (D >= 0) {
      const R = T + M + e[y + S], O = n[R], A = i[R];
      D *= D, c = D * D * (O * b + A * C);
    }
    let U = 0.5 - E * E - P * P;
    if (U >= 0) {
      const R = T + 1 + e[y + 1], O = n[R], A = i[R];
      U *= U, u = U * U * (O * E + A * P);
    }
    return 70 * (l + c + u);
  };
}
function IV(s) {
  const n = new Uint8Array(512);
  for (let i = 0; i < 512 / 2; i++)
    n[i] = i;
  for (let i = 0; i < 512 / 2 - 1; i++) {
    const r = i + ~~(s() * (256 - i)), o = n[i];
    n[i] = n[r], n[r] = o;
  }
  for (let i = 256; i < 512; i++)
    n[i] = n[i - 256];
  return n;
}
function LV() {
  return {
    enabled: !1,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: !0
  };
}
function FV() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: !1,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: []
  };
}
function cg() {
  return {
    blendMode: "additive",
    renderTrails: !1,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: !1,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: !1,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: LV()
  };
}
class Qf {
  constructor(e = {}) {
    fe(this, "particles", []);
    fe(this, "emitters", /* @__PURE__ */ new Map());
    fe(this, "gravityWells", /* @__PURE__ */ new Map());
    fe(this, "vortices", /* @__PURE__ */ new Map());
    fe(this, "modulations", []);
    fe(this, "config");
    fe(this, "boundaryMask", null);
    fe(this, "frameCount", 0);
    fe(this, "emissionAccumulators", /* @__PURE__ */ new Map());
    fe(this, "nextParticleId", 0);
    fe(this, "trailHistory", /* @__PURE__ */ new Map());
    // Audio reactivity state
    fe(this, "featureOverrides", /* @__PURE__ */ new Map());
    // Turbulence noise generator
    fe(this, "noise2D");
    fe(this, "noiseTime", 0);
    // Render options cache for spatial grid
    fe(this, "renderOptions", cg());
    this.config = { ...FV(), ...e }, this.noise2D = kV();
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    if (this.emitters.set(e.id, { ...e }), this.emissionAccumulators.set(e.id, 0), e.initialBurst > 0 && e.enabled) {
      const n = Math.floor(e.emissionRate * e.initialBurst * 10);
      for (let i = 0; i < n; i++)
        this.spawnParticle(e);
    }
  }
  updateEmitter(e, n) {
    const i = this.emitters.get(e);
    i && Object.assign(i, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.emissionAccumulators.delete(e);
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(e) {
    this.gravityWells.set(e.id, { ...e });
  }
  updateGravityWell(e, n) {
    const i = this.gravityWells.get(e);
    i && Object.assign(i, n);
  }
  removeGravityWell(e) {
    this.gravityWells.delete(e);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(e) {
    this.vortices.set(e.id, { ...e });
  }
  updateVortex(e, n) {
    const i = this.vortices.get(e);
    i && Object.assign(i, n);
  }
  removeVortex(e) {
    this.vortices.delete(e);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(e) {
    this.modulations.push({ ...e });
  }
  removeModulation(e) {
    const n = this.modulations.findIndex((i) => i.id === e);
    n >= 0 && this.modulations.splice(n, 1);
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(e) {
    this.boundaryMask = e;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(e, n, i) {
    const r = i ? `${i}:${e}` : `*:${e}`;
    this.featureOverrides.set(r, n);
  }
  getFeatureValue(e, n) {
    return this.featureOverrides.get(`${n}:${e}`) ?? this.featureOverrides.get(`*:${e}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(e = 1) {
    this.emitters.forEach((u, d) => {
      if (!u.enabled) return;
      const m = (this.getFeatureValue("emissionRate", d) ?? u.emissionRate) * e;
      let p = (this.emissionAccumulators.get(d) || 0) + m;
      for (; p >= 1 && this.particles.length < this.config.maxParticles; )
        this.spawnParticle(u), p -= 1;
      this.emissionAccumulators.set(d, p);
    });
    const n = this.config.windDirection * Math.PI / 180, i = Math.cos(n) * this.config.windStrength * 1e-3, r = Math.sin(n) * this.config.windStrength * 1e-3, o = this.getFeatureValue("gravity", "*") ?? this.config.gravity, a = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength, l = i * (a / Math.max(1, this.config.windStrength)), c = r * (a / Math.max(1, this.config.windStrength));
    for (let u = this.particles.length - 1; u >= 0; u--) {
      const d = this.particles[u];
      if (d.prevX = d.x, d.prevY = d.y, this.trailHistory.has(d.id)) {
        const m = this.trailHistory.get(d.id);
        m.unshift({ x: d.x, y: d.y }), m.length > 20 && m.pop();
      }
      d.vy += o * 1e-3 * e, d.vx += l * e, d.vy += c * e, this.gravityWells.forEach((m) => {
        if (!m.enabled) return;
        const p = m.x - d.x, v = m.y - d.y, x = Math.sqrt(p * p + v * v);
        if (x < m.radius && x > 1e-3) {
          let g = m.strength * 1e-4;
          switch (m.falloff) {
            case "linear":
              g *= 1 - x / m.radius;
              break;
            case "quadratic":
              g *= Math.pow(1 - x / m.radius, 2);
              break;
          }
          const _ = p / x, M = v / x;
          d.vx += _ * g * e, d.vy += M * g * e;
        }
      }), this.vortices.forEach((m) => {
        if (!m.enabled) return;
        const p = m.x - d.x, v = m.y - d.y, x = Math.sqrt(p * p + v * v);
        if (x < m.radius && x > 1e-3) {
          const g = 1 - x / m.radius, _ = m.strength * 1e-4 * g, M = p / x, S = v / x, b = -S, C = M;
          d.vx += b * _ * e, d.vy += C * _ * e;
          const E = m.inwardPull * 1e-4 * g;
          d.vx += M * E * e, d.vy += S * E * e;
        }
      }), this.applyTurbulence(d, e);
      const h = 1 - this.config.friction;
      d.vx *= h, d.vy *= h, d.x += d.vx * e, d.y += d.vy * e, this.boundaryMask && this.config.respectMaskBoundary && this.handleBoundaryCollision(d), this.handleCanvasBoundary(d), this.applyModulations(d), d.age += e, d.age > d.lifetime && (d.isSubParticle || this.triggerSubEmitters(d), this.particles.splice(u, 1), this.trailHistory.delete(d.id));
    }
    this.noiseTime += e, this.frameCount++;
  }
  spawnParticle(e) {
    if (this.particles.length >= this.config.maxParticles) return;
    const n = e.spread * Math.PI / 180, r = e.direction * Math.PI / 180 + (Math.random() - 0.5) * n, a = (e.speed + (Math.random() - 0.5) * 2 * e.speedVariance) * 1e-3, l = Math.max(1, e.size + (Math.random() - 0.5) * 2 * e.sizeVariance), c = Math.max(1, e.particleLifetime + (Math.random() - 0.5) * 2 * e.lifetimeVariance), u = {
      id: this.nextParticleId++,
      x: e.x,
      y: e.y,
      prevX: e.x,
      prevY: e.y,
      vx: Math.cos(r) * a,
      vy: Math.sin(r) * a,
      age: 0,
      lifetime: c,
      size: l,
      baseSize: l,
      color: [...e.color, 255],
      baseColor: [...e.color, 255],
      emitterId: e.id,
      isSubParticle: !1
    };
    this.particles.push(u), this.trailHistory.set(u.id, [{ x: u.x, y: u.y }]);
  }
  handleBoundaryCollision(e) {
    if (!this.boundaryMask) return;
    const n = Math.floor(e.x * this.boundaryMask.width), i = Math.floor(e.y * this.boundaryMask.height);
    if (n < 0 || n >= this.boundaryMask.width || i < 0 || i >= this.boundaryMask.height)
      return;
    const r = (i * this.boundaryMask.width + n) * 4;
    if (this.boundaryMask.data[r] < 128)
      switch (this.config.boundaryBehavior) {
        case "bounce":
          e.vx *= -0.8, e.vy *= -0.8, e.x = e.prevX, e.y = e.prevY;
          break;
        case "kill":
          e.age = e.lifetime + 1;
          break;
        case "wrap":
          e.x = Math.random(), e.y = Math.random();
          break;
      }
  }
  handleCanvasBoundary(e) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        e.x < 0 && (e.x = 0, e.vx *= -0.8), e.x > 1 && (e.x = 1, e.vx *= -0.8), e.y < 0 && (e.y = 0, e.vy *= -0.8), e.y > 1 && (e.y = 1, e.vy *= -0.8);
        break;
      case "kill":
        (e.x < -0.1 || e.x > 1.1 || e.y < -0.1 || e.y > 1.1) && (e.age = e.lifetime + 1);
        break;
      case "wrap":
        e.x < 0 && (e.x += 1), e.x > 1 && (e.x -= 1), e.y < 0 && (e.y += 1), e.y > 1 && (e.y -= 1);
        break;
    }
  }
  applyModulations(e) {
    const n = e.age / e.lifetime;
    for (const i of this.modulations) {
      if (i.emitterId !== "*" && i.emitterId !== e.emitterId) continue;
      const r = i.easing, o = ru[r] || ru.linear, a = UE(n, o), l = i.startValue + (i.endValue - i.startValue) * a;
      switch (i.property) {
        case "size":
          e.size = e.baseSize * l;
          break;
        case "speed":
          const c = Math.sqrt(e.vx * e.vx + e.vy * e.vy);
          if (c > 1e-4) {
            const u = l / Math.max(1e-4, c * 1e3);
            e.vx *= u, e.vy *= u;
          }
          break;
        case "opacity":
          e.color[3] = Math.max(0, Math.min(255, e.baseColor[3] * l));
          break;
        case "colorR":
          e.color[0] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorG":
          e.color[1] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorB":
          e.color[2] = Math.max(0, Math.min(255, l * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(e, n) {
    const i = this.config.turbulenceFields || [];
    for (const r of i) {
      if (!r.enabled) continue;
      const o = e.x * r.scale * 1e3, a = e.y * r.scale * 1e3, l = this.noiseTime * r.evolutionSpeed, c = this.noise2D(o + l, a + l) * Math.PI * 2, u = r.strength * 1e-5;
      e.vx += Math.cos(c) * u * n, e.vy += Math.sin(c) * u * n;
    }
  }
  addTurbulence(e) {
    this.config.turbulenceFields || (this.config.turbulenceFields = []), this.config.turbulenceFields.push(e);
  }
  updateTurbulence(e, n) {
    var r;
    const i = (r = this.config.turbulenceFields) == null ? void 0 : r.find((o) => o.id === e);
    i && Object.assign(i, n);
  }
  removeTurbulence(e) {
    this.config.turbulenceFields && (this.config.turbulenceFields = this.config.turbulenceFields.filter((n) => n.id !== e));
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  triggerSubEmitters(e) {
    const n = this.config.subEmitters || [];
    for (const i of n)
      if (i.enabled && !(i.parentEmitterId !== "*" && i.parentEmitterId !== e.emitterId))
        for (let r = 0; r < i.spawnCount; r++) {
          const o = (Math.random() - 0.5) * i.spread * Math.PI / 180, l = Math.atan2(e.vy, e.vx) + o, c = Math.sqrt(e.vx ** 2 + e.vy ** 2) * i.inheritVelocity, u = i.speed * 1e-3 + c, d = {
            id: this.nextParticleId++,
            x: e.x,
            y: e.y,
            prevX: e.x,
            prevY: e.y,
            vx: Math.cos(l) * u + e.vx * i.inheritVelocity,
            vy: Math.sin(l) * u + e.vy * i.inheritVelocity,
            age: 0,
            lifetime: i.lifetime * (1 + (Math.random() - 0.5) * 0.2),
            size: i.size * (1 + (Math.random() - 0.5) * i.sizeVariance / i.size),
            baseSize: i.size,
            color: [...i.color, 255],
            baseColor: [...i.color, 255],
            emitterId: i.id,
            isSubParticle: !0
          };
          this.particles.push(d), this.trailHistory.set(d.id, [{ x: d.x, y: d.y }]);
        }
  }
  addSubEmitter(e) {
    this.config.subEmitters || (this.config.subEmitters = []), this.config.subEmitters.push(e);
  }
  updateSubEmitter(e, n) {
    var r;
    const i = (r = this.config.subEmitters) == null ? void 0 : r.find((o) => o.id === e);
    i && Object.assign(i, n);
  }
  removeSubEmitter(e) {
    this.config.subEmitters && (this.config.subEmitters = this.config.subEmitters.filter((n) => n.id !== e));
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(e, n) {
    const i = this.emitters.get(e);
    if (!i || !i.enabled) return;
    const r = n ?? i.burstCount ?? 20;
    for (let o = 0; o < r; o++)
      this.spawnParticle(i);
  }
  triggerAllBursts() {
    for (const e of this.emitters.values())
      e.burstOnBeat && e.enabled && this.triggerBurst(e.id);
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    var i;
    const e = ((i = this.renderOptions.connections) == null ? void 0 : i.maxDistance) || 100, n = /* @__PURE__ */ new Map();
    for (const r of this.particles) {
      const o = Math.floor(r.x * 1e3 / e), a = Math.floor(r.y * 1e3 / e), l = `${o},${a}`;
      n.has(l) || n.set(l, []), n.get(l).push(r);
    }
    return { cellSize: e, cells: n };
  }
  getNeighborParticles(e, n) {
    const i = Math.floor(e.x * 1e3 / n.cellSize), r = Math.floor(e.y * 1e3 / n.cellSize), o = [];
    for (let a = -1; a <= 1; a++)
      for (let l = -1; l <= 1; l++) {
        const c = `${i + a},${r + l}`, u = n.cells.get(c);
        u && o.push(...u);
      }
    return o;
  }
  renderConnections(e, n, i) {
    const r = this.renderOptions.connections;
    if (!(r != null && r.enabled) || this.particles.length < 2) return;
    const o = this.buildSpatialGrid(), a = r.maxDistance / 1e3, l = a * a;
    e.lineWidth = r.lineWidth;
    for (const c of this.particles) {
      const u = this.getNeighborParticles(c, o);
      let d = 0;
      for (const h of u) {
        if (h.id <= c.id) continue;
        if (d >= r.maxConnections) break;
        const m = h.x - c.x, p = h.y - c.y, v = m * m + p * p;
        if (v < l) {
          const x = Math.sqrt(v);
          let g = r.lineOpacity;
          r.fadeByDistance && (g *= 1 - x / a);
          const _ = Math.round((c.color[0] + h.color[0]) / 2), M = Math.round((c.color[1] + h.color[1]) / 2), S = Math.round((c.color[2] + h.color[2]) / 2);
          e.strokeStyle = `rgba(${_},${M},${S},${g})`, e.beginPath(), e.moveTo(c.x * n, c.y * i), e.lineTo(h.x * n, h.y * i), e.stroke(), d++;
        }
      }
    }
  }
  reset() {
    this.particles = [], this.frameCount = 0, this.trailHistory.clear(), this.emissionAccumulators.forEach((e, n) => {
      this.emissionAccumulators.set(n, 0);
    }), this.nextParticleId = 0;
  }
  warmup() {
    for (let e = 0; e < this.config.warmupPeriod; e++)
      this.step(1);
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(e) {
    Object.assign(this.config, e);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(e, n, i, r = cg()) {
    switch (this.renderOptions = r, e.save(), r.blendMode) {
      case "additive":
        e.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        e.globalCompositeOperation = "multiply";
        break;
      case "screen":
        e.globalCompositeOperation = "screen";
        break;
      default:
        e.globalCompositeOperation = "source-over";
    }
    this.renderConnections(e, n, i);
    for (const o of this.particles) {
      const a = o.x * n, l = o.y * i, c = o.size;
      if (r.renderTrails) {
        const u = this.trailHistory.get(o.id);
        if (u && u.length > 1) {
          e.beginPath(), e.moveTo(a, l);
          const d = Math.min(u.length, r.trailLength);
          for (let h = 0; h < d; h++) {
            const m = u[h], p = o.color[3] * Math.pow(r.trailOpacityFalloff, h + 1);
            e.strokeStyle = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${p / 255})`, e.lineWidth = c * Math.pow(r.trailOpacityFalloff, h), e.lineTo(m.x * n, m.y * i);
          }
          e.stroke();
        }
      }
      r.glowEnabled ? (e.shadowBlur = r.glowRadius, e.shadowColor = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${r.glowIntensity})`) : e.shadowBlur = 0, r.motionBlur && (o.vx !== 0 || o.vy !== 0) ? this.renderParticleWithMotionBlur(e, o, a, l, c, n, i, r) : this.renderParticleShape(e, a, l, c, o.color, r.particleShape);
    }
    e.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(e, n, i, r, o, a, l, c) {
    const u = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
    if (u < 1e-4) {
      this.renderParticleShape(e, i, r, o, n.color, c.particleShape);
      return;
    }
    const d = c.motionBlurStrength * u * 500, h = Math.min(c.motionBlurSamples, 16), m = n.vx / u, p = n.vy / u, v = Math.min(d * o, o * 10);
    for (let x = 0; x < h; x++) {
      const g = x / (h - 1), _ = (1 - g * 0.8) / h, M = i - m * v * g, S = r - p * v * g, b = o * (1 - g * 0.3), C = n.color[3] / 255 * _ * h;
      e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${Math.min(1, C)})`, this.renderParticleShape(e, M, S, b, null, c.particleShape);
    }
    e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${n.color[3] / 255})`, this.renderParticleShape(e, i, r, o, n.color, c.particleShape);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(e, n, i, r, o, a) {
    switch (o && (e.fillStyle = `rgba(${o[0]}, ${o[1]}, ${o[2]}, ${o[3] / 255})`), a) {
      case "circle":
        e.beginPath(), e.arc(n, i, r / 2, 0, Math.PI * 2), e.fill();
        break;
      case "square":
        e.fillRect(n - r / 2, i - r / 2, r, r);
        break;
      case "triangle":
        e.beginPath(), e.moveTo(n, i - r / 2), e.lineTo(n - r / 2, i + r / 2), e.lineTo(n + r / 2, i + r / 2), e.closePath(), e.fill();
        break;
      case "star":
        this.drawStar(e, n, i, 5, r / 2, r / 4), e.fill();
        break;
    }
  }
  drawStar(e, n, i, r, o, a) {
    e.beginPath();
    let l = -Math.PI / 2;
    for (let c = 0; c < r; c++) {
      const u = n + Math.cos(l) * o, d = i + Math.sin(l) * o;
      c === 0 ? e.moveTo(u, d) : e.lineTo(u, d), l += Math.PI / r;
      const h = n + Math.cos(l) * a, m = i + Math.sin(l) * a;
      e.lineTo(h, m), l += Math.PI / r;
    }
    e.closePath();
  }
  renderToMask(e, n) {
    const r = new OffscreenCanvas(e, n).getContext("2d");
    r.fillStyle = "#FFFFFF", r.fillRect(0, 0, e, n);
    const o = this.renderOptions.connections;
    o != null && o.enabled && this.particles.length >= 2 && (r.strokeStyle = "#000000", r.lineWidth = o.lineWidth * 2, this.renderConnections(r, e, n)), r.fillStyle = "#000000";
    for (const a of this.particles) {
      const l = a.x * e, c = a.y * n, u = a.size * 1.5;
      r.beginPath(), r.arc(l, c, u / 2, 0, Math.PI * 2), r.fill();
    }
    return r.getImageData(0, 0, e, n);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(e) {
    const n = new Qf(e.config);
    if (e.emitters)
      for (const i of e.emitters)
        n.addEmitter(i);
    if (e.gravityWells)
      for (const i of e.gravityWells)
        n.addGravityWell(i);
    if (e.vortices)
      for (const i of e.vortices)
        n.addVortex(i);
    if (e.modulations)
      for (const i of e.modulations)
        n.addModulation(i);
    return n;
  }
}
class UV {
  constructor() {
    fe(this, "offscreenCanvas", null);
    fe(this, "ctx", null);
    fe(this, "particleSystems", /* @__PURE__ */ new Map());
  }
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(e, n) {
    const i = Math.round(e / 8) * 8, r = Math.round(n / 8) * 8, o = Math.max(256, i), a = Math.max(256, r), l = e === o && n === a;
    return {
      valid: l,
      correctedWidth: o,
      correctedHeight: a,
      message: l ? void 0 : `Adjusted to ${o}x${a} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(e, n, i) {
    const { frameCount: r } = e.composition, { width: o, height: a } = n;
    this.offscreenCanvas = new OffscreenCanvas(o, a), this.ctx = this.offscreenCanvas.getContext("2d"), this.initializeParticleSystems(e);
    const l = [];
    for (let c = 0; c < r; c++) {
      i && i({
        frame: c,
        total: r,
        percent: Math.round(c / r * 100)
      }), this.stepParticleSystemsToFrame(e, c);
      const u = await this.generateFrame(e, c, n);
      l.push(u);
    }
    return this.particleSystems.clear(), i && i({
      frame: r,
      total: r,
      percent: 100
    }), l;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(e, n, i) {
    const r = this.ctx, { width: o, height: a } = i;
    if (r.fillStyle = "#FFFFFF", r.fillRect(0, 0, o, a), i.matteMode === "include_all")
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    r.fillStyle = "#000000";
    const l = o / e.composition.width, c = a / e.composition.height, u = e.layers.filter(
      (h) => h.type === "text" && h.visible && n >= h.inPoint && n <= h.outPoint
    );
    for (const h of u)
      await this.renderTextLayerToMatte(r, h, e, n, l, c);
    const d = e.layers.filter(
      (h) => h.type === "particles" && h.visible && n >= h.inPoint && n <= h.outPoint
    );
    for (const h of d)
      this.renderParticleLayerToMatte(r, h, o, a);
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(e, n, i) {
    (!this.offscreenCanvas || this.offscreenCanvas.width !== i.width || this.offscreenCanvas.height !== i.height) && (this.offscreenCanvas = new OffscreenCanvas(i.width, i.height), this.ctx = this.offscreenCanvas.getContext("2d"));
    const r = await this.generateFrame(e, n, i);
    return URL.createObjectURL(r);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(e, n, i, r, o, a) {
    const l = n.data;
    if (!l) return;
    const c = n.properties.find((h) => h.name === "fontSize"), d = (c ? an(c, r) : l.fontSize) * Math.min(o, a);
    e.font = `${l.fontWeight} ${d}px "${l.fontFamily}"`, l.pathLayerId ? await this.renderTextOnPathToMatte(e, n, l, i, r, d, o, a) : this.renderTextBlockToMatte(e, n, l, r, d, o, a);
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(e, n, i, r, o, a, l, c) {
    const u = r.layers.find((S) => S.id === i.pathLayerId);
    if (!u || u.type !== "spline") return;
    const d = u.data;
    if (!(d != null && d.controlPoints) || d.controlPoints.length < 2) return;
    const h = this.buildPathCommands(d);
    if (!h || h.length < 2) return;
    const m = RV(h);
    if (!m) return;
    const p = new PV(m), v = n.properties.find((S) => S.name === "pathOffset"), x = v ? an(v, o) : i.pathOffset, g = p.totalLength;
    let _ = x * g;
    const M = 4 * Math.min(l, c);
    for (const S of i.text) {
      if (S === " ") {
        const D = e.measureText(" ").width;
        _ += D + i.letterSpacing;
        continue;
      }
      const b = e.measureText(S).width, C = Math.max(0, Math.min(_, g)), { point: E, tangent: P } = p.getPointAtDistance(C), T = Math.atan2(P.y, P.x), y = E.x * l, w = E.y * c;
      e.save(), e.translate(y, w), e.rotate(T), e.fillRect(
        -M,
        -a - M,
        b + M * 2,
        a + M * 2
      ), e.restore(), _ += b + i.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(e) {
    const n = e.controlPoints;
    if (!n || n.length < 2) return null;
    const i = [];
    i.push(["M", n[0].x, n[0].y]);
    for (let r = 0; r < n.length - 1; r++) {
      const o = n[r], a = n[r + 1], l = o.handleOut || { x: o.x, y: o.y }, c = a.handleIn || { x: a.x, y: a.y };
      i.push([
        "C",
        l.x,
        l.y,
        c.x,
        c.y,
        a.x,
        a.y
      ]);
    }
    return i;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(e, n, i, r, o, a, l) {
    const c = n.transform.position, u = an(c, r), d = n.transform.rotation, h = an(d, r), m = n.transform.scale, p = an(m, r);
    e.save(), e.translate(u.x * a, u.y * l), e.rotate(h * Math.PI / 180), e.scale(p.x, p.y);
    const x = e.measureText(i.text).width, g = o, _ = 4;
    e.fillRect(
      -_,
      -g - _,
      x + _ * 2,
      g + _ * 2
    ), e.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(e, n = "matte_sequence", i) {
    const r = (await Promise.resolve().then(() => uH)).default, o = new r();
    e.forEach((u, d) => {
      const h = `${n}_${String(d).padStart(4, "0")}.png`;
      o.file(h, u);
    });
    const a = await o.generateAsync(
      { type: "blob" },
      (u) => {
        i && i(Math.round(u.percent));
      }
    ), l = URL.createObjectURL(a), c = document.createElement("a");
    c.href = l, c.download = `${n}.zip`, document.body.appendChild(c), c.click(), document.body.removeChild(c), URL.revokeObjectURL(l);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(e) {
    this.particleSystems.clear();
    const n = e.layers.filter(
      (i) => i.type === "particles"
    );
    for (const i of n) {
      const r = i.data;
      if (!r) continue;
      const o = new Qf(r.systemConfig);
      for (const l of r.emitters)
        o.addEmitter(l);
      for (const l of r.gravityWells)
        o.addGravityWell(l);
      for (const l of r.vortices)
        o.addVortex(l);
      for (const l of r.modulations)
        o.addModulation(l);
      const a = r.systemConfig.warmupPeriod || 0;
      for (let l = 0; l < a; l++)
        o.step();
      this.particleSystems.set(i.id, o);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(e, n) {
    if (n !== 0)
      for (const i of e.layers) {
        if (i.type !== "particles") continue;
        const r = this.particleSystems.get(i.id);
        r && i.visible && n >= i.inPoint && n <= i.outPoint && r.step();
      }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(e, n, i, r) {
    const o = this.particleSystems.get(n.id);
    if (!o) return;
    const a = o.renderToMask(i, r), l = new OffscreenCanvas(i, r);
    l.getContext("2d").putImageData(a, 0, 0), e.globalCompositeOperation = "multiply", e.drawImage(l, 0, 0), e.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null, this.ctx = null, this.particleSystems.clear();
  }
}
const Mr = new UV(), OV = { class: "export-dialog" }, zV = { class: "dialog-header" }, NV = { class: "dialog-content" }, BV = { class: "form-group" }, VV = { class: "resolution-presets" }, GV = ["onClick"], HV = { class: "custom-resolution" }, $V = { class: "dimension-input" }, WV = { class: "dimension-input" }, XV = {
  key: 0,
  class: "dimension-warning"
}, jV = { class: "form-group" }, YV = { class: "matte-mode-options" }, qV = { class: "form-group" }, ZV = { class: "preview-container" }, KV = ["src"], JV = {
  key: 1,
  class: "preview-placeholder"
}, QV = {
  key: 0,
  class: "progress-section"
}, e7 = { class: "progress-bar" }, t7 = { class: "progress-text" }, n7 = { class: "dialog-footer" }, i7 = { class: "export-info" }, s7 = ["disabled"], r7 = ["disabled"], o7 = /* @__PURE__ */ Ot({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(s, { emit: e }) {
    const n = e, i = sn(), r = Mr.getResolutionPresets(), o = we("720p (1280x720)"), a = we(1280), l = we(720), c = we(), u = we("exclude_text"), d = we(null), h = we(!1), m = we(0), p = we(""), v = Ie(() => a.value), x = Ie(() => l.value);
    function g(b) {
      o.value = b.label, a.value = b.width, l.value = b.height, c.value = void 0;
    }
    function _() {
      const b = Mr.validateDimensions(a.value, l.value);
      if (!b.valid)
        a.value = b.correctedWidth, l.value = b.correctedHeight, c.value = b.message, o.value = "";
      else {
        c.value = void 0;
        const C = r.find(
          (E) => E.width === a.value && E.height === l.value
        );
        o.value = (C == null ? void 0 : C.label) || "";
      }
    }
    async function M() {
      if (!i.hasProject) return;
      d.value && (URL.revokeObjectURL(d.value), d.value = null);
      const b = {
        width: v.value,
        height: x.value,
        matteMode: u.value
      };
      d.value = await Mr.generatePreviewFrame(
        i.project,
        0,
        b
      );
    }
    async function S() {
      if (h.value || !i.hasProject) return;
      h.value = !0, m.value = 0, p.value = "Generating frames...";
      const b = {
        width: v.value,
        height: x.value,
        matteMode: u.value
      };
      try {
        const C = await Mr.generateMatteSequence(
          i.project,
          b,
          (E) => {
            m.value = E.percent, p.value = `Generating frame ${E.frame + 1} of ${E.total}...`;
          }
        );
        p.value = "Creating ZIP archive...", await Mr.downloadAsZip(
          C,
          `matte_${Date.now()}`,
          (E) => {
            p.value = `Compressing... ${E}%`;
          }
        ), p.value = "Export complete!", n("exported"), setTimeout(() => {
          n("close");
        }, 1e3);
      } catch (C) {
        console.error("[ExportDialog] Export failed:", C), p.value = `Export failed: ${C instanceof Error ? C.message : "Unknown error"}`;
      } finally {
        h.value = !1;
      }
    }
    return Ft(
      [v, x, u],
      () => {
        M();
      },
      { immediate: !1 }
    ), _n(() => {
      if (i.hasProject) {
        const b = Mr.validateDimensions(i.width, i.height);
        a.value = b.correctedWidth, l.value = b.correctedHeight;
        const C = r.find(
          (E) => E.width === a.value && E.height === l.value
        );
        o.value = (C == null ? void 0 : C.label) || "", b.valid || (c.value = b.message);
      }
      M();
    }), Nn(() => {
      d.value && URL.revokeObjectURL(d.value), Mr.dispose();
    }), (b, C) => (te(), ae("div", {
      class: "export-dialog-overlay",
      onClick: C[6] || (C[6] = _t((E) => n("close"), ["self"]))
    }, [
      f("div", OV, [
        f("div", zV, [
          C[8] || (C[8] = f("h3", null, "Export Matte Sequence", -1)),
          f("button", {
            class: "close-btn",
            onClick: C[0] || (C[0] = (E) => n("close"))
          }, [...C[7] || (C[7] = [
            f("i", { class: "pi pi-times" }, null, -1)
          ])])
        ]),
        f("div", NV, [
          f("div", BV, [
            C[13] || (C[13] = f("label", null, "Resolution", -1)),
            f("div", VV, [
              (te(!0), ae(qe, null, ot(Ve(r), (E) => (te(), ae("button", {
                key: E.label,
                class: Fe(["preset-btn", { active: o.value === E.label }]),
                onClick: (P) => g(E)
              }, xe(E.label), 11, GV))), 128))
            ]),
            f("div", HV, [
              f("div", $V, [
                C[9] || (C[9] = f("label", null, "Width", -1)),
                st(f("input", {
                  "onUpdate:modelValue": C[1] || (C[1] = (E) => a.value = E),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: _
                }, null, 544), [
                  [
                    Ut,
                    a.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ]),
              C[11] || (C[11] = f("span", { class: "dimension-x" }, "", -1)),
              f("div", WV, [
                C[10] || (C[10] = f("label", null, "Height", -1)),
                st(f("input", {
                  "onUpdate:modelValue": C[2] || (C[2] = (E) => l.value = E),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: _
                }, null, 544), [
                  [
                    Ut,
                    l.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ])
            ]),
            c.value ? (te(), ae("p", XV, [
              C[12] || (C[12] = f("i", { class: "pi pi-info-circle" }, null, -1)),
              ct(" " + xe(c.value), 1)
            ])) : Pe("", !0)
          ]),
          f("div", jV, [
            C[16] || (C[16] = f("label", null, "Matte Mode", -1)),
            f("div", YV, [
              f("button", {
                class: Fe(["mode-btn", { active: u.value === "exclude_text" }]),
                onClick: C[3] || (C[3] = (E) => u.value = "exclude_text")
              }, [...C[14] || (C[14] = [
                f("i", { class: "pi pi-ban" }, null, -1),
                f("span", null, "Exclude Text", -1),
                f("small", null, "Text regions are BLACK (excluded from generation)", -1)
              ])], 2),
              f("button", {
                class: Fe(["mode-btn", { active: u.value === "include_all" }]),
                onClick: C[4] || (C[4] = (E) => u.value = "include_all")
              }, [...C[15] || (C[15] = [
                f("i", { class: "pi pi-check-circle" }, null, -1),
                f("span", null, "Include All", -1),
                f("small", null, "Entire frame is WHITE (generate everything)", -1)
              ])], 2)
            ])
          ]),
          f("div", qV, [
            C[18] || (C[18] = f("label", null, "Preview (Frame 0)", -1)),
            f("div", ZV, [
              d.value ? (te(), ae("img", {
                key: 0,
                src: d.value,
                alt: "Matte preview",
                class: "preview-image"
              }, null, 8, KV)) : (te(), ae("div", JV, [...C[17] || (C[17] = [
                f("i", { class: "pi pi-image" }, null, -1),
                f("span", null, "Generating preview...", -1)
              ])]))
            ]),
            C[19] || (C[19] = f("p", { class: "preview-info" }, [
              ct(" White = Keep original / generate content"),
              f("br"),
              ct(" Black = Exclude from generation ")
            ], -1))
          ]),
          h.value ? (te(), ae("div", QV, [
            f("div", e7, [
              f("div", {
                class: "progress-fill",
                style: yt({ width: `${m.value}%` })
              }, null, 4)
            ]),
            f("p", t7, xe(p.value), 1)
          ])) : Pe("", !0)
        ]),
        f("div", n7, [
          f("div", i7, [
            f("span", null, xe(Ve(i).frameCount) + " frames @ " + xe(v.value) + "" + xe(x.value), 1)
          ]),
          f("button", {
            class: "cancel-btn",
            onClick: C[5] || (C[5] = (E) => n("close")),
            disabled: h.value
          }, " Cancel ", 8, s7),
          f("button", {
            class: "export-btn",
            onClick: S,
            disabled: h.value || !Ve(i).hasProject
          }, [
            C[20] || (C[20] = f("i", { class: "pi pi-download" }, null, -1)),
            ct(" " + xe(h.value ? "Exporting..." : "Export ZIP"), 1)
          ], 8, r7)
        ])
      ])
    ]));
  }
}), a7 = /* @__PURE__ */ Gt(o7, [["__scopeId", "data-v-34eee532"]]), l7 = {
  "wan22-i2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-t2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !1,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-fun-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-first-last": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 30,
    cfgScale: 5
  },
  "uni3c-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "uni3c-motion": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  motionctrl: {
    width: 576,
    height: 320,
    frameCount: 16,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 7.5
  },
  "motionctrl-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 3
  },
  cogvideox: {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 16,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 50,
    cfgScale: 6
  },
  "controlnet-depth": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "midas",
    controlType: "depth",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-canny": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    controlType: "canny",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-lineart": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    controlType: "lineart",
    steps: 20,
    cfgScale: 7.5
  },
  "animatediff-cameractrl": {
    width: 512,
    height: 512,
    frameCount: 16,
    fps: 8,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 7.5
  },
  "custom-workflow": {
    width: 1024,
    height: 1024,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 7
  },
  // New model targets (Dec 2025)
  "light-x": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "wan-move": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  ati: {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  ttm: {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 30,
    cfgScale: 5
  },
  "camera-comfyui": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  }
}, c7 = {
  midas: {
    format: "midas",
    bitDepth: 8,
    invert: !0,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  zoe: {
    format: "zoe",
    bitDepth: 16,
    invert: !1,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "depth-pro": {
    format: "depth-pro",
    bitDepth: 16,
    invert: !1,
    normalize: !1,
    colormap: "grayscale",
    nearClip: 0.01,
    farClip: 100
  },
  normalized: {
    format: "normalized",
    bitDepth: 8,
    invert: !1,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  }
}, u7 = [
  {
    name: "832x480 (Wan 2.2)",
    width: 832,
    height: 480,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "uni3c-camera"]
  },
  {
    name: "1280x720 (HD)",
    width: 1280,
    height: 720,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v"]
  },
  {
    name: "1024x576 (SVD)",
    width: 1024,
    height: 576,
    aspectRatio: "16:9",
    recommended: ["motionctrl-svd"]
  },
  {
    name: "576x320 (MotionCtrl)",
    width: 576,
    height: 320,
    aspectRatio: "16:9",
    recommended: ["motionctrl"]
  },
  {
    name: "720x480 (CogVideoX)",
    width: 720,
    height: 480,
    aspectRatio: "3:2",
    recommended: ["cogvideox"]
  },
  {
    name: "512x512 (Square)",
    width: 512,
    height: 512,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny", "animatediff-cameractrl"]
  },
  {
    name: "1024x1024 (Square HD)",
    width: 1024,
    height: 1024,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny"]
  }
], d7 = [
  {
    name: "16 frames (~0.7s)",
    frameCount: 16,
    duration: "0.67s",
    fps: 24,
    recommended: ["motionctrl", "animatediff-cameractrl"]
  },
  {
    name: "25 frames (~1s)",
    frameCount: 25,
    duration: "1.04s",
    fps: 24,
    recommended: ["motionctrl-svd"]
  },
  {
    name: "49 frames (~3s)",
    frameCount: 49,
    duration: "3.06s",
    fps: 16,
    recommended: ["cogvideox"]
  },
  {
    name: "81 frames (~3.4s)",
    frameCount: 81,
    duration: "3.38s",
    fps: 24,
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "uni3c-camera"]
  },
  {
    name: "121 frames (~5s)",
    frameCount: 121,
    duration: "5.04s",
    fps: 24,
    recommended: ["wan22-i2v"]
  }
], ug = {
  "wan22-i2v": {
    name: "Wan 2.2 Image-to-Video",
    description: "Generate video from a reference image with text prompt",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanImageToVideo", "WanModel", "WanVAE"]
  },
  "wan22-t2v": {
    name: "Wan 2.2 Text-to-Video",
    description: "Generate video from text prompt only",
    requiredInputs: ["prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanTextToVideo", "WanModel", "WanVAE"]
  },
  "wan22-fun-camera": {
    name: "Wan 2.2 Fun Camera",
    description: "Generate video with camera motion presets",
    requiredInputs: ["reference_image", "prompt", "camera_motion"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFunCameraToVideo", "WanModel", "WanVAE"]
  },
  "wan22-first-last": {
    name: "Wan 2.2 First+Last Frame",
    description: "Generate video interpolating between first and last frames",
    requiredInputs: ["first_frame", "last_frame", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFirstLastFrameToVideo", "WanModel", "WanVAE"]
  },
  "uni3c-camera": {
    name: "Uni3C Camera Control",
    description: "Generate video with precise 3D camera trajectory control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CCameraControl"]
  },
  "uni3c-motion": {
    name: "Uni3C Human Motion + Camera",
    description: "Generate video with human motion and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "motion_data"],
    optionalInputs: ["depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CMotionControl"]
  },
  motionctrl: {
    name: "MotionCtrl",
    description: "Camera-controlled video generation using pose matrices",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["prompt"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlLoader", "MotionCtrlSample"]
  },
  "motionctrl-svd": {
    name: "MotionCtrl SVD",
    description: "MotionCtrl for Stable Video Diffusion",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["motion_preset"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlSVDLoader", "MotionCtrlSVDSample"]
  },
  cogvideox: {
    name: "CogVideoX",
    description: "High-quality video generation from CogVideo team",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["CogVideoXLoader", "CogVideoXSampler"]
  },
  "controlnet-depth": {
    name: "ControlNet Depth",
    description: "Depth-guided image generation",
    requiredInputs: ["depth_map", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply"]
  },
  "controlnet-canny": {
    name: "ControlNet Canny",
    description: "Edge-guided image generation",
    requiredInputs: ["canny_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "CannyEdgePreprocessor"]
  },
  "controlnet-lineart": {
    name: "ControlNet LineArt",
    description: "Line art guided image generation",
    requiredInputs: ["lineart_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "LineArtPreprocessor"]
  },
  "animatediff-cameractrl": {
    name: "AnimateDiff CameraCtrl",
    description: "AnimateDiff with camera control extension",
    requiredInputs: ["reference_image", "camera_poses", "prompt"],
    optionalInputs: ["negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["AnimateDiffLoader", "CameraCtrlPoses"]
  },
  "custom-workflow": {
    name: "Custom Workflow",
    description: "Use your own ComfyUI workflow template",
    requiredInputs: ["workflow_template"],
    optionalInputs: [],
    outputTypes: ["video", "image"],
    comfyNodes: []
  },
  // New model targets (Dec 2025)
  "light-x": {
    name: "Light-X Relighting",
    description: "Video generation with relighting and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "lighting_data"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["LightXLoader", "LightXSampler"]
  },
  "wan-move": {
    name: "Wan-Move Point Trajectories",
    description: "Video generation with user-defined point trajectories",
    requiredInputs: ["reference_image", "prompt", "point_trajectories"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanMoveLoader", "WanMovePointTrajectory"]
  },
  ati: {
    name: "ATI Any Trajectory",
    description: "Any Trajectory Instruction - flexible camera/object motion",
    requiredInputs: ["reference_image", "prompt", "trajectory_instruction"],
    optionalInputs: ["negative_prompt", "camera_poses"],
    outputTypes: ["video"],
    comfyNodes: ["ATILoader", "ATISampler"]
  },
  ttm: {
    name: "TTM Time-to-Move",
    description: "Cut-and-drag video editing with temporal control",
    requiredInputs: ["reference_image", "last_frame", "drag_points"],
    optionalInputs: ["prompt", "mask"],
    outputTypes: ["video"],
    comfyNodes: ["TTMLoader", "TTMDragEditor"]
  },
  "camera-comfyui": {
    name: "Camera-ComfyUI 4x4 Matrices",
    description: "Generic camera control via 4x4 transformation matrices",
    requiredInputs: ["reference_image", "camera_matrices"],
    optionalInputs: ["prompt", "depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["CameraMatrixLoader", "CameraMatrixApply"]
  }
};
function h7(s) {
  const { width: e, height: n, nearClip: i, farClip: r, camera: o, layers: a, frame: l } = s, c = new Float32Array(e * n);
  c.fill(r);
  let u = r, d = i;
  const h = [...a].filter((m) => m.visible).sort((m, p) => {
    const v = Yd(m, l), x = Yd(p, l);
    return v - x;
  });
  for (const m of h) {
    const p = Yd(m, l), v = f7(m, l);
    if (v < 0.01) continue;
    const x = p7(m, l, o, e, n);
    if (!x) continue;
    const g = o.position.z, _ = Math.abs(p - g), M = Math.max(i, Math.min(r, _));
    u = Math.min(u, M), d = Math.max(d, M), m.type === "depthflow" && m7(m) ? v7(c, m, x, e, n, i, r) : g7(c, x, M, v, e, n);
  }
  return {
    depthBuffer: c,
    width: e,
    height: n,
    minDepth: u,
    maxDepth: d
  };
}
function Yd(s, e) {
  var i;
  const n = (i = s.transform) == null ? void 0 : i.position;
  if (!n) return 0;
  if (n.keyframes && n.keyframes.length > 0)
    return jy(n.keyframes, e, 2) || 0;
  if (n.value) {
    const r = n.value;
    if (typeof r == "object" && "z" in r)
      return r.z ?? 0;
  }
  return 0;
}
function f7(s, e) {
  var n;
  return s.opacity && "keyframes" in s.opacity && ((n = s.opacity.keyframes) == null ? void 0 : n.length) > 0 ? (jy(s.opacity.keyframes, e) || 100) / 100 : s.opacity && "value" in s.opacity ? (s.opacity.value || 100) / 100 : 1;
}
function p7(s, e, n, i, r) {
  var T, y, w;
  let o = 0, a = 0;
  const l = (T = s.transform) == null ? void 0 : T.position;
  if (l && "value" in l) {
    const D = l.value;
    Array.isArray(D) && (o = D[0] || 0, a = D[1] || 0);
  }
  const c = s.width || i, u = s.height || r;
  let d = 1, h = 1;
  const m = (y = s.transform) == null ? void 0 : y.scale;
  if (m && "value" in m) {
    const D = m.value;
    Array.isArray(D) && (d = (D[0] || 100) / 100, h = (D[1] || 100) / 100);
  }
  const p = c * d, v = u * h;
  let x = 0.5, g = 0.5;
  const _ = (w = s.transform) == null ? void 0 : w.anchorPoint;
  if (_ && "value" in _) {
    const D = _.value;
    Array.isArray(D) && (x = (D[0] || 0) / c + 0.5, g = (D[1] || 0) / u + 0.5);
  }
  const M = o - p * x + i / 2, S = a - v * g + r / 2, b = Math.max(0, Math.min(i, M)), C = Math.max(0, Math.min(r, S)), E = Math.max(0, Math.min(i - b, p - (b - M))), P = Math.max(0, Math.min(r - C, v - (C - S)));
  return E <= 0 || P <= 0 ? null : {
    x: b,
    y: C,
    width: E,
    height: P
  };
}
function m7(s) {
  return s.type === "depthflow" && !!s.depthMapData;
}
function v7(s, e, n, i, r, o, a) {
  const l = e.depthMapData, c = e.depthWidth || n.width, u = e.depthHeight || n.height;
  for (let d = 0; d < n.height; d++)
    for (let h = 0; h < n.width; h++) {
      const m = Math.floor(n.x + h), p = Math.floor(n.y + d);
      if (m < 0 || m >= i || p < 0 || p >= r) continue;
      const v = Math.floor(h / n.width * c), g = Math.floor(d / n.height * u) * c + v;
      let _;
      l instanceof Float32Array ? _ = l[g] : _ = l[g] / 255;
      const M = o + _ * (a - o), S = p * i + m;
      M < s[S] && (s[S] = M);
    }
}
function g7(s, e, n, i, r, o) {
  const a = Math.floor(e.x), l = Math.floor(e.y), c = Math.min(r, Math.ceil(e.x + e.width)), u = Math.min(o, Math.ceil(e.y + e.height));
  for (let d = l; d < u; d++)
    for (let h = a; h < c; h++) {
      const m = d * r + h;
      i > 0.5 && n < s[m] && (s[m] = n);
    }
}
function jy(s, e, n) {
  if (!s || s.length === 0) return null;
  let i = s[0], r = s[s.length - 1];
  for (let c = 0; c < s.length; c++)
    if (s[c].frame <= e && (i = s[c]), s[c].frame >= e && c < s.length) {
      r = s[c];
      break;
    }
  if (i.frame === r.frame) {
    const c = i.value;
    return n !== void 0 && Array.isArray(c) ? c[n] : c;
  }
  const o = (e - i.frame) / (r.frame - i.frame), a = n !== void 0 && Array.isArray(i.value) ? i.value[n] : i.value, l = n !== void 0 && Array.isArray(r.value) ? r.value[n] : r.value;
  return a + (l - a) * o;
}
function y7(s, e) {
  const n = c7[e], { depthBuffer: i, width: r, height: o, minDepth: a, maxDepth: l } = s, c = r * o;
  if (n.bitDepth === 16) {
    const u = new Uint16Array(c);
    for (let d = 0; d < c; d++) {
      let h;
      n.normalize ? h = (i[d] - a) / (l - a) : h = i[d] / n.farClip, n.invert && (h = 1 - h), u[d] = Math.max(0, Math.min(65535, Math.round(h * 65535)));
    }
    return u;
  } else {
    const u = new Uint8Array(c);
    for (let d = 0; d < c; d++) {
      let h = (i[d] - a) / (l - a);
      n.invert && (h = 1 - h), u[d] = Math.max(0, Math.min(255, Math.round(h * 255)));
    }
    return u;
  }
}
function _7(s, e, n) {
  const i = new ImageData(e, n), r = s instanceof Uint16Array;
  for (let o = 0; o < e * n; o++) {
    const a = r ? Math.floor(s[o] / 256) : s[o], l = o * 4;
    i.data[l] = a, i.data[l + 1] = a, i.data[l + 2] = a, i.data[l + 3] = 255;
  }
  return i;
}
const Sc = qo("ComfyUI");
class x7 {
  constructor(e) {
    fe(this, "serverAddress");
    fe(this, "clientId");
    fe(this, "ws", null);
    fe(this, "messageHandlers", /* @__PURE__ */ new Map());
    this.serverAddress = e.serverAddress.replace(/\/$/, ""), this.clientId = e.clientId || this.generateClientId();
  }
  generateClientId() {
    return "weyl_" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }
  // ============================================================================
  // HTTP Endpoints
  // ============================================================================
  /**
   * Check server connectivity
   */
  async checkConnection() {
    try {
      return (await fetch(`http://${this.serverAddress}/system_stats`, {
        method: "GET",
        signal: AbortSignal.timeout(5e3)
      })).ok;
    } catch {
      return !1;
    }
  }
  /**
   * Get system stats (GPU, memory, etc.)
   */
  async getSystemStats() {
    try {
      const e = await fetch(`http://${this.serverAddress}/system_stats`);
      return e.ok ? e.json() : null;
    } catch {
      return null;
    }
  }
  /**
   * Get queue status
   */
  async getQueueStatus() {
    try {
      const e = await fetch(`http://${this.serverAddress}/prompt`);
      return e.ok ? e.json() : null;
    } catch {
      return null;
    }
  }
  /**
   * Upload image to ComfyUI input folder
   */
  async uploadImage(e, n, i = "input", r, o = !0) {
    const a = new FormData();
    a.append("image", e, n), a.append("type", i), a.append("overwrite", o.toString()), r && a.append("subfolder", r);
    const l = await fetch(`http://${this.serverAddress}/upload/image`, {
      method: "POST",
      body: a
    });
    if (!l.ok) {
      const c = await l.text();
      throw new Error(`Failed to upload image: ${c}`);
    }
    return l.json();
  }
  /**
   * Upload mask image
   */
  async uploadMask(e, n, i) {
    const r = new FormData();
    r.append("image", e, n), r.append("original_ref", JSON.stringify(i)), r.append("type", "input");
    const o = await fetch(`http://${this.serverAddress}/upload/mask`, {
      method: "POST",
      body: r
    });
    if (!o.ok)
      throw new Error(`Failed to upload mask: ${await o.text()}`);
    return o.json();
  }
  /**
   * Queue a workflow for execution
   */
  async queuePrompt(e, n) {
    const i = {
      prompt: e,
      client_id: this.clientId,
      extra_data: n
    }, r = await fetch(`http://${this.serverAddress}/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(i)
    });
    if (!r.ok) {
      const o = await r.text();
      throw new Error(`Failed to queue prompt: ${o}`);
    }
    return r.json();
  }
  /**
   * Get execution history for a prompt
   */
  async getHistory(e) {
    const n = e ? `http://${this.serverAddress}/history/${e}` : `http://${this.serverAddress}/history`, i = await fetch(n);
    if (!i.ok)
      throw new Error(`Failed to get history: ${await i.text()}`);
    return i.json();
  }
  /**
   * Get a specific output image/video
   */
  async getOutput(e, n = "", i = "output") {
    const r = new URLSearchParams({
      filename: e,
      subfolder: n,
      type: i
    }), o = await fetch(`http://${this.serverAddress}/view?${r}`);
    if (!o.ok)
      throw new Error(`Failed to get output: ${await o.text()}`);
    return o.blob();
  }
  /**
   * Get output as data URL
   */
  async getOutputAsDataURL(e, n = "", i = "output") {
    const r = await this.getOutput(e, n, i);
    return new Promise((o, a) => {
      const l = new FileReader();
      l.onloadend = () => o(l.result), l.onerror = a, l.readAsDataURL(r);
    });
  }
  /**
   * Cancel current execution
   */
  async interrupt() {
    const e = await fetch(`http://${this.serverAddress}/interrupt`, {
      method: "POST"
    });
    if (!e.ok)
      throw new Error(`Failed to interrupt: ${await e.text()}`);
  }
  /**
   * Clear queue
   */
  async clearQueue() {
    const e = await fetch(`http://${this.serverAddress}/queue`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ clear: !0 })
    });
    if (!e.ok)
      throw new Error(`Failed to clear queue: ${await e.text()}`);
  }
  /**
   * Delete item from queue
   */
  async deleteFromQueue(e, n) {
    const i = await fetch(`http://${this.serverAddress}/${e}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ delete: n })
    });
    if (!i.ok)
      throw new Error(`Failed to delete from ${e}: ${await i.text()}`);
  }
  /**
   * Get available models
   */
  async getModels(e) {
    const n = {
      checkpoints: "checkpoints",
      loras: "loras",
      vae: "vae",
      controlnet: "controlnet"
    }, i = await fetch(
      `http://${this.serverAddress}/models/${n[e]}`
    );
    return i.ok ? i.json() : [];
  }
  /**
   * Get available ControlNet models
   */
  async getControlNetModels() {
    return this.getModels("controlnet");
  }
  // ============================================================================
  // WebSocket Connection
  // ============================================================================
  /**
   * Connect WebSocket for real-time progress updates
   */
  connectWebSocket() {
    return new Promise((e, n) => {
      const i = `ws://${this.serverAddress}/ws?clientId=${this.clientId}`;
      this.ws = new WebSocket(i), this.ws.onopen = () => {
        Sc.debug("WebSocket connected"), e();
      }, this.ws.onerror = (r) => {
        Sc.error("WebSocket error:", r), n(new Error("WebSocket connection failed"));
      }, this.ws.onclose = () => {
        Sc.debug("WebSocket disconnected"), this.ws = null;
      }, this.ws.onmessage = (r) => {
        try {
          const o = JSON.parse(r.data);
          this.handleWebSocketMessage(o);
        } catch (o) {
          Sc.error("Failed to parse WebSocket message:", o);
        }
      };
    });
  }
  /**
   * Disconnect WebSocket
   */
  disconnectWebSocket() {
    this.ws && (this.ws.close(), this.ws = null), this.messageHandlers.clear();
  }
  /**
   * Check if WebSocket is connected
   */
  isWebSocketConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
  /**
   * Register a message handler for a specific message type
   */
  onMessage(e, n) {
    this.messageHandlers.set(e, n);
  }
  /**
   * Remove a message handler
   */
  offMessage(e) {
    this.messageHandlers.delete(e);
  }
  handleWebSocketMessage(e) {
    const { type: n } = e, i = this.messageHandlers.get(n);
    i && i(e);
    const r = this.messageHandlers.get("all");
    r && r(e);
  }
  // ============================================================================
  // Convenience Methods
  // ============================================================================
  /**
   * Upload an ImageData object as PNG
   */
  async uploadImageData(e, n, i) {
    const r = new OffscreenCanvas(e.width, e.height);
    r.getContext("2d").putImageData(e, 0, 0);
    const a = await r.convertToBlob({ type: "image/png" });
    return this.uploadImage(a, n, "input", i);
  }
  /**
   * Upload a canvas as PNG
   */
  async uploadCanvas(e, n, i) {
    let r;
    return e instanceof OffscreenCanvas ? r = await e.convertToBlob({ type: "image/png" }) : r = await new Promise((o, a) => {
      e.toBlob((l) => {
        l ? o(l) : a(new Error("Failed to convert canvas to blob"));
      }, "image/png");
    }), this.uploadImage(r, n, "input", i);
  }
  /**
   * Wait for a prompt to complete
   */
  async waitForPrompt(e, n, i = 3e5) {
    const r = Date.now();
    return this.isWebSocketConnected() || await this.connectWebSocket(), new Promise((o, a) => {
      let l = !1;
      const c = () => {
        this.offMessage("progress"), this.offMessage("executing"), this.offMessage("executed"), this.offMessage("execution_error");
      }, u = () => {
        Date.now() - r > i && (c(), a(new Error("Prompt execution timed out")));
      };
      this.onMessage("progress", (d) => {
        u(), n == null || n({
          status: "executing",
          currentStep: d.data.value,
          totalSteps: d.data.max,
          percentage: d.data.value / d.data.max * 100
        });
      }), this.onMessage("executing", (d) => {
        u(), d.data.prompt_id === e && (n == null || n({
          status: "executing",
          currentNode: d.data.node,
          percentage: 10
          // Approximate
        }));
      }), this.onMessage("executed", async (d) => {
        if (d.data.prompt_id === e && !l) {
          l = !0, c(), n == null || n({
            status: "completed",
            percentage: 100
          });
          const h = await this.getHistory(e);
          o(h[e]);
        }
      }), this.onMessage("execution_error", (d) => {
        d.data.prompt_id === e && (c(), n == null || n({
          status: "error",
          percentage: 0
        }), a(new Error(d.data.exception_message || "Execution failed")));
      });
    });
  }
  /**
   * Execute a workflow and wait for completion
   */
  async executeWorkflow(e, n) {
    const { prompt_id: i } = await this.queuePrompt(e);
    n == null || n({
      status: "queued",
      percentage: 0
    });
    const r = await this.waitForPrompt(i, n), o = [];
    for (const a of Object.values(r.outputs))
      a.images && o.push(...a.images), a.gifs && o.push(...a.gifs);
    return {
      promptId: i,
      history: r,
      outputs: o
    };
  }
  // ============================================================================
  // Getters
  // ============================================================================
  get server() {
    return this.serverAddress;
  }
  get id() {
    return this.clientId;
  }
}
let Mc = null;
function So(s) {
  return (!Mc || s && s !== Mc.server) && (Mc = new x7({
    serverAddress: s || "127.0.0.1:8188"
  })), Mc;
}
let Yy = 1;
function Us() {
  Yy = 1;
}
function vt() {
  return String(Yy++);
}
function ft(s, e, n) {
  const i = {
    class_type: s,
    inputs: e
  };
  return n && (i._meta = { title: n }), i;
}
function We(s, e = 0) {
  return [s, e];
}
function ep(s, e) {
  const n = vt();
  return s[n] = ft("CheckpointLoaderSimple", {
    ckpt_name: e
  }, "Load Checkpoint"), n;
}
function jo(s, e, n, i) {
  const r = vt();
  return s[r] = ft("CLIPTextEncode", {
    clip: e,
    text: n
  }, i), r;
}
function ar(s, e, n) {
  const i = vt();
  return s[i] = ft("LoadImage", {
    image: e
  }, n || "Load Image"), i;
}
function lr(s, e, n, i) {
  const r = vt();
  return s[r] = ft("ImageResize", {
    image: e,
    width: n,
    height: i,
    interpolation: "lanczos",
    method: "fill / crop",
    condition: "always",
    multiple_of: 8
  }, "Resize Image"), r;
}
function b7(s, e, n) {
  const i = vt();
  return s[i] = ft("VAEEncode", {
    pixels: e,
    vae: n
  }, "VAE Encode"), i;
}
function El(s, e, n) {
  const i = vt();
  return s[i] = ft("VAEDecode", {
    samples: e,
    vae: n
  }, "VAE Decode"), i;
}
function Tl(s, e, n, i, r, o) {
  const a = vt();
  return s[a] = ft("KSampler", {
    model: e,
    positive: n,
    negative: i,
    latent_image: r,
    seed: o.seed ?? Math.floor(Math.random() * 2147483647),
    steps: o.steps ?? 20,
    cfg: o.cfg ?? 7,
    sampler_name: "euler",
    scheduler: "normal",
    denoise: o.denoise ?? 1
  }, "KSampler"), a;
}
function Os(s, e, n) {
  const i = vt();
  return s[i] = ft("VHS_VideoCombine", {
    images: e,
    frame_rate: n.fps,
    loop_count: 0,
    filename_prefix: n.filename || "weyl_output",
    format: n.format || "video/h264-mp4",
    pingpong: !1,
    save_output: !0,
    audio: null,
    meta_batch: null
  }, "Video Output"), i;
}
function dg(s) {
  Us();
  const e = {}, n = s.width > 640 || s.height > 640, i = s.wanModel || (n ? "i2v_720p" : "i2v_480p"), r = vt();
  e[r] = ft("DownloadAndLoadWan2_1Model", {
    model: `wan2.1_${i}_bf16.safetensors`,
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Model");
  const o = vt();
  e[o] = ft("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const a = vt();
  e[a] = ft("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const l = ar(e, s.referenceImage || "input.png", "Reference Image"), c = lr(e, We(l), s.width, s.height), u = vt();
  e[u] = ft("WanTextEncode", {
    text_encoder: We(a),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const d = vt();
  e[d] = ft("WanImageToVideo", {
    wan_model: We(r),
    positive: We(u),
    image: We(c),
    vae: We(o),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE",
    denoise_strength: s.denoise || 1
  }, "I2V Generation");
  const h = vt();
  return e[h] = ft("WanVAEDecode", {
    vae: We(o),
    samples: We(d),
    enable_vae_tiling: !0,
    tile_sample_min_height: 240,
    tile_sample_min_width: 240,
    tile_overlap_factor_height: 0.2,
    tile_overlap_factor_width: 0.2
  }, "VAE Decode"), Os(e, We(h), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_i2v"
  }), e;
}
function w7(s) {
  Us();
  const e = {}, n = vt();
  e[n] = ft("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_fun_camera_control_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Fun Camera");
  const i = vt();
  e[i] = ft("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const r = vt();
  e[r] = ft("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const o = ar(e, s.referenceImage || "input.png", "Reference Image"), a = lr(e, We(o), s.width, s.height), l = vt();
  e[l] = ft("WanTextEncode", {
    text_encoder: We(r),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const c = vt();
  e[c] = ft("WanFunCameraMotion", {
    motion_type: s.cameraMotion || "Static",
    length: s.frameCount
  }, "Camera Motion");
  const u = vt();
  e[u] = ft("WanFunCameraI2V", {
    wan_model: We(n),
    positive: We(l),
    image: We(a),
    camera_motion: We(c),
    vae: We(i),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "Fun Camera I2V");
  const d = vt();
  return e[d] = ft("WanVAEDecode", {
    vae: We(i),
    samples: We(u),
    enable_vae_tiling: !0
  }, "VAE Decode"), Os(e, We(d), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_fun_camera"
  }), e;
}
function S7(s) {
  Us();
  const e = {}, n = vt();
  e[n] = ft("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_flf2v_720p_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan FLF2V");
  const i = vt();
  e[i] = ft("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load VAE");
  const r = vt();
  e[r] = ft("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const o = ar(e, s.referenceImage || "first.png", "First Frame"), a = ar(e, s.lastFrameImage || "last.png", "Last Frame"), l = lr(e, We(o), s.width, s.height), c = lr(e, We(a), s.width, s.height), u = vt();
  e[u] = ft("WanTextEncode", {
    text_encoder: We(r),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const d = vt();
  e[d] = ft("WanFirstLastFrameToVideo", {
    wan_model: We(n),
    positive: We(u),
    first_frame: We(l),
    last_frame: We(c),
    vae: We(i),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "First+Last I2V");
  const h = vt();
  return e[h] = ft("WanVAEDecode", {
    vae: We(i),
    samples: We(d),
    enable_vae_tiling: !0
  }, "VAE Decode"), Os(e, We(h), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_flf"
  }), e;
}
function M7(s) {
  var h;
  Us();
  const e = {}, n = vt();
  e[n] = ft("DownloadAndLoadUni3CModel", {
    model: "uni3c_camera_control.safetensors",
    precision: "bf16"
  }, "Load Uni3C");
  const i = vt();
  e[i] = ft("ImageOnlyCheckpointLoader", {
    ckpt_name: s.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const r = ar(e, s.referenceImage || "input.png", "Reference Image"), o = lr(e, We(r), s.width, s.height), a = vt();
  s.trajType === "custom" && ((h = s.cameraData) != null && h.trajectory) ? e[a] = ft("Uni3CCustomTrajectory", {
    trajectory_data: JSON.stringify(s.cameraData.trajectory),
    length: s.frameCount
  }, "Custom Trajectory") : e[a] = ft("Uni3CPresetTrajectory", {
    traj_type: s.trajType || "orbit",
    length: s.frameCount
  }, "Preset Trajectory");
  const l = vt();
  e[l] = ft("ApplyUni3CCameraControl", {
    model: We(i),
    uni3c: We(n),
    trajectory: We(a),
    image: We(o),
    control_strength: 1
  }, "Apply Camera Control");
  const c = vt();
  e[c] = ft("SVDEncode", {
    model: We(l),
    image: We(o),
    vae: We(i, 2),
    width: s.width,
    height: s.height,
    video_frames: s.frameCount,
    motion_bucket_id: 127,
    fps: s.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const u = Tl(
    e,
    We(l),
    We(c, 1),
    We(c, 2),
    We(c),
    { seed: s.seed, steps: s.steps || 25, cfg: s.cfgScale || 2.5, denoise: 1 }
  ), d = El(e, We(u), We(i, 2));
  return Os(e, We(d), {
    fps: s.fps,
    filename: s.outputFilename || "uni3c_output"
  }), e;
}
function C7(s) {
  Us();
  const e = {}, n = vt();
  e[n] = ft("LoadMotionCtrl", {
    model: "motionctrl.pth"
  }, "Load MotionCtrl");
  const i = vt();
  e[i] = ft("ImageOnlyCheckpointLoader", {
    ckpt_name: s.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const r = ar(e, s.referenceImage || "input.png", "Reference Image"), o = lr(e, We(r), s.width, s.height), a = vt();
  s.cameraPoses ? e[a] = ft("MotionCtrlCameraPoses", {
    poses: JSON.stringify(s.cameraPoses)
  }, "Camera Poses") : e[a] = ft("MotionCtrlPresetPoses", {
    preset: s.motionPreset || "static",
    length: s.frameCount
  }, "Preset Poses");
  const l = vt();
  e[l] = ft("ApplyMotionCtrl", {
    model: We(i),
    motion_ctrl: We(n),
    camera_poses: We(a),
    control_strength: 1
  }, "Apply MotionCtrl");
  const c = vt();
  e[c] = ft("SVDEncode", {
    model: We(l),
    image: We(o),
    vae: We(i, 2),
    width: s.width,
    height: s.height,
    video_frames: s.frameCount,
    motion_bucket_id: 127,
    fps: s.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const u = Tl(
    e,
    We(l),
    We(c, 1),
    We(c, 2),
    We(c),
    { seed: s.seed, steps: s.steps || 25, cfg: s.cfgScale || 2.5 }
  ), d = El(e, We(u), We(i, 2));
  return Os(e, We(d), {
    fps: s.fps,
    filename: s.outputFilename || "motionctrl_output"
  }), e;
}
function E7(s) {
  Us();
  const e = {}, n = ep(e, s.checkpoint || "sd_xl_base_1.0.safetensors"), i = vt();
  e[i] = ft("ControlNetLoader", {
    control_net_name: s.controlnetModel || "control_v11f1p_sd15_depth.pth"
  }, "Load ControlNet Depth");
  const r = vt();
  e[r] = ft("VHS_LoadImages", {
    directory: "depth_sequence",
    image_load_cap: s.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Depth Sequence");
  const o = ar(e, s.referenceImage || "reference.png", "Reference Image"), a = lr(e, We(o), s.width, s.height), l = jo(e, We(n, 1), s.prompt, "Positive"), c = jo(e, We(n, 1), s.negativePrompt, "Negative"), u = vt();
  e[u] = ft("ControlNetApply", {
    conditioning: We(l),
    control_net: We(i),
    image: We(r),
    strength: 1
  }, "Apply ControlNet");
  const d = b7(e, We(a), We(n, 2)), h = Tl(
    e,
    We(n),
    We(u),
    We(c),
    We(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7, denoise: s.denoise || 0.75 }
  ), m = El(e, We(h), We(n, 2));
  return Os(e, We(m), {
    fps: s.fps,
    filename: s.outputFilename || "controlnet_depth"
  }), e;
}
function T7(s) {
  Us();
  const e = {}, n = ep(e, s.checkpoint || "dreamshaper_8.safetensors"), i = vt();
  e[i] = ft("ADE_LoadAnimateDiffModel", {
    model_name: "mm_sd_v15_v2.ckpt"
  }, "Load AnimateDiff");
  const r = vt();
  e[r] = ft("ADE_LoadCameraCtrlModel", {
    model_name: "cameractrl_v10.ckpt"
  }, "Load CameraCtrl");
  const o = vt();
  s.cameraPoses ? e[o] = ft("ADE_CameraCtrlPoses", {
    poses: JSON.stringify(s.cameraPoses)
  }, "Camera Poses") : e[o] = ft("ADE_CameraCtrlPreset", {
    motion_type: s.cameraMotion || "Static",
    speed: 1,
    frame_length: s.frameCount
  }, "Camera Preset");
  const a = vt();
  e[a] = ft("ADE_ApplyAnimateDiffModel", {
    model: We(n),
    motion_model: We(i)
  }, "Apply AnimateDiff");
  const l = vt();
  e[l] = ft("ADE_ApplyCameraCtrl", {
    model: We(a),
    cameractrl: We(r),
    poses: We(o)
  }, "Apply CameraCtrl");
  const c = jo(e, We(n, 1), s.prompt, "Positive"), u = jo(e, We(n, 1), s.negativePrompt, "Negative"), d = vt();
  e[d] = ft("EmptyLatentImage", {
    width: s.width,
    height: s.height,
    batch_size: s.frameCount
  }, "Empty Latent");
  const h = Tl(
    e,
    We(l),
    We(c),
    We(u),
    We(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7 }
  ), m = El(e, We(h), We(n, 2));
  return Os(e, We(m), {
    fps: s.fps,
    filename: s.outputFilename || "animatediff_cameractrl"
  }), e;
}
function A7(s) {
  Us();
  const e = {}, n = vt();
  e[n] = ft("DownloadAndLoadCogVideoModel", {
    model: "CogVideoX-5b-I2V",
    precision: "bf16"
  }, "Load CogVideoX");
  const i = vt();
  e[i] = ft("DownloadAndLoadCogVideoTextEncoder", {
    model: "t5-v1_1-xxl-encoder-bf16",
    precision: "bf16"
  }, "Load T5 Encoder");
  const r = vt();
  e[r] = ft("DownloadAndLoadCogVideoVAE", {
    model: "cogvideox_vae",
    precision: "bf16"
  }, "Load CogVideo VAE");
  const o = ar(e, s.referenceImage || "input.png", "Reference Image"), a = lr(e, We(o), s.width, s.height), l = vt();
  e[l] = ft("CogVideoTextEncode", {
    text_encoder: We(i),
    prompt: s.prompt,
    force_offload: !0
  }, "Encode Prompt");
  const c = vt();
  e[c] = ft("CogVideoImageToVideo", {
    model: We(n),
    positive: We(l),
    image: We(a),
    vae: We(r),
    width: s.width,
    height: s.height,
    num_frames: s.frameCount,
    steps: s.steps || 50,
    cfg: s.cfgScale || 6,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "CogVideoX DDIM"
  }, "CogVideoX I2V");
  const u = vt();
  return e[u] = ft("CogVideoDecode", {
    vae: We(r),
    samples: We(c),
    enable_vae_tiling: !0
  }, "Decode Video"), Os(e, We(u), {
    fps: s.fps,
    filename: s.outputFilename || "cogvideox_output"
  }), e;
}
function hg(s, e) {
  Us();
  const n = {}, i = {
    canny: "control_v11p_sd15_canny.pth",
    lineart: "control_v11p_sd15_lineart.pth",
    softedge: "control_v11p_sd15_softedge.pth",
    normal: "control_v11p_sd15_normalbae.pth",
    seg: "control_v11p_sd15_seg.pth"
  }, r = ep(n, s.checkpoint || "v1-5-pruned-emaonly.safetensors"), o = vt();
  n[o] = ft("ControlNetLoader", {
    control_net_name: s.controlnetModel || i[e]
  }, `Load ControlNet ${e}`);
  const a = vt();
  n[a] = ft("VHS_LoadImages", {
    directory: "control_sequence",
    image_load_cap: s.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Control Sequence");
  const l = jo(n, We(r, 1), s.prompt, "Positive"), c = jo(n, We(r, 1), s.negativePrompt, "Negative"), u = vt();
  n[u] = ft("ControlNetApply", {
    conditioning: We(l),
    control_net: We(o),
    image: We(a),
    strength: 1
  }, "Apply ControlNet");
  const d = vt();
  n[d] = ft("EmptyLatentImage", {
    width: s.width,
    height: s.height,
    batch_size: s.frameCount
  }, "Empty Latent");
  const h = Tl(
    n,
    We(r),
    We(u),
    We(c),
    We(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7 }
  ), m = El(n, We(h), We(r, 2));
  return Os(n, We(m), {
    fps: s.fps,
    filename: s.outputFilename || `controlnet_${e}`
  }), n;
}
function P7(s, e) {
  switch (s) {
    case "wan22-i2v":
      return dg(e);
    case "wan22-t2v":
      return dg({ ...e, referenceImage: void 0 });
    case "wan22-fun-camera":
      return w7(e);
    case "wan22-first-last":
      return S7(e);
    case "uni3c-camera":
    case "uni3c-motion":
      return M7(e);
    case "motionctrl":
    case "motionctrl-svd":
      return C7(e);
    case "cogvideox":
      return A7(e);
    case "controlnet-depth":
      return E7(e);
    case "controlnet-canny":
      return hg(e, "canny");
    case "controlnet-lineart":
      return hg(e, "lineart");
    case "animatediff-cameractrl":
      return T7(e);
    case "custom-workflow":
      return {};
    default:
      throw new Error(`Unknown export target: ${s}`);
  }
}
function R7(s) {
  const e = [], n = [], i = Object.keys(s);
  for (const [o, a] of Object.entries(s)) {
    a.class_type || e.push(`Node ${o}: missing class_type`);
    for (const [l, c] of Object.entries(a.inputs))
      if (Array.isArray(c) && c.length === 2) {
        const [u] = c;
        typeof u == "string" && !i.includes(u) && e.push(`Node ${o}.${l}: references non-existent node ${u}`);
      }
  }
  return Object.values(s).some(
    (o) => o.class_type.includes("Save") || o.class_type.includes("Output") || o.class_type.includes("Preview")
  ) || n.push("Workflow has no output/save nodes"), {
    valid: e.length === 0,
    errors: e,
    warnings: n
  };
}
class D7 {
  constructor(e) {
    fe(this, "layers");
    fe(this, "cameraKeyframes");
    fe(this, "config");
    fe(this, "onProgress");
    fe(this, "abortSignal");
    fe(this, "aborted", !1);
    this.layers = e.layers, this.cameraKeyframes = e.cameraKeyframes, this.config = e.config, this.onProgress = e.onProgress || (() => {
    }), this.abortSignal = e.abortSignal, this.abortSignal && this.abortSignal.addEventListener("abort", () => {
      this.aborted = !0;
    });
  }
  checkAborted() {
    if (this.aborted)
      throw new Error("Export aborted");
  }
  updateProgress(e) {
    this.onProgress({
      stage: "preparing",
      stageProgress: 0,
      overallProgress: 0,
      message: "",
      ...e
    });
  }
  // ============================================================================
  // Main Export Method
  // ============================================================================
  async execute() {
    const e = Date.now(), n = {
      success: !1,
      outputFiles: {},
      errors: [],
      warnings: [],
      duration: 0
    };
    try {
      this.updateProgress({
        stage: "preparing",
        stageProgress: 0,
        overallProgress: 0,
        message: "Preparing export..."
      });
      const i = this.validateConfig();
      if (i.length > 0)
        return n.errors = i, n;
      this.config.exportReferenceFrame && (this.checkAborted(), await this.renderReferenceFrame(n)), this.config.exportLastFrame && (this.checkAborted(), await this.renderLastFrame(n)), this.config.exportDepthMap && (this.checkAborted(), await this.renderDepthSequence(n)), this.config.exportControlImages && (this.checkAborted(), await this.renderControlSequence(n)), this.config.exportCameraData && (this.checkAborted(), await this.exportCameraData(n)), this.checkAborted(), await this.generateWorkflow(n), this.config.autoQueueWorkflow && this.config.comfyuiServer && (this.checkAborted(), await this.queueWorkflow(n)), n.success = n.errors.length === 0;
    } catch (i) {
      i instanceof Error && i.message === "Export aborted" ? n.errors.push("Export was cancelled") : n.errors.push(i instanceof Error ? i.message : "Unknown error");
    }
    return n.duration = Date.now() - e, n;
  }
  // ============================================================================
  // Validation
  // ============================================================================
  validateConfig() {
    const e = [];
    return (this.config.width < 64 || this.config.width > 4096) && e.push("Width must be between 64 and 4096"), (this.config.height < 64 || this.config.height > 4096) && e.push("Height must be between 64 and 4096"), (this.config.frameCount < 1 || this.config.frameCount > 1e3) && e.push("Frame count must be between 1 and 1000"), (this.config.fps < 1 || this.config.fps > 120) && e.push("FPS must be between 1 and 120"), (this.config.startFrame < 0 || this.config.startFrame >= this.config.frameCount) && e.push("Invalid start frame"), (this.config.endFrame <= this.config.startFrame || this.config.endFrame > this.config.frameCount) && e.push("Invalid end frame"), !this.config.prompt && this.needsPrompt() && e.push("Prompt is required for this export target"), e;
  }
  needsPrompt() {
    return !["controlnet-depth", "controlnet-canny", "controlnet-lineart"].includes(this.config.target);
  }
  // ============================================================================
  // Frame Rendering
  // ============================================================================
  async renderReferenceFrame(e) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 5,
      message: "Rendering reference frame..."
    });
    const n = new OffscreenCanvas(this.config.width, this.config.height), i = n.getContext("2d");
    await this.renderFrameToCanvas(i, this.config.startFrame);
    const r = await n.convertToBlob({ type: "image/png" }), o = `${this.config.filenamePrefix}_reference.png`;
    if (this.config.comfyuiServer) {
      const l = await So(this.config.comfyuiServer).uploadImage(r, o);
      e.outputFiles.referenceImage = l.name;
    } else
      e.outputFiles.referenceImage = await this.saveBlobLocally(r, o);
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 10,
      message: "Reference frame complete"
    });
  }
  async renderLastFrame(e) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 12,
      message: "Rendering last frame..."
    });
    const n = new OffscreenCanvas(this.config.width, this.config.height), i = n.getContext("2d");
    await this.renderFrameToCanvas(i, this.config.endFrame - 1);
    const r = await n.convertToBlob({ type: "image/png" }), o = `${this.config.filenamePrefix}_last.png`;
    if (this.config.comfyuiServer) {
      const l = await So(this.config.comfyuiServer).uploadImage(r, o);
      e.outputFiles.lastImage = l.name;
    } else
      e.outputFiles.lastImage = await this.saveBlobLocally(r, o);
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 15,
      message: "Last frame complete"
    });
  }
  async renderFrameToCanvas(e, n) {
    e.clearRect(0, 0, e.canvas.width, e.canvas.height);
    const i = [...this.layers].filter((r) => r.visible).sort((r, o) => {
      var c, u, d, h, m, p;
      const a = ((d = (u = (c = r.transform) == null ? void 0 : c.position) == null ? void 0 : u.value) == null ? void 0 : d.z) ?? 0, l = ((p = (m = (h = o.transform) == null ? void 0 : h.position) == null ? void 0 : m.value) == null ? void 0 : p.z) ?? 0;
      return a - l;
    });
    for (const r of i)
      await this.renderLayerToCanvas(e, r, n);
  }
  async renderLayerToCanvas(e, n, i) {
    var u, d, h, m, p, v, x;
    const r = ((d = (u = n.transform) == null ? void 0 : u.position) == null ? void 0 : d.value) ?? { x: 0, y: 0 }, o = ((m = (h = n.transform) == null ? void 0 : h.scale) == null ? void 0 : m.value) ?? { x: 100, y: 100 }, a = ((v = (p = n.transform) == null ? void 0 : p.rotation) == null ? void 0 : v.value) ?? 0, l = typeof ((x = n.opacity) == null ? void 0 : x.value) == "number" ? n.opacity.value : 100;
    e.save(), e.globalAlpha = l / 100, e.translate(r.x, r.y), e.rotate(a * Math.PI / 180), e.scale(o.x / 100, o.y / 100);
    const c = n.data;
    if (n.type === "image" && (c != null && c.src)) {
      const g = await this.loadImage(c.src);
      e.drawImage(g, -g.width / 2, -g.height / 2);
    } else if (n.type === "solid" && (c != null && c.color)) {
      e.fillStyle = c.color || "#000000";
      const g = c.width ?? 100, _ = c.height ?? 100;
      e.fillRect(-g / 2, -_ / 2, g, _);
    }
    e.restore();
  }
  loadImage(e) {
    return new Promise((n, i) => {
      const r = new Image();
      r.onload = () => n(r), r.onerror = i, r.src = e;
    });
  }
  // ============================================================================
  // Depth Sequence Rendering
  // ============================================================================
  async renderDepthSequence(e) {
    const n = this.config.endFrame - this.config.startFrame, i = [];
    for (let r = 0; r < n; r++) {
      this.checkAborted();
      const o = this.config.startFrame + r, a = r / n * 100;
      this.updateProgress({
        stage: "rendering_depth",
        stageProgress: a,
        overallProgress: 15 + a * 0.25,
        currentFrame: r + 1,
        totalFrames: n,
        message: `Rendering depth frame ${r + 1}/${n}`
      });
      const l = {
        id: "default",
        name: "Default Camera",
        type: "one-node",
        position: { x: 0, y: 0, z: 1e3 },
        pointOfInterest: { x: 0, y: 0, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1,
        focalLength: 50,
        angleOfView: 60,
        filmSize: 36,
        measureFilmSize: "horizontal",
        nearClip: 0.1,
        farClip: 100,
        depthOfField: {
          enabled: !1,
          focusDistance: 100,
          aperture: 1.2,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off"
      }, c = h7({
        width: this.config.width,
        height: this.config.height,
        nearClip: 0.1,
        farClip: 100,
        camera: l,
        layers: this.layers,
        frame: o
      }), u = y7(
        c,
        this.config.depthFormat
      ), d = _7(
        u,
        this.config.width,
        this.config.height
      ), h = new OffscreenCanvas(this.config.width, this.config.height);
      h.getContext("2d").putImageData(d, 0, 0);
      const p = await h.convertToBlob({ type: "image/png" }), v = `${this.config.filenamePrefix}_depth_${String(r).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const g = await So(this.config.comfyuiServer).uploadImage(p, v, "input", "depth_sequence");
        i.push(g.name);
      } else
        i.push(await this.saveBlobLocally(p, v));
    }
    e.outputFiles.depthSequence = i, this.updateProgress({
      stage: "rendering_depth",
      stageProgress: 100,
      overallProgress: 40,
      message: "Depth sequence complete"
    });
  }
  // ============================================================================
  // Control Image Rendering
  // ============================================================================
  async renderControlSequence(e) {
    const n = this.config.endFrame - this.config.startFrame, i = [];
    for (let r = 0; r < n; r++) {
      this.checkAborted();
      const o = this.config.startFrame + r, a = r / n * 100;
      this.updateProgress({
        stage: "rendering_control",
        stageProgress: a,
        overallProgress: 40 + a * 0.2,
        currentFrame: r + 1,
        totalFrames: n,
        message: `Rendering control frame ${r + 1}/${n}`
      });
      const l = new OffscreenCanvas(this.config.width, this.config.height), c = l.getContext("2d");
      await this.renderFrameToCanvas(c, o);
      const d = await (await this.applyControlPreprocessing(l, this.config.controlType || "depth")).convertToBlob({ type: "image/png" }), h = `${this.config.filenamePrefix}_control_${String(r).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const p = await So(this.config.comfyuiServer).uploadImage(d, h, "input", "control_sequence");
        i.push(p.name);
      } else
        i.push(await this.saveBlobLocally(d, h));
    }
    e.outputFiles.controlSequence = i, this.updateProgress({
      stage: "rendering_control",
      stageProgress: 100,
      overallProgress: 60,
      message: "Control sequence complete"
    });
  }
  async applyControlPreprocessing(e, n) {
    const i = new OffscreenCanvas(e.width, e.height), r = i.getContext("2d"), a = e.getContext("2d").getImageData(0, 0, e.width, e.height), l = a.data;
    switch (n) {
      case "canny":
        this.applyEdgeDetection(l, e.width, e.height);
        break;
      case "lineart":
        this.applyLineart(l);
        break;
      case "softedge":
        this.applySoftEdge(l, e.width, e.height);
        break;
    }
    return r.putImageData(a, 0, 0), i;
  }
  applyEdgeDetection(e, n, i) {
    const r = new Float32Array(n * i);
    for (let a = 0; a < n * i; a++) {
      const l = a * 4;
      r[a] = (e[l] * 0.299 + e[l + 1] * 0.587 + e[l + 2] * 0.114) / 255;
    }
    const o = new Float32Array(n * i);
    for (let a = 1; a < i - 1; a++)
      for (let l = 1; l < n - 1; l++) {
        const c = a * n + l, u = -r[c - n - 1] + r[c - n + 1] + -2 * r[c - 1] + 2 * r[c + 1] + -r[c + n - 1] + r[c + n + 1], d = -r[c - n - 1] - 2 * r[c - n] - r[c - n + 1] + r[c + n - 1] + 2 * r[c + n] + r[c + n + 1];
        o[c] = Math.min(1, Math.sqrt(u * u + d * d) * 2);
      }
    for (let a = 0; a < n * i; a++) {
      const l = a * 4, c = Math.floor(o[a] * 255);
      e[l] = c, e[l + 1] = c, e[l + 2] = c;
    }
  }
  applyLineart(e) {
    for (let n = 0; n < e.length; n += 4) {
      const r = e[n] * 0.299 + e[n + 1] * 0.587 + e[n + 2] * 0.114 > 128 ? 255 : 0;
      e[n] = r, e[n + 1] = r, e[n + 2] = r;
    }
  }
  applySoftEdge(e, n, i) {
    this.applyEdgeDetection(e, n, i);
    const r = new Uint8ClampedArray(e), o = 2;
    for (let a = o; a < i - o; a++)
      for (let l = o; l < n - o; l++) {
        let c = 0, u = 0;
        for (let m = -o; m <= o; m++)
          for (let p = -o; p <= o; p++) {
            const v = ((a + m) * n + (l + p)) * 4;
            c += r[v], u++;
          }
        const d = (a * n + l) * 4, h = Math.floor(c / u);
        e[d] = h, e[d + 1] = h, e[d + 2] = h;
      }
  }
  // ============================================================================
  // Camera Data Export
  // ============================================================================
  async exportCameraData(e) {
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 0,
      overallProgress: 60,
      message: "Exporting camera data..."
    });
    const n = {
      type: "one-node",
      position: { x: 0, y: 0, z: 1e3 },
      orientation: { x: 0, y: 0, z: 0 },
      zoom: 1,
      focalLength: 50,
      filmSize: 36,
      depthOfField: {
        enabled: !1,
        focusDistance: 100,
        aperture: 1.2,
        fStop: 2.8,
        blurLevel: 1,
        lockToZoom: !1
      }
    }, i = rT(
      this.config.target,
      n,
      this.cameraKeyframes,
      this.config.endFrame - this.config.startFrame,
      this.config.width,
      this.config.height,
      this.config.fps
    ), r = `${this.config.filenamePrefix}_camera.json`, o = new Blob([JSON.stringify(i, null, 2)], { type: "application/json" });
    this.config.comfyuiServer ? e.outputFiles.cameraData = r : e.outputFiles.cameraData = await this.saveBlobLocally(o, r), this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 100,
      overallProgress: 65,
      message: "Camera data exported"
    });
  }
  // ============================================================================
  // Workflow Generation
  // ============================================================================
  async generateWorkflow(e) {
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 0,
      overallProgress: 65,
      message: "Generating workflow..."
    });
    const n = {
      referenceImage: e.outputFiles.referenceImage,
      lastFrameImage: e.outputFiles.lastImage,
      depthSequence: e.outputFiles.depthSequence,
      controlImages: e.outputFiles.controlSequence,
      prompt: this.config.prompt,
      negativePrompt: this.config.negativePrompt,
      width: this.config.width,
      height: this.config.height,
      frameCount: this.config.endFrame - this.config.startFrame,
      fps: this.config.fps,
      seed: this.config.seed,
      steps: this.config.steps,
      cfgScale: this.config.cfgScale,
      outputFilename: this.config.filenamePrefix
    };
    e.outputFiles.cameraData && (n.cameraData = e.outputFiles.cameraData);
    const i = P7(this.config.target, n), r = R7(i);
    r.valid || e.errors.push(...r.errors), e.warnings.push(...r.warnings);
    const o = `${this.config.filenamePrefix}_workflow.json`, a = new Blob([JSON.stringify(i, null, 2)], { type: "application/json" });
    e.outputFiles.workflowJson = await this.saveBlobLocally(a, o), this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 100,
      overallProgress: 70,
      message: "Workflow generated"
    });
  }
  // ============================================================================
  // ComfyUI Queue
  // ============================================================================
  async queueWorkflow(e) {
    if (!this.config.comfyuiServer || !e.outputFiles.workflowJson)
      return;
    this.updateProgress({
      stage: "queuing",
      stageProgress: 0,
      overallProgress: 70,
      message: "Connecting to ComfyUI..."
    });
    const n = So(this.config.comfyuiServer);
    if (!await n.checkConnection()) {
      e.errors.push("Could not connect to ComfyUI server");
      return;
    }
    const o = await (await fetch(e.outputFiles.workflowJson)).json();
    this.updateProgress({
      stage: "queuing",
      stageProgress: 50,
      overallProgress: 75,
      message: "Queueing workflow..."
    });
    const a = await n.queuePrompt(o);
    if (e.outputFiles.promptId = a.prompt_id, a.node_errors && Object.keys(a.node_errors).length > 0) {
      e.errors.push("Workflow has node errors: " + JSON.stringify(a.node_errors));
      return;
    }
    this.updateProgress({
      stage: "generating",
      stageProgress: 0,
      overallProgress: 80,
      message: "Generating video..."
    });
    try {
      await n.waitForPrompt(a.prompt_id, (l) => {
        this.updateProgress({
          stage: "generating",
          stageProgress: l.percentage,
          overallProgress: 80 + l.percentage * 0.15,
          message: `Generating: ${l.percentage.toFixed(0)}%`,
          preview: l.preview
        });
      }), this.updateProgress({
        stage: "complete",
        stageProgress: 100,
        overallProgress: 100,
        message: "Export complete!"
      });
    } catch (l) {
      e.errors.push(l instanceof Error ? l.message : "Generation failed");
    }
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  async saveBlobLocally(e, n) {
    const i = URL.createObjectURL(e), r = document.createElement("a");
    return r.href = i, r.download = n, document.body.appendChild(r), r.click(), document.body.removeChild(r), i;
  }
}
async function k7(s, e, n, i) {
  return new D7({
    layers: s,
    cameraKeyframes: e,
    config: n,
    onProgress: i
  }).execute();
}
const I7 = { class: "export-dialog" }, L7 = { class: "dialog-tabs" }, F7 = { class: "dialog-content" }, U7 = {
  key: 0,
  class: "tab-content"
}, O7 = { class: "target-grid" }, z7 = { class: "target-buttons" }, N7 = ["onClick"], B7 = {
  key: 0,
  class: "target-info"
}, V7 = { class: "info-row" }, G7 = { class: "info-row" }, H7 = { class: "info-row" }, $7 = {
  key: 1,
  class: "tab-content"
}, W7 = { class: "settings-section" }, X7 = { class: "preset-buttons" }, j7 = ["onClick"], Y7 = { class: "input-row" }, q7 = { class: "settings-section" }, Z7 = { class: "preset-buttons" }, K7 = ["onClick"], J7 = { class: "input-row" }, Q7 = { class: "input-row" }, e9 = { class: "settings-section" }, t9 = { class: "checkbox-grid" }, n9 = {
  key: 0,
  class: "settings-section"
}, i9 = ["value"], s9 = {
  key: 1,
  class: "settings-section"
}, r9 = ["value"], o9 = {
  key: 2,
  class: "tab-content"
}, a9 = { class: "settings-section" }, l9 = { class: "settings-section" }, c9 = { class: "settings-section" }, u9 = { class: "input-row" }, d9 = { class: "input-row seed-row" }, h9 = {
  key: 3,
  class: "tab-content"
}, f9 = { class: "settings-section" }, p9 = { class: "server-row" }, m9 = { key: 0 }, v9 = { key: 1 }, g9 = { key: 2 }, y9 = { key: 3 }, _9 = { class: "settings-section" }, x9 = { class: "checkbox-large" }, b9 = {
  key: 0,
  class: "export-progress"
}, w9 = { class: "progress-header" }, S9 = { class: "progress-bar" }, M9 = {
  key: 0,
  class: "progress-details"
}, C9 = {
  key: 1,
  class: "export-error"
}, E9 = { class: "dialog-footer" }, T9 = ["disabled"], A9 = /* @__PURE__ */ Ot({
  __name: "ComfyUIExportDialog",
  props: {
    layers: {},
    cameraKeyframes: {},
    currentFrame: {},
    totalFrames: {}
  },
  emits: ["close", "exported"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we("target"), o = we("wan22-i2v"), a = we(832), l = we(480), c = we(81), u = we(24), d = we(0), h = we(81), m = we(!0), p = we(!1), v = we(!0), x = we(!0), g = we(!1), _ = we("midas"), M = we("depth"), S = we(""), b = we("blurry, low quality, distorted"), C = we(void 0), E = we(30), P = we(5), T = we("127.0.0.1:8188"), y = we(!1), w = we("disconnected"), D = we(!1), U = we(null), R = we(null), O = we(null), A = Ie(() => ug[o.value]), G = Ie(() => ({
      "Wan 2.2": ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "wan-move"],
      Uni3C: ["uni3c-camera", "uni3c-motion"],
      MotionCtrl: ["motionctrl", "motionctrl-svd"],
      Camera: ["animatediff-cameractrl", "camera-comfyui", "ati"],
      Advanced: ["light-x", "ttm", "cogvideox"],
      ControlNet: ["controlnet-depth", "controlnet-canny", "controlnet-lineart"],
      Custom: ["custom-workflow"]
    })), ue = Ie(() => ({
      "wan22-i2v": "Image to Video",
      "wan22-t2v": "Text to Video",
      "wan22-fun-camera": "Fun Camera",
      "wan22-first-last": "First + Last Frame",
      "wan-move": "Point Trajectories",
      "uni3c-camera": "Camera Control",
      "uni3c-motion": "Motion + Camera",
      motionctrl: "MotionCtrl",
      "motionctrl-svd": "MotionCtrl SVD",
      cogvideox: "CogVideoX I2V",
      "animatediff-cameractrl": "CameraCtrl",
      "camera-comfyui": "4x4 Matrices",
      ati: "Any Trajectory",
      "light-x": "Relighting",
      ttm: "Cut & Drag",
      "controlnet-depth": "Depth",
      "controlnet-canny": "Canny Edge",
      "controlnet-lineart": "Line Art",
      "custom-workflow": "Custom Workflow"
    })), Q = [
      { value: "midas", label: "MiDaS (8-bit inverted)" },
      { value: "zoe", label: "Zoe (16-bit linear)" },
      { value: "depth-pro", label: "Depth-Pro (metric)" },
      { value: "normalized", label: "Normalized (0-1)" }
    ], le = [
      { value: "depth", label: "Depth" },
      { value: "canny", label: "Canny Edge" },
      { value: "lineart", label: "Line Art" },
      { value: "softedge", label: "Soft Edge" },
      { value: "normal", label: "Normal Map" }
    ];
    function re(Y) {
      o.value = Y;
      const H = l7[Y];
      H && (a.value = H.width ?? 832, l.value = H.height ?? 480, c.value = H.frameCount ?? 81, u.value = H.fps ?? 24, h.value = c.value);
      const I = ug[Y];
      I && (m.value = I.requiredInputs.includes("depth_sequence") || I.requiredInputs.includes("depth_map"), v.value = I.requiredInputs.includes("camera_data") || I.requiredInputs.includes("camera_trajectory") || I.requiredInputs.includes("camera_poses"), x.value = I.requiredInputs.includes("reference_image") || I.requiredInputs.includes("first_frame"), g.value = I.requiredInputs.includes("last_frame"), p.value = Y.startsWith("controlnet-"));
    }
    async function j() {
      w.value = "connecting";
      try {
        const H = await So(T.value).checkConnection();
        w.value = H ? "connected" : "error";
      } catch {
        w.value = "error";
      }
    }
    function $(Y) {
      a.value = Y.width, l.value = Y.height;
    }
    function q(Y) {
      c.value = Y, h.value = Math.min(h.value, Y);
    }
    function oe() {
      C.value = Math.floor(Math.random() * 2147483647);
    }
    async function ie() {
      D.value = !0, R.value = null, O.value = new AbortController();
      const Y = {
        target: o.value,
        width: a.value,
        height: l.value,
        frameCount: c.value,
        fps: u.value,
        startFrame: d.value,
        endFrame: h.value,
        outputDir: "",
        filenamePrefix: `weyl_${o.value}_${Date.now()}`,
        exportDepthMap: m.value,
        exportControlImages: p.value,
        exportCameraData: v.value,
        exportReferenceFrame: x.value,
        exportLastFrame: g.value,
        depthFormat: _.value,
        controlType: M.value,
        prompt: S.value,
        negativePrompt: b.value,
        seed: C.value,
        steps: E.value,
        cfgScale: P.value,
        comfyuiServer: T.value,
        autoQueueWorkflow: y.value
      };
      try {
        const H = await k7(
          n.layers,
          n.cameraKeyframes,
          Y,
          (I) => {
            U.value = I;
          }
        );
        H.success ? i("exported", H) : R.value = H.errors.join(`
`);
      } catch (H) {
        R.value = H instanceof Error ? H.message : "Export failed";
      } finally {
        D.value = !1, O.value = null;
      }
    }
    function ce() {
      O.value && O.value.abort();
    }
    function V() {
      D.value && ce(), i("close");
    }
    return _n(() => {
      h.value = Math.min(c.value, n.totalFrames), j();
    }), Ft(o, () => {
      re(o.value);
    }), (Y, H) => {
      var I, F, L;
      return te(), ae("div", {
        class: "export-dialog-overlay",
        onClick: _t(V, ["self"])
      }, [
        f("div", I7, [
          f("header", { class: "dialog-header" }, [
            H[24] || (H[24] = f("h2", null, "Export to ComfyUI", -1)),
            f("button", {
              class: "close-btn",
              onClick: V
            }, "")
          ]),
          f("nav", L7, [
            f("button", {
              class: Fe({ active: r.value === "target" }),
              onClick: H[0] || (H[0] = (ee) => r.value = "target")
            }, " Target ", 2),
            f("button", {
              class: Fe({ active: r.value === "output" }),
              onClick: H[1] || (H[1] = (ee) => r.value = "output")
            }, " Output ", 2),
            f("button", {
              class: Fe({ active: r.value === "generation" }),
              onClick: H[2] || (H[2] = (ee) => r.value = "generation")
            }, " Generation ", 2),
            f("button", {
              class: Fe({ active: r.value === "comfyui" }),
              onClick: H[3] || (H[3] = (ee) => r.value = "comfyui")
            }, " ComfyUI ", 2)
          ]),
          f("div", F7, [
            r.value === "target" ? (te(), ae("div", U7, [
              f("div", O7, [
                (te(!0), ae(qe, null, ot(G.value, (ee, Z) => (te(), ae("div", {
                  key: Z,
                  class: "target-category"
                }, [
                  f("h3", null, xe(Z), 1),
                  f("div", z7, [
                    (te(!0), ae(qe, null, ot(ee, (k) => (te(), ae("button", {
                      key: k,
                      class: Fe({ selected: o.value === k }),
                      onClick: (ne) => re(k)
                    }, xe(ue.value[k]), 11, N7))), 128))
                  ])
                ]))), 128))
              ]),
              A.value ? (te(), ae("div", B7, [
                f("h4", null, xe(ue.value[o.value]), 1),
                f("div", V7, [
                  H[25] || (H[25] = f("span", { class: "label" }, "Required:", -1)),
                  f("span", null, xe(A.value.requiredInputs.join(", ") || "None"), 1)
                ]),
                f("div", G7, [
                  H[26] || (H[26] = f("span", { class: "label" }, "Optional:", -1)),
                  f("span", null, xe(A.value.optionalInputs.join(", ") || "None"), 1)
                ]),
                f("div", H7, [
                  H[27] || (H[27] = f("span", { class: "label" }, "Outputs:", -1)),
                  f("span", null, xe(A.value.outputTypes.join(", ")), 1)
                ])
              ])) : Pe("", !0)
            ])) : Pe("", !0),
            r.value === "output" ? (te(), ae("div", $7, [
              f("div", W7, [
                H[28] || (H[28] = f("h3", null, "Resolution", -1)),
                f("div", X7, [
                  (te(!0), ae(qe, null, ot(Ve(u7), (ee) => (te(), ae("button", {
                    key: ee.name,
                    onClick: (Z) => $(ee)
                  }, xe(ee.name), 9, j7))), 128))
                ]),
                f("div", Y7, [
                  ze(et, {
                    modelValue: a.value,
                    "onUpdate:modelValue": H[4] || (H[4] = (ee) => a.value = ee),
                    label: "Width",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"]),
                  ze(et, {
                    modelValue: l.value,
                    "onUpdate:modelValue": H[5] || (H[5] = (ee) => l.value = ee),
                    label: "Height",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"])
                ])
              ]),
              f("div", q7, [
                H[29] || (H[29] = f("h3", null, "Frames", -1)),
                f("div", Z7, [
                  (te(!0), ae(qe, null, ot(Ve(d7), (ee) => (te(), ae("button", {
                    key: ee.name,
                    onClick: (Z) => q(ee.frameCount)
                  }, xe(ee.name), 9, K7))), 128))
                ]),
                f("div", J7, [
                  ze(et, {
                    modelValue: c.value,
                    "onUpdate:modelValue": H[6] || (H[6] = (ee) => c.value = ee),
                    label: "Total Frames",
                    min: 1,
                    max: 1e3
                  }, null, 8, ["modelValue"]),
                  ze(et, {
                    modelValue: u.value,
                    "onUpdate:modelValue": H[7] || (H[7] = (ee) => u.value = ee),
                    label: "FPS",
                    min: 1,
                    max: 120
                  }, null, 8, ["modelValue"])
                ]),
                f("div", Q7, [
                  ze(et, {
                    modelValue: d.value,
                    "onUpdate:modelValue": H[8] || (H[8] = (ee) => d.value = ee),
                    label: "Start",
                    min: 0,
                    max: h.value - 1
                  }, null, 8, ["modelValue", "max"]),
                  ze(et, {
                    modelValue: h.value,
                    "onUpdate:modelValue": H[9] || (H[9] = (ee) => h.value = ee),
                    label: "End",
                    min: d.value + 1,
                    max: c.value
                  }, null, 8, ["modelValue", "min", "max"])
                ])
              ]),
              f("div", e9, [
                H[35] || (H[35] = f("h3", null, "Export Options", -1)),
                f("div", t9, [
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": H[10] || (H[10] = (ee) => x.value = ee)
                    }, null, 512), [
                      [xi, x.value]
                    ]),
                    H[30] || (H[30] = ct(" Reference Frame ", -1))
                  ]),
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": H[11] || (H[11] = (ee) => g.value = ee)
                    }, null, 512), [
                      [xi, g.value]
                    ]),
                    H[31] || (H[31] = ct(" Last Frame ", -1))
                  ]),
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": H[12] || (H[12] = (ee) => m.value = ee)
                    }, null, 512), [
                      [xi, m.value]
                    ]),
                    H[32] || (H[32] = ct(" Depth Maps ", -1))
                  ]),
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": H[13] || (H[13] = (ee) => p.value = ee)
                    }, null, 512), [
                      [xi, p.value]
                    ]),
                    H[33] || (H[33] = ct(" Control Images ", -1))
                  ]),
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": H[14] || (H[14] = (ee) => v.value = ee)
                    }, null, 512), [
                      [xi, v.value]
                    ]),
                    H[34] || (H[34] = ct(" Camera Data ", -1))
                  ])
                ])
              ]),
              m.value ? (te(), ae("div", n9, [
                H[36] || (H[36] = f("h3", null, "Depth Format", -1)),
                st(f("select", {
                  "onUpdate:modelValue": H[15] || (H[15] = (ee) => _.value = ee)
                }, [
                  (te(), ae(qe, null, ot(Q, (ee) => f("option", {
                    key: ee.value,
                    value: ee.value
                  }, xe(ee.label), 9, i9)), 64))
                ], 512), [
                  [Cn, _.value]
                ])
              ])) : Pe("", !0),
              p.value ? (te(), ae("div", s9, [
                H[37] || (H[37] = f("h3", null, "Control Type", -1)),
                st(f("select", {
                  "onUpdate:modelValue": H[16] || (H[16] = (ee) => M.value = ee)
                }, [
                  (te(), ae(qe, null, ot(le, (ee) => f("option", {
                    key: ee.value,
                    value: ee.value
                  }, xe(ee.label), 9, r9)), 64))
                ], 512), [
                  [Cn, M.value]
                ])
              ])) : Pe("", !0)
            ])) : Pe("", !0),
            r.value === "generation" ? (te(), ae("div", o9, [
              f("div", a9, [
                H[38] || (H[38] = f("h3", null, "Prompt", -1)),
                st(f("textarea", {
                  "onUpdate:modelValue": H[17] || (H[17] = (ee) => S.value = ee),
                  placeholder: "Describe the video you want to generate...",
                  rows: "4"
                }, null, 512), [
                  [Ut, S.value]
                ])
              ]),
              f("div", l9, [
                H[39] || (H[39] = f("h3", null, "Negative Prompt", -1)),
                st(f("textarea", {
                  "onUpdate:modelValue": H[18] || (H[18] = (ee) => b.value = ee),
                  placeholder: "What to avoid...",
                  rows: "2"
                }, null, 512), [
                  [Ut, b.value]
                ])
              ]),
              f("div", c9, [
                H[40] || (H[40] = f("h3", null, "Parameters", -1)),
                f("div", u9, [
                  ze(et, {
                    modelValue: E.value,
                    "onUpdate:modelValue": H[19] || (H[19] = (ee) => E.value = ee),
                    label: "Steps",
                    min: 1,
                    max: 100
                  }, null, 8, ["modelValue"]),
                  ze(et, {
                    modelValue: P.value,
                    "onUpdate:modelValue": H[20] || (H[20] = (ee) => P.value = ee),
                    label: "CFG Scale",
                    min: 1,
                    max: 20,
                    step: 0.5
                  }, null, 8, ["modelValue"])
                ]),
                f("div", d9, [
                  ze(et, {
                    modelValue: C.value ?? 0,
                    "onUpdate:modelValue": H[21] || (H[21] = (ee) => C.value = ee),
                    label: "Seed",
                    min: 0,
                    max: 2147483647
                  }, null, 8, ["modelValue"]),
                  f("button", {
                    class: "randomize-btn",
                    onClick: oe
                  }, "Random")
                ])
              ])
            ])) : Pe("", !0),
            r.value === "comfyui" ? (te(), ae("div", h9, [
              f("div", f9, [
                H[41] || (H[41] = f("h3", null, "Server", -1)),
                f("div", p9, [
                  st(f("input", {
                    type: "text",
                    "onUpdate:modelValue": H[22] || (H[22] = (ee) => T.value = ee),
                    placeholder: "127.0.0.1:8188"
                  }, null, 512), [
                    [Ut, T.value]
                  ]),
                  f("button", { onClick: j }, xe(w.value === "connecting" ? "Connecting..." : "Test"), 1)
                ]),
                f("div", {
                  class: Fe(["connection-status", w.value])
                }, [
                  w.value === "connected" ? (te(), ae("span", m9, "Connected")) : w.value === "error" ? (te(), ae("span", v9, "Connection failed")) : w.value === "connecting" ? (te(), ae("span", g9, "Connecting...")) : (te(), ae("span", y9, "Not connected"))
                ], 2)
              ]),
              f("div", _9, [
                H[43] || (H[43] = f("h3", null, "Workflow", -1)),
                f("label", x9, [
                  st(f("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": H[23] || (H[23] = (ee) => y.value = ee)
                  }, null, 512), [
                    [xi, y.value]
                  ]),
                  H[42] || (H[42] = f("span", null, [
                    f("strong", null, "Auto-queue workflow"),
                    f("small", null, "Automatically send workflow to ComfyUI after export")
                  ], -1))
                ])
              ])
            ])) : Pe("", !0)
          ]),
          D.value ? (te(), ae("div", b9, [
            f("div", w9, [
              f("span", null, xe(((I = U.value) == null ? void 0 : I.message) || "Exporting..."), 1),
              f("button", { onClick: ce }, "Cancel")
            ]),
            f("div", S9, [
              f("div", {
                class: "progress-fill",
                style: yt({ width: `${((F = U.value) == null ? void 0 : F.overallProgress) || 0}%` })
              }, null, 4)
            ]),
            (L = U.value) != null && L.currentFrame ? (te(), ae("div", M9, " Frame " + xe(U.value.currentFrame) + " / " + xe(U.value.totalFrames), 1)) : Pe("", !0)
          ])) : Pe("", !0),
          R.value ? (te(), ae("div", C9, xe(R.value), 1)) : Pe("", !0),
          f("footer", E9, [
            f("button", {
              class: "secondary",
              onClick: V
            }, "Cancel"),
            f("button", {
              class: "primary",
              disabled: D.value,
              onClick: ie
            }, xe(D.value ? "Exporting..." : "Export"), 9, T9)
          ])
        ])
      ]);
    };
  }
}), P9 = /* @__PURE__ */ Gt(A9, [["__scopeId", "data-v-784836ff"]]), R9 = { class: "dialog-container" }, D9 = { class: "dialog-content" }, k9 = { class: "form-row" }, I9 = { class: "tabs" }, L9 = {
  key: 0,
  class: "tab-content"
}, F9 = { class: "form-row" }, U9 = { class: "form-row dimensions-row" }, O9 = { class: "dimension-group" }, z9 = { class: "dimension-group" }, N9 = { class: "form-row" }, B9 = { class: "aspect-info" }, V9 = { class: "form-row" }, G9 = { class: "form-row" }, H9 = { class: "resolution-info" }, $9 = { class: "form-row" }, W9 = { class: "duration-inputs" }, X9 = { class: "duration-helper" }, j9 = { class: "form-row" }, Y9 = { class: "color-picker-row" }, q9 = { class: "color-label" }, Z9 = {
  key: 1,
  class: "tab-content"
}, K9 = { class: "form-row" }, J9 = { class: "form-row" }, Q9 = { class: "form-row" }, eG = { class: "motion-blur-settings" }, tG = {
  key: 0,
  class: "motion-blur-params"
}, nG = { class: "param-row" }, iG = { class: "param-row" }, sG = { class: "dialog-footer" }, rG = { class: "preview-toggle" }, oG = /* @__PURE__ */ Ot({
  __name: "CompositionSettingsDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "confirm"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = we("basic"), a = we("custom"), l = we(!1), c = we(16 / 9), u = we(!1), d = we({
      name: "Main Comp",
      width: 1920,
      height: 1080,
      pixelAspectRatio: 1,
      fps: 30,
      frameCount: 300,
      resolution: "full",
      backgroundColor: "#000000",
      autoResizeToContent: !0,
      startTimecode: "00:00:00:00",
      motionBlurEnabled: !1,
      shutterAngle: 180,
      shutterPhase: -90
    }), h = Ie(() => {
      const y = d.value.width / d.value.height * d.value.pixelAspectRatio;
      return Math.abs(y - 16 / 9) < 0.01 ? "16:9 (1.78)" : Math.abs(y - 4 / 3) < 0.01 ? "4:3 (1.33)" : Math.abs(y - 1) < 0.01 ? "1:1 (1.0)" : Math.abs(y - 9 / 16) < 0.01 ? "9:16 (0.56)" : Math.abs(y - 21 / 9) < 0.01 ? "21:9 (2.33)" : `${y.toFixed(2)}`;
    }), m = Ie(() => d.value.frameCount / d.value.fps), p = we("00:00:10:00"), v = Ie(() => {
      const w = { full: 1, half: 2, third: 3, quarter: 4 }[d.value.resolution], D = Math.floor(d.value.width / w), U = Math.floor(d.value.height / w), R = (D * U * 4 / (1024 * 1024)).toFixed(1);
      return `${D} x ${U}, ${R} MB per 8bpc frame`;
    }), x = {
      "1080p30": { width: 1920, height: 1080, fps: 30 },
      "1080p60": { width: 1920, height: 1080, fps: 60 },
      "720p30": { width: 1280, height: 720, fps: 30 },
      "4k30": { width: 3840, height: 2160, fps: 30 },
      instagram_square: { width: 1080, height: 1080, fps: 30 },
      instagram_story: { width: 1080, height: 1920, fps: 30 },
      tiktok: { width: 1080, height: 1920, fps: 30 },
      youtube_short: { width: 1080, height: 1920, fps: 60 },
      sd15_512: { width: 512, height: 512, fps: 8 },
      sd15_768: { width: 768, height: 512, fps: 8 },
      sdxl_1024: { width: 1024, height: 1024, fps: 8 },
      wan_480p: { width: 832, height: 480, fps: 16 },
      wan_720p: { width: 1280, height: 720, fps: 16 }
    };
    function g() {
      const y = x[a.value];
      y && (y.width && (d.value.width = y.width), y.height && (d.value.height = y.height), y.fps && (d.value.fps = y.fps), c.value = d.value.width / d.value.height, S());
    }
    function _(y) {
      d.value.width = Math.round(d.value.width / 8) * 8, d.value.height = Math.round(d.value.height / 8) * 8, l.value ? y === "width" ? d.value.height = Math.round(d.value.width / c.value / 8) * 8 : d.value.width = Math.round(d.value.height * c.value / 8) * 8 : c.value = d.value.width / d.value.height, a.value = "custom";
    }
    function M() {
      const y = p.value.split(":").map((w) => parseInt(w) || 0);
      if (y.length === 4) {
        const [w, D, U, R] = y, O = w * 3600 + D * 60 + U;
        d.value.frameCount = Math.round(O * d.value.fps) + R;
      } else y.length === 1 && (d.value.frameCount = y[0]);
    }
    function S() {
      const y = d.value.frameCount, w = d.value.fps, D = Math.floor(y / w), U = y % Math.round(w), R = Math.floor(D / 3600), O = Math.floor(D % 3600 / 60), A = D % 60;
      p.value = `${b(R)}:${b(O)}:${b(A)}:${b(U)}`;
    }
    function b(y) {
      return y.toString().padStart(2, "0");
    }
    function C() {
      var y, w, D, U, R, O;
      d.value = {
        name: ((w = (y = r.project) == null ? void 0 : y.meta) == null ? void 0 : w.name) || "Main Comp",
        width: r.width,
        height: r.height,
        pixelAspectRatio: 1,
        fps: r.fps,
        frameCount: r.frameCount,
        resolution: "full",
        backgroundColor: ((U = (D = r.project) == null ? void 0 : D.composition) == null ? void 0 : U.backgroundColor) || "#000000",
        autoResizeToContent: ((O = (R = r.project) == null ? void 0 : R.composition) == null ? void 0 : O.autoResizeToContent) ?? !0,
        startTimecode: "00:00:00:00",
        motionBlurEnabled: !1,
        shutterAngle: 180,
        shutterPhase: -90
      }, c.value = d.value.width / d.value.height, S();
    }
    function E() {
      i("close");
    }
    function P() {
      i("confirm", { ...d.value }), i("close");
    }
    function T(y) {
      y.key === "Escape" ? E() : y.key === "Enter" && !y.shiftKey && P();
    }
    return Ft(() => n.visible, (y) => {
      y && C();
    }), Ft(d, () => {
      u.value && n.visible && r.resizeComposition(d.value.width, d.value.height, d.value.frameCount);
    }, { deep: !0 }), _n(() => {
      window.addEventListener("keydown", T);
    }), Nn(() => {
      window.removeEventListener("keydown", T);
    }), (y, w) => (te(), St(Uo, { to: "body" }, [
      s.visible ? (te(), ae("div", {
        key: 0,
        class: "dialog-overlay",
        onClick: _t(E, ["self"])
      }, [
        f("div", R9, [
          f("div", { class: "dialog-header" }, [
            w[20] || (w[20] = f("span", { class: "dialog-title" }, "Composition Settings", -1)),
            f("button", {
              class: "close-btn",
              onClick: E
            }, "")
          ]),
          f("div", D9, [
            f("div", k9, [
              w[21] || (w[21] = f("label", null, "Composition Name:", -1)),
              st(f("input", {
                type: "text",
                "onUpdate:modelValue": w[0] || (w[0] = (D) => d.value.name = D),
                class: "text-input full-width"
              }, null, 512), [
                [Ut, d.value.name]
              ])
            ]),
            f("div", I9, [
              f("button", {
                class: Fe({ active: o.value === "basic" }),
                onClick: w[1] || (w[1] = (D) => o.value = "basic")
              }, "Basic", 2),
              f("button", {
                class: Fe({ active: o.value === "advanced" }),
                onClick: w[2] || (w[2] = (D) => o.value = "advanced")
              }, "Advanced", 2)
            ]),
            o.value === "basic" ? (te(), ae("div", L9, [
              f("div", F9, [
                w[23] || (w[23] = f("label", null, "Preset:", -1)),
                st(f("select", {
                  "onUpdate:modelValue": w[3] || (w[3] = (D) => a.value = D),
                  onChange: g,
                  class: "select-input"
                }, [...w[22] || (w[22] = [
                  f("option", { value: "custom" }, "Custom", -1),
                  f("optgroup", { label: "Video" }, [
                    f("option", { value: "1080p30" }, "HD 1080p 30fps (1920x1080)"),
                    f("option", { value: "1080p60" }, "HD 1080p 60fps (1920x1080)"),
                    f("option", { value: "720p30" }, "HD 720p 30fps (1280x720)"),
                    f("option", { value: "4k30" }, "4K UHD 30fps (3840x2160)")
                  ], -1),
                  f("optgroup", { label: "Social Media" }, [
                    f("option", { value: "instagram_square" }, "Instagram Square (1080x1080)"),
                    f("option", { value: "instagram_story" }, "Instagram Story (1080x1920)"),
                    f("option", { value: "tiktok" }, "TikTok/Reels (1080x1920)"),
                    f("option", { value: "youtube_short" }, "YouTube Short (1080x1920)")
                  ], -1),
                  f("optgroup", { label: "AI Video (ComfyUI)" }, [
                    f("option", { value: "sd15_512" }, "SD 1.5 (512x512)"),
                    f("option", { value: "sd15_768" }, "SD 1.5 (768x512)"),
                    f("option", { value: "sdxl_1024" }, "SDXL (1024x1024)"),
                    f("option", { value: "wan_480p" }, "Wan 2.1 480p (832x480)"),
                    f("option", { value: "wan_720p" }, "Wan 2.1 720p (1280x720)")
                  ], -1)
                ])], 544), [
                  [Cn, a.value]
                ])
              ]),
              f("div", U9, [
                f("div", O9, [
                  w[24] || (w[24] = f("label", null, "Width:", -1)),
                  st(f("input", {
                    type: "number",
                    "onUpdate:modelValue": w[4] || (w[4] = (D) => d.value.width = D),
                    step: 8,
                    min: "64",
                    max: "8192",
                    class: "number-input",
                    onChange: w[5] || (w[5] = (D) => _("width"))
                  }, null, 544), [
                    [
                      Ut,
                      d.value.width,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  w[25] || (w[25] = f("span", { class: "unit" }, "px", -1))
                ]),
                f("button", {
                  class: Fe(["lock-btn", { locked: l.value }]),
                  onClick: w[6] || (w[6] = (D) => l.value = !l.value),
                  title: "Lock Aspect Ratio"
                }, xe(l.value ? "" : ""), 3),
                f("div", z9, [
                  w[26] || (w[26] = f("label", null, "Height:", -1)),
                  st(f("input", {
                    type: "number",
                    "onUpdate:modelValue": w[7] || (w[7] = (D) => d.value.height = D),
                    step: 8,
                    min: "64",
                    max: "8192",
                    class: "number-input",
                    onChange: w[8] || (w[8] = (D) => _("height"))
                  }, null, 544), [
                    [
                      Ut,
                      d.value.height,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  w[27] || (w[27] = f("span", { class: "unit" }, "px", -1))
                ])
              ]),
              f("div", N9, [
                w[29] || (w[29] = f("label", null, "Pixel Aspect Ratio:", -1)),
                st(f("select", {
                  "onUpdate:modelValue": w[9] || (w[9] = (D) => d.value.pixelAspectRatio = D),
                  class: "select-input"
                }, [...w[28] || (w[28] = [
                  f("option", { value: "1" }, "Square Pixels (1.0)", -1),
                  f("option", { value: "1.067" }, "D1/DV NTSC (0.9)", -1),
                  f("option", { value: "1.422" }, "D1/DV PAL (1.067)", -1),
                  f("option", { value: "1.333" }, "Anamorphic 2:1 (2.0)", -1)
                ])], 512), [
                  [Cn, d.value.pixelAspectRatio]
                ]),
                f("span", B9, "Frame Aspect Ratio: " + xe(h.value), 1)
              ]),
              f("div", V9, [
                w[31] || (w[31] = f("label", null, "Frame Rate:", -1)),
                st(f("select", {
                  "onUpdate:modelValue": w[10] || (w[10] = (D) => d.value.fps = D),
                  class: "select-input short"
                }, [...w[30] || (w[30] = [
                  f("option", { value: 8 }, "8", -1),
                  f("option", { value: 12 }, "12", -1),
                  f("option", { value: 15 }, "15", -1),
                  f("option", { value: 16 }, "16", -1),
                  f("option", { value: 23.976 }, "23.976", -1),
                  f("option", { value: 24 }, "24", -1),
                  f("option", { value: 25 }, "25", -1),
                  f("option", { value: 29.97 }, "29.97", -1),
                  f("option", { value: 30 }, "30", -1),
                  f("option", { value: 50 }, "50", -1),
                  f("option", { value: 59.94 }, "59.94", -1),
                  f("option", { value: 60 }, "60", -1)
                ])], 512), [
                  [
                    Cn,
                    d.value.fps,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                w[32] || (w[32] = f("span", { class: "unit" }, "frames per second", -1))
              ]),
              f("div", G9, [
                w[34] || (w[34] = f("label", null, "Resolution:", -1)),
                st(f("select", {
                  "onUpdate:modelValue": w[11] || (w[11] = (D) => d.value.resolution = D),
                  class: "select-input short"
                }, [...w[33] || (w[33] = [
                  f("option", { value: "full" }, "Full", -1),
                  f("option", { value: "half" }, "Half", -1),
                  f("option", { value: "third" }, "Third", -1),
                  f("option", { value: "quarter" }, "Quarter", -1)
                ])], 512), [
                  [Cn, d.value.resolution]
                ]),
                f("span", H9, xe(v.value), 1)
              ]),
              f("div", $9, [
                w[35] || (w[35] = f("label", null, "Duration:", -1)),
                f("div", W9, [
                  st(f("input", {
                    type: "text",
                    "onUpdate:modelValue": w[12] || (w[12] = (D) => p.value = D),
                    class: "timecode-input",
                    placeholder: "00:00:00:00",
                    onBlur: M
                  }, null, 544), [
                    [Ut, p.value]
                  ]),
                  f("span", X9, xe(d.value.frameCount) + " frames = " + xe(m.value.toFixed(2)) + "s ", 1)
                ])
              ]),
              f("div", j9, [
                w[36] || (w[36] = f("label", null, "Background Color:", -1)),
                f("div", Y9, [
                  st(f("input", {
                    type: "color",
                    "onUpdate:modelValue": w[13] || (w[13] = (D) => d.value.backgroundColor = D),
                    class: "color-input"
                  }, null, 512), [
                    [Ut, d.value.backgroundColor]
                  ]),
                  f("span", q9, xe(d.value.backgroundColor), 1)
                ])
              ])
            ])) : Pe("", !0),
            o.value === "advanced" ? (te(), ae("div", Z9, [
              f("div", K9, [
                f("label", null, [
                  st(f("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": w[14] || (w[14] = (D) => d.value.autoResizeToContent = D)
                  }, null, 512), [
                    [xi, d.value.autoResizeToContent]
                  ]),
                  w[37] || (w[37] = ct(" Auto-resize composition when importing video ", -1))
                ])
              ]),
              f("div", J9, [
                w[38] || (w[38] = f("label", null, "Start Timecode:", -1)),
                st(f("input", {
                  type: "text",
                  "onUpdate:modelValue": w[15] || (w[15] = (D) => d.value.startTimecode = D),
                  class: "timecode-input",
                  placeholder: "00:00:00:00"
                }, null, 512), [
                  [Ut, d.value.startTimecode]
                ])
              ]),
              f("div", Q9, [
                w[44] || (w[44] = f("label", null, "Motion Blur:", -1)),
                f("div", eG, [
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": w[16] || (w[16] = (D) => d.value.motionBlurEnabled = D)
                    }, null, 512), [
                      [xi, d.value.motionBlurEnabled]
                    ]),
                    w[39] || (w[39] = ct(" Enable Motion Blur ", -1))
                  ]),
                  d.value.motionBlurEnabled ? (te(), ae("div", tG, [
                    f("div", nG, [
                      w[40] || (w[40] = f("label", null, "Shutter Angle:", -1)),
                      st(f("input", {
                        type: "number",
                        "onUpdate:modelValue": w[17] || (w[17] = (D) => d.value.shutterAngle = D),
                        min: "0",
                        max: "720",
                        class: "number-input short"
                      }, null, 512), [
                        [
                          Ut,
                          d.value.shutterAngle,
                          void 0,
                          { number: !0 }
                        ]
                      ]),
                      w[41] || (w[41] = f("span", { class: "unit" }, "", -1))
                    ]),
                    f("div", iG, [
                      w[42] || (w[42] = f("label", null, "Shutter Phase:", -1)),
                      st(f("input", {
                        type: "number",
                        "onUpdate:modelValue": w[18] || (w[18] = (D) => d.value.shutterPhase = D),
                        min: "-360",
                        max: "360",
                        class: "number-input short"
                      }, null, 512), [
                        [
                          Ut,
                          d.value.shutterPhase,
                          void 0,
                          { number: !0 }
                        ]
                      ]),
                      w[43] || (w[43] = f("span", { class: "unit" }, "", -1))
                    ])
                  ])) : Pe("", !0)
                ])
              ])
            ])) : Pe("", !0)
          ]),
          f("div", sG, [
            f("div", rG, [
              f("label", null, [
                st(f("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": w[19] || (w[19] = (D) => u.value = D)
                }, null, 512), [
                  [xi, u.value]
                ]),
                w[45] || (w[45] = ct(" Preview ", -1))
              ])
            ]),
            f("div", { class: "dialog-actions" }, [
              f("button", {
                class: "btn btn-secondary",
                onClick: E
              }, "Cancel"),
              f("button", {
                class: "btn btn-primary",
                onClick: P
              }, "OK")
            ])
          ])
        ])
      ])) : Pe("", !0)
    ]));
  }
}), aG = /* @__PURE__ */ Gt(oG, [["__scopeId", "data-v-76356b13"]]), lG = { class: "workspace-layout" }, cG = { class: "toolbar" }, uG = { class: "tool-group" }, dG = { class: "tool-group" }, hG = ["title"], fG = { class: "icon" }, pG = { class: "timecode-display" }, mG = { class: "tool-group" }, vG = { class: "tool-group" }, gG = ["disabled"], yG = ["disabled"], _G = { class: "workspace-content" }, xG = { class: "panel left-panel" }, bG = { class: "panel-tabs" }, wG = { class: "panel-content" }, SG = { class: "panel viewport-panel" }, MG = { class: "viewport-header" }, CG = { class: "viewport-tabs" }, EG = { class: "viewport-controls" }, TG = { class: "viewport-content" }, AG = { class: "panel timeline-panel" }, PG = { class: "panel graph-editor-panel" }, RG = {
  key: 1,
  class: "panel timeline-panel"
}, DG = { class: "panel right-panel" }, kG = { class: "panel-tabs" }, IG = { class: "panel-content" }, LG = { class: "status-bar" }, FG = { class: "status-left" }, UG = { class: "status-item" }, OG = { class: "status-item" }, zG = { class: "status-center" }, NG = {
  key: 0,
  class: "render-progress"
}, BG = { class: "status-right" }, VG = { class: "status-item" }, GG = { class: "status-item" }, HG = /* @__PURE__ */ Ot({
  __name: "WorkspaceLayout",
  setup(s) {
    const e = sn(), n = Ie({
      get: () => e.currentTool,
      set: (I) => e.setTool(I)
    }), i = we("standard"), r = we("project"), o = we("properties"), a = we("composition"), l = we("fit"), c = we(!1), u = we(!0), d = we(!1), h = we(!1), m = we(!1), p = we(!1), v = we(!1), x = we("cpu"), g = we(null), _ = Ie(() => {
      const I = e.getActiveCameraAtFrame();
      return I || My("default", b.value, C.value);
    }), M = we(Cy()), S = we({
      showGrid: !0,
      showAxes: !0,
      showCameraFrustum: !0,
      showCompositionBounds: !0,
      showFocalPlane: !1,
      showLayerOutlines: !0,
      gridSize: 100,
      gridDivisions: 10
    }), b = Ie(() => {
      var I, F;
      return ((F = (I = e.project) == null ? void 0 : I.composition) == null ? void 0 : F.width) || 1920;
    }), C = Ie(() => {
      var I, F;
      return ((F = (I = e.project) == null ? void 0 : I.composition) == null ? void 0 : F.height) || 1080;
    }), E = we(60), P = we("0 MB"), T = we(0), y = Ie(() => {
      var ne, J;
      const I = e.currentFrame, F = ((J = (ne = e.project) == null ? void 0 : ne.composition) == null ? void 0 : J.fps) || 30, L = I / F, ee = Math.floor(L / 60), Z = Math.floor(L % 60), k = I % F;
      return `${String(ee).padStart(2, "0")}:${String(Z).padStart(2, "0")}:${String(k).padStart(2, "0")}`;
    }), w = Ie(() => {
      var I, F;
      return ((F = (I = e.project) == null ? void 0 : I.meta) == null ? void 0 : F.name) || "Untitled Project";
    }), D = Ie(() => {
      var F;
      const I = (F = e.project) == null ? void 0 : F.composition;
      return I ? `${I.width}${I.height} @ ${I.fps}fps` : "No Composition";
    }), U = Ie(() => e.canUndo), R = Ie(() => e.canRedo);
    function O() {
      v.value = !v.value, v.value ? e.play() : e.pause();
    }
    function A() {
      e.goToStart();
    }
    function G() {
      e.goToEnd();
    }
    function ue() {
      e.setFrame(e.currentFrame + 1);
    }
    function Q() {
      e.setFrame(Math.max(0, e.currentFrame - 1));
    }
    function le() {
      e.undo();
    }
    function re() {
      e.redo();
    }
    function j(I) {
      e.activeCameraId && e.updateCamera(I.id, I);
    }
    function $() {
      console.log("[Weyl] Matte export completed");
    }
    function q(I) {
      console.log("[Weyl] ComfyUI export completed", I), m.value = !1;
    }
    function oe(I) {
      console.log("[Weyl] Composition settings updated:", I), e.updateCompositionSettings(e.activeCompositionId, {
        width: I.width,
        height: I.height,
        fps: I.fps,
        frameCount: I.frameCount,
        backgroundColor: I.backgroundColor,
        autoResizeToContent: I.autoResizeToContent
      }), e.renameComposition(e.activeCompositionId, I.name), p.value = !1;
    }
    const ie = Ie(() => {
      const I = e.getActiveCameraAtFrame();
      return I ? e.getCameraKeyframes(I.id) : [];
    });
    function ce() {
      console.log("[WorkspaceLayout] Zoom changed to:", l.value);
    }
    function V(I) {
      var F, L;
      if (!(((F = document.activeElement) == null ? void 0 : F.tagName) === "INPUT" || ((L = document.activeElement) == null ? void 0 : L.tagName) === "TEXTAREA"))
        switch (I.key.toLowerCase()) {
          case " ":
            I.preventDefault(), O();
            break;
          case "v":
            n.value = "select";
            break;
          case "p":
            n.value = "pen";
            break;
          case "t":
            n.value = "text";
            break;
          case "h":
            n.value = "hand";
            break;
          case "z":
            I.ctrlKey || I.metaKey ? (I.preventDefault(), I.shiftKey ? re() : le()) : n.value = "zoom";
            break;
          case "home":
            I.preventDefault(), A();
            break;
          case "end":
            I.preventDefault(), G();
            break;
          case "arrowleft":
            I.preventDefault(), Q();
            break;
          case "arrowright":
            I.preventDefault(), ue();
            break;
          case "g":
            I.shiftKey && (d.value = !d.value);
            break;
          case "k":
            (I.ctrlKey || I.metaKey) && (I.preventDefault(), p.value = !0);
            break;
        }
    }
    let Y;
    function H() {
      if ("memory" in performance) {
        const I = performance.memory, F = Math.round(I.usedJSHeapSize / 1024 / 1024);
        P.value = `${F} MB`;
      }
    }
    return _n(async () => {
      const I = await PT();
      x.value = I.tier, window.addEventListener("keydown", V), Y = window.setInterval(H, 1e3);
    }), Nn(() => {
      window.removeEventListener("keydown", V), clearInterval(Y);
    }), (I, F) => (te(), ae("div", lG, [
      f("div", cG, [
        f("div", uG, [
          f("button", {
            class: Fe({ active: n.value === "select" }),
            onClick: F[0] || (F[0] = (L) => n.value = "select"),
            title: "Select (V)"
          }, [...F[27] || (F[27] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: Fe({ active: n.value === "pen" }),
            onClick: F[1] || (F[1] = (L) => n.value = "pen"),
            title: "Pen Tool (P)"
          }, [...F[28] || (F[28] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: Fe({ active: n.value === "text" }),
            onClick: F[2] || (F[2] = (L) => n.value = "text"),
            title: "Text Tool (T)"
          }, [...F[29] || (F[29] = [
            f("span", { class: "icon" }, "T", -1)
          ])], 2),
          f("button", {
            class: Fe({ active: n.value === "hand" }),
            onClick: F[3] || (F[3] = (L) => n.value = "hand"),
            title: "Hand Tool (H)"
          }, [...F[30] || (F[30] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: Fe({ active: n.value === "zoom" }),
            onClick: F[4] || (F[4] = (L) => n.value = "zoom"),
            title: "Zoom Tool (Z)"
          }, [...F[31] || (F[31] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2)
        ]),
        F[41] || (F[41] = f("div", { class: "divider" }, null, -1)),
        f("div", dG, [
          f("button", {
            onClick: A,
            title: "Go to Start (Home)"
          }, [...F[32] || (F[32] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: Q,
            title: "Step Backward"
          }, [...F[33] || (F[33] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: O,
            title: v.value ? "Pause (Space)" : "Play (Space)"
          }, [
            f("span", fG, xe(v.value ? "" : ""), 1)
          ], 8, hG),
          f("button", {
            onClick: ue,
            title: "Step Forward"
          }, [...F[34] || (F[34] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: G,
            title: "Go to End (End)"
          }, [...F[35] || (F[35] = [
            f("span", { class: "icon" }, "", -1)
          ])])
        ]),
        f("div", pG, xe(y.value), 1),
        F[42] || (F[42] = f("div", { class: "divider" }, null, -1)),
        f("div", mG, [
          st(f("select", {
            "onUpdate:modelValue": F[5] || (F[5] = (L) => i.value = L),
            class: "workspace-selector"
          }, [...F[36] || (F[36] = [
            f("option", { value: "standard" }, "Standard", -1),
            f("option", { value: "animation" }, "Animation", -1),
            f("option", { value: "effects" }, "Effects", -1),
            f("option", { value: "minimal" }, "Minimal", -1)
          ])], 512), [
            [Cn, i.value]
          ])
        ]),
        F[43] || (F[43] = f("div", { class: "spacer" }, null, -1)),
        f("div", vG, [
          f("span", {
            class: Fe(["gpu-badge", x.value])
          }, xe(x.value.toUpperCase()), 3),
          f("button", {
            onClick: le,
            disabled: !U.value,
            title: "Undo (Ctrl+Z)"
          }, [...F[37] || (F[37] = [
            f("span", { class: "icon" }, "", -1)
          ])], 8, gG),
          f("button", {
            onClick: re,
            disabled: !R.value,
            title: "Redo (Ctrl+Shift+Z)"
          }, [...F[38] || (F[38] = [
            f("span", { class: "icon" }, "", -1)
          ])], 8, yG),
          f("button", {
            onClick: F[6] || (F[6] = (L) => h.value = !0),
            title: "Export Matte"
          }, [...F[39] || (F[39] = [
            f("span", { class: "icon" }, "", -1),
            ct(" Matte ", -1)
          ])]),
          f("button", {
            onClick: F[7] || (F[7] = (L) => m.value = !0),
            title: "Export to ComfyUI"
          }, [...F[40] || (F[40] = [
            f("span", { class: "icon" }, "", -1),
            ct(" ComfyUI ", -1)
          ])])
        ])
      ]),
      f("div", _G, [
        ze(Ve(ed), { class: "default-theme horizontal-split" }, {
          default: zi(() => [
            ze(Ve(pr), {
              size: 12,
              "min-size": 8,
              "max-size": 20
            }, {
              default: zi(() => [
                f("div", xG, [
                  f("div", bG, [
                    f("button", {
                      class: Fe({ active: r.value === "project" }),
                      onClick: F[8] || (F[8] = (L) => r.value = "project")
                    }, " Project ", 2),
                    f("button", {
                      class: Fe({ active: r.value === "effects" }),
                      onClick: F[9] || (F[9] = (L) => r.value = "effects")
                    }, " Effects ", 2)
                  ]),
                  f("div", wG, [
                    r.value === "project" ? (te(), St(iA, {
                      key: 0,
                      onOpenCompositionSettings: F[10] || (F[10] = (L) => p.value = !0)
                    })) : r.value === "effects" ? (te(), St(UA, { key: 1 })) : Pe("", !0)
                  ])
                ])
              ]),
              _: 1
            }),
            ze(Ve(pr), {
              size: 70,
              "min-size": 40
            }, {
              default: zi(() => [
                ze(Ve(ed), {
                  horizontal: "",
                  class: "default-theme"
                }, {
                  default: zi(() => [
                    ze(Ve(pr), {
                      size: 65,
                      "min-size": 20
                    }, {
                      default: zi(() => [
                        f("div", SG, [
                          f("div", MG, [
                            f("div", CG, [
                              f("button", {
                                class: Fe({ active: a.value === "composition" }),
                                onClick: F[11] || (F[11] = (L) => a.value = "composition")
                              }, " Composition ", 2),
                              f("button", {
                                class: Fe({ active: a.value === "layer" }),
                                onClick: F[12] || (F[12] = (L) => a.value = "layer")
                              }, " Layer ", 2),
                              f("button", {
                                class: Fe({ active: a.value === "footage" }),
                                onClick: F[13] || (F[13] = (L) => a.value = "footage")
                              }, " Footage ", 2)
                            ]),
                            f("div", EG, [
                              st(f("select", {
                                "onUpdate:modelValue": F[14] || (F[14] = (L) => l.value = L),
                                onChange: ce,
                                class: "zoom-select"
                              }, [...F[44] || (F[44] = [
                                f("option", { value: "fit" }, "Fit", -1),
                                f("option", { value: "25" }, "25%", -1),
                                f("option", { value: "50" }, "50%", -1),
                                f("option", { value: "75" }, "75%", -1),
                                f("option", { value: "100" }, "100%", -1),
                                f("option", { value: "150" }, "150%", -1),
                                f("option", { value: "200" }, "200%", -1)
                              ])], 544), [
                                [Cn, l.value]
                              ]),
                              f("button", {
                                class: Fe({ active: c.value }),
                                onClick: F[15] || (F[15] = (L) => c.value = !c.value),
                                title: "Toggle Guides"
                              }, [...F[45] || (F[45] = [
                                f("span", { class: "icon" }, "", -1)
                              ])], 2),
                              f("button", {
                                class: Fe({ active: u.value }),
                                onClick: F[16] || (F[16] = (L) => u.value = !u.value),
                                title: "Toggle Grid"
                              }, [...F[46] || (F[46] = [
                                f("span", { class: "icon" }, "", -1)
                              ])], 2)
                            ])
                          ]),
                          f("div", TG, [
                            a.value === "composition" ? (te(), St(D8, {
                              key: 0,
                              ref_key: "threeCanvasRef",
                              ref: g
                            }, null, 512)) : (te(), St(R6, {
                              key: 1,
                              camera: _.value,
                              viewportState: M.value,
                              viewOptions: S.value,
                              compWidth: b.value,
                              compHeight: C.value
                            }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"]))
                          ])
                        ])
                      ]),
                      _: 1
                    }),
                    ze(Ve(pr), {
                      size: 35,
                      "min-size": 15
                    }, {
                      default: zi(() => [
                        d.value ? (te(), St(Ve(ed), {
                          key: 0,
                          horizontal: "",
                          class: "default-theme"
                        }, {
                          default: zi(() => [
                            ze(Ve(pr), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: zi(() => [
                                f("div", AG, [
                                  ze(ig, {
                                    onOpenCompositionSettings: F[17] || (F[17] = (L) => p.value = !0)
                                  })
                                ])
                              ]),
                              _: 1
                            }),
                            ze(Ve(pr), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: zi(() => [
                                f("div", PG, [
                                  ze(xV, {
                                    onClose: F[18] || (F[18] = (L) => d.value = !1)
                                  })
                                ])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })) : (te(), ae("div", RG, [
                          ze(ig, {
                            onOpenCompositionSettings: F[19] || (F[19] = (L) => p.value = !0)
                          })
                        ]))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            ze(Ve(pr), {
              size: 18,
              "min-size": 12,
              "max-size": 25
            }, {
              default: zi(() => [
                f("div", DG, [
                  f("div", kG, [
                    f("button", {
                      class: Fe({ active: o.value === "effects" }),
                      onClick: F[20] || (F[20] = (L) => o.value = "effects")
                    }, " Effects ", 2),
                    f("button", {
                      class: Fe({ active: o.value === "properties" }),
                      onClick: F[21] || (F[21] = (L) => o.value = "properties")
                    }, " Props ", 2),
                    f("button", {
                      class: Fe({ active: o.value === "camera" }),
                      onClick: F[22] || (F[22] = (L) => o.value = "camera")
                    }, " Cam ", 2),
                    f("button", {
                      class: Fe({ active: o.value === "audio" }),
                      onClick: F[23] || (F[23] = (L) => o.value = "audio")
                    }, " Audio ", 2)
                  ]),
                  f("div", IG, [
                    o.value === "effects" ? (te(), St(rP, { key: 0 })) : o.value === "properties" ? (te(), St(rU, { key: 1 })) : o.value === "camera" ? (te(), St(OO, {
                      key: 2,
                      camera: _.value,
                      "onUpdate:camera": j
                    }, null, 8, ["camera"])) : o.value === "audio" ? (te(), St(l6, { key: 3 })) : Pe("", !0)
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      f("div", LG, [
        f("div", FG, [
          f("span", UG, xe(w.value), 1),
          F[47] || (F[47] = f("span", { class: "status-divider" }, "|", -1)),
          f("span", OG, xe(D.value), 1)
        ]),
        f("div", zG, [
          T.value > 0 ? (te(), ae("span", NG, " Rendering: " + xe(Math.round(T.value * 100)) + "% ", 1)) : Pe("", !0)
        ]),
        f("div", BG, [
          f("span", VG, xe(P.value), 1),
          F[48] || (F[48] = f("span", { class: "status-divider" }, "|", -1)),
          f("span", GG, xe(E.value) + " fps", 1)
        ])
      ]),
      h.value ? (te(), St(a7, {
        key: 0,
        onClose: F[24] || (F[24] = (L) => h.value = !1),
        onExported: $
      })) : Pe("", !0),
      m.value ? (te(), St(P9, {
        key: 1,
        layers: Ve(e).layers,
        "camera-keyframes": ie.value,
        "current-frame": Ve(e).currentFrame,
        "total-frames": Ve(e).frameCount,
        onClose: F[25] || (F[25] = (L) => m.value = !1),
        onExported: q
      }, null, 8, ["layers", "camera-keyframes", "current-frame", "total-frames"])) : Pe("", !0),
      ze(aG, {
        visible: p.value,
        onClose: F[26] || (F[26] = (L) => p.value = !1),
        onConfirm: oe
      }, null, 8, ["visible"])
    ]));
  }
}), $G = /* @__PURE__ */ Gt(HG, [["__scopeId", "data-v-7dd8f679"]]), WG = /* @__PURE__ */ Ot({
  __name: "App",
  setup(s) {
    return (e, n) => (te(), St($G));
  }
}), qy = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
], Zy = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function Ky(s) {
  const e = { r: 0, g: 0, b: 0, a: 0, next: null };
  let n = e;
  for (let i = 1; i < s; i++)
    n.next = { r: 0, g: 0, b: 0, a: 0, next: null }, n = n.next;
  return n.next = e, e;
}
function XG(s, e, n) {
  const i = s.data, r = s.width, o = s.height;
  e = Math.max(0, Math.min(255, Math.round(e))), n = Math.max(0, Math.min(255, Math.round(n))), !(e === 0 && n === 0) && (e > 0 && jG(i, r, o, e), n > 0 && YG(i, r, o, n));
}
function jG(s, e, n, i) {
  const r = i + i + 1, o = e - 1, a = qy[i], l = Zy[i], c = Ky(r);
  for (let u = 0; u < n; u++) {
    let d = 0, h = 0, m = 0, p = 0, v = 0, x = 0, g = 0, _ = 0, M = 0, S = 0, b = 0, C = 0;
    const E = u * e;
    let P = c, T = c;
    const y = s[E * 4], w = s[E * 4 + 1], D = s[E * 4 + 2], U = s[E * 4 + 3];
    for (let O = 0; O <= i; O++) {
      P.r = y, P.g = w, P.b = D, P.a = U;
      const A = i + 1 - O;
      M += y * A, S += w * A, b += D * A, C += U * A, O > 0 ? (d += y, h += w, m += D, p += U) : (v += y, x += w, g += D, _ += U), P = P.next;
    }
    for (let O = 1; O <= i; O++) {
      const A = Math.min(O, o), G = (E + A) * 4, ue = s[G], Q = s[G + 1], le = s[G + 2], re = s[G + 3];
      P.r = ue, P.g = Q, P.b = le, P.a = re;
      const j = i + 1 - O;
      M += ue * j, S += Q * j, b += le * j, C += re * j, d += ue, h += Q, m += le, p += re, P = P.next;
    }
    let R = c;
    for (let O = 0; O < i; O++)
      R = R.next;
    T = R.next;
    for (let O = 0; O < e; O++) {
      const A = (E + O) * 4;
      s[A] = M * a >>> l, s[A + 1] = S * a >>> l, s[A + 2] = b * a >>> l, s[A + 3] = C * a >>> l, M -= v, S -= x, b -= g, C -= _, v -= R.r, x -= R.g, g -= R.b, _ -= R.a;
      const G = Math.min(O + i + 1, o), ue = (E + G) * 4;
      R.r = s[ue], R.g = s[ue + 1], R.b = s[ue + 2], R.a = s[ue + 3], d += R.r, h += R.g, m += R.b, p += R.a, M += d, S += h, b += m, C += p, R = R.next, v += T.r, x += T.g, g += T.b, _ += T.a, d -= T.r, h -= T.g, m -= T.b, p -= T.a, T = T.next;
    }
  }
}
function YG(s, e, n, i) {
  const r = i + i + 1, o = n - 1, a = qy[i], l = Zy[i], c = Ky(r);
  for (let u = 0; u < e; u++) {
    let d = 0, h = 0, m = 0, p = 0, v = 0, x = 0, g = 0, _ = 0, M = 0, S = 0, b = 0, C = 0, E = c, P = c;
    const T = s[u * 4], y = s[u * 4 + 1], w = s[u * 4 + 2], D = s[u * 4 + 3];
    for (let R = 0; R <= i; R++) {
      E.r = T, E.g = y, E.b = w, E.a = D;
      const O = i + 1 - R;
      M += T * O, S += y * O, b += w * O, C += D * O, R > 0 ? (d += T, h += y, m += w, p += D) : (v += T, x += y, g += w, _ += D), E = E.next;
    }
    for (let R = 1; R <= i; R++) {
      const A = (Math.min(R, o) * e + u) * 4, G = s[A], ue = s[A + 1], Q = s[A + 2], le = s[A + 3];
      E.r = G, E.g = ue, E.b = Q, E.a = le;
      const re = i + 1 - R;
      M += G * re, S += ue * re, b += Q * re, C += le * re, d += G, h += ue, m += Q, p += le, E = E.next;
    }
    let U = c;
    for (let R = 0; R < i; R++)
      U = U.next;
    P = U.next;
    for (let R = 0; R < n; R++) {
      const O = (R * e + u) * 4;
      s[O] = M * a >>> l, s[O + 1] = S * a >>> l, s[O + 2] = b * a >>> l, s[O + 3] = C * a >>> l, M -= v, S -= x, b -= g, C -= _, v -= U.r, x -= U.g, g -= U.b, _ -= U.a;
      const G = (Math.min(R + i + 1, o) * e + u) * 4;
      U.r = s[G], U.g = s[G + 1], U.b = s[G + 2], U.a = s[G + 3], d += U.r, h += U.g, m += U.b, p += U.a, M += d, S += h, b += m, C += p, U = U.next, v += P.r, x += P.g, g += P.b, _ += P.a, d -= P.r, h -= P.g, m -= P.b, p -= P.a, P = P.next;
    }
  }
}
function qG(s, e) {
  const n = e.blurriness ?? 10, i = e.blur_dimensions ?? "both";
  if (n <= 0)
    return s;
  const r = Jo(s.canvas), o = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height);
  let a = 0, l = 0;
  switch (i) {
    case "horizontal":
      a = n;
      break;
    case "vertical":
      l = n;
      break;
    case "both":
    default:
      a = n, l = n;
      break;
  }
  return XG(o, a, l), r.ctx.putImageData(o, 0, 0), r;
}
function ZG() {
  wo("gaussian-blur", qG);
}
function KG(s, e) {
  const n = (e.brightness ?? 0) / 100, i = (e.contrast ?? 0) / 100, r = e.use_legacy ?? !1;
  if (n === 0 && i === 0)
    return s;
  const o = Jo(s.canvas), a = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), l = a.data, c = r ? 1 + i : 259 * (i * 255 + 255) / (255 * (259 - i * 255));
  for (let u = 0; u < l.length; u += 4) {
    let d = l[u], h = l[u + 1], m = l[u + 2];
    d += n * 255, h += n * 255, m += n * 255, d = c * (d - 128) + 128, h = c * (h - 128) + 128, m = c * (m - 128) + 128, l[u] = Math.max(0, Math.min(255, d)), l[u + 1] = Math.max(0, Math.min(255, h)), l[u + 2] = Math.max(0, Math.min(255, m));
  }
  return o.ctx.putImageData(a, 0, 0), o;
}
function JG(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), r = Math.min(s, e, n), o = (i + r) / 2;
  let a = 0, l = 0;
  if (i !== r) {
    const c = i - r;
    switch (l = o > 0.5 ? c / (2 - i - r) : c / (i + r), i) {
      case s:
        a = ((e - n) / c + (e < n ? 6 : 0)) / 6;
        break;
      case e:
        a = ((n - s) / c + 2) / 6;
        break;
      case n:
        a = ((s - e) / c + 4) / 6;
        break;
    }
  }
  return [a, l, o];
}
function QG(s, e, n) {
  let i, r, o;
  if (e === 0)
    i = r = o = n;
  else {
    const a = (u, d, h) => (h < 0 && (h += 1), h > 1 && (h -= 1), h < 0.16666666666666666 ? u + (d - u) * 6 * h : h < 0.5 ? d : h < 0.6666666666666666 ? u + (d - u) * (0.6666666666666666 - h) * 6 : u), l = n < 0.5 ? n * (1 + e) : n + e - n * e, c = 2 * n - l;
    i = a(c, l, s + 1 / 3), r = a(c, l, s), o = a(c, l, s - 1 / 3);
  }
  return [Math.round(i * 255), Math.round(r * 255), Math.round(o * 255)];
}
function eH(s, e) {
  const n = (e.master_hue ?? 0) / 360, i = (e.master_saturation ?? 0) / 100, r = (e.master_lightness ?? 0) / 100, o = e.colorize ?? !1;
  if (n === 0 && i === 0 && r === 0 && !o)
    return s;
  const a = Jo(s.canvas), l = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), c = l.data;
  for (let u = 0; u < c.length; u += 4) {
    const d = c[u], h = c[u + 1], m = c[u + 2];
    let [p, v, x] = JG(d, h, m);
    o ? (p = n, v = Math.abs(i) + 0.25) : (p = (p + n) % 1, p < 0 && (p += 1), v = v + v * i), x = x + x * r, v = Math.max(0, Math.min(1, v)), x = Math.max(0, Math.min(1, x));
    const [g, _, M] = QG(p, v, x);
    c[u] = g, c[u + 1] = _, c[u + 2] = M;
  }
  return a.ctx.putImageData(l, 0, 0), a;
}
function tH(s, e) {
  const n = e.input_black ?? 0, i = e.input_white ?? 255, r = e.gamma ?? 1, o = e.output_black ?? 0, a = e.output_white ?? 255;
  if (n === 0 && i === 255 && r === 1 && o === 0 && a === 255)
    return s;
  const l = Jo(s.canvas), c = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), u = c.data, d = new Uint8Array(256), h = i - n, m = a - o;
  for (let p = 0; p < 256; p++) {
    let v = (p - n) / h;
    v = Math.max(0, Math.min(1, v)), v = Math.pow(v, 1 / r), v = o + v * m, v = Math.max(0, Math.min(255, v)), d[p] = Math.round(v);
  }
  for (let p = 0; p < u.length; p += 4)
    u[p] = d[u[p]], u[p + 1] = d[u[p + 1]], u[p + 2] = d[u[p + 2]];
  return l.ctx.putImageData(c, 0, 0), l;
}
function nH(s, e) {
  const n = e.map_black_to ?? { r: 0, g: 0, b: 0 }, i = e.map_white_to ?? { r: 255, g: 255, b: 255 }, r = (e.amount_to_tint ?? 100) / 100;
  if (r === 0)
    return s;
  const o = Jo(s.canvas), a = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), l = a.data;
  for (let c = 0; c < l.length; c += 4) {
    const u = l[c], d = l[c + 1], h = l[c + 2], m = (u * 0.299 + d * 0.587 + h * 0.114) / 255, p = n.r + (i.r - n.r) * m, v = n.g + (i.g - n.g) * m, x = n.b + (i.b - n.b) * m;
    l[c] = Math.round(u + (p - u) * r), l[c + 1] = Math.round(d + (v - d) * r), l[c + 2] = Math.round(h + (x - h) * r);
  }
  return o.ctx.putImageData(a, 0, 0), o;
}
function iH(s, e) {
  const n = e.shadow_color ?? { r: 0, g: 0, b: 0 }, i = (e.opacity ?? 50) / 100, r = (e.direction ?? 135) * Math.PI / 180, o = e.distance ?? 5, a = e.softness ?? 5, l = e.shadow_only ?? !1, c = Jo(s.canvas), { width: u, height: d } = s.canvas, h = Math.cos(r) * o, m = Math.sin(r) * o;
  return c.ctx.shadowColor = `rgba(${n.r}, ${n.g}, ${n.b}, ${i})`, c.ctx.shadowBlur = a, c.ctx.shadowOffsetX = h, c.ctx.shadowOffsetY = m, c.ctx.drawImage(s.canvas, 0, 0), c.ctx.shadowColor = "transparent", c.ctx.shadowBlur = 0, c.ctx.shadowOffsetX = 0, c.ctx.shadowOffsetY = 0, l || c.ctx.drawImage(s.canvas, 0, 0), c;
}
function sH() {
  wo("brightness-contrast", KG), wo("hue-saturation", eH), wo("levels", tH), wo("tint", nH), wo("drop-shadow", iH);
}
function rH() {
  ZG(), sH();
}
let Jy = null;
function fg(s) {
  let e = null;
  if (typeof s == "string" ? e = document.getElementById(s) || document.querySelector(s) : s instanceof HTMLElement ? e = s : e = document.getElementById("weyl-compositor-root") || document.getElementById("app"), !e) return null;
  rH();
  const n = Tx(WG);
  return n.use(Rx()), n.mount(e), Jy = n, oH(), n;
}
function oH() {
  window.addEventListener("weyl:inputs-ready", (s) => {
    window.dispatchEvent(new CustomEvent("weyl:load-project-inputs", { detail: s.detail }));
  });
}
async function hH(s, e) {
  var n, i;
  return ((i = (n = window.WeylCompositor) == null ? void 0 : n.sendOutput) == null ? void 0 : i.call(n, s, e)) ?? !1;
}
document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => fg()) : setTimeout(() => {
  Jy || fg();
}, 0);
var Cc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function aH(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
function Ec(s) {
  throw new Error('Could not dynamically require "' + s + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Qy = { exports: {} };
(function(s, e) {
  var n = { env: {} };
  /*!
  
  	JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  	<http://stuartk.com/jszip>
  
  	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  	JSZip uses the library pako released under the MIT license :
  	https://github.com/nodeca/pako/blob/main/LICENSE
  	*/
  (function(i) {
    s.exports = i();
  })(function() {
    return function i(r, o, a) {
      function l(d, h) {
        if (!o[d]) {
          if (!r[d]) {
            var m = typeof Ec == "function" && Ec;
            if (!h && m) return m(d, !0);
            if (c) return c(d, !0);
            var p = new Error("Cannot find module '" + d + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var v = o[d] = { exports: {} };
          r[d][0].call(v.exports, function(x) {
            var g = r[d][1][x];
            return l(g || x);
          }, v, v.exports, i, r, o, a);
        }
        return o[d].exports;
      }
      for (var c = typeof Ec == "function" && Ec, u = 0; u < a.length; u++) l(a[u]);
      return l;
    }({ 1: [function(i, r, o) {
      var a = i("./utils"), l = i("./support"), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      o.encode = function(u) {
        for (var d, h, m, p, v, x, g, _ = [], M = 0, S = u.length, b = S, C = a.getTypeOf(u) !== "string"; M < u.length; ) b = S - M, m = C ? (d = u[M++], h = M < S ? u[M++] : 0, M < S ? u[M++] : 0) : (d = u.charCodeAt(M++), h = M < S ? u.charCodeAt(M++) : 0, M < S ? u.charCodeAt(M++) : 0), p = d >> 2, v = (3 & d) << 4 | h >> 4, x = 1 < b ? (15 & h) << 2 | m >> 6 : 64, g = 2 < b ? 63 & m : 64, _.push(c.charAt(p) + c.charAt(v) + c.charAt(x) + c.charAt(g));
        return _.join("");
      }, o.decode = function(u) {
        var d, h, m, p, v, x, g = 0, _ = 0, M = "data:";
        if (u.substr(0, M.length) === M) throw new Error("Invalid base64 input, it looks like a data url.");
        var S, b = 3 * (u = u.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (u.charAt(u.length - 1) === c.charAt(64) && b--, u.charAt(u.length - 2) === c.charAt(64) && b--, b % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (S = l.uint8array ? new Uint8Array(0 | b) : new Array(0 | b); g < u.length; ) d = c.indexOf(u.charAt(g++)) << 2 | (p = c.indexOf(u.charAt(g++))) >> 4, h = (15 & p) << 4 | (v = c.indexOf(u.charAt(g++))) >> 2, m = (3 & v) << 6 | (x = c.indexOf(u.charAt(g++))), S[_++] = d, v !== 64 && (S[_++] = h), x !== 64 && (S[_++] = m);
        return S;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(i, r, o) {
      var a = i("./external"), l = i("./stream/DataWorker"), c = i("./stream/Crc32Probe"), u = i("./stream/DataLengthProbe");
      function d(h, m, p, v, x) {
        this.compressedSize = h, this.uncompressedSize = m, this.crc32 = p, this.compression = v, this.compressedContent = x;
      }
      d.prototype = { getContentWorker: function() {
        var h = new l(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), m = this;
        return h.on("end", function() {
          if (this.streamInfo.data_length !== m.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), h;
      }, getCompressedWorker: function() {
        return new l(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, d.createWorkerFrom = function(h, m, p) {
        return h.pipe(new c()).pipe(new u("uncompressedSize")).pipe(m.compressWorker(p)).pipe(new u("compressedSize")).withStreamInfo("compression", m);
      }, r.exports = d;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(i, r, o) {
      var a = i("./stream/GenericWorker");
      o.STORE = { magic: "\0\0", compressWorker: function() {
        return new a("STORE compression");
      }, uncompressWorker: function() {
        return new a("STORE decompression");
      } }, o.DEFLATE = i("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(i, r, o) {
      var a = i("./utils"), l = function() {
        for (var c, u = [], d = 0; d < 256; d++) {
          c = d;
          for (var h = 0; h < 8; h++) c = 1 & c ? 3988292384 ^ c >>> 1 : c >>> 1;
          u[d] = c;
        }
        return u;
      }();
      r.exports = function(c, u) {
        return c !== void 0 && c.length ? a.getTypeOf(c) !== "string" ? function(d, h, m, p) {
          var v = l, x = p + m;
          d ^= -1;
          for (var g = p; g < x; g++) d = d >>> 8 ^ v[255 & (d ^ h[g])];
          return -1 ^ d;
        }(0 | u, c, c.length, 0) : function(d, h, m, p) {
          var v = l, x = p + m;
          d ^= -1;
          for (var g = p; g < x; g++) d = d >>> 8 ^ v[255 & (d ^ h.charCodeAt(g))];
          return -1 ^ d;
        }(0 | u, c, c.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(i, r, o) {
      o.base64 = !1, o.binary = !1, o.dir = !1, o.createFolders = !0, o.date = null, o.compression = null, o.compressionOptions = null, o.comment = null, o.unixPermissions = null, o.dosPermissions = null;
    }, {}], 6: [function(i, r, o) {
      var a = null;
      a = typeof Promise < "u" ? Promise : i("lie"), r.exports = { Promise: a };
    }, { lie: 37 }], 7: [function(i, r, o) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", l = i("pako"), c = i("./utils"), u = i("./stream/GenericWorker"), d = a ? "uint8array" : "array";
      function h(m, p) {
        u.call(this, "FlateWorker/" + m), this._pako = null, this._pakoAction = m, this._pakoOptions = p, this.meta = {};
      }
      o.magic = "\b\0", c.inherits(h, u), h.prototype.processChunk = function(m) {
        this.meta = m.meta, this._pako === null && this._createPako(), this._pako.push(c.transformTo(d, m.data), !1);
      }, h.prototype.flush = function() {
        u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, h.prototype.cleanUp = function() {
        u.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new l[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var m = this;
        this._pako.onData = function(p) {
          m.push({ data: p, meta: m.meta });
        };
      }, o.compressWorker = function(m) {
        return new h("Deflate", m);
      }, o.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(i, r, o) {
      function a(v, x) {
        var g, _ = "";
        for (g = 0; g < x; g++) _ += String.fromCharCode(255 & v), v >>>= 8;
        return _;
      }
      function l(v, x, g, _, M, S) {
        var b, C, E = v.file, P = v.compression, T = S !== d.utf8encode, y = c.transformTo("string", S(E.name)), w = c.transformTo("string", d.utf8encode(E.name)), D = E.comment, U = c.transformTo("string", S(D)), R = c.transformTo("string", d.utf8encode(D)), O = w.length !== E.name.length, A = R.length !== D.length, G = "", ue = "", Q = "", le = E.dir, re = E.date, j = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        x && !g || (j.crc32 = v.crc32, j.compressedSize = v.compressedSize, j.uncompressedSize = v.uncompressedSize);
        var $ = 0;
        x && ($ |= 8), T || !O && !A || ($ |= 2048);
        var q = 0, oe = 0;
        le && (q |= 16), M === "UNIX" ? (oe = 798, q |= function(ce, V) {
          var Y = ce;
          return ce || (Y = V ? 16893 : 33204), (65535 & Y) << 16;
        }(E.unixPermissions, le)) : (oe = 20, q |= function(ce) {
          return 63 & (ce || 0);
        }(E.dosPermissions)), b = re.getUTCHours(), b <<= 6, b |= re.getUTCMinutes(), b <<= 5, b |= re.getUTCSeconds() / 2, C = re.getUTCFullYear() - 1980, C <<= 4, C |= re.getUTCMonth() + 1, C <<= 5, C |= re.getUTCDate(), O && (ue = a(1, 1) + a(h(y), 4) + w, G += "up" + a(ue.length, 2) + ue), A && (Q = a(1, 1) + a(h(U), 4) + R, G += "uc" + a(Q.length, 2) + Q);
        var ie = "";
        return ie += `
\0`, ie += a($, 2), ie += P.magic, ie += a(b, 2), ie += a(C, 2), ie += a(j.crc32, 4), ie += a(j.compressedSize, 4), ie += a(j.uncompressedSize, 4), ie += a(y.length, 2), ie += a(G.length, 2), { fileRecord: m.LOCAL_FILE_HEADER + ie + y + G, dirRecord: m.CENTRAL_FILE_HEADER + a(oe, 2) + ie + a(U.length, 2) + "\0\0\0\0" + a(q, 4) + a(_, 4) + y + G + U };
      }
      var c = i("../utils"), u = i("../stream/GenericWorker"), d = i("../utf8"), h = i("../crc32"), m = i("../signature");
      function p(v, x, g, _) {
        u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = x, this.zipPlatform = g, this.encodeFileName = _, this.streamFiles = v, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      c.inherits(p, u), p.prototype.push = function(v) {
        var x = v.meta.percent || 0, g = this.entriesCount, _ = this._sources.length;
        this.accumulate ? this.contentBuffer.push(v) : (this.bytesWritten += v.data.length, u.prototype.push.call(this, { data: v.data, meta: { currentFile: this.currentFile, percent: g ? (x + 100 * (g - _ - 1)) / g : 100 } }));
      }, p.prototype.openedSource = function(v) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = v.file.name;
        var x = this.streamFiles && !v.file.dir;
        if (x) {
          var g = l(v, x, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: g.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, p.prototype.closedSource = function(v) {
        this.accumulate = !1;
        var x = this.streamFiles && !v.file.dir, g = l(v, x, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(g.dirRecord), x) this.push({ data: function(_) {
          return m.DATA_DESCRIPTOR + a(_.crc32, 4) + a(_.compressedSize, 4) + a(_.uncompressedSize, 4);
        }(v), meta: { percent: 100 } });
        else for (this.push({ data: g.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var v = this.bytesWritten, x = 0; x < this.dirRecords.length; x++) this.push({ data: this.dirRecords[x], meta: { percent: 100 } });
        var g = this.bytesWritten - v, _ = function(M, S, b, C, E) {
          var P = c.transformTo("string", E(C));
          return m.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(M, 2) + a(M, 2) + a(S, 4) + a(b, 4) + a(P.length, 2) + P;
        }(this.dirRecords.length, g, v, this.zipComment, this.encodeFileName);
        this.push({ data: _, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(v) {
        this._sources.push(v);
        var x = this;
        return v.on("data", function(g) {
          x.processChunk(g);
        }), v.on("end", function() {
          x.closedSource(x.previous.streamInfo), x._sources.length ? x.prepareNextSource() : x.end();
        }), v.on("error", function(g) {
          x.error(g);
        }), this;
      }, p.prototype.resume = function() {
        return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(v) {
        var x = this._sources;
        if (!u.prototype.error.call(this, v)) return !1;
        for (var g = 0; g < x.length; g++) try {
          x[g].error(v);
        } catch {
        }
        return !0;
      }, p.prototype.lock = function() {
        u.prototype.lock.call(this);
        for (var v = this._sources, x = 0; x < v.length; x++) v[x].lock();
      }, r.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(i, r, o) {
      var a = i("../compressions"), l = i("./ZipFileWorker");
      o.generateWorker = function(c, u, d) {
        var h = new l(u.streamFiles, d, u.platform, u.encodeFileName), m = 0;
        try {
          c.forEach(function(p, v) {
            m++;
            var x = function(S, b) {
              var C = S || b, E = a[C];
              if (!E) throw new Error(C + " is not a valid compression method !");
              return E;
            }(v.options.compression, u.compression), g = v.options.compressionOptions || u.compressionOptions || {}, _ = v.dir, M = v.date;
            v._compressWorker(x, g).withStreamInfo("file", { name: p, dir: _, date: M, comment: v.comment || "", unixPermissions: v.unixPermissions, dosPermissions: v.dosPermissions }).pipe(h);
          }), h.entriesCount = m;
        } catch (p) {
          h.error(p);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(i, r, o) {
      function a() {
        if (!(this instanceof a)) return new a();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var l = new a();
          for (var c in this) typeof this[c] != "function" && (l[c] = this[c]);
          return l;
        };
      }
      (a.prototype = i("./object")).loadAsync = i("./load"), a.support = i("./support"), a.defaults = i("./defaults"), a.version = "3.10.1", a.loadAsync = function(l, c) {
        return new a().loadAsync(l, c);
      }, a.external = i("./external"), r.exports = a;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(i, r, o) {
      var a = i("./utils"), l = i("./external"), c = i("./utf8"), u = i("./zipEntries"), d = i("./stream/Crc32Probe"), h = i("./nodejsUtils");
      function m(p) {
        return new l.Promise(function(v, x) {
          var g = p.decompressed.getContentWorker().pipe(new d());
          g.on("error", function(_) {
            x(_);
          }).on("end", function() {
            g.streamInfo.crc32 !== p.decompressed.crc32 ? x(new Error("Corrupted zip : CRC32 mismatch")) : v();
          }).resume();
        });
      }
      r.exports = function(p, v) {
        var x = this;
        return v = a.extend(v || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: c.utf8decode }), h.isNode && h.isStream(p) ? l.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", p, !0, v.optimizedBinaryString, v.base64).then(function(g) {
          var _ = new u(v);
          return _.load(g), _;
        }).then(function(g) {
          var _ = [l.Promise.resolve(g)], M = g.files;
          if (v.checkCRC32) for (var S = 0; S < M.length; S++) _.push(m(M[S]));
          return l.Promise.all(_);
        }).then(function(g) {
          for (var _ = g.shift(), M = _.files, S = 0; S < M.length; S++) {
            var b = M[S], C = b.fileNameStr, E = a.resolve(b.fileNameStr);
            x.file(E, b.decompressed, { binary: !0, optimizedBinaryString: !0, date: b.date, dir: b.dir, comment: b.fileCommentStr.length ? b.fileCommentStr : null, unixPermissions: b.unixPermissions, dosPermissions: b.dosPermissions, createFolders: v.createFolders }), b.dir || (x.file(E).unsafeOriginalName = C);
          }
          return _.zipComment.length && (x.comment = _.zipComment), x;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(i, r, o) {
      var a = i("../utils"), l = i("../stream/GenericWorker");
      function c(u, d) {
        l.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = !1, this._bindStream(d);
      }
      a.inherits(c, l), c.prototype._bindStream = function(u) {
        var d = this;
        (this._stream = u).pause(), u.on("data", function(h) {
          d.push({ data: h, meta: { percent: 0 } });
        }).on("error", function(h) {
          d.isPaused ? this.generatedError = h : d.error(h);
        }).on("end", function() {
          d.isPaused ? d._upstreamEnded = !0 : d.end();
        });
      }, c.prototype.pause = function() {
        return !!l.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, c.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, r.exports = c;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(i, r, o) {
      var a = i("readable-stream").Readable;
      function l(c, u, d) {
        a.call(this, u), this._helper = c;
        var h = this;
        c.on("data", function(m, p) {
          h.push(m) || h._helper.pause(), d && d(p);
        }).on("error", function(m) {
          h.emit("error", m);
        }).on("end", function() {
          h.push(null);
        });
      }
      i("../utils").inherits(l, a), l.prototype._read = function() {
        this._helper.resume();
      }, r.exports = l;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(i, r, o) {
      r.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(a, l) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(a, l);
        if (typeof a == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(a, l);
      }, allocBuffer: function(a) {
        if (Buffer.alloc) return Buffer.alloc(a);
        var l = new Buffer(a);
        return l.fill(0), l;
      }, isBuffer: function(a) {
        return Buffer.isBuffer(a);
      }, isStream: function(a) {
        return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
      } };
    }, {}], 15: [function(i, r, o) {
      function a(E, P, T) {
        var y, w = c.getTypeOf(P), D = c.extend(T || {}, h);
        D.date = D.date || /* @__PURE__ */ new Date(), D.compression !== null && (D.compression = D.compression.toUpperCase()), typeof D.unixPermissions == "string" && (D.unixPermissions = parseInt(D.unixPermissions, 8)), D.unixPermissions && 16384 & D.unixPermissions && (D.dir = !0), D.dosPermissions && 16 & D.dosPermissions && (D.dir = !0), D.dir && (E = M(E)), D.createFolders && (y = _(E)) && S.call(this, y, !0);
        var U = w === "string" && D.binary === !1 && D.base64 === !1;
        T && T.binary !== void 0 || (D.binary = !U), (P instanceof m && P.uncompressedSize === 0 || D.dir || !P || P.length === 0) && (D.base64 = !1, D.binary = !0, P = "", D.compression = "STORE", w = "string");
        var R = null;
        R = P instanceof m || P instanceof u ? P : x.isNode && x.isStream(P) ? new g(E, P) : c.prepareContent(E, P, D.binary, D.optimizedBinaryString, D.base64);
        var O = new p(E, R, D);
        this.files[E] = O;
      }
      var l = i("./utf8"), c = i("./utils"), u = i("./stream/GenericWorker"), d = i("./stream/StreamHelper"), h = i("./defaults"), m = i("./compressedObject"), p = i("./zipObject"), v = i("./generate"), x = i("./nodejsUtils"), g = i("./nodejs/NodejsStreamInputAdapter"), _ = function(E) {
        E.slice(-1) === "/" && (E = E.substring(0, E.length - 1));
        var P = E.lastIndexOf("/");
        return 0 < P ? E.substring(0, P) : "";
      }, M = function(E) {
        return E.slice(-1) !== "/" && (E += "/"), E;
      }, S = function(E, P) {
        return P = P !== void 0 ? P : h.createFolders, E = M(E), this.files[E] || a.call(this, E, null, { dir: !0, createFolders: P }), this.files[E];
      };
      function b(E) {
        return Object.prototype.toString.call(E) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(E) {
        var P, T, y;
        for (P in this.files) y = this.files[P], (T = P.slice(this.root.length, P.length)) && P.slice(0, this.root.length) === this.root && E(T, y);
      }, filter: function(E) {
        var P = [];
        return this.forEach(function(T, y) {
          E(T, y) && P.push(y);
        }), P;
      }, file: function(E, P, T) {
        if (arguments.length !== 1) return E = this.root + E, a.call(this, E, P, T), this;
        if (b(E)) {
          var y = E;
          return this.filter(function(D, U) {
            return !U.dir && y.test(D);
          });
        }
        var w = this.files[this.root + E];
        return w && !w.dir ? w : null;
      }, folder: function(E) {
        if (!E) return this;
        if (b(E)) return this.filter(function(w, D) {
          return D.dir && E.test(w);
        });
        var P = this.root + E, T = S.call(this, P), y = this.clone();
        return y.root = T.name, y;
      }, remove: function(E) {
        E = this.root + E;
        var P = this.files[E];
        if (P || (E.slice(-1) !== "/" && (E += "/"), P = this.files[E]), P && !P.dir) delete this.files[E];
        else for (var T = this.filter(function(w, D) {
          return D.name.slice(0, E.length) === E;
        }), y = 0; y < T.length; y++) delete this.files[T[y].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(E) {
        var P, T = {};
        try {
          if ((T = c.extend(E || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: l.utf8encode })).type = T.type.toLowerCase(), T.compression = T.compression.toUpperCase(), T.type === "binarystring" && (T.type = "string"), !T.type) throw new Error("No output type specified.");
          c.checkSupport(T.type), T.platform !== "darwin" && T.platform !== "freebsd" && T.platform !== "linux" && T.platform !== "sunos" || (T.platform = "UNIX"), T.platform === "win32" && (T.platform = "DOS");
          var y = T.comment || this.comment || "";
          P = v.generateWorker(this, T, y);
        } catch (w) {
          (P = new u("error")).error(w);
        }
        return new d(P, T.type || "string", T.mimeType);
      }, generateAsync: function(E, P) {
        return this.generateInternalStream(E).accumulate(P);
      }, generateNodeStream: function(E, P) {
        return (E = E || {}).type || (E.type = "nodebuffer"), this.generateInternalStream(E).toNodejsStream(P);
      } };
      r.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(i, r, o) {
      r.exports = i("stream");
    }, { stream: void 0 }], 17: [function(i, r, o) {
      var a = i("./DataReader");
      function l(c) {
        a.call(this, c);
        for (var u = 0; u < this.data.length; u++) c[u] = 255 & c[u];
      }
      i("../utils").inherits(l, a), l.prototype.byteAt = function(c) {
        return this.data[this.zero + c];
      }, l.prototype.lastIndexOfSignature = function(c) {
        for (var u = c.charCodeAt(0), d = c.charCodeAt(1), h = c.charCodeAt(2), m = c.charCodeAt(3), p = this.length - 4; 0 <= p; --p) if (this.data[p] === u && this.data[p + 1] === d && this.data[p + 2] === h && this.data[p + 3] === m) return p - this.zero;
        return -1;
      }, l.prototype.readAndCheckSignature = function(c) {
        var u = c.charCodeAt(0), d = c.charCodeAt(1), h = c.charCodeAt(2), m = c.charCodeAt(3), p = this.readData(4);
        return u === p[0] && d === p[1] && h === p[2] && m === p[3];
      }, l.prototype.readData = function(c) {
        if (this.checkOffset(c), c === 0) return [];
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(i, r, o) {
      var a = i("../utils");
      function l(c) {
        this.data = c, this.length = c.length, this.index = 0, this.zero = 0;
      }
      l.prototype = { checkOffset: function(c) {
        this.checkIndex(this.index + c);
      }, checkIndex: function(c) {
        if (this.length < this.zero + c || c < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + c + "). Corrupted zip ?");
      }, setIndex: function(c) {
        this.checkIndex(c), this.index = c;
      }, skip: function(c) {
        this.setIndex(this.index + c);
      }, byteAt: function() {
      }, readInt: function(c) {
        var u, d = 0;
        for (this.checkOffset(c), u = this.index + c - 1; u >= this.index; u--) d = (d << 8) + this.byteAt(u);
        return this.index += c, d;
      }, readString: function(c) {
        return a.transformTo("string", this.readData(c));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var c = this.readInt(4);
        return new Date(Date.UTC(1980 + (c >> 25 & 127), (c >> 21 & 15) - 1, c >> 16 & 31, c >> 11 & 31, c >> 5 & 63, (31 & c) << 1));
      } }, r.exports = l;
    }, { "../utils": 32 }], 19: [function(i, r, o) {
      var a = i("./Uint8ArrayReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.readData = function(c) {
        this.checkOffset(c);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(i, r, o) {
      var a = i("./DataReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.byteAt = function(c) {
        return this.data.charCodeAt(this.zero + c);
      }, l.prototype.lastIndexOfSignature = function(c) {
        return this.data.lastIndexOf(c) - this.zero;
      }, l.prototype.readAndCheckSignature = function(c) {
        return c === this.readData(4);
      }, l.prototype.readData = function(c) {
        this.checkOffset(c);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(i, r, o) {
      var a = i("./ArrayReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.readData = function(c) {
        if (this.checkOffset(c), c === 0) return new Uint8Array(0);
        var u = this.data.subarray(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(i, r, o) {
      var a = i("../utils"), l = i("../support"), c = i("./ArrayReader"), u = i("./StringReader"), d = i("./NodeBufferReader"), h = i("./Uint8ArrayReader");
      r.exports = function(m) {
        var p = a.getTypeOf(m);
        return a.checkSupport(p), p !== "string" || l.uint8array ? p === "nodebuffer" ? new d(m) : l.uint8array ? new h(a.transformTo("uint8array", m)) : new c(a.transformTo("array", m)) : new u(m);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(i, r, o) {
      o.LOCAL_FILE_HEADER = "PK", o.CENTRAL_FILE_HEADER = "PK", o.CENTRAL_DIRECTORY_END = "PK", o.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", o.ZIP64_CENTRAL_DIRECTORY_END = "PK", o.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(i, r, o) {
      var a = i("./GenericWorker"), l = i("../utils");
      function c(u) {
        a.call(this, "ConvertWorker to " + u), this.destType = u;
      }
      l.inherits(c, a), c.prototype.processChunk = function(u) {
        this.push({ data: l.transformTo(this.destType, u.data), meta: u.meta });
      }, r.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(i, r, o) {
      var a = i("./GenericWorker"), l = i("../crc32");
      function c() {
        a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      i("../utils").inherits(c, a), c.prototype.processChunk = function(u) {
        this.streamInfo.crc32 = l(u.data, this.streamInfo.crc32 || 0), this.push(u);
      }, r.exports = c;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(i, r, o) {
      var a = i("../utils"), l = i("./GenericWorker");
      function c(u) {
        l.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
      }
      a.inherits(c, l), c.prototype.processChunk = function(u) {
        if (u) {
          var d = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = d + u.data.length;
        }
        l.prototype.processChunk.call(this, u);
      }, r.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(i, r, o) {
      var a = i("../utils"), l = i("./GenericWorker");
      function c(u) {
        l.call(this, "DataWorker");
        var d = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(h) {
          d.dataIsReady = !0, d.data = h, d.max = h && h.length || 0, d.type = a.getTypeOf(h), d.isPaused || d._tickAndRepeat();
        }, function(h) {
          d.error(h);
        });
      }
      a.inherits(c, l), c.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this.data = null;
      }, c.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, a.delay(this._tickAndRepeat, [], this)), !0);
      }, c.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, c.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var u = null, d = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            u = this.data.substring(this.index, d);
            break;
          case "uint8array":
            u = this.data.subarray(this.index, d);
            break;
          case "array":
          case "nodebuffer":
            u = this.data.slice(this.index, d);
        }
        return this.index = d, this.push({ data: u, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, r.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(i, r, o) {
      function a(l) {
        this.name = l || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      a.prototype = { push: function(l) {
        this.emit("data", l);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (l) {
          this.emit("error", l);
        }
        return !0;
      }, error: function(l) {
        return !this.isFinished && (this.isPaused ? this.generatedError = l : (this.isFinished = !0, this.emit("error", l), this.previous && this.previous.error(l), this.cleanUp()), !0);
      }, on: function(l, c) {
        return this._listeners[l].push(c), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(l, c) {
        if (this._listeners[l]) for (var u = 0; u < this._listeners[l].length; u++) this._listeners[l][u].call(this, c);
      }, pipe: function(l) {
        return l.registerPrevious(this);
      }, registerPrevious: function(l) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = l.streamInfo, this.mergeStreamInfo(), this.previous = l;
        var c = this;
        return l.on("data", function(u) {
          c.processChunk(u);
        }), l.on("end", function() {
          c.end();
        }), l.on("error", function(u) {
          c.error(u);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var l = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), l = !0), this.previous && this.previous.resume(), !l;
      }, flush: function() {
      }, processChunk: function(l) {
        this.push(l);
      }, withStreamInfo: function(l, c) {
        return this.extraStreamInfo[l] = c, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var l in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, l) && (this.streamInfo[l] = this.extraStreamInfo[l]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var l = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + l : l;
      } }, r.exports = a;
    }, {}], 29: [function(i, r, o) {
      var a = i("../utils"), l = i("./ConvertWorker"), c = i("./GenericWorker"), u = i("../base64"), d = i("../support"), h = i("../external"), m = null;
      if (d.nodestream) try {
        m = i("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function p(x, g) {
        return new h.Promise(function(_, M) {
          var S = [], b = x._internalType, C = x._outputType, E = x._mimeType;
          x.on("data", function(P, T) {
            S.push(P), g && g(T);
          }).on("error", function(P) {
            S = [], M(P);
          }).on("end", function() {
            try {
              var P = function(T, y, w) {
                switch (T) {
                  case "blob":
                    return a.newBlob(a.transformTo("arraybuffer", y), w);
                  case "base64":
                    return u.encode(y);
                  default:
                    return a.transformTo(T, y);
                }
              }(C, function(T, y) {
                var w, D = 0, U = null, R = 0;
                for (w = 0; w < y.length; w++) R += y[w].length;
                switch (T) {
                  case "string":
                    return y.join("");
                  case "array":
                    return Array.prototype.concat.apply([], y);
                  case "uint8array":
                    for (U = new Uint8Array(R), w = 0; w < y.length; w++) U.set(y[w], D), D += y[w].length;
                    return U;
                  case "nodebuffer":
                    return Buffer.concat(y);
                  default:
                    throw new Error("concat : unsupported type '" + T + "'");
                }
              }(b, S), E);
              _(P);
            } catch (T) {
              M(T);
            }
            S = [];
          }).resume();
        });
      }
      function v(x, g, _) {
        var M = g;
        switch (g) {
          case "blob":
          case "arraybuffer":
            M = "uint8array";
            break;
          case "base64":
            M = "string";
        }
        try {
          this._internalType = M, this._outputType = g, this._mimeType = _, a.checkSupport(M), this._worker = x.pipe(new l(M)), x.lock();
        } catch (S) {
          this._worker = new c("error"), this._worker.error(S);
        }
      }
      v.prototype = { accumulate: function(x) {
        return p(this, x);
      }, on: function(x, g) {
        var _ = this;
        return x === "data" ? this._worker.on(x, function(M) {
          g.call(_, M.data, M.meta);
        }) : this._worker.on(x, function() {
          a.delay(g, arguments, _);
        }), this;
      }, resume: function() {
        return a.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(x) {
        if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new m(this, { objectMode: this._outputType !== "nodebuffer" }, x);
      } }, r.exports = v;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(i, r, o) {
      if (o.base64 = !0, o.array = !0, o.string = !0, o.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", o.nodebuffer = typeof Buffer < "u", o.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") o.blob = !1;
      else {
        var a = new ArrayBuffer(0);
        try {
          o.blob = new Blob([a], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var l = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            l.append(a), o.blob = l.getBlob("application/zip").size === 0;
          } catch {
            o.blob = !1;
          }
        }
      }
      try {
        o.nodestream = !!i("readable-stream").Readable;
      } catch {
        o.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(i, r, o) {
      for (var a = i("./utils"), l = i("./support"), c = i("./nodejsUtils"), u = i("./stream/GenericWorker"), d = new Array(256), h = 0; h < 256; h++) d[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      d[254] = d[254] = 1;
      function m() {
        u.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        u.call(this, "utf-8 encode");
      }
      o.utf8encode = function(v) {
        return l.nodebuffer ? c.newBufferFrom(v, "utf-8") : function(x) {
          var g, _, M, S, b, C = x.length, E = 0;
          for (S = 0; S < C; S++) (64512 & (_ = x.charCodeAt(S))) == 55296 && S + 1 < C && (64512 & (M = x.charCodeAt(S + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (M - 56320), S++), E += _ < 128 ? 1 : _ < 2048 ? 2 : _ < 65536 ? 3 : 4;
          for (g = l.uint8array ? new Uint8Array(E) : new Array(E), S = b = 0; b < E; S++) (64512 & (_ = x.charCodeAt(S))) == 55296 && S + 1 < C && (64512 & (M = x.charCodeAt(S + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (M - 56320), S++), _ < 128 ? g[b++] = _ : (_ < 2048 ? g[b++] = 192 | _ >>> 6 : (_ < 65536 ? g[b++] = 224 | _ >>> 12 : (g[b++] = 240 | _ >>> 18, g[b++] = 128 | _ >>> 12 & 63), g[b++] = 128 | _ >>> 6 & 63), g[b++] = 128 | 63 & _);
          return g;
        }(v);
      }, o.utf8decode = function(v) {
        return l.nodebuffer ? a.transformTo("nodebuffer", v).toString("utf-8") : function(x) {
          var g, _, M, S, b = x.length, C = new Array(2 * b);
          for (g = _ = 0; g < b; ) if ((M = x[g++]) < 128) C[_++] = M;
          else if (4 < (S = d[M])) C[_++] = 65533, g += S - 1;
          else {
            for (M &= S === 2 ? 31 : S === 3 ? 15 : 7; 1 < S && g < b; ) M = M << 6 | 63 & x[g++], S--;
            1 < S ? C[_++] = 65533 : M < 65536 ? C[_++] = M : (M -= 65536, C[_++] = 55296 | M >> 10 & 1023, C[_++] = 56320 | 1023 & M);
          }
          return C.length !== _ && (C.subarray ? C = C.subarray(0, _) : C.length = _), a.applyFromCharCode(C);
        }(v = a.transformTo(l.uint8array ? "uint8array" : "array", v));
      }, a.inherits(m, u), m.prototype.processChunk = function(v) {
        var x = a.transformTo(l.uint8array ? "uint8array" : "array", v.data);
        if (this.leftOver && this.leftOver.length) {
          if (l.uint8array) {
            var g = x;
            (x = new Uint8Array(g.length + this.leftOver.length)).set(this.leftOver, 0), x.set(g, this.leftOver.length);
          } else x = this.leftOver.concat(x);
          this.leftOver = null;
        }
        var _ = function(S, b) {
          var C;
          for ((b = b || S.length) > S.length && (b = S.length), C = b - 1; 0 <= C && (192 & S[C]) == 128; ) C--;
          return C < 0 || C === 0 ? b : C + d[S[C]] > b ? C : b;
        }(x), M = x;
        _ !== x.length && (l.uint8array ? (M = x.subarray(0, _), this.leftOver = x.subarray(_, x.length)) : (M = x.slice(0, _), this.leftOver = x.slice(_, x.length))), this.push({ data: o.utf8decode(M), meta: v.meta });
      }, m.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: o.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, o.Utf8DecodeWorker = m, a.inherits(p, u), p.prototype.processChunk = function(v) {
        this.push({ data: o.utf8encode(v.data), meta: v.meta });
      }, o.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(i, r, o) {
      var a = i("./support"), l = i("./base64"), c = i("./nodejsUtils"), u = i("./external");
      function d(g) {
        return g;
      }
      function h(g, _) {
        for (var M = 0; M < g.length; ++M) _[M] = 255 & g.charCodeAt(M);
        return _;
      }
      i("setimmediate"), o.newBlob = function(g, _) {
        o.checkSupport("blob");
        try {
          return new Blob([g], { type: _ });
        } catch {
          try {
            var M = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return M.append(g), M.getBlob(_);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var m = { stringifyByChunk: function(g, _, M) {
        var S = [], b = 0, C = g.length;
        if (C <= M) return String.fromCharCode.apply(null, g);
        for (; b < C; ) _ === "array" || _ === "nodebuffer" ? S.push(String.fromCharCode.apply(null, g.slice(b, Math.min(b + M, C)))) : S.push(String.fromCharCode.apply(null, g.subarray(b, Math.min(b + M, C)))), b += M;
        return S.join("");
      }, stringifyByChar: function(g) {
        for (var _ = "", M = 0; M < g.length; M++) _ += String.fromCharCode(g[M]);
        return _;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return a.nodebuffer && String.fromCharCode.apply(null, c.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(g) {
        var _ = 65536, M = o.getTypeOf(g), S = !0;
        if (M === "uint8array" ? S = m.applyCanBeUsed.uint8array : M === "nodebuffer" && (S = m.applyCanBeUsed.nodebuffer), S) for (; 1 < _; ) try {
          return m.stringifyByChunk(g, M, _);
        } catch {
          _ = Math.floor(_ / 2);
        }
        return m.stringifyByChar(g);
      }
      function v(g, _) {
        for (var M = 0; M < g.length; M++) _[M] = g[M];
        return _;
      }
      o.applyFromCharCode = p;
      var x = {};
      x.string = { string: d, array: function(g) {
        return h(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return x.string.uint8array(g).buffer;
      }, uint8array: function(g) {
        return h(g, new Uint8Array(g.length));
      }, nodebuffer: function(g) {
        return h(g, c.allocBuffer(g.length));
      } }, x.array = { string: p, array: d, arraybuffer: function(g) {
        return new Uint8Array(g).buffer;
      }, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return c.newBufferFrom(g);
      } }, x.arraybuffer = { string: function(g) {
        return p(new Uint8Array(g));
      }, array: function(g) {
        return v(new Uint8Array(g), new Array(g.byteLength));
      }, arraybuffer: d, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return c.newBufferFrom(new Uint8Array(g));
      } }, x.uint8array = { string: p, array: function(g) {
        return v(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return g.buffer;
      }, uint8array: d, nodebuffer: function(g) {
        return c.newBufferFrom(g);
      } }, x.nodebuffer = { string: p, array: function(g) {
        return v(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return x.nodebuffer.uint8array(g).buffer;
      }, uint8array: function(g) {
        return v(g, new Uint8Array(g.length));
      }, nodebuffer: d }, o.transformTo = function(g, _) {
        if (_ = _ || "", !g) return _;
        o.checkSupport(g);
        var M = o.getTypeOf(_);
        return x[M][g](_);
      }, o.resolve = function(g) {
        for (var _ = g.split("/"), M = [], S = 0; S < _.length; S++) {
          var b = _[S];
          b === "." || b === "" && S !== 0 && S !== _.length - 1 || (b === ".." ? M.pop() : M.push(b));
        }
        return M.join("/");
      }, o.getTypeOf = function(g) {
        return typeof g == "string" ? "string" : Object.prototype.toString.call(g) === "[object Array]" ? "array" : a.nodebuffer && c.isBuffer(g) ? "nodebuffer" : a.uint8array && g instanceof Uint8Array ? "uint8array" : a.arraybuffer && g instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, o.checkSupport = function(g) {
        if (!a[g.toLowerCase()]) throw new Error(g + " is not supported by this platform");
      }, o.MAX_VALUE_16BITS = 65535, o.MAX_VALUE_32BITS = -1, o.pretty = function(g) {
        var _, M, S = "";
        for (M = 0; M < (g || "").length; M++) S += "\\x" + ((_ = g.charCodeAt(M)) < 16 ? "0" : "") + _.toString(16).toUpperCase();
        return S;
      }, o.delay = function(g, _, M) {
        setImmediate(function() {
          g.apply(M || null, _ || []);
        });
      }, o.inherits = function(g, _) {
        function M() {
        }
        M.prototype = _.prototype, g.prototype = new M();
      }, o.extend = function() {
        var g, _, M = {};
        for (g = 0; g < arguments.length; g++) for (_ in arguments[g]) Object.prototype.hasOwnProperty.call(arguments[g], _) && M[_] === void 0 && (M[_] = arguments[g][_]);
        return M;
      }, o.prepareContent = function(g, _, M, S, b) {
        return u.Promise.resolve(_).then(function(C) {
          return a.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new u.Promise(function(E, P) {
            var T = new FileReader();
            T.onload = function(y) {
              E(y.target.result);
            }, T.onerror = function(y) {
              P(y.target.error);
            }, T.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var E = o.getTypeOf(C);
          return E ? (E === "arraybuffer" ? C = o.transformTo("uint8array", C) : E === "string" && (b ? C = l.decode(C) : M && S !== !0 && (C = function(P) {
            return h(P, a.uint8array ? new Uint8Array(P.length) : new Array(P.length));
          }(C))), C) : u.Promise.reject(new Error("Can't read the data of '" + g + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(i, r, o) {
      var a = i("./reader/readerFor"), l = i("./utils"), c = i("./signature"), u = i("./zipEntry"), d = i("./support");
      function h(m) {
        this.files = [], this.loadOptions = m;
      }
      h.prototype = { checkSignature: function(m) {
        if (!this.reader.readAndCheckSignature(m)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + l.pretty(p) + ", expected " + l.pretty(m) + ")");
        }
      }, isSignature: function(m, p) {
        var v = this.reader.index;
        this.reader.setIndex(m);
        var x = this.reader.readString(4) === p;
        return this.reader.setIndex(v), x;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var m = this.reader.readData(this.zipCommentLength), p = d.uint8array ? "uint8array" : "array", v = l.transformTo(p, m);
        this.zipComment = this.loadOptions.decodeFileName(v);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var m, p, v, x = this.zip64EndOfCentralSize - 44; 0 < x; ) m = this.reader.readInt(2), p = this.reader.readInt(4), v = this.reader.readData(p), this.zip64ExtensibleData[m] = { id: m, length: p, value: v };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var m, p;
        for (m = 0; m < this.files.length; m++) p = this.files[m], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(c.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var m;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(c.CENTRAL_FILE_HEADER); ) (m = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(m);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var m = this.reader.lastIndexOfSignature(c.CENTRAL_DIRECTORY_END);
        if (m < 0) throw this.isSignature(0, c.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(m);
        var p = m;
        if (this.checkSignature(c.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === l.MAX_VALUE_16BITS || this.diskWithCentralDirStart === l.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === l.MAX_VALUE_16BITS || this.centralDirRecords === l.MAX_VALUE_16BITS || this.centralDirSize === l.MAX_VALUE_32BITS || this.centralDirOffset === l.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (m = this.reader.lastIndexOfSignature(c.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(m), this.checkSignature(c.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, c.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(c.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(c.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var v = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (v += 20, v += 12 + this.zip64EndOfCentralSize);
        var x = p - v;
        if (0 < x) this.isSignature(p, c.CENTRAL_FILE_HEADER) || (this.reader.zero = x);
        else if (x < 0) throw new Error("Corrupted zip: missing " + Math.abs(x) + " bytes.");
      }, prepareReader: function(m) {
        this.reader = a(m);
      }, load: function(m) {
        this.prepareReader(m), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, r.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(i, r, o) {
      var a = i("./reader/readerFor"), l = i("./utils"), c = i("./compressedObject"), u = i("./crc32"), d = i("./utf8"), h = i("./compressions"), m = i("./support");
      function p(v, x) {
        this.options = v, this.loadOptions = x;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(v) {
        var x, g;
        if (v.skip(22), this.fileNameLength = v.readInt(2), g = v.readInt(2), this.fileName = v.readData(this.fileNameLength), v.skip(g), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((x = function(_) {
          for (var M in h) if (Object.prototype.hasOwnProperty.call(h, M) && h[M].magic === _) return h[M];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + l.pretty(this.compressionMethod) + " unknown (inner file : " + l.transformTo("string", this.fileName) + ")");
        this.decompressed = new c(this.compressedSize, this.uncompressedSize, this.crc32, x, v.readData(this.compressedSize));
      }, readCentralPart: function(v) {
        this.versionMadeBy = v.readInt(2), v.skip(2), this.bitFlag = v.readInt(2), this.compressionMethod = v.readString(2), this.date = v.readDate(), this.crc32 = v.readInt(4), this.compressedSize = v.readInt(4), this.uncompressedSize = v.readInt(4);
        var x = v.readInt(2);
        if (this.extraFieldsLength = v.readInt(2), this.fileCommentLength = v.readInt(2), this.diskNumberStart = v.readInt(2), this.internalFileAttributes = v.readInt(2), this.externalFileAttributes = v.readInt(4), this.localHeaderOffset = v.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        v.skip(x), this.readExtraFields(v), this.parseZIP64ExtraField(v), this.fileComment = v.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var v = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), v == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), v == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var v = a(this.extraFields[1].value);
          this.uncompressedSize === l.MAX_VALUE_32BITS && (this.uncompressedSize = v.readInt(8)), this.compressedSize === l.MAX_VALUE_32BITS && (this.compressedSize = v.readInt(8)), this.localHeaderOffset === l.MAX_VALUE_32BITS && (this.localHeaderOffset = v.readInt(8)), this.diskNumberStart === l.MAX_VALUE_32BITS && (this.diskNumberStart = v.readInt(4));
        }
      }, readExtraFields: function(v) {
        var x, g, _, M = v.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); v.index + 4 < M; ) x = v.readInt(2), g = v.readInt(2), _ = v.readData(g), this.extraFields[x] = { id: x, length: g, value: _ };
        v.setIndex(M);
      }, handleUTF8: function() {
        var v = m.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = d.utf8decode(this.fileName), this.fileCommentStr = d.utf8decode(this.fileComment);
        else {
          var x = this.findExtraFieldUnicodePath();
          if (x !== null) this.fileNameStr = x;
          else {
            var g = l.transformTo(v, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(g);
          }
          var _ = this.findExtraFieldUnicodeComment();
          if (_ !== null) this.fileCommentStr = _;
          else {
            var M = l.transformTo(v, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(M);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var v = this.extraFields[28789];
        if (v) {
          var x = a(v.value);
          return x.readInt(1) !== 1 || u(this.fileName) !== x.readInt(4) ? null : d.utf8decode(x.readData(v.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var v = this.extraFields[25461];
        if (v) {
          var x = a(v.value);
          return x.readInt(1) !== 1 || u(this.fileComment) !== x.readInt(4) ? null : d.utf8decode(x.readData(v.length - 5));
        }
        return null;
      } }, r.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(i, r, o) {
      function a(x, g, _) {
        this.name = x, this.dir = _.dir, this.date = _.date, this.comment = _.comment, this.unixPermissions = _.unixPermissions, this.dosPermissions = _.dosPermissions, this._data = g, this._dataBinary = _.binary, this.options = { compression: _.compression, compressionOptions: _.compressionOptions };
      }
      var l = i("./stream/StreamHelper"), c = i("./stream/DataWorker"), u = i("./utf8"), d = i("./compressedObject"), h = i("./stream/GenericWorker");
      a.prototype = { internalStream: function(x) {
        var g = null, _ = "string";
        try {
          if (!x) throw new Error("No output type specified.");
          var M = (_ = x.toLowerCase()) === "string" || _ === "text";
          _ !== "binarystring" && _ !== "text" || (_ = "string"), g = this._decompressWorker();
          var S = !this._dataBinary;
          S && !M && (g = g.pipe(new u.Utf8EncodeWorker())), !S && M && (g = g.pipe(new u.Utf8DecodeWorker()));
        } catch (b) {
          (g = new h("error")).error(b);
        }
        return new l(g, _, "");
      }, async: function(x, g) {
        return this.internalStream(x).accumulate(g);
      }, nodeStream: function(x, g) {
        return this.internalStream(x || "nodebuffer").toNodejsStream(g);
      }, _compressWorker: function(x, g) {
        if (this._data instanceof d && this._data.compression.magic === x.magic) return this._data.getCompressedWorker();
        var _ = this._decompressWorker();
        return this._dataBinary || (_ = _.pipe(new u.Utf8EncodeWorker())), d.createWorkerFrom(_, x, g);
      }, _decompressWorker: function() {
        return this._data instanceof d ? this._data.getContentWorker() : this._data instanceof h ? this._data : new c(this._data);
      } };
      for (var m = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, v = 0; v < m.length; v++) a.prototype[m[v]] = p;
      r.exports = a;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(i, r, o) {
      (function(a) {
        var l, c, u = a.MutationObserver || a.WebKitMutationObserver;
        if (u) {
          var d = 0, h = new u(x), m = a.document.createTextNode("");
          h.observe(m, { characterData: !0 }), l = function() {
            m.data = d = ++d % 2;
          };
        } else if (a.setImmediate || a.MessageChannel === void 0) l = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
          var g = a.document.createElement("script");
          g.onreadystatechange = function() {
            x(), g.onreadystatechange = null, g.parentNode.removeChild(g), g = null;
          }, a.document.documentElement.appendChild(g);
        } : function() {
          setTimeout(x, 0);
        };
        else {
          var p = new a.MessageChannel();
          p.port1.onmessage = x, l = function() {
            p.port2.postMessage(0);
          };
        }
        var v = [];
        function x() {
          var g, _;
          c = !0;
          for (var M = v.length; M; ) {
            for (_ = v, v = [], g = -1; ++g < M; ) _[g]();
            M = v.length;
          }
          c = !1;
        }
        r.exports = function(g) {
          v.push(g) !== 1 || c || l();
        };
      }).call(this, typeof Cc < "u" ? Cc : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(i, r, o) {
      var a = i("immediate");
      function l() {
      }
      var c = {}, u = ["REJECTED"], d = ["FULFILLED"], h = ["PENDING"];
      function m(M) {
        if (typeof M != "function") throw new TypeError("resolver must be a function");
        this.state = h, this.queue = [], this.outcome = void 0, M !== l && g(this, M);
      }
      function p(M, S, b) {
        this.promise = M, typeof S == "function" && (this.onFulfilled = S, this.callFulfilled = this.otherCallFulfilled), typeof b == "function" && (this.onRejected = b, this.callRejected = this.otherCallRejected);
      }
      function v(M, S, b) {
        a(function() {
          var C;
          try {
            C = S(b);
          } catch (E) {
            return c.reject(M, E);
          }
          C === M ? c.reject(M, new TypeError("Cannot resolve promise with itself")) : c.resolve(M, C);
        });
      }
      function x(M) {
        var S = M && M.then;
        if (M && (typeof M == "object" || typeof M == "function") && typeof S == "function") return function() {
          S.apply(M, arguments);
        };
      }
      function g(M, S) {
        var b = !1;
        function C(T) {
          b || (b = !0, c.reject(M, T));
        }
        function E(T) {
          b || (b = !0, c.resolve(M, T));
        }
        var P = _(function() {
          S(E, C);
        });
        P.status === "error" && C(P.value);
      }
      function _(M, S) {
        var b = {};
        try {
          b.value = M(S), b.status = "success";
        } catch (C) {
          b.status = "error", b.value = C;
        }
        return b;
      }
      (r.exports = m).prototype.finally = function(M) {
        if (typeof M != "function") return this;
        var S = this.constructor;
        return this.then(function(b) {
          return S.resolve(M()).then(function() {
            return b;
          });
        }, function(b) {
          return S.resolve(M()).then(function() {
            throw b;
          });
        });
      }, m.prototype.catch = function(M) {
        return this.then(null, M);
      }, m.prototype.then = function(M, S) {
        if (typeof M != "function" && this.state === d || typeof S != "function" && this.state === u) return this;
        var b = new this.constructor(l);
        return this.state !== h ? v(b, this.state === d ? M : S, this.outcome) : this.queue.push(new p(b, M, S)), b;
      }, p.prototype.callFulfilled = function(M) {
        c.resolve(this.promise, M);
      }, p.prototype.otherCallFulfilled = function(M) {
        v(this.promise, this.onFulfilled, M);
      }, p.prototype.callRejected = function(M) {
        c.reject(this.promise, M);
      }, p.prototype.otherCallRejected = function(M) {
        v(this.promise, this.onRejected, M);
      }, c.resolve = function(M, S) {
        var b = _(x, S);
        if (b.status === "error") return c.reject(M, b.value);
        var C = b.value;
        if (C) g(M, C);
        else {
          M.state = d, M.outcome = S;
          for (var E = -1, P = M.queue.length; ++E < P; ) M.queue[E].callFulfilled(S);
        }
        return M;
      }, c.reject = function(M, S) {
        M.state = u, M.outcome = S;
        for (var b = -1, C = M.queue.length; ++b < C; ) M.queue[b].callRejected(S);
        return M;
      }, m.resolve = function(M) {
        return M instanceof this ? M : c.resolve(new this(l), M);
      }, m.reject = function(M) {
        var S = new this(l);
        return c.reject(S, M);
      }, m.all = function(M) {
        var S = this;
        if (Object.prototype.toString.call(M) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var b = M.length, C = !1;
        if (!b) return this.resolve([]);
        for (var E = new Array(b), P = 0, T = -1, y = new this(l); ++T < b; ) w(M[T], T);
        return y;
        function w(D, U) {
          S.resolve(D).then(function(R) {
            E[U] = R, ++P !== b || C || (C = !0, c.resolve(y, E));
          }, function(R) {
            C || (C = !0, c.reject(y, R));
          });
        }
      }, m.race = function(M) {
        var S = this;
        if (Object.prototype.toString.call(M) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var b = M.length, C = !1;
        if (!b) return this.resolve([]);
        for (var E = -1, P = new this(l); ++E < b; ) T = M[E], S.resolve(T).then(function(y) {
          C || (C = !0, c.resolve(P, y));
        }, function(y) {
          C || (C = !0, c.reject(P, y));
        });
        var T;
        return P;
      };
    }, { immediate: 36 }], 38: [function(i, r, o) {
      var a = {};
      (0, i("./lib/utils/common").assign)(a, i("./lib/deflate"), i("./lib/inflate"), i("./lib/zlib/constants")), r.exports = a;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(i, r, o) {
      var a = i("./zlib/deflate"), l = i("./utils/common"), c = i("./utils/strings"), u = i("./zlib/messages"), d = i("./zlib/zstream"), h = Object.prototype.toString, m = 0, p = -1, v = 0, x = 8;
      function g(M) {
        if (!(this instanceof g)) return new g(M);
        this.options = l.assign({ level: p, method: x, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: v, to: "" }, M || {});
        var S = this.options;
        S.raw && 0 < S.windowBits ? S.windowBits = -S.windowBits : S.gzip && 0 < S.windowBits && S.windowBits < 16 && (S.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d(), this.strm.avail_out = 0;
        var b = a.deflateInit2(this.strm, S.level, S.method, S.windowBits, S.memLevel, S.strategy);
        if (b !== m) throw new Error(u[b]);
        if (S.header && a.deflateSetHeader(this.strm, S.header), S.dictionary) {
          var C;
          if (C = typeof S.dictionary == "string" ? c.string2buf(S.dictionary) : h.call(S.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(S.dictionary) : S.dictionary, (b = a.deflateSetDictionary(this.strm, C)) !== m) throw new Error(u[b]);
          this._dict_set = !0;
        }
      }
      function _(M, S) {
        var b = new g(S);
        if (b.push(M, !0), b.err) throw b.msg || u[b.err];
        return b.result;
      }
      g.prototype.push = function(M, S) {
        var b, C, E = this.strm, P = this.options.chunkSize;
        if (this.ended) return !1;
        C = S === ~~S ? S : S === !0 ? 4 : 0, typeof M == "string" ? E.input = c.string2buf(M) : h.call(M) === "[object ArrayBuffer]" ? E.input = new Uint8Array(M) : E.input = M, E.next_in = 0, E.avail_in = E.input.length;
        do {
          if (E.avail_out === 0 && (E.output = new l.Buf8(P), E.next_out = 0, E.avail_out = P), (b = a.deflate(E, C)) !== 1 && b !== m) return this.onEnd(b), !(this.ended = !0);
          E.avail_out !== 0 && (E.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(c.buf2binstring(l.shrinkBuf(E.output, E.next_out))) : this.onData(l.shrinkBuf(E.output, E.next_out)));
        } while ((0 < E.avail_in || E.avail_out === 0) && b !== 1);
        return C === 4 ? (b = a.deflateEnd(this.strm), this.onEnd(b), this.ended = !0, b === m) : C !== 2 || (this.onEnd(m), !(E.avail_out = 0));
      }, g.prototype.onData = function(M) {
        this.chunks.push(M);
      }, g.prototype.onEnd = function(M) {
        M === m && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = M, this.msg = this.strm.msg;
      }, o.Deflate = g, o.deflate = _, o.deflateRaw = function(M, S) {
        return (S = S || {}).raw = !0, _(M, S);
      }, o.gzip = function(M, S) {
        return (S = S || {}).gzip = !0, _(M, S);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(i, r, o) {
      var a = i("./zlib/inflate"), l = i("./utils/common"), c = i("./utils/strings"), u = i("./zlib/constants"), d = i("./zlib/messages"), h = i("./zlib/zstream"), m = i("./zlib/gzheader"), p = Object.prototype.toString;
      function v(g) {
        if (!(this instanceof v)) return new v(g);
        this.options = l.assign({ chunkSize: 16384, windowBits: 0, to: "" }, g || {});
        var _ = this.options;
        _.raw && 0 <= _.windowBits && _.windowBits < 16 && (_.windowBits = -_.windowBits, _.windowBits === 0 && (_.windowBits = -15)), !(0 <= _.windowBits && _.windowBits < 16) || g && g.windowBits || (_.windowBits += 32), 15 < _.windowBits && _.windowBits < 48 && !(15 & _.windowBits) && (_.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var M = a.inflateInit2(this.strm, _.windowBits);
        if (M !== u.Z_OK) throw new Error(d[M]);
        this.header = new m(), a.inflateGetHeader(this.strm, this.header);
      }
      function x(g, _) {
        var M = new v(_);
        if (M.push(g, !0), M.err) throw M.msg || d[M.err];
        return M.result;
      }
      v.prototype.push = function(g, _) {
        var M, S, b, C, E, P, T = this.strm, y = this.options.chunkSize, w = this.options.dictionary, D = !1;
        if (this.ended) return !1;
        S = _ === ~~_ ? _ : _ === !0 ? u.Z_FINISH : u.Z_NO_FLUSH, typeof g == "string" ? T.input = c.binstring2buf(g) : p.call(g) === "[object ArrayBuffer]" ? T.input = new Uint8Array(g) : T.input = g, T.next_in = 0, T.avail_in = T.input.length;
        do {
          if (T.avail_out === 0 && (T.output = new l.Buf8(y), T.next_out = 0, T.avail_out = y), (M = a.inflate(T, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && w && (P = typeof w == "string" ? c.string2buf(w) : p.call(w) === "[object ArrayBuffer]" ? new Uint8Array(w) : w, M = a.inflateSetDictionary(this.strm, P)), M === u.Z_BUF_ERROR && D === !0 && (M = u.Z_OK, D = !1), M !== u.Z_STREAM_END && M !== u.Z_OK) return this.onEnd(M), !(this.ended = !0);
          T.next_out && (T.avail_out !== 0 && M !== u.Z_STREAM_END && (T.avail_in !== 0 || S !== u.Z_FINISH && S !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (b = c.utf8border(T.output, T.next_out), C = T.next_out - b, E = c.buf2string(T.output, b), T.next_out = C, T.avail_out = y - C, C && l.arraySet(T.output, T.output, b, C, 0), this.onData(E)) : this.onData(l.shrinkBuf(T.output, T.next_out)))), T.avail_in === 0 && T.avail_out === 0 && (D = !0);
        } while ((0 < T.avail_in || T.avail_out === 0) && M !== u.Z_STREAM_END);
        return M === u.Z_STREAM_END && (S = u.Z_FINISH), S === u.Z_FINISH ? (M = a.inflateEnd(this.strm), this.onEnd(M), this.ended = !0, M === u.Z_OK) : S !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(T.avail_out = 0));
      }, v.prototype.onData = function(g) {
        this.chunks.push(g);
      }, v.prototype.onEnd = function(g) {
        g === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = g, this.msg = this.strm.msg;
      }, o.Inflate = v, o.inflate = x, o.inflateRaw = function(g, _) {
        return (_ = _ || {}).raw = !0, x(g, _);
      }, o.ungzip = x;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(i, r, o) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      o.assign = function(u) {
        for (var d = Array.prototype.slice.call(arguments, 1); d.length; ) {
          var h = d.shift();
          if (h) {
            if (typeof h != "object") throw new TypeError(h + "must be non-object");
            for (var m in h) h.hasOwnProperty(m) && (u[m] = h[m]);
          }
        }
        return u;
      }, o.shrinkBuf = function(u, d) {
        return u.length === d ? u : u.subarray ? u.subarray(0, d) : (u.length = d, u);
      };
      var l = { arraySet: function(u, d, h, m, p) {
        if (d.subarray && u.subarray) u.set(d.subarray(h, h + m), p);
        else for (var v = 0; v < m; v++) u[p + v] = d[h + v];
      }, flattenChunks: function(u) {
        var d, h, m, p, v, x;
        for (d = m = 0, h = u.length; d < h; d++) m += u[d].length;
        for (x = new Uint8Array(m), d = p = 0, h = u.length; d < h; d++) v = u[d], x.set(v, p), p += v.length;
        return x;
      } }, c = { arraySet: function(u, d, h, m, p) {
        for (var v = 0; v < m; v++) u[p + v] = d[h + v];
      }, flattenChunks: function(u) {
        return [].concat.apply([], u);
      } };
      o.setTyped = function(u) {
        u ? (o.Buf8 = Uint8Array, o.Buf16 = Uint16Array, o.Buf32 = Int32Array, o.assign(o, l)) : (o.Buf8 = Array, o.Buf16 = Array, o.Buf32 = Array, o.assign(o, c));
      }, o.setTyped(a);
    }, {}], 42: [function(i, r, o) {
      var a = i("./common"), l = !0, c = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        l = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        c = !1;
      }
      for (var u = new a.Buf8(256), d = 0; d < 256; d++) u[d] = 252 <= d ? 6 : 248 <= d ? 5 : 240 <= d ? 4 : 224 <= d ? 3 : 192 <= d ? 2 : 1;
      function h(m, p) {
        if (p < 65537 && (m.subarray && c || !m.subarray && l)) return String.fromCharCode.apply(null, a.shrinkBuf(m, p));
        for (var v = "", x = 0; x < p; x++) v += String.fromCharCode(m[x]);
        return v;
      }
      u[254] = u[254] = 1, o.string2buf = function(m) {
        var p, v, x, g, _, M = m.length, S = 0;
        for (g = 0; g < M; g++) (64512 & (v = m.charCodeAt(g))) == 55296 && g + 1 < M && (64512 & (x = m.charCodeAt(g + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (x - 56320), g++), S += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
        for (p = new a.Buf8(S), g = _ = 0; _ < S; g++) (64512 & (v = m.charCodeAt(g))) == 55296 && g + 1 < M && (64512 & (x = m.charCodeAt(g + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (x - 56320), g++), v < 128 ? p[_++] = v : (v < 2048 ? p[_++] = 192 | v >>> 6 : (v < 65536 ? p[_++] = 224 | v >>> 12 : (p[_++] = 240 | v >>> 18, p[_++] = 128 | v >>> 12 & 63), p[_++] = 128 | v >>> 6 & 63), p[_++] = 128 | 63 & v);
        return p;
      }, o.buf2binstring = function(m) {
        return h(m, m.length);
      }, o.binstring2buf = function(m) {
        for (var p = new a.Buf8(m.length), v = 0, x = p.length; v < x; v++) p[v] = m.charCodeAt(v);
        return p;
      }, o.buf2string = function(m, p) {
        var v, x, g, _, M = p || m.length, S = new Array(2 * M);
        for (v = x = 0; v < M; ) if ((g = m[v++]) < 128) S[x++] = g;
        else if (4 < (_ = u[g])) S[x++] = 65533, v += _ - 1;
        else {
          for (g &= _ === 2 ? 31 : _ === 3 ? 15 : 7; 1 < _ && v < M; ) g = g << 6 | 63 & m[v++], _--;
          1 < _ ? S[x++] = 65533 : g < 65536 ? S[x++] = g : (g -= 65536, S[x++] = 55296 | g >> 10 & 1023, S[x++] = 56320 | 1023 & g);
        }
        return h(S, x);
      }, o.utf8border = function(m, p) {
        var v;
        for ((p = p || m.length) > m.length && (p = m.length), v = p - 1; 0 <= v && (192 & m[v]) == 128; ) v--;
        return v < 0 || v === 0 ? p : v + u[m[v]] > p ? v : p;
      };
    }, { "./common": 41 }], 43: [function(i, r, o) {
      r.exports = function(a, l, c, u) {
        for (var d = 65535 & a | 0, h = a >>> 16 & 65535 | 0, m = 0; c !== 0; ) {
          for (c -= m = 2e3 < c ? 2e3 : c; h = h + (d = d + l[u++] | 0) | 0, --m; ) ;
          d %= 65521, h %= 65521;
        }
        return d | h << 16 | 0;
      };
    }, {}], 44: [function(i, r, o) {
      r.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(i, r, o) {
      var a = function() {
        for (var l, c = [], u = 0; u < 256; u++) {
          l = u;
          for (var d = 0; d < 8; d++) l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
          c[u] = l;
        }
        return c;
      }();
      r.exports = function(l, c, u, d) {
        var h = a, m = d + u;
        l ^= -1;
        for (var p = d; p < m; p++) l = l >>> 8 ^ h[255 & (l ^ c[p])];
        return -1 ^ l;
      };
    }, {}], 46: [function(i, r, o) {
      var a, l = i("../utils/common"), c = i("./trees"), u = i("./adler32"), d = i("./crc32"), h = i("./messages"), m = 0, p = 4, v = 0, x = -2, g = -1, _ = 4, M = 2, S = 8, b = 9, C = 286, E = 30, P = 19, T = 2 * C + 1, y = 15, w = 3, D = 258, U = D + w + 1, R = 42, O = 113, A = 1, G = 2, ue = 3, Q = 4;
      function le(k, ne) {
        return k.msg = h[ne], ne;
      }
      function re(k) {
        return (k << 1) - (4 < k ? 9 : 0);
      }
      function j(k) {
        for (var ne = k.length; 0 <= --ne; ) k[ne] = 0;
      }
      function $(k) {
        var ne = k.state, J = ne.pending;
        J > k.avail_out && (J = k.avail_out), J !== 0 && (l.arraySet(k.output, ne.pending_buf, ne.pending_out, J, k.next_out), k.next_out += J, ne.pending_out += J, k.total_out += J, k.avail_out -= J, ne.pending -= J, ne.pending === 0 && (ne.pending_out = 0));
      }
      function q(k, ne) {
        c._tr_flush_block(k, 0 <= k.block_start ? k.block_start : -1, k.strstart - k.block_start, ne), k.block_start = k.strstart, $(k.strm);
      }
      function oe(k, ne) {
        k.pending_buf[k.pending++] = ne;
      }
      function ie(k, ne) {
        k.pending_buf[k.pending++] = ne >>> 8 & 255, k.pending_buf[k.pending++] = 255 & ne;
      }
      function ce(k, ne) {
        var J, B, X = k.max_chain_length, se = k.strstart, z = k.prev_length, N = k.nice_match, K = k.strstart > k.w_size - U ? k.strstart - (k.w_size - U) : 0, he = k.window, me = k.w_mask, ge = k.prev, Me = k.strstart + D, Te = he[se + z - 1], Ae = he[se + z];
        k.prev_length >= k.good_match && (X >>= 2), N > k.lookahead && (N = k.lookahead);
        do
          if (he[(J = ne) + z] === Ae && he[J + z - 1] === Te && he[J] === he[se] && he[++J] === he[se + 1]) {
            se += 2, J++;
            do
              ;
            while (he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && se < Me);
            if (B = D - (Me - se), se = Me - D, z < B) {
              if (k.match_start = ne, N <= (z = B)) break;
              Te = he[se + z - 1], Ae = he[se + z];
            }
          }
        while ((ne = ge[ne & me]) > K && --X != 0);
        return z <= k.lookahead ? z : k.lookahead;
      }
      function V(k) {
        var ne, J, B, X, se, z, N, K, he, me, ge = k.w_size;
        do {
          if (X = k.window_size - k.lookahead - k.strstart, k.strstart >= ge + (ge - U)) {
            for (l.arraySet(k.window, k.window, ge, ge, 0), k.match_start -= ge, k.strstart -= ge, k.block_start -= ge, ne = J = k.hash_size; B = k.head[--ne], k.head[ne] = ge <= B ? B - ge : 0, --J; ) ;
            for (ne = J = ge; B = k.prev[--ne], k.prev[ne] = ge <= B ? B - ge : 0, --J; ) ;
            X += ge;
          }
          if (k.strm.avail_in === 0) break;
          if (z = k.strm, N = k.window, K = k.strstart + k.lookahead, he = X, me = void 0, me = z.avail_in, he < me && (me = he), J = me === 0 ? 0 : (z.avail_in -= me, l.arraySet(N, z.input, z.next_in, me, K), z.state.wrap === 1 ? z.adler = u(z.adler, N, me, K) : z.state.wrap === 2 && (z.adler = d(z.adler, N, me, K)), z.next_in += me, z.total_in += me, me), k.lookahead += J, k.lookahead + k.insert >= w) for (se = k.strstart - k.insert, k.ins_h = k.window[se], k.ins_h = (k.ins_h << k.hash_shift ^ k.window[se + 1]) & k.hash_mask; k.insert && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[se + w - 1]) & k.hash_mask, k.prev[se & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = se, se++, k.insert--, !(k.lookahead + k.insert < w)); ) ;
        } while (k.lookahead < U && k.strm.avail_in !== 0);
      }
      function Y(k, ne) {
        for (var J, B; ; ) {
          if (k.lookahead < U) {
            if (V(k), k.lookahead < U && ne === m) return A;
            if (k.lookahead === 0) break;
          }
          if (J = 0, k.lookahead >= w && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + w - 1]) & k.hash_mask, J = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), J !== 0 && k.strstart - J <= k.w_size - U && (k.match_length = ce(k, J)), k.match_length >= w) if (B = c._tr_tally(k, k.strstart - k.match_start, k.match_length - w), k.lookahead -= k.match_length, k.match_length <= k.max_lazy_match && k.lookahead >= w) {
            for (k.match_length--; k.strstart++, k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + w - 1]) & k.hash_mask, J = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart, --k.match_length != 0; ) ;
            k.strstart++;
          } else k.strstart += k.match_length, k.match_length = 0, k.ins_h = k.window[k.strstart], k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + 1]) & k.hash_mask;
          else B = c._tr_tally(k, 0, k.window[k.strstart]), k.lookahead--, k.strstart++;
          if (B && (q(k, !1), k.strm.avail_out === 0)) return A;
        }
        return k.insert = k.strstart < w - 1 ? k.strstart : w - 1, ne === p ? (q(k, !0), k.strm.avail_out === 0 ? ue : Q) : k.last_lit && (q(k, !1), k.strm.avail_out === 0) ? A : G;
      }
      function H(k, ne) {
        for (var J, B, X; ; ) {
          if (k.lookahead < U) {
            if (V(k), k.lookahead < U && ne === m) return A;
            if (k.lookahead === 0) break;
          }
          if (J = 0, k.lookahead >= w && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + w - 1]) & k.hash_mask, J = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), k.prev_length = k.match_length, k.prev_match = k.match_start, k.match_length = w - 1, J !== 0 && k.prev_length < k.max_lazy_match && k.strstart - J <= k.w_size - U && (k.match_length = ce(k, J), k.match_length <= 5 && (k.strategy === 1 || k.match_length === w && 4096 < k.strstart - k.match_start) && (k.match_length = w - 1)), k.prev_length >= w && k.match_length <= k.prev_length) {
            for (X = k.strstart + k.lookahead - w, B = c._tr_tally(k, k.strstart - 1 - k.prev_match, k.prev_length - w), k.lookahead -= k.prev_length - 1, k.prev_length -= 2; ++k.strstart <= X && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + w - 1]) & k.hash_mask, J = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), --k.prev_length != 0; ) ;
            if (k.match_available = 0, k.match_length = w - 1, k.strstart++, B && (q(k, !1), k.strm.avail_out === 0)) return A;
          } else if (k.match_available) {
            if ((B = c._tr_tally(k, 0, k.window[k.strstart - 1])) && q(k, !1), k.strstart++, k.lookahead--, k.strm.avail_out === 0) return A;
          } else k.match_available = 1, k.strstart++, k.lookahead--;
        }
        return k.match_available && (B = c._tr_tally(k, 0, k.window[k.strstart - 1]), k.match_available = 0), k.insert = k.strstart < w - 1 ? k.strstart : w - 1, ne === p ? (q(k, !0), k.strm.avail_out === 0 ? ue : Q) : k.last_lit && (q(k, !1), k.strm.avail_out === 0) ? A : G;
      }
      function I(k, ne, J, B, X) {
        this.good_length = k, this.max_lazy = ne, this.nice_length = J, this.max_chain = B, this.func = X;
      }
      function F() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = S, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new l.Buf16(2 * T), this.dyn_dtree = new l.Buf16(2 * (2 * E + 1)), this.bl_tree = new l.Buf16(2 * (2 * P + 1)), j(this.dyn_ltree), j(this.dyn_dtree), j(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new l.Buf16(y + 1), this.heap = new l.Buf16(2 * C + 1), j(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new l.Buf16(2 * C + 1), j(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function L(k) {
        var ne;
        return k && k.state ? (k.total_in = k.total_out = 0, k.data_type = M, (ne = k.state).pending = 0, ne.pending_out = 0, ne.wrap < 0 && (ne.wrap = -ne.wrap), ne.status = ne.wrap ? R : O, k.adler = ne.wrap === 2 ? 0 : 1, ne.last_flush = m, c._tr_init(ne), v) : le(k, x);
      }
      function ee(k) {
        var ne = L(k);
        return ne === v && function(J) {
          J.window_size = 2 * J.w_size, j(J.head), J.max_lazy_match = a[J.level].max_lazy, J.good_match = a[J.level].good_length, J.nice_match = a[J.level].nice_length, J.max_chain_length = a[J.level].max_chain, J.strstart = 0, J.block_start = 0, J.lookahead = 0, J.insert = 0, J.match_length = J.prev_length = w - 1, J.match_available = 0, J.ins_h = 0;
        }(k.state), ne;
      }
      function Z(k, ne, J, B, X, se) {
        if (!k) return x;
        var z = 1;
        if (ne === g && (ne = 6), B < 0 ? (z = 0, B = -B) : 15 < B && (z = 2, B -= 16), X < 1 || b < X || J !== S || B < 8 || 15 < B || ne < 0 || 9 < ne || se < 0 || _ < se) return le(k, x);
        B === 8 && (B = 9);
        var N = new F();
        return (k.state = N).strm = k, N.wrap = z, N.gzhead = null, N.w_bits = B, N.w_size = 1 << N.w_bits, N.w_mask = N.w_size - 1, N.hash_bits = X + 7, N.hash_size = 1 << N.hash_bits, N.hash_mask = N.hash_size - 1, N.hash_shift = ~~((N.hash_bits + w - 1) / w), N.window = new l.Buf8(2 * N.w_size), N.head = new l.Buf16(N.hash_size), N.prev = new l.Buf16(N.w_size), N.lit_bufsize = 1 << X + 6, N.pending_buf_size = 4 * N.lit_bufsize, N.pending_buf = new l.Buf8(N.pending_buf_size), N.d_buf = 1 * N.lit_bufsize, N.l_buf = 3 * N.lit_bufsize, N.level = ne, N.strategy = se, N.method = J, ee(k);
      }
      a = [new I(0, 0, 0, 0, function(k, ne) {
        var J = 65535;
        for (J > k.pending_buf_size - 5 && (J = k.pending_buf_size - 5); ; ) {
          if (k.lookahead <= 1) {
            if (V(k), k.lookahead === 0 && ne === m) return A;
            if (k.lookahead === 0) break;
          }
          k.strstart += k.lookahead, k.lookahead = 0;
          var B = k.block_start + J;
          if ((k.strstart === 0 || k.strstart >= B) && (k.lookahead = k.strstart - B, k.strstart = B, q(k, !1), k.strm.avail_out === 0) || k.strstart - k.block_start >= k.w_size - U && (q(k, !1), k.strm.avail_out === 0)) return A;
        }
        return k.insert = 0, ne === p ? (q(k, !0), k.strm.avail_out === 0 ? ue : Q) : (k.strstart > k.block_start && (q(k, !1), k.strm.avail_out), A);
      }), new I(4, 4, 8, 4, Y), new I(4, 5, 16, 8, Y), new I(4, 6, 32, 32, Y), new I(4, 4, 16, 16, H), new I(8, 16, 32, 32, H), new I(8, 16, 128, 128, H), new I(8, 32, 128, 256, H), new I(32, 128, 258, 1024, H), new I(32, 258, 258, 4096, H)], o.deflateInit = function(k, ne) {
        return Z(k, ne, S, 15, 8, 0);
      }, o.deflateInit2 = Z, o.deflateReset = ee, o.deflateResetKeep = L, o.deflateSetHeader = function(k, ne) {
        return k && k.state ? k.state.wrap !== 2 ? x : (k.state.gzhead = ne, v) : x;
      }, o.deflate = function(k, ne) {
        var J, B, X, se;
        if (!k || !k.state || 5 < ne || ne < 0) return k ? le(k, x) : x;
        if (B = k.state, !k.output || !k.input && k.avail_in !== 0 || B.status === 666 && ne !== p) return le(k, k.avail_out === 0 ? -5 : x);
        if (B.strm = k, J = B.last_flush, B.last_flush = ne, B.status === R) if (B.wrap === 2) k.adler = 0, oe(B, 31), oe(B, 139), oe(B, 8), B.gzhead ? (oe(B, (B.gzhead.text ? 1 : 0) + (B.gzhead.hcrc ? 2 : 0) + (B.gzhead.extra ? 4 : 0) + (B.gzhead.name ? 8 : 0) + (B.gzhead.comment ? 16 : 0)), oe(B, 255 & B.gzhead.time), oe(B, B.gzhead.time >> 8 & 255), oe(B, B.gzhead.time >> 16 & 255), oe(B, B.gzhead.time >> 24 & 255), oe(B, B.level === 9 ? 2 : 2 <= B.strategy || B.level < 2 ? 4 : 0), oe(B, 255 & B.gzhead.os), B.gzhead.extra && B.gzhead.extra.length && (oe(B, 255 & B.gzhead.extra.length), oe(B, B.gzhead.extra.length >> 8 & 255)), B.gzhead.hcrc && (k.adler = d(k.adler, B.pending_buf, B.pending, 0)), B.gzindex = 0, B.status = 69) : (oe(B, 0), oe(B, 0), oe(B, 0), oe(B, 0), oe(B, 0), oe(B, B.level === 9 ? 2 : 2 <= B.strategy || B.level < 2 ? 4 : 0), oe(B, 3), B.status = O);
        else {
          var z = S + (B.w_bits - 8 << 4) << 8;
          z |= (2 <= B.strategy || B.level < 2 ? 0 : B.level < 6 ? 1 : B.level === 6 ? 2 : 3) << 6, B.strstart !== 0 && (z |= 32), z += 31 - z % 31, B.status = O, ie(B, z), B.strstart !== 0 && (ie(B, k.adler >>> 16), ie(B, 65535 & k.adler)), k.adler = 1;
        }
        if (B.status === 69) if (B.gzhead.extra) {
          for (X = B.pending; B.gzindex < (65535 & B.gzhead.extra.length) && (B.pending !== B.pending_buf_size || (B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), $(k), X = B.pending, B.pending !== B.pending_buf_size)); ) oe(B, 255 & B.gzhead.extra[B.gzindex]), B.gzindex++;
          B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), B.gzindex === B.gzhead.extra.length && (B.gzindex = 0, B.status = 73);
        } else B.status = 73;
        if (B.status === 73) if (B.gzhead.name) {
          X = B.pending;
          do {
            if (B.pending === B.pending_buf_size && (B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), $(k), X = B.pending, B.pending === B.pending_buf_size)) {
              se = 1;
              break;
            }
            se = B.gzindex < B.gzhead.name.length ? 255 & B.gzhead.name.charCodeAt(B.gzindex++) : 0, oe(B, se);
          } while (se !== 0);
          B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), se === 0 && (B.gzindex = 0, B.status = 91);
        } else B.status = 91;
        if (B.status === 91) if (B.gzhead.comment) {
          X = B.pending;
          do {
            if (B.pending === B.pending_buf_size && (B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), $(k), X = B.pending, B.pending === B.pending_buf_size)) {
              se = 1;
              break;
            }
            se = B.gzindex < B.gzhead.comment.length ? 255 & B.gzhead.comment.charCodeAt(B.gzindex++) : 0, oe(B, se);
          } while (se !== 0);
          B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), se === 0 && (B.status = 103);
        } else B.status = 103;
        if (B.status === 103 && (B.gzhead.hcrc ? (B.pending + 2 > B.pending_buf_size && $(k), B.pending + 2 <= B.pending_buf_size && (oe(B, 255 & k.adler), oe(B, k.adler >> 8 & 255), k.adler = 0, B.status = O)) : B.status = O), B.pending !== 0) {
          if ($(k), k.avail_out === 0) return B.last_flush = -1, v;
        } else if (k.avail_in === 0 && re(ne) <= re(J) && ne !== p) return le(k, -5);
        if (B.status === 666 && k.avail_in !== 0) return le(k, -5);
        if (k.avail_in !== 0 || B.lookahead !== 0 || ne !== m && B.status !== 666) {
          var N = B.strategy === 2 ? function(K, he) {
            for (var me; ; ) {
              if (K.lookahead === 0 && (V(K), K.lookahead === 0)) {
                if (he === m) return A;
                break;
              }
              if (K.match_length = 0, me = c._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++, me && (q(K, !1), K.strm.avail_out === 0)) return A;
            }
            return K.insert = 0, he === p ? (q(K, !0), K.strm.avail_out === 0 ? ue : Q) : K.last_lit && (q(K, !1), K.strm.avail_out === 0) ? A : G;
          }(B, ne) : B.strategy === 3 ? function(K, he) {
            for (var me, ge, Me, Te, Ae = K.window; ; ) {
              if (K.lookahead <= D) {
                if (V(K), K.lookahead <= D && he === m) return A;
                if (K.lookahead === 0) break;
              }
              if (K.match_length = 0, K.lookahead >= w && 0 < K.strstart && (ge = Ae[Me = K.strstart - 1]) === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me]) {
                Te = K.strstart + D;
                do
                  ;
                while (ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && Me < Te);
                K.match_length = D - (Te - Me), K.match_length > K.lookahead && (K.match_length = K.lookahead);
              }
              if (K.match_length >= w ? (me = c._tr_tally(K, 1, K.match_length - w), K.lookahead -= K.match_length, K.strstart += K.match_length, K.match_length = 0) : (me = c._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++), me && (q(K, !1), K.strm.avail_out === 0)) return A;
            }
            return K.insert = 0, he === p ? (q(K, !0), K.strm.avail_out === 0 ? ue : Q) : K.last_lit && (q(K, !1), K.strm.avail_out === 0) ? A : G;
          }(B, ne) : a[B.level].func(B, ne);
          if (N !== ue && N !== Q || (B.status = 666), N === A || N === ue) return k.avail_out === 0 && (B.last_flush = -1), v;
          if (N === G && (ne === 1 ? c._tr_align(B) : ne !== 5 && (c._tr_stored_block(B, 0, 0, !1), ne === 3 && (j(B.head), B.lookahead === 0 && (B.strstart = 0, B.block_start = 0, B.insert = 0))), $(k), k.avail_out === 0)) return B.last_flush = -1, v;
        }
        return ne !== p ? v : B.wrap <= 0 ? 1 : (B.wrap === 2 ? (oe(B, 255 & k.adler), oe(B, k.adler >> 8 & 255), oe(B, k.adler >> 16 & 255), oe(B, k.adler >> 24 & 255), oe(B, 255 & k.total_in), oe(B, k.total_in >> 8 & 255), oe(B, k.total_in >> 16 & 255), oe(B, k.total_in >> 24 & 255)) : (ie(B, k.adler >>> 16), ie(B, 65535 & k.adler)), $(k), 0 < B.wrap && (B.wrap = -B.wrap), B.pending !== 0 ? v : 1);
      }, o.deflateEnd = function(k) {
        var ne;
        return k && k.state ? (ne = k.state.status) !== R && ne !== 69 && ne !== 73 && ne !== 91 && ne !== 103 && ne !== O && ne !== 666 ? le(k, x) : (k.state = null, ne === O ? le(k, -3) : v) : x;
      }, o.deflateSetDictionary = function(k, ne) {
        var J, B, X, se, z, N, K, he, me = ne.length;
        if (!k || !k.state || (se = (J = k.state).wrap) === 2 || se === 1 && J.status !== R || J.lookahead) return x;
        for (se === 1 && (k.adler = u(k.adler, ne, me, 0)), J.wrap = 0, me >= J.w_size && (se === 0 && (j(J.head), J.strstart = 0, J.block_start = 0, J.insert = 0), he = new l.Buf8(J.w_size), l.arraySet(he, ne, me - J.w_size, J.w_size, 0), ne = he, me = J.w_size), z = k.avail_in, N = k.next_in, K = k.input, k.avail_in = me, k.next_in = 0, k.input = ne, V(J); J.lookahead >= w; ) {
          for (B = J.strstart, X = J.lookahead - (w - 1); J.ins_h = (J.ins_h << J.hash_shift ^ J.window[B + w - 1]) & J.hash_mask, J.prev[B & J.w_mask] = J.head[J.ins_h], J.head[J.ins_h] = B, B++, --X; ) ;
          J.strstart = B, J.lookahead = w - 1, V(J);
        }
        return J.strstart += J.lookahead, J.block_start = J.strstart, J.insert = J.lookahead, J.lookahead = 0, J.match_length = J.prev_length = w - 1, J.match_available = 0, k.next_in = N, k.input = K, k.avail_in = z, J.wrap = se, v;
      }, o.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(i, r, o) {
      r.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(i, r, o) {
      r.exports = function(a, l) {
        var c, u, d, h, m, p, v, x, g, _, M, S, b, C, E, P, T, y, w, D, U, R, O, A, G;
        c = a.state, u = a.next_in, A = a.input, d = u + (a.avail_in - 5), h = a.next_out, G = a.output, m = h - (l - a.avail_out), p = h + (a.avail_out - 257), v = c.dmax, x = c.wsize, g = c.whave, _ = c.wnext, M = c.window, S = c.hold, b = c.bits, C = c.lencode, E = c.distcode, P = (1 << c.lenbits) - 1, T = (1 << c.distbits) - 1;
        e: do {
          b < 15 && (S += A[u++] << b, b += 8, S += A[u++] << b, b += 8), y = C[S & P];
          t: for (; ; ) {
            if (S >>>= w = y >>> 24, b -= w, (w = y >>> 16 & 255) === 0) G[h++] = 65535 & y;
            else {
              if (!(16 & w)) {
                if (!(64 & w)) {
                  y = C[(65535 & y) + (S & (1 << w) - 1)];
                  continue t;
                }
                if (32 & w) {
                  c.mode = 12;
                  break e;
                }
                a.msg = "invalid literal/length code", c.mode = 30;
                break e;
              }
              D = 65535 & y, (w &= 15) && (b < w && (S += A[u++] << b, b += 8), D += S & (1 << w) - 1, S >>>= w, b -= w), b < 15 && (S += A[u++] << b, b += 8, S += A[u++] << b, b += 8), y = E[S & T];
              n: for (; ; ) {
                if (S >>>= w = y >>> 24, b -= w, !(16 & (w = y >>> 16 & 255))) {
                  if (!(64 & w)) {
                    y = E[(65535 & y) + (S & (1 << w) - 1)];
                    continue n;
                  }
                  a.msg = "invalid distance code", c.mode = 30;
                  break e;
                }
                if (U = 65535 & y, b < (w &= 15) && (S += A[u++] << b, (b += 8) < w && (S += A[u++] << b, b += 8)), v < (U += S & (1 << w) - 1)) {
                  a.msg = "invalid distance too far back", c.mode = 30;
                  break e;
                }
                if (S >>>= w, b -= w, (w = h - m) < U) {
                  if (g < (w = U - w) && c.sane) {
                    a.msg = "invalid distance too far back", c.mode = 30;
                    break e;
                  }
                  if (O = M, (R = 0) === _) {
                    if (R += x - w, w < D) {
                      for (D -= w; G[h++] = M[R++], --w; ) ;
                      R = h - U, O = G;
                    }
                  } else if (_ < w) {
                    if (R += x + _ - w, (w -= _) < D) {
                      for (D -= w; G[h++] = M[R++], --w; ) ;
                      if (R = 0, _ < D) {
                        for (D -= w = _; G[h++] = M[R++], --w; ) ;
                        R = h - U, O = G;
                      }
                    }
                  } else if (R += _ - w, w < D) {
                    for (D -= w; G[h++] = M[R++], --w; ) ;
                    R = h - U, O = G;
                  }
                  for (; 2 < D; ) G[h++] = O[R++], G[h++] = O[R++], G[h++] = O[R++], D -= 3;
                  D && (G[h++] = O[R++], 1 < D && (G[h++] = O[R++]));
                } else {
                  for (R = h - U; G[h++] = G[R++], G[h++] = G[R++], G[h++] = G[R++], 2 < (D -= 3); ) ;
                  D && (G[h++] = G[R++], 1 < D && (G[h++] = G[R++]));
                }
                break;
              }
            }
            break;
          }
        } while (u < d && h < p);
        u -= D = b >> 3, S &= (1 << (b -= D << 3)) - 1, a.next_in = u, a.next_out = h, a.avail_in = u < d ? d - u + 5 : 5 - (u - d), a.avail_out = h < p ? p - h + 257 : 257 - (h - p), c.hold = S, c.bits = b;
      };
    }, {}], 49: [function(i, r, o) {
      var a = i("../utils/common"), l = i("./adler32"), c = i("./crc32"), u = i("./inffast"), d = i("./inftrees"), h = 1, m = 2, p = 0, v = -2, x = 1, g = 852, _ = 592;
      function M(R) {
        return (R >>> 24 & 255) + (R >>> 8 & 65280) + ((65280 & R) << 8) + ((255 & R) << 24);
      }
      function S() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function b(R) {
        var O;
        return R && R.state ? (O = R.state, R.total_in = R.total_out = O.total = 0, R.msg = "", O.wrap && (R.adler = 1 & O.wrap), O.mode = x, O.last = 0, O.havedict = 0, O.dmax = 32768, O.head = null, O.hold = 0, O.bits = 0, O.lencode = O.lendyn = new a.Buf32(g), O.distcode = O.distdyn = new a.Buf32(_), O.sane = 1, O.back = -1, p) : v;
      }
      function C(R) {
        var O;
        return R && R.state ? ((O = R.state).wsize = 0, O.whave = 0, O.wnext = 0, b(R)) : v;
      }
      function E(R, O) {
        var A, G;
        return R && R.state ? (G = R.state, O < 0 ? (A = 0, O = -O) : (A = 1 + (O >> 4), O < 48 && (O &= 15)), O && (O < 8 || 15 < O) ? v : (G.window !== null && G.wbits !== O && (G.window = null), G.wrap = A, G.wbits = O, C(R))) : v;
      }
      function P(R, O) {
        var A, G;
        return R ? (G = new S(), (R.state = G).window = null, (A = E(R, O)) !== p && (R.state = null), A) : v;
      }
      var T, y, w = !0;
      function D(R) {
        if (w) {
          var O;
          for (T = new a.Buf32(512), y = new a.Buf32(32), O = 0; O < 144; ) R.lens[O++] = 8;
          for (; O < 256; ) R.lens[O++] = 9;
          for (; O < 280; ) R.lens[O++] = 7;
          for (; O < 288; ) R.lens[O++] = 8;
          for (d(h, R.lens, 0, 288, T, 0, R.work, { bits: 9 }), O = 0; O < 32; ) R.lens[O++] = 5;
          d(m, R.lens, 0, 32, y, 0, R.work, { bits: 5 }), w = !1;
        }
        R.lencode = T, R.lenbits = 9, R.distcode = y, R.distbits = 5;
      }
      function U(R, O, A, G) {
        var ue, Q = R.state;
        return Q.window === null && (Q.wsize = 1 << Q.wbits, Q.wnext = 0, Q.whave = 0, Q.window = new a.Buf8(Q.wsize)), G >= Q.wsize ? (a.arraySet(Q.window, O, A - Q.wsize, Q.wsize, 0), Q.wnext = 0, Q.whave = Q.wsize) : (G < (ue = Q.wsize - Q.wnext) && (ue = G), a.arraySet(Q.window, O, A - G, ue, Q.wnext), (G -= ue) ? (a.arraySet(Q.window, O, A - G, G, 0), Q.wnext = G, Q.whave = Q.wsize) : (Q.wnext += ue, Q.wnext === Q.wsize && (Q.wnext = 0), Q.whave < Q.wsize && (Q.whave += ue))), 0;
      }
      o.inflateReset = C, o.inflateReset2 = E, o.inflateResetKeep = b, o.inflateInit = function(R) {
        return P(R, 15);
      }, o.inflateInit2 = P, o.inflate = function(R, O) {
        var A, G, ue, Q, le, re, j, $, q, oe, ie, ce, V, Y, H, I, F, L, ee, Z, k, ne, J, B, X = 0, se = new a.Buf8(4), z = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!R || !R.state || !R.output || !R.input && R.avail_in !== 0) return v;
        (A = R.state).mode === 12 && (A.mode = 13), le = R.next_out, ue = R.output, j = R.avail_out, Q = R.next_in, G = R.input, re = R.avail_in, $ = A.hold, q = A.bits, oe = re, ie = j, ne = p;
        e: for (; ; ) switch (A.mode) {
          case x:
            if (A.wrap === 0) {
              A.mode = 13;
              break;
            }
            for (; q < 16; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if (2 & A.wrap && $ === 35615) {
              se[A.check = 0] = 255 & $, se[1] = $ >>> 8 & 255, A.check = c(A.check, se, 2, 0), q = $ = 0, A.mode = 2;
              break;
            }
            if (A.flags = 0, A.head && (A.head.done = !1), !(1 & A.wrap) || (((255 & $) << 8) + ($ >> 8)) % 31) {
              R.msg = "incorrect header check", A.mode = 30;
              break;
            }
            if ((15 & $) != 8) {
              R.msg = "unknown compression method", A.mode = 30;
              break;
            }
            if (q -= 4, k = 8 + (15 & ($ >>>= 4)), A.wbits === 0) A.wbits = k;
            else if (k > A.wbits) {
              R.msg = "invalid window size", A.mode = 30;
              break;
            }
            A.dmax = 1 << k, R.adler = A.check = 1, A.mode = 512 & $ ? 10 : 12, q = $ = 0;
            break;
          case 2:
            for (; q < 16; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if (A.flags = $, (255 & A.flags) != 8) {
              R.msg = "unknown compression method", A.mode = 30;
              break;
            }
            if (57344 & A.flags) {
              R.msg = "unknown header flags set", A.mode = 30;
              break;
            }
            A.head && (A.head.text = $ >> 8 & 1), 512 & A.flags && (se[0] = 255 & $, se[1] = $ >>> 8 & 255, A.check = c(A.check, se, 2, 0)), q = $ = 0, A.mode = 3;
          case 3:
            for (; q < 32; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            A.head && (A.head.time = $), 512 & A.flags && (se[0] = 255 & $, se[1] = $ >>> 8 & 255, se[2] = $ >>> 16 & 255, se[3] = $ >>> 24 & 255, A.check = c(A.check, se, 4, 0)), q = $ = 0, A.mode = 4;
          case 4:
            for (; q < 16; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            A.head && (A.head.xflags = 255 & $, A.head.os = $ >> 8), 512 & A.flags && (se[0] = 255 & $, se[1] = $ >>> 8 & 255, A.check = c(A.check, se, 2, 0)), q = $ = 0, A.mode = 5;
          case 5:
            if (1024 & A.flags) {
              for (; q < 16; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              A.length = $, A.head && (A.head.extra_len = $), 512 & A.flags && (se[0] = 255 & $, se[1] = $ >>> 8 & 255, A.check = c(A.check, se, 2, 0)), q = $ = 0;
            } else A.head && (A.head.extra = null);
            A.mode = 6;
          case 6:
            if (1024 & A.flags && (re < (ce = A.length) && (ce = re), ce && (A.head && (k = A.head.extra_len - A.length, A.head.extra || (A.head.extra = new Array(A.head.extra_len)), a.arraySet(A.head.extra, G, Q, ce, k)), 512 & A.flags && (A.check = c(A.check, G, ce, Q)), re -= ce, Q += ce, A.length -= ce), A.length)) break e;
            A.length = 0, A.mode = 7;
          case 7:
            if (2048 & A.flags) {
              if (re === 0) break e;
              for (ce = 0; k = G[Q + ce++], A.head && k && A.length < 65536 && (A.head.name += String.fromCharCode(k)), k && ce < re; ) ;
              if (512 & A.flags && (A.check = c(A.check, G, ce, Q)), re -= ce, Q += ce, k) break e;
            } else A.head && (A.head.name = null);
            A.length = 0, A.mode = 8;
          case 8:
            if (4096 & A.flags) {
              if (re === 0) break e;
              for (ce = 0; k = G[Q + ce++], A.head && k && A.length < 65536 && (A.head.comment += String.fromCharCode(k)), k && ce < re; ) ;
              if (512 & A.flags && (A.check = c(A.check, G, ce, Q)), re -= ce, Q += ce, k) break e;
            } else A.head && (A.head.comment = null);
            A.mode = 9;
          case 9:
            if (512 & A.flags) {
              for (; q < 16; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              if ($ !== (65535 & A.check)) {
                R.msg = "header crc mismatch", A.mode = 30;
                break;
              }
              q = $ = 0;
            }
            A.head && (A.head.hcrc = A.flags >> 9 & 1, A.head.done = !0), R.adler = A.check = 0, A.mode = 12;
            break;
          case 10:
            for (; q < 32; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            R.adler = A.check = M($), q = $ = 0, A.mode = 11;
          case 11:
            if (A.havedict === 0) return R.next_out = le, R.avail_out = j, R.next_in = Q, R.avail_in = re, A.hold = $, A.bits = q, 2;
            R.adler = A.check = 1, A.mode = 12;
          case 12:
            if (O === 5 || O === 6) break e;
          case 13:
            if (A.last) {
              $ >>>= 7 & q, q -= 7 & q, A.mode = 27;
              break;
            }
            for (; q < 3; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            switch (A.last = 1 & $, q -= 1, 3 & ($ >>>= 1)) {
              case 0:
                A.mode = 14;
                break;
              case 1:
                if (D(A), A.mode = 20, O !== 6) break;
                $ >>>= 2, q -= 2;
                break e;
              case 2:
                A.mode = 17;
                break;
              case 3:
                R.msg = "invalid block type", A.mode = 30;
            }
            $ >>>= 2, q -= 2;
            break;
          case 14:
            for ($ >>>= 7 & q, q -= 7 & q; q < 32; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if ((65535 & $) != ($ >>> 16 ^ 65535)) {
              R.msg = "invalid stored block lengths", A.mode = 30;
              break;
            }
            if (A.length = 65535 & $, q = $ = 0, A.mode = 15, O === 6) break e;
          case 15:
            A.mode = 16;
          case 16:
            if (ce = A.length) {
              if (re < ce && (ce = re), j < ce && (ce = j), ce === 0) break e;
              a.arraySet(ue, G, Q, ce, le), re -= ce, Q += ce, j -= ce, le += ce, A.length -= ce;
              break;
            }
            A.mode = 12;
            break;
          case 17:
            for (; q < 14; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if (A.nlen = 257 + (31 & $), $ >>>= 5, q -= 5, A.ndist = 1 + (31 & $), $ >>>= 5, q -= 5, A.ncode = 4 + (15 & $), $ >>>= 4, q -= 4, 286 < A.nlen || 30 < A.ndist) {
              R.msg = "too many length or distance symbols", A.mode = 30;
              break;
            }
            A.have = 0, A.mode = 18;
          case 18:
            for (; A.have < A.ncode; ) {
              for (; q < 3; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              A.lens[z[A.have++]] = 7 & $, $ >>>= 3, q -= 3;
            }
            for (; A.have < 19; ) A.lens[z[A.have++]] = 0;
            if (A.lencode = A.lendyn, A.lenbits = 7, J = { bits: A.lenbits }, ne = d(0, A.lens, 0, 19, A.lencode, 0, A.work, J), A.lenbits = J.bits, ne) {
              R.msg = "invalid code lengths set", A.mode = 30;
              break;
            }
            A.have = 0, A.mode = 19;
          case 19:
            for (; A.have < A.nlen + A.ndist; ) {
              for (; I = (X = A.lencode[$ & (1 << A.lenbits) - 1]) >>> 16 & 255, F = 65535 & X, !((H = X >>> 24) <= q); ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              if (F < 16) $ >>>= H, q -= H, A.lens[A.have++] = F;
              else {
                if (F === 16) {
                  for (B = H + 2; q < B; ) {
                    if (re === 0) break e;
                    re--, $ += G[Q++] << q, q += 8;
                  }
                  if ($ >>>= H, q -= H, A.have === 0) {
                    R.msg = "invalid bit length repeat", A.mode = 30;
                    break;
                  }
                  k = A.lens[A.have - 1], ce = 3 + (3 & $), $ >>>= 2, q -= 2;
                } else if (F === 17) {
                  for (B = H + 3; q < B; ) {
                    if (re === 0) break e;
                    re--, $ += G[Q++] << q, q += 8;
                  }
                  q -= H, k = 0, ce = 3 + (7 & ($ >>>= H)), $ >>>= 3, q -= 3;
                } else {
                  for (B = H + 7; q < B; ) {
                    if (re === 0) break e;
                    re--, $ += G[Q++] << q, q += 8;
                  }
                  q -= H, k = 0, ce = 11 + (127 & ($ >>>= H)), $ >>>= 7, q -= 7;
                }
                if (A.have + ce > A.nlen + A.ndist) {
                  R.msg = "invalid bit length repeat", A.mode = 30;
                  break;
                }
                for (; ce--; ) A.lens[A.have++] = k;
              }
            }
            if (A.mode === 30) break;
            if (A.lens[256] === 0) {
              R.msg = "invalid code -- missing end-of-block", A.mode = 30;
              break;
            }
            if (A.lenbits = 9, J = { bits: A.lenbits }, ne = d(h, A.lens, 0, A.nlen, A.lencode, 0, A.work, J), A.lenbits = J.bits, ne) {
              R.msg = "invalid literal/lengths set", A.mode = 30;
              break;
            }
            if (A.distbits = 6, A.distcode = A.distdyn, J = { bits: A.distbits }, ne = d(m, A.lens, A.nlen, A.ndist, A.distcode, 0, A.work, J), A.distbits = J.bits, ne) {
              R.msg = "invalid distances set", A.mode = 30;
              break;
            }
            if (A.mode = 20, O === 6) break e;
          case 20:
            A.mode = 21;
          case 21:
            if (6 <= re && 258 <= j) {
              R.next_out = le, R.avail_out = j, R.next_in = Q, R.avail_in = re, A.hold = $, A.bits = q, u(R, ie), le = R.next_out, ue = R.output, j = R.avail_out, Q = R.next_in, G = R.input, re = R.avail_in, $ = A.hold, q = A.bits, A.mode === 12 && (A.back = -1);
              break;
            }
            for (A.back = 0; I = (X = A.lencode[$ & (1 << A.lenbits) - 1]) >>> 16 & 255, F = 65535 & X, !((H = X >>> 24) <= q); ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if (I && !(240 & I)) {
              for (L = H, ee = I, Z = F; I = (X = A.lencode[Z + (($ & (1 << L + ee) - 1) >> L)]) >>> 16 & 255, F = 65535 & X, !(L + (H = X >>> 24) <= q); ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              $ >>>= L, q -= L, A.back += L;
            }
            if ($ >>>= H, q -= H, A.back += H, A.length = F, I === 0) {
              A.mode = 26;
              break;
            }
            if (32 & I) {
              A.back = -1, A.mode = 12;
              break;
            }
            if (64 & I) {
              R.msg = "invalid literal/length code", A.mode = 30;
              break;
            }
            A.extra = 15 & I, A.mode = 22;
          case 22:
            if (A.extra) {
              for (B = A.extra; q < B; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              A.length += $ & (1 << A.extra) - 1, $ >>>= A.extra, q -= A.extra, A.back += A.extra;
            }
            A.was = A.length, A.mode = 23;
          case 23:
            for (; I = (X = A.distcode[$ & (1 << A.distbits) - 1]) >>> 16 & 255, F = 65535 & X, !((H = X >>> 24) <= q); ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if (!(240 & I)) {
              for (L = H, ee = I, Z = F; I = (X = A.distcode[Z + (($ & (1 << L + ee) - 1) >> L)]) >>> 16 & 255, F = 65535 & X, !(L + (H = X >>> 24) <= q); ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              $ >>>= L, q -= L, A.back += L;
            }
            if ($ >>>= H, q -= H, A.back += H, 64 & I) {
              R.msg = "invalid distance code", A.mode = 30;
              break;
            }
            A.offset = F, A.extra = 15 & I, A.mode = 24;
          case 24:
            if (A.extra) {
              for (B = A.extra; q < B; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              A.offset += $ & (1 << A.extra) - 1, $ >>>= A.extra, q -= A.extra, A.back += A.extra;
            }
            if (A.offset > A.dmax) {
              R.msg = "invalid distance too far back", A.mode = 30;
              break;
            }
            A.mode = 25;
          case 25:
            if (j === 0) break e;
            if (ce = ie - j, A.offset > ce) {
              if ((ce = A.offset - ce) > A.whave && A.sane) {
                R.msg = "invalid distance too far back", A.mode = 30;
                break;
              }
              V = ce > A.wnext ? (ce -= A.wnext, A.wsize - ce) : A.wnext - ce, ce > A.length && (ce = A.length), Y = A.window;
            } else Y = ue, V = le - A.offset, ce = A.length;
            for (j < ce && (ce = j), j -= ce, A.length -= ce; ue[le++] = Y[V++], --ce; ) ;
            A.length === 0 && (A.mode = 21);
            break;
          case 26:
            if (j === 0) break e;
            ue[le++] = A.length, j--, A.mode = 21;
            break;
          case 27:
            if (A.wrap) {
              for (; q < 32; ) {
                if (re === 0) break e;
                re--, $ |= G[Q++] << q, q += 8;
              }
              if (ie -= j, R.total_out += ie, A.total += ie, ie && (R.adler = A.check = A.flags ? c(A.check, ue, ie, le - ie) : l(A.check, ue, ie, le - ie)), ie = j, (A.flags ? $ : M($)) !== A.check) {
                R.msg = "incorrect data check", A.mode = 30;
                break;
              }
              q = $ = 0;
            }
            A.mode = 28;
          case 28:
            if (A.wrap && A.flags) {
              for (; q < 32; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              if ($ !== (4294967295 & A.total)) {
                R.msg = "incorrect length check", A.mode = 30;
                break;
              }
              q = $ = 0;
            }
            A.mode = 29;
          case 29:
            ne = 1;
            break e;
          case 30:
            ne = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return v;
        }
        return R.next_out = le, R.avail_out = j, R.next_in = Q, R.avail_in = re, A.hold = $, A.bits = q, (A.wsize || ie !== R.avail_out && A.mode < 30 && (A.mode < 27 || O !== 4)) && U(R, R.output, R.next_out, ie - R.avail_out) ? (A.mode = 31, -4) : (oe -= R.avail_in, ie -= R.avail_out, R.total_in += oe, R.total_out += ie, A.total += ie, A.wrap && ie && (R.adler = A.check = A.flags ? c(A.check, ue, ie, R.next_out - ie) : l(A.check, ue, ie, R.next_out - ie)), R.data_type = A.bits + (A.last ? 64 : 0) + (A.mode === 12 ? 128 : 0) + (A.mode === 20 || A.mode === 15 ? 256 : 0), (oe == 0 && ie === 0 || O === 4) && ne === p && (ne = -5), ne);
      }, o.inflateEnd = function(R) {
        if (!R || !R.state) return v;
        var O = R.state;
        return O.window && (O.window = null), R.state = null, p;
      }, o.inflateGetHeader = function(R, O) {
        var A;
        return R && R.state && 2 & (A = R.state).wrap ? ((A.head = O).done = !1, p) : v;
      }, o.inflateSetDictionary = function(R, O) {
        var A, G = O.length;
        return R && R.state ? (A = R.state).wrap !== 0 && A.mode !== 11 ? v : A.mode === 11 && l(1, O, G, 0) !== A.check ? -3 : U(R, O, G, G) ? (A.mode = 31, -4) : (A.havedict = 1, p) : v;
      }, o.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(i, r, o) {
      var a = i("../utils/common"), l = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], c = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], d = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      r.exports = function(h, m, p, v, x, g, _, M) {
        var S, b, C, E, P, T, y, w, D, U = M.bits, R = 0, O = 0, A = 0, G = 0, ue = 0, Q = 0, le = 0, re = 0, j = 0, $ = 0, q = null, oe = 0, ie = new a.Buf16(16), ce = new a.Buf16(16), V = null, Y = 0;
        for (R = 0; R <= 15; R++) ie[R] = 0;
        for (O = 0; O < v; O++) ie[m[p + O]]++;
        for (ue = U, G = 15; 1 <= G && ie[G] === 0; G--) ;
        if (G < ue && (ue = G), G === 0) return x[g++] = 20971520, x[g++] = 20971520, M.bits = 1, 0;
        for (A = 1; A < G && ie[A] === 0; A++) ;
        for (ue < A && (ue = A), R = re = 1; R <= 15; R++) if (re <<= 1, (re -= ie[R]) < 0) return -1;
        if (0 < re && (h === 0 || G !== 1)) return -1;
        for (ce[1] = 0, R = 1; R < 15; R++) ce[R + 1] = ce[R] + ie[R];
        for (O = 0; O < v; O++) m[p + O] !== 0 && (_[ce[m[p + O]]++] = O);
        if (T = h === 0 ? (q = V = _, 19) : h === 1 ? (q = l, oe -= 257, V = c, Y -= 257, 256) : (q = u, V = d, -1), R = A, P = g, le = O = $ = 0, C = -1, E = (j = 1 << (Q = ue)) - 1, h === 1 && 852 < j || h === 2 && 592 < j) return 1;
        for (; ; ) {
          for (y = R - le, D = _[O] < T ? (w = 0, _[O]) : _[O] > T ? (w = V[Y + _[O]], q[oe + _[O]]) : (w = 96, 0), S = 1 << R - le, A = b = 1 << Q; x[P + ($ >> le) + (b -= S)] = y << 24 | w << 16 | D | 0, b !== 0; ) ;
          for (S = 1 << R - 1; $ & S; ) S >>= 1;
          if (S !== 0 ? ($ &= S - 1, $ += S) : $ = 0, O++, --ie[R] == 0) {
            if (R === G) break;
            R = m[p + _[O]];
          }
          if (ue < R && ($ & E) !== C) {
            for (le === 0 && (le = ue), P += A, re = 1 << (Q = R - le); Q + le < G && !((re -= ie[Q + le]) <= 0); ) Q++, re <<= 1;
            if (j += 1 << Q, h === 1 && 852 < j || h === 2 && 592 < j) return 1;
            x[C = $ & E] = ue << 24 | Q << 16 | P - g | 0;
          }
        }
        return $ !== 0 && (x[P + $] = R - le << 24 | 64 << 16 | 0), M.bits = ue, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(i, r, o) {
      r.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(i, r, o) {
      var a = i("../utils/common"), l = 0, c = 1;
      function u(X) {
        for (var se = X.length; 0 <= --se; ) X[se] = 0;
      }
      var d = 0, h = 29, m = 256, p = m + 1 + h, v = 30, x = 19, g = 2 * p + 1, _ = 15, M = 16, S = 7, b = 256, C = 16, E = 17, P = 18, T = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], y = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], D = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], U = new Array(2 * (p + 2));
      u(U);
      var R = new Array(2 * v);
      u(R);
      var O = new Array(512);
      u(O);
      var A = new Array(256);
      u(A);
      var G = new Array(h);
      u(G);
      var ue, Q, le, re = new Array(v);
      function j(X, se, z, N, K) {
        this.static_tree = X, this.extra_bits = se, this.extra_base = z, this.elems = N, this.max_length = K, this.has_stree = X && X.length;
      }
      function $(X, se) {
        this.dyn_tree = X, this.max_code = 0, this.stat_desc = se;
      }
      function q(X) {
        return X < 256 ? O[X] : O[256 + (X >>> 7)];
      }
      function oe(X, se) {
        X.pending_buf[X.pending++] = 255 & se, X.pending_buf[X.pending++] = se >>> 8 & 255;
      }
      function ie(X, se, z) {
        X.bi_valid > M - z ? (X.bi_buf |= se << X.bi_valid & 65535, oe(X, X.bi_buf), X.bi_buf = se >> M - X.bi_valid, X.bi_valid += z - M) : (X.bi_buf |= se << X.bi_valid & 65535, X.bi_valid += z);
      }
      function ce(X, se, z) {
        ie(X, z[2 * se], z[2 * se + 1]);
      }
      function V(X, se) {
        for (var z = 0; z |= 1 & X, X >>>= 1, z <<= 1, 0 < --se; ) ;
        return z >>> 1;
      }
      function Y(X, se, z) {
        var N, K, he = new Array(_ + 1), me = 0;
        for (N = 1; N <= _; N++) he[N] = me = me + z[N - 1] << 1;
        for (K = 0; K <= se; K++) {
          var ge = X[2 * K + 1];
          ge !== 0 && (X[2 * K] = V(he[ge]++, ge));
        }
      }
      function H(X) {
        var se;
        for (se = 0; se < p; se++) X.dyn_ltree[2 * se] = 0;
        for (se = 0; se < v; se++) X.dyn_dtree[2 * se] = 0;
        for (se = 0; se < x; se++) X.bl_tree[2 * se] = 0;
        X.dyn_ltree[2 * b] = 1, X.opt_len = X.static_len = 0, X.last_lit = X.matches = 0;
      }
      function I(X) {
        8 < X.bi_valid ? oe(X, X.bi_buf) : 0 < X.bi_valid && (X.pending_buf[X.pending++] = X.bi_buf), X.bi_buf = 0, X.bi_valid = 0;
      }
      function F(X, se, z, N) {
        var K = 2 * se, he = 2 * z;
        return X[K] < X[he] || X[K] === X[he] && N[se] <= N[z];
      }
      function L(X, se, z) {
        for (var N = X.heap[z], K = z << 1; K <= X.heap_len && (K < X.heap_len && F(se, X.heap[K + 1], X.heap[K], X.depth) && K++, !F(se, N, X.heap[K], X.depth)); ) X.heap[z] = X.heap[K], z = K, K <<= 1;
        X.heap[z] = N;
      }
      function ee(X, se, z) {
        var N, K, he, me, ge = 0;
        if (X.last_lit !== 0) for (; N = X.pending_buf[X.d_buf + 2 * ge] << 8 | X.pending_buf[X.d_buf + 2 * ge + 1], K = X.pending_buf[X.l_buf + ge], ge++, N === 0 ? ce(X, K, se) : (ce(X, (he = A[K]) + m + 1, se), (me = T[he]) !== 0 && ie(X, K -= G[he], me), ce(X, he = q(--N), z), (me = y[he]) !== 0 && ie(X, N -= re[he], me)), ge < X.last_lit; ) ;
        ce(X, b, se);
      }
      function Z(X, se) {
        var z, N, K, he = se.dyn_tree, me = se.stat_desc.static_tree, ge = se.stat_desc.has_stree, Me = se.stat_desc.elems, Te = -1;
        for (X.heap_len = 0, X.heap_max = g, z = 0; z < Me; z++) he[2 * z] !== 0 ? (X.heap[++X.heap_len] = Te = z, X.depth[z] = 0) : he[2 * z + 1] = 0;
        for (; X.heap_len < 2; ) he[2 * (K = X.heap[++X.heap_len] = Te < 2 ? ++Te : 0)] = 1, X.depth[K] = 0, X.opt_len--, ge && (X.static_len -= me[2 * K + 1]);
        for (se.max_code = Te, z = X.heap_len >> 1; 1 <= z; z--) L(X, he, z);
        for (K = Me; z = X.heap[1], X.heap[1] = X.heap[X.heap_len--], L(X, he, 1), N = X.heap[1], X.heap[--X.heap_max] = z, X.heap[--X.heap_max] = N, he[2 * K] = he[2 * z] + he[2 * N], X.depth[K] = (X.depth[z] >= X.depth[N] ? X.depth[z] : X.depth[N]) + 1, he[2 * z + 1] = he[2 * N + 1] = K, X.heap[1] = K++, L(X, he, 1), 2 <= X.heap_len; ) ;
        X.heap[--X.heap_max] = X.heap[1], function(Ae, Xe) {
          var Oe, He, Ye, $e, Le, nt, Je = Xe.dyn_tree, bt = Xe.max_code, Se = Xe.stat_desc.static_tree, Ne = Xe.stat_desc.has_stree, Re = Xe.stat_desc.extra_bits, Be = Xe.stat_desc.extra_base, je = Xe.stat_desc.max_length, Ge = 0;
          for ($e = 0; $e <= _; $e++) Ae.bl_count[$e] = 0;
          for (Je[2 * Ae.heap[Ae.heap_max] + 1] = 0, Oe = Ae.heap_max + 1; Oe < g; Oe++) je < ($e = Je[2 * Je[2 * (He = Ae.heap[Oe]) + 1] + 1] + 1) && ($e = je, Ge++), Je[2 * He + 1] = $e, bt < He || (Ae.bl_count[$e]++, Le = 0, Be <= He && (Le = Re[He - Be]), nt = Je[2 * He], Ae.opt_len += nt * ($e + Le), Ne && (Ae.static_len += nt * (Se[2 * He + 1] + Le)));
          if (Ge !== 0) {
            do {
              for ($e = je - 1; Ae.bl_count[$e] === 0; ) $e--;
              Ae.bl_count[$e]--, Ae.bl_count[$e + 1] += 2, Ae.bl_count[je]--, Ge -= 2;
            } while (0 < Ge);
            for ($e = je; $e !== 0; $e--) for (He = Ae.bl_count[$e]; He !== 0; ) bt < (Ye = Ae.heap[--Oe]) || (Je[2 * Ye + 1] !== $e && (Ae.opt_len += ($e - Je[2 * Ye + 1]) * Je[2 * Ye], Je[2 * Ye + 1] = $e), He--);
          }
        }(X, se), Y(he, Te, X.bl_count);
      }
      function k(X, se, z) {
        var N, K, he = -1, me = se[1], ge = 0, Me = 7, Te = 4;
        for (me === 0 && (Me = 138, Te = 3), se[2 * (z + 1) + 1] = 65535, N = 0; N <= z; N++) K = me, me = se[2 * (N + 1) + 1], ++ge < Me && K === me || (ge < Te ? X.bl_tree[2 * K] += ge : K !== 0 ? (K !== he && X.bl_tree[2 * K]++, X.bl_tree[2 * C]++) : ge <= 10 ? X.bl_tree[2 * E]++ : X.bl_tree[2 * P]++, he = K, Te = (ge = 0) === me ? (Me = 138, 3) : K === me ? (Me = 6, 3) : (Me = 7, 4));
      }
      function ne(X, se, z) {
        var N, K, he = -1, me = se[1], ge = 0, Me = 7, Te = 4;
        for (me === 0 && (Me = 138, Te = 3), N = 0; N <= z; N++) if (K = me, me = se[2 * (N + 1) + 1], !(++ge < Me && K === me)) {
          if (ge < Te) for (; ce(X, K, X.bl_tree), --ge != 0; ) ;
          else K !== 0 ? (K !== he && (ce(X, K, X.bl_tree), ge--), ce(X, C, X.bl_tree), ie(X, ge - 3, 2)) : ge <= 10 ? (ce(X, E, X.bl_tree), ie(X, ge - 3, 3)) : (ce(X, P, X.bl_tree), ie(X, ge - 11, 7));
          he = K, Te = (ge = 0) === me ? (Me = 138, 3) : K === me ? (Me = 6, 3) : (Me = 7, 4);
        }
      }
      u(re);
      var J = !1;
      function B(X, se, z, N) {
        ie(X, (d << 1) + (N ? 1 : 0), 3), function(K, he, me, ge) {
          I(K), oe(K, me), oe(K, ~me), a.arraySet(K.pending_buf, K.window, he, me, K.pending), K.pending += me;
        }(X, se, z);
      }
      o._tr_init = function(X) {
        J || (function() {
          var se, z, N, K, he, me = new Array(_ + 1);
          for (K = N = 0; K < h - 1; K++) for (G[K] = N, se = 0; se < 1 << T[K]; se++) A[N++] = K;
          for (A[N - 1] = K, K = he = 0; K < 16; K++) for (re[K] = he, se = 0; se < 1 << y[K]; se++) O[he++] = K;
          for (he >>= 7; K < v; K++) for (re[K] = he << 7, se = 0; se < 1 << y[K] - 7; se++) O[256 + he++] = K;
          for (z = 0; z <= _; z++) me[z] = 0;
          for (se = 0; se <= 143; ) U[2 * se + 1] = 8, se++, me[8]++;
          for (; se <= 255; ) U[2 * se + 1] = 9, se++, me[9]++;
          for (; se <= 279; ) U[2 * se + 1] = 7, se++, me[7]++;
          for (; se <= 287; ) U[2 * se + 1] = 8, se++, me[8]++;
          for (Y(U, p + 1, me), se = 0; se < v; se++) R[2 * se + 1] = 5, R[2 * se] = V(se, 5);
          ue = new j(U, T, m + 1, p, _), Q = new j(R, y, 0, v, _), le = new j(new Array(0), w, 0, x, S);
        }(), J = !0), X.l_desc = new $(X.dyn_ltree, ue), X.d_desc = new $(X.dyn_dtree, Q), X.bl_desc = new $(X.bl_tree, le), X.bi_buf = 0, X.bi_valid = 0, H(X);
      }, o._tr_stored_block = B, o._tr_flush_block = function(X, se, z, N) {
        var K, he, me = 0;
        0 < X.level ? (X.strm.data_type === 2 && (X.strm.data_type = function(ge) {
          var Me, Te = 4093624447;
          for (Me = 0; Me <= 31; Me++, Te >>>= 1) if (1 & Te && ge.dyn_ltree[2 * Me] !== 0) return l;
          if (ge.dyn_ltree[18] !== 0 || ge.dyn_ltree[20] !== 0 || ge.dyn_ltree[26] !== 0) return c;
          for (Me = 32; Me < m; Me++) if (ge.dyn_ltree[2 * Me] !== 0) return c;
          return l;
        }(X)), Z(X, X.l_desc), Z(X, X.d_desc), me = function(ge) {
          var Me;
          for (k(ge, ge.dyn_ltree, ge.l_desc.max_code), k(ge, ge.dyn_dtree, ge.d_desc.max_code), Z(ge, ge.bl_desc), Me = x - 1; 3 <= Me && ge.bl_tree[2 * D[Me] + 1] === 0; Me--) ;
          return ge.opt_len += 3 * (Me + 1) + 5 + 5 + 4, Me;
        }(X), K = X.opt_len + 3 + 7 >>> 3, (he = X.static_len + 3 + 7 >>> 3) <= K && (K = he)) : K = he = z + 5, z + 4 <= K && se !== -1 ? B(X, se, z, N) : X.strategy === 4 || he === K ? (ie(X, 2 + (N ? 1 : 0), 3), ee(X, U, R)) : (ie(X, 4 + (N ? 1 : 0), 3), function(ge, Me, Te, Ae) {
          var Xe;
          for (ie(ge, Me - 257, 5), ie(ge, Te - 1, 5), ie(ge, Ae - 4, 4), Xe = 0; Xe < Ae; Xe++) ie(ge, ge.bl_tree[2 * D[Xe] + 1], 3);
          ne(ge, ge.dyn_ltree, Me - 1), ne(ge, ge.dyn_dtree, Te - 1);
        }(X, X.l_desc.max_code + 1, X.d_desc.max_code + 1, me + 1), ee(X, X.dyn_ltree, X.dyn_dtree)), H(X), N && I(X);
      }, o._tr_tally = function(X, se, z) {
        return X.pending_buf[X.d_buf + 2 * X.last_lit] = se >>> 8 & 255, X.pending_buf[X.d_buf + 2 * X.last_lit + 1] = 255 & se, X.pending_buf[X.l_buf + X.last_lit] = 255 & z, X.last_lit++, se === 0 ? X.dyn_ltree[2 * z]++ : (X.matches++, se--, X.dyn_ltree[2 * (A[z] + m + 1)]++, X.dyn_dtree[2 * q(se)]++), X.last_lit === X.lit_bufsize - 1;
      }, o._tr_align = function(X) {
        ie(X, 2, 3), ce(X, b, U), function(se) {
          se.bi_valid === 16 ? (oe(se, se.bi_buf), se.bi_buf = 0, se.bi_valid = 0) : 8 <= se.bi_valid && (se.pending_buf[se.pending++] = 255 & se.bi_buf, se.bi_buf >>= 8, se.bi_valid -= 8);
        }(X);
      };
    }, { "../utils/common": 41 }], 53: [function(i, r, o) {
      r.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(i, r, o) {
      (function(a) {
        (function(l, c) {
          if (!l.setImmediate) {
            var u, d, h, m, p = 1, v = {}, x = !1, g = l.document, _ = Object.getPrototypeOf && Object.getPrototypeOf(l);
            _ = _ && _.setTimeout ? _ : l, u = {}.toString.call(l.process) === "[object process]" ? function(C) {
              n.nextTick(function() {
                S(C);
              });
            } : function() {
              if (l.postMessage && !l.importScripts) {
                var C = !0, E = l.onmessage;
                return l.onmessage = function() {
                  C = !1;
                }, l.postMessage("", "*"), l.onmessage = E, C;
              }
            }() ? (m = "setImmediate$" + Math.random() + "$", l.addEventListener ? l.addEventListener("message", b, !1) : l.attachEvent("onmessage", b), function(C) {
              l.postMessage(m + C, "*");
            }) : l.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(C) {
              S(C.data);
            }, function(C) {
              h.port2.postMessage(C);
            }) : g && "onreadystatechange" in g.createElement("script") ? (d = g.documentElement, function(C) {
              var E = g.createElement("script");
              E.onreadystatechange = function() {
                S(C), E.onreadystatechange = null, d.removeChild(E), E = null;
              }, d.appendChild(E);
            }) : function(C) {
              setTimeout(S, 0, C);
            }, _.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var E = new Array(arguments.length - 1), P = 0; P < E.length; P++) E[P] = arguments[P + 1];
              var T = { callback: C, args: E };
              return v[p] = T, u(p), p++;
            }, _.clearImmediate = M;
          }
          function M(C) {
            delete v[C];
          }
          function S(C) {
            if (x) setTimeout(S, 0, C);
            else {
              var E = v[C];
              if (E) {
                x = !0;
                try {
                  (function(P) {
                    var T = P.callback, y = P.args;
                    switch (y.length) {
                      case 0:
                        T();
                        break;
                      case 1:
                        T(y[0]);
                        break;
                      case 2:
                        T(y[0], y[1]);
                        break;
                      case 3:
                        T(y[0], y[1], y[2]);
                        break;
                      default:
                        T.apply(c, y);
                    }
                  })(E);
                } finally {
                  M(C), x = !1;
                }
              }
            }
          }
          function b(C) {
            C.source === l && typeof C.data == "string" && C.data.indexOf(m) === 0 && S(+C.data.slice(m.length));
          }
        })(typeof self > "u" ? a === void 0 ? this : a : self);
      }).call(this, typeof Cc < "u" ? Cc : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Qy);
var lH = Qy.exports;
const cH = /* @__PURE__ */ aH(lH), uH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: cH
}, Symbol.toStringTag, { value: "Module" }));
export {
  fg as mountApp,
  hH as sendToComfyUI
};
