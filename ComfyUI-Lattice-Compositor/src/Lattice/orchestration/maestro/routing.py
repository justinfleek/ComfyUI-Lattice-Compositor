"""
MAESTRO Routing - Layer 0: Basic Routing

Pure functions for intent-to-agent routing.
"""

from __future__ import annotations

import hashlib
import uuid
from typing import Optional

from .events import (
    AgentSelectedEvent,
    NoMatchEvent,
    RoutingCompletedEvent,
    RoutingRequestedEvent,
)
from .state import MaestroState, apply_event, empty_maestro_state
from .types import RoutingRequest, SelectedAgent


def make_uuid(namespace: str, content: str) -> str:
    """Generate UUID5 from namespace and content."""
    namespace_uuid = uuid.uuid5(uuid.NAMESPACE_DNS, namespace)
    return str(uuid.uuid5(namespace_uuid, content))


def generate_request_id(session_id: str, user_input: str) -> str:
    """
    Generate deterministic request ID.

    Uses UUID5 to generate a deterministic ID from request content. The same
    request content always produces the same ID, enabling idempotent routing.
    """
    content = f"routing_request:{session_id}:{user_input}"
    return make_uuid("maestro", content)


def request_routing(
    session_id: str,
    user_input: str,
    context: Optional[dict[str, str | int | float | bool | None]] = None,
    metadata: Optional[dict[str, str]] = None,
) -> tuple[RoutingRequest, RoutingRequestedEvent]:
    """
    Create a routing request and its corresponding event.

    This is a pure function with no side effects. It returns an immutable
    request and event that represent the routing request.
    """
    request_id = generate_request_id(session_id, user_input)

    request = RoutingRequest(
        request_id=request_id,
        session_id=session_id,
        user_input=user_input,
        context=context or {},
        metadata=metadata or {},
    )

    event = RoutingRequestedEvent.create(
        request_id=request_id,
        session_id=session_id,
        user_input=user_input,
        context=context,
        metadata=metadata,
    )

    return request, event


def select_best_agent(
    user_input: str,
    min_confidence: float = 0.3,
) -> Optional[SelectedAgent]:
    """
    Select the best agent for a user intent.

    This is a simplified version. In the full implementation, this would
    query the Agent Registry to find the best matching agent.

    Args:
        user_input: User's intent text
        min_confidence: Minimum confidence threshold (default 0.3)

    Returns:
        SelectedAgent if found with sufficient confidence, None otherwise
    """
    # Simplified: In full implementation, this would query agent registry
    # For now, return None to indicate no match
    # This will be expanded when agent registry is integrated
    return None


def route_to_agent(
    state: MaestroState,
    request: RoutingRequest,
    selected: Optional[SelectedAgent],
) -> tuple[MaestroState, RoutingCompletedEvent | NoMatchEvent]:
    """
    Route request to selected agent or handle no match.

    Pure function that produces events based on routing decision.
    """
    if selected is None:
        # No match found
        event = NoMatchEvent.create(
            request_id=request.request_id,
            user_input=request.user_input,
            reason="no_agents_available",
        )
        new_state = apply_event(state, event)
        return new_state, event

    # Agent selected - create selection event
    selection_event = AgentSelectedEvent.create(
        request_id=request.request_id,
        agent_id=selected.agent_id,
        agent_name=selected.agent_name,
        capability_id=selected.capability_id,
        capability_name=selected.capability_name,
        confidence=selected.confidence,
        domain=selected.domain,
    )

    # Apply selection event
    state_after_selection = apply_event(state, selection_event)

    # Create completion event
    completion_event = RoutingCompletedEvent.create(
        request_id=request.request_id,
        routing_type="direct",
        message_id=None,  # Would be generated by message bus
        correlation_id=None,  # Would be generated by message bus
        agent_id=selected.agent_id,
    )

    # Apply completion event
    final_state = apply_event(state_after_selection, completion_event)

    return final_state, completion_event


def derive_state(events: list[RoutingRequestedEvent | AgentSelectedEvent | RoutingCompletedEvent | NoMatchEvent]) -> MaestroState:
    """
    Derive MAESTRO state from a sequence of events.

    Pure function: folds events in order to produce final state.
    """
    state = empty_maestro_state()
    for event in events:
        state = apply_event(state, event)
    return state
