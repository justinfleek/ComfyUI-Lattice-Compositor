# BUG-030: getAudioAmplitudeAtFrame Division by Zero

## Summary
The `getAudioAmplitudeAtFrame` function performs linear interpolation without checking if the denominator (frame range) is zero. When two keyframes have the same frame value, division by zero produces NaN.

## Severity: MEDIUM

## Location
- File: /ui/src/stores/actions/audioActions.ts
- Lines: 673
- Function: `getAudioAmplitudeAtFrame`

## The Bug
Line 673 divides by `(nextKf.frame - prevKf.frame)` without checking for zero.

## Code Evidence
```typescript
// Lines 661-674
const prevKf = [...property.keyframes]
  .filter(k => k.frame <= frame)
  .sort((a, b) => b.frame - a.frame)[0];
const nextKf = [...property.keyframes]
  .filter(k => k.frame > frame)
  .sort((a, b) => a.frame - b.frame)[0];

// ... guards for missing keyframes ...

// Line 673 - DIVISION BY ZERO
const t = (frame - prevKf.frame) / (nextKf.frame - prevKf.frame);
//                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//                                  If both frames equal, this is 0!

return (prevKf.value as number) + t * ((nextKf.value as number) - (prevKf.value as number));
```

## Crash Path Trace
```
1. User creates keyframes at frame 10 with values 50 and 75
2. User queries getAudioAmplitudeAtFrame(store, 'both', 10)
3. Line 661-666: prevKf.frame=10, nextKf.frame=10 (or undefined path)
4. Actually, filter(k => k.frame > frame) would exclude frame=10
   So this path requires frame to fall BETWEEN two adjacent identical-frame keyframes
5. Edge case: duplicate keyframes from bug or import
6. Line 673: t = (10 - 10) / (10 - 10) = 0/0 = NaN
7. Line 674: prevKf.value + NaN * diff = NaN
8. Returns NaN -> expression returns garbage
```

## Impact
- Expressions return NaN instead of valid amplitude
- NaN propagates to animation calculations
- Silent corruption of animation output
- Can occur with duplicate keyframes from bugs or file corruption

## Suggested Fix
```typescript
// Before line 673:
const frameDiff = nextKf.frame - prevKf.frame;
if (frameDiff === 0) {
  return prevKf.value as number;  // Same frame, just return either value
}
const t = (frame - prevKf.frame) / frameDiff;
```
