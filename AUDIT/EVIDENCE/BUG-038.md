# BUG-038: NaN ImageData Dimensions Permanently Corrupt Memory Counter

## Summary
The `set()` function calculates `size = imageData.width * imageData.height * 4` without validation. If `imageData` has NaN dimensions (e.g., from a failed canvas operation), `size = NaN`, and then `this.currentMemory += NaN` permanently corrupts `currentMemory` to NaN. All subsequent memory checks and eviction logic fail.

## Severity: MEDIUM

## Location
- File: /ui/src/services/frameCache.ts
- Lines: 334, 364, 383, 417, 575
- Function: set, remove, clearComposition, ensureCapacity

## The Bug

### Size calculation with no validation
```typescript
// Line 334 - No validation of imageData dimensions
let size = imageData.width * imageData.height * 4;
// If width or height is NaN: NaN * NaN * 4 = NaN
// If width or height is Infinity: Infinity * 100 * 4 = Infinity
```

### NaN corrupts currentMemory
```typescript
// Line 364 - NaN addition corrupts counter
this.currentMemory += size;  // 0 + NaN = NaN, now currentMemory = NaN forever
```

### All subsequent operations fail
```typescript
// Line 567 - Memory check fails with NaN
this.currentMemory + requiredSize > this.config.maxMemoryBytes
// NaN + 1000 > 512MB → NaN > 512MB → false (always)
// Eviction NEVER triggers, cache grows unbounded

// Line 383, 417, 575 - Subtractions also produce NaN
this.currentMemory -= cached.size;  // NaN - anything = NaN
```

## Proof of Failure
```typescript
const cache = new FrameCache();

// Create ImageData with NaN dimensions (simulating corrupted data)
const badImageData = {
  width: NaN,
  height: 100,
  data: new Uint8ClampedArray(0)
} as ImageData;

await cache.set(0, "comp1", badImageData, "hash1");
// size = NaN * 100 * 4 = NaN
// currentMemory = 0 + NaN = NaN

// All subsequent sets never trigger eviction
for (let i = 0; i < 10000; i++) {
  const goodImageData = new ImageData(1920, 1080);  // ~8MB each
  await cache.set(i, "comp1", goodImageData, "hash1");
  // currentMemory = NaN + 8MB = NaN
  // NaN > 512MB = false → no eviction
}
// Memory grows to 80GB, browser crashes
```

## Chain Reaction
1. One bad ImageData → size = NaN
2. currentMemory becomes NaN
3. Memory check `NaN > maxMemoryBytes` always false
4. Eviction never triggers
5. Cache grows unbounded
6. Browser runs out of memory

## Impact
- Cache memory tracking permanently broken after single bad input
- No eviction occurs, unbounded memory growth
- Medium severity because requires malformed ImageData, but once triggered, catastrophic

## Suggested Fix
Validate size calculation:
```typescript
async set(frame: number, compositionId: string, imageData: ImageData, stateHash: string): Promise<void> {
  // Validate imageData dimensions
  if (!Number.isFinite(imageData.width) || !Number.isFinite(imageData.height) ||
      imageData.width <= 0 || imageData.height <= 0) {
    console.warn('Invalid imageData dimensions, skipping cache');
    return;
  }

  let size = imageData.width * imageData.height * 4;

  // Double-check size is valid
  if (!Number.isFinite(size) || size <= 0) {
    console.warn('Invalid calculated size, skipping cache');
    return;
  }

  // ... rest of function
}
```
