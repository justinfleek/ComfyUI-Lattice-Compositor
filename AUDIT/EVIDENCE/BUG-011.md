# BUG-011: Silent Data Corruption on Zero Scale

## Summary
The `fromComp()` function silently replaces a user's explicit scale value of 0 with 100, causing unexpected coordinate conversion results. This is a data integrity issue where valid user input is silently discarded.

## Severity: LOW

## Location
- File: /ui/src/services/expressions/coordinateConversion.ts
- Lines: 185-187
- Function: fromComp

## The Bug
The guard uses JavaScript's falsy coercion which treats 0 as false:

```typescript
// Lines 185-187
const sx = (scale[0] || 100) / 100;  // If scale[0] = 0, becomes 100/100 = 1
const sy = (scale[1] || 100) / 100;
const sz = (scale[2] || 100) / 100;
```

## Proof of Failure
```typescript
const transform = {
  position: [0, 0, 0],
  scale: [0, 0, 0],  // User explicitly set scale to 0 (collapse to point)
  rotation: [0, 0, 0],
  anchor: [0, 0, 0]
};

fromComp([100, 100, 100], transform);
// Expected: All coordinates should map to same point (scale 0)
// Actual: Coordinates unchanged (treated as scale 100)
```

## Impact
- User's explicit scale=0 is silently ignored
- Coordinate conversion produces wrong results
- No warning or error

## Note on `|| 1` Guards
Lines 188-190 have additional guards:
```typescript
x3 /= sx || 1;
```

These are **redundant** because:
- If scale[0] = 0 → sx = (0 || 100) / 100 = 1 (already non-zero)
- If scale[0] = NaN → sx = (NaN || 100) / 100 = 1 (already non-zero)

The `|| 1` can never trigger because `|| 100` already prevents falsy values.

## Suggested Fix
Use nullish coalescing (??) instead of logical OR (||):

```typescript
const sx = (scale[0] ?? 100) / 100;  // Only replaces undefined/null, not 0
const sy = (scale[1] ?? 100) / 100;
const sz = (scale[2] ?? 100) / 100;

// Still need div-by-zero protection:
x3 /= sx === 0 ? 1 : sx;  // Or handle scale=0 case explicitly
```

Or validate and warn:
```typescript
if (scale[0] === 0 || scale[1] === 0 || scale[2] === 0) {
  console.warn('[Expressions] Scale of 0 may produce unexpected results');
}
```

---

## Fix Applied
**Date:** 2025-12-27
**Fixed by:** Claude (Forensic Audit)

### Code Change
```typescript
// toComp (lines 114-117) - changed || to ??:
// Apply scale (BUG-011: use ?? to preserve intentional 0)
x *= (scale[0] ?? 100) / 100;
y *= (scale[1] ?? 100) / 100;
z *= (scale[2] ?? 100) / 100;

// fromComp (lines 201-210) - changed || to ?? and added warning:
// Inverse scale (BUG-011: use ?? to preserve intentional 0, || 1 guards div/0)
const sx = (scale[0] ?? 100) / 100;
const sy = (scale[1] ?? 100) / 100;
const sz = (scale[2] ?? 100) / 100;
if (sx === 0 || sy === 0 || sz === 0) {
  console.warn('[Expressions] Scale of 0 in fromComp produces undefined inverse');
}
x3 /= sx || 1;  // || 1 now actually triggers for scale=0
y3 /= sy || 1;
z3 /= sz || 1;
```

### Verification
| Input | Before | After |
|-------|--------|-------|
| scale=[0,100,100] in toComp | Treated as [100,100,100] | Collapses X to 0 ✓ |
| scale=[0,100,100] in fromComp | Treated as [100,100,100] | Warns + uses fallback ✓ |
| scale=[null,100,100] | 100 (correct) | 100 (correct) ✓ |
| scale=[50,50,50] | 0.5 each | 0.5 each ✓ |

### Pattern Used
Silent corruption - changed `||` to `??` (nullish coalescing) to preserve intentional zero values
