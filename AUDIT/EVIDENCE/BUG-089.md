# BUG-089: NestedCompLayer NaN Frame Propagation (SYSTEMIC-005)

## Summary
In NestedCompLayer.onEvaluateFrame(), the calculated nestedFrame is clamped using Math.max/min. However, Math.max/min don't catch NaN - they propagate it. If nestedFrame becomes NaN (from NaN fps or other sources), clampedFrame becomes NaN and is passed to renderComposition().

## Severity: LOW

## Location
- File: /ui/src/engine/layers/NestedCompLayer.ts
- Lines: 256-258
- Function: onEvaluateFrame

## The Bug
```typescript
// Lines 252-264 in onEvaluateFrame()
// Calculate nested frame
const nestedFrame = this.calculateNestedFrame(frame);
// If nestedFrame is NaN (from NaN in fps, stretchFactor, etc.)

// Clamp to composition bounds
const clampedFrame = Math.max(
  0,
  Math.min(nestedFrame, this.cachedComposition.settings.frameCount - 1)
);
// Math.min(NaN, 99) = NaN
// Math.max(0, NaN) = NaN
// clampedFrame = NaN!

// Request render of nested composition
this.renderTexture = this.renderContext.renderComposition(
  this.nestedCompData.compositionId,
  clampedFrame  // NaN passed to renderer!
);
```

## How NaN Reaches nestedFrame
```typescript
// Source 1: NaN parentFPS (via BUG-088)
this.parentFPS = NaN;
nestedFrame = layerFrame * stretchFactor * (childFps / NaN);  // = NaN

// Source 2: NaN in timeStretch
const timeStretch = this.layerData.timeStretch;  // NaN from corrupted data
const stretchFactor = 100 / Math.abs(timeStretch);  // 100 / NaN = NaN

// Source 3: NaN in speed map evaluation
const remappedTime = this.nestedCompEvaluator.evaluate(speedMapProp, parentFrame);
// If evaluator returns NaN (from expression error)
return Math.floor(NaN * nestedFps);  // = NaN
```

## Proof of Failure
```typescript
const layer = new NestedCompLayer(layerData);
layer.setFPS(NaN);  // BUG-088 allows this

layer.setFrameRateOverride(true, 30);
layer.evaluateFrame(100);

// calculateNestedFrame(100):
// -> nestedFrame = ... * (30 / NaN) = NaN

// onEvaluateFrame:
// -> clampedFrame = Math.max(0, Math.min(NaN, 99)) = NaN
// -> renderComposition(compId, NaN) called with NaN frame
```

## Impact
- Nested composition renders at undefined frame
- May cause render errors or undefined behavior in NestedCompRenderer
- Low severity: Requires NaN to propagate through calculation

## Related
- BUG-082, BUG-083, BUG-084: Math.max/min NaN bypass patterns
- BUG-088: NaN fps source in this file
- SYSTEMIC-005: Math.max/min Don't Catch NaN

## Suggested Fix
```typescript
protected onEvaluateFrame(frame: number): void {
  if (!this.renderContext || !this.cachedComposition) {
    return;
  }

  // Calculate nested frame
  const nestedFrame = this.calculateNestedFrame(frame);

  // Validate nestedFrame before clamping
  if (!Number.isFinite(nestedFrame)) {
    console.warn('NestedCompLayer: Invalid nestedFrame, using 0');
    nestedFrame = 0;
  }

  // Clamp to composition bounds
  const clampedFrame = Math.max(
    0,
    Math.min(nestedFrame, this.cachedComposition.settings.frameCount - 1)
  );

  // ... rest of implementation
}
```
