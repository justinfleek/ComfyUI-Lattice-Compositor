# BUG-174: DepthLayer Shader Division by Zero

## Summary
The depth visualization shader divides by (maxDepth - minDepth) without checking if they're equal. When minDepth === maxDepth, division by zero produces undefined GLSL behavior. Additionally, NaN values from expressions can be stored without validation.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/DepthLayer.ts
- Lines: 107 (shader), 217 (onUpdate)
- Functions: Shader fragmentShader, onUpdate()

## Crash Path Trace
```
Shader Code (Line 107):
  float normalizedDepth = (depth - minDepth) / (maxDepth - minDepth);

Test Cases:
  → minDepth=0.5, maxDepth=0.5:
    denominator = 0.5 - 0.5 = 0
    normalizedDepth = (depth - 0.5) / 0 = undefined (GPU-dependent)

  → minDepth=NaN:
    denominator = maxDepth - NaN = NaN
    normalizedDepth = X / NaN = NaN

Line 108: normalizedDepth = clamp(normalizedDepth, 0.0, 1.0);
  → clamp(NaN, 0.0, 1.0) = NaN in GLSL

Line 134: gl_FragColor = vec4(color, opacity);
  → color contains NaN → undefined rendering

---

Function: onUpdate(properties)

Line 217: Object.assign(this.depthData, data);
  → data.minDepth=NaN: this.depthData.minDepth = NaN
  → data.maxDepth=0.5, data.minDepth=0.5: stored directly

Line 208 (onEvaluateFrame): this.material.uniforms.minDepth.value = this.depthData.minDepth;
  → Uniform receives NaN or same value as maxDepth

Result: SILENT CORRUPTION - depth visualization produces undefined colors
```

## Code Evidence
```glsl
// Shader lines 106-108
// Normalize depth to 0-1 range
float normalizedDepth = (depth - minDepth) / (maxDepth - minDepth);  // DIV/0 if equal
normalizedDepth = clamp(normalizedDepth, 0.0, 1.0);  // clamp(NaN) = NaN
```

```typescript
// Line 217
protected onUpdate(properties: Partial<Layer>): void {
  const data = properties.data as Partial<DepthLayerData> | undefined;
  if (data) {
    Object.assign(this.depthData, data);  // NaN/equal values stored without validation
    // ...
  }
}
```

## Impact
- Expression evaluation can return NaN for minDepth/maxDepth
- User can set minDepth === maxDepth (invalid but not prevented)
- Shader produces undefined colors (black, garbage, or no output depending on GPU)
- Low severity as depth visualization is a preview feature

## Suggested Fix
```glsl
// In shader
float range = maxDepth - minDepth;
float normalizedDepth;
if (abs(range) < 0.0001) {
  normalizedDepth = 0.5; // Fallback for degenerate case
} else {
  normalizedDepth = (depth - minDepth) / range;
}
normalizedDepth = clamp(normalizedDepth, 0.0, 1.0);
```

```typescript
// In onUpdate
if (data.minDepth !== undefined || data.maxDepth !== undefined) {
  const min = data.minDepth ?? this.depthData.minDepth;
  const max = data.maxDepth ?? this.depthData.maxDepth;
  if (!Number.isFinite(min) || !Number.isFinite(max) || min >= max) {
    console.warn(`DepthLayer: invalid depth range [${min}, ${max}]`);
    return;
  }
}
```
