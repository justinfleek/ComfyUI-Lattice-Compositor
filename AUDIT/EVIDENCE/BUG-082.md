# BUG-082: NaN Opacity Bypasses Math.max/min Clamp in BaseLayer

## Summary
In BaseLayer.applyOpacity(), opacity is clamped using Math.max/min which don't catch NaN. If the evaluator or driven value produces NaN, it propagates to material.opacity, corrupting rendering.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/BaseLayer.ts
- Lines: 481-482
- Function: applyOpacity

## The Bug
```typescript
protected applyOpacity(opacity: number): void {
  const normalizedOpacity = Math.max(0, Math.min(100, opacity)) / 100;
  // If opacity is NaN:
  // Math.min(100, NaN) = NaN
  // Math.max(0, NaN) = NaN
  // NaN / 100 = NaN

  // Line 488:
  material.opacity = normalizedOpacity;  // Sets to NaN!
}
```

## Proof of Failure
```typescript
const layer = new ImageLayer(layerData);

// If expression/evaluator produces NaN
layer.drivenValues.set('opacity', NaN);
layer.evaluateFrame(0);

// Line 256: baseOpacity = NaN (from getDrivenOrBase)
// Line 259: this.applyOpacity(NaN)
// Line 482: normalizedOpacity = NaN
// Line 488: material.opacity = NaN â†’ rendering corruption
```

## Impact
- Material opacity corrupted with NaN
- Layer may become invisible or render incorrectly
- Low severity: Requires NaN from expression/evaluator (rare)

## Related: SYSTEMIC-005
Math.max/min don't catch NaN - same pattern as BUG-051, BUG-072, BUG-078.

## Suggested Fix
```typescript
protected applyOpacity(opacity: number): void {
  if (!Number.isFinite(opacity)) {
    opacity = 100;  // Default to fully opaque
  }
  const normalizedOpacity = Math.max(0, Math.min(100, opacity)) / 100;
  // ...
}
```
