# BUG-092: BaseLayer.applyOpacity() NaN Propagation

## Summary
`applyOpacity(opacity)` uses `Math.max(0, Math.min(100, opacity))` to clamp the value, but Math.max/min don't catch NaN - they propagate it. If opacity=NaN, all layer materials receive `material.opacity = NaN`.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/BaseLayer.ts
- Lines: 481-494
- Function: applyOpacity

## The Bug
```typescript
// Lines 481-494
protected applyOpacity(opacity: number): void {
  const normalizedOpacity = Math.max(0, Math.min(100, opacity)) / 100;
  // If opacity = NaN:
  // Math.min(100, NaN) = NaN
  // Math.max(0, NaN) = NaN
  // NaN / 100 = NaN

  this.group.traverse((child) => {
    if (child instanceof THREE.Mesh && child.material) {
      const material = child.material as THREE.Material & { opacity?: number };
      if ('opacity' in material) {
        material.opacity = normalizedOpacity;  // NaN assigned!
        material.transparent = normalizedOpacity < 1;  // NaN < 1 = false
        material.needsUpdate = true;
      }
    }
  });
}
```

## Proof of Failure
```typescript
const layer = new ImageLayer(layerData);

// Opacity becomes NaN through animation evaluation with corrupted keyframes
layer.applyOpacity(NaN);

// Result:
// - material.opacity = NaN
// - material.transparent = false (NaN < 1 is false)
// - Layer renders with undefined opacity behavior
```

## Impact
- Layer renders with undefined/corrupted opacity
- Visual artifacts or invisible layers
- Low severity: Requires NaN to reach applyOpacity

## Related
- SYSTEMIC-005: Math.max/min Don't Catch NaN
- BUG-089: Same pattern in NestedCompLayer

## Suggested Fix
```typescript
protected applyOpacity(opacity: number): void {
  // Validate opacity, fallback to 100 (fully opaque)
  if (!Number.isFinite(opacity)) {
    opacity = 100;
  }
  const normalizedOpacity = Math.max(0, Math.min(100, opacity)) / 100;
  // ... rest of implementation
}
```
