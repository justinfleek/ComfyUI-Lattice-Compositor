# BUG-095: BaseLayer.setParent() Circular Parenting Not Prevented

## Summary
`setParent(parent)` doesn't check if setting the parent would create a circular hierarchy. If layer A parents to layer B, and layer B parents to layer A, a circular reference is created that could cause infinite loops during transform calculation or disposal.

## Severity: MEDIUM

## Location
- File: /ui/src/engine/layers/BaseLayer.ts
- Lines: 1519-1531
- Function: setParent

## The Bug
```typescript
// Lines 1519-1531
setParent(parent: BaseLayer | null): void {
  // Remove from old parent's Three.js hierarchy
  if (this.parentLayer) {
    this.parentLayer.getObject().remove(this.group);
  }

  this.parentLayer = parent;  // NO CIRCULAR CHECK!

  // Add to new parent's Three.js hierarchy
  if (parent) {
    parent.getObject().add(this.group);
  }
}
```

## Proof of Failure
```typescript
const layerA = new ImageLayer(dataA);
const layerB = new ImageLayer(dataB);

// Create circular reference
layerA.setParent(layerB);  // A's parent is B
layerB.setParent(layerA);  // B's parent is A

// Now: A -> B -> A -> B -> A -> ...

// Scenario 1: Transform propagation
// When evaluating A's transform, needs B's world transform
// When evaluating B's transform, needs A's world transform
// -> Infinite recursion (limited by stack in Three.js)

// Scenario 2: Disposal
// Disposing A would trigger B disposal, which triggers A disposal
// -> Infinite recursion
```

## Impact
- Stack overflow during transform calculations
- Infinite loops during disposal
- Application crash
- Three.js may have internal protections, but behavior is undefined

## Related
- 14U: Composition/Nesting category
- BUG-010: Similar circular reference issue in coordinateConversion

## Suggested Fix
```typescript
setParent(parent: BaseLayer | null): void {
  // Check for self-parenting
  if (parent === this) {
    console.warn('BaseLayer.setParent: Cannot parent layer to itself');
    return;
  }

  // Check for circular parenting (parent is a descendant of this layer)
  if (parent && this.isAncestorOf(parent)) {
    console.warn('BaseLayer.setParent: Circular parenting detected');
    return;
  }

  // Remove from old parent's Three.js hierarchy
  if (this.parentLayer) {
    this.parentLayer.getObject().remove(this.group);
  }

  this.parentLayer = parent;

  // Add to new parent's Three.js hierarchy
  if (parent) {
    parent.getObject().add(this.group);
  }
}

/**
 * Check if this layer is an ancestor of the given layer
 */
private isAncestorOf(layer: BaseLayer): boolean {
  let current: BaseLayer | null = layer;
  const visited = new Set<string>();

  while (current) {
    if (visited.has(current.id)) {
      return true;  // Cycle detected
    }
    if (current === this) {
      return true;
    }
    visited.add(current.id);
    current = current.parentLayer;
  }

  return false;
}
```
