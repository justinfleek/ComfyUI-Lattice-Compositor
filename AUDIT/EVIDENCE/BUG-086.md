# BUG-086: ParticleLayer.preCacheFrames() Infinite Loop (SYSTEMIC-006)

## Summary
The preCacheFrames() async method has a for loop that iterates from startFrame to endFrame. If endFrame is Infinity (from unvalidated input), the loop never terminates, freezing the application.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/ParticleLayer.ts
- Line: 917
- Function: preCacheFrames

## The Bug
```typescript
// Lines 909-929
async preCacheFrames(
  startFrame: number,
  endFrame: number,
  onProgress?: (current: number, total: number) => void
): Promise<void> {
  const totalFrames = endFrame - startFrame + 1;  // Infinity if endFrame=Infinity

  // Line 917 - INFINITE LOOP if endFrame=Infinity!
  for (let frame = startFrame; frame <= endFrame; frame++) {
    this.particleSystem.simulateToFrame(frame, this.fps);

    if (onProgress) {
      onProgress(frame - startFrame + 1, totalFrames);
    }

    // Yield to prevent blocking UI (every 10 frames)
    if ((frame - startFrame) % 10 === 0) {
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
}
```

## Proof of Failure
```typescript
const layer = new ParticleLayer(layerData);

// If composition duration is Infinity (from malformed data)
await layer.preCacheFrames(0, Infinity);
// -> for (frame = 0; frame <= Infinity; frame++) NEVER TERMINATES

// Even though it yields every 10 frames, the loop runs forever
// Browser eventually crashes from memory exhaustion
```

## Impact
- Application hangs indefinitely
- Browser may crash from memory exhaustion
- Low severity: Requires Infinity to be passed from caller

## Related
- SYSTEMIC-006: Unbounded Loop Parameters
- BUG-012, BUG-066, BUG-068, BUG-069, BUG-076, BUG-080: Similar infinite loop patterns

## Suggested Fix
```typescript
async preCacheFrames(
  startFrame: number,
  endFrame: number,
  onProgress?: (current: number, total: number) => void
): Promise<void> {
  // Validate inputs
  if (!Number.isFinite(startFrame) || !Number.isFinite(endFrame)) {
    console.warn('preCacheFrames: Invalid frame range');
    return;
  }

  // Cap to reasonable maximum
  const maxFrames = 100000;
  const cappedEnd = Math.min(endFrame, startFrame + maxFrames);

  const totalFrames = cappedEnd - startFrame + 1;

  for (let frame = startFrame; frame <= cappedEnd; frame++) {
    // ... rest of implementation
  }
}
```
