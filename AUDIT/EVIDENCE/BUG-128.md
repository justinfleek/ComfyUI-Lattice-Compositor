# BUG-128: SolidLayer.setShadowOpacity() NaN Bypass

## Summary
The `setShadowOpacity(opacity)` method uses `Math.max(0, Math.min(100, opacity))` for clamping. However, NaN bypasses these checks and propagates to `material.opacity`.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/SolidLayer.ts
- Lines: 211-217
- Function: setShadowOpacity

## The Bug
```typescript
// Lines 211-217
setShadowOpacity(opacity: number): void {
  this.shadowOpacity = Math.max(0, Math.min(100, opacity));
  //                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // NaN bypasses! Math.max(0, Math.min(100, NaN)) = NaN

  if (this.shadowCatcher && this.material instanceof THREE.ShadowMaterial) {
    this.material.opacity = this.shadowOpacity / 100;  // NaN / 100 = NaN
    this.material.needsUpdate = true;
  }
}
```

## Proof of Failure
```typescript
const solidLayer = new SolidLayer(layerData);
solidLayer.setShadowCatcher(true);

// NaN comparison behavior:
console.log(Math.min(100, NaN));  // NaN
console.log(Math.max(0, NaN));    // NaN

// Attack: opacity = NaN
solidLayer.setShadowOpacity(NaN);
// this.shadowOpacity = NaN
// material.opacity = NaN / 100 = NaN
// Three.js ShadowMaterial with NaN opacity - undefined rendering

// Attack: opacity = Infinity
solidLayer.setShadowOpacity(Infinity);
// this.shadowOpacity = Math.max(0, Math.min(100, Infinity)) = 100
// This is actually handled correctly!

// Attack: opacity = -Infinity
solidLayer.setShadowOpacity(-Infinity);
// Math.max(0, Math.min(100, -Infinity)) = Math.max(0, -Infinity) = 0
// This is also handled correctly!
```

## Impact
- NaN opacity passed to Three.js material
- Shadow rendering may be undefined
- Low severity: Typically comes from UI slider, not direct NaN input

## Related
- BUG-082: BaseLayer.applyOpacity NaN bypass (SYSTEMIC-005)
- BUG-092: BaseLayer.applyOpacity NaN propagation
- BUG-115: TextLayer.applyOpacity NaN bypass
- SYSTEMIC-005: NaN bypass via comparison operators

## Suggested Fix
```typescript
setShadowOpacity(opacity: number): void {
  // Guard against NaN
  if (!Number.isFinite(opacity)) {
    opacity = 50;  // Default to 50%
  }

  this.shadowOpacity = Math.max(0, Math.min(100, opacity));

  if (this.shadowCatcher && this.material instanceof THREE.ShadowMaterial) {
    this.material.opacity = this.shadowOpacity / 100;
    this.material.needsUpdate = true;
  }
}
```
