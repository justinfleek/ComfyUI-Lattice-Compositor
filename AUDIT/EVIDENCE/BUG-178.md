# BUG-178: NaN Bypasses Clamp in smoothstep()

## Summary
smoothstep() divides by (edge1-edge0) without validation. When edge1=edge0, result is NaN which bypasses Math.min/max clamping.

## Severity: MEDIUM

## Location
- File: ui/src/services/expressions/expressionEvaluator.ts
- Lines: 115-118
- Function: mathExpressions.smoothstep()

## The Bug
```typescript
smoothstep(edge0: number, edge1: number, x: number): number {
  const t = mathExpressions.clamp((x - edge0) / (edge1 - edge0), 0, 1);
  return t * t * (3 - 2 * t);
}
```

When `edge1 = edge0`:
- `(x - edge0) / 0` = Infinity or -Infinity or NaN
- `clamp(NaN, 0, 1)` calls `Math.min(1, Math.max(0, NaN))`
- `Math.max(0, NaN) = NaN` (NaN is not clamped!)
- `Math.min(1, NaN) = NaN`
- Final result: NaN

## Code Evidence
```typescript
// Lines 115-118
smoothstep(edge0: number, edge1: number, x: number): number {
  const t = mathExpressions.clamp((x - edge0) / (edge1 - edge0), 0, 1);
  return t * t * (3 - 2 * t);
}

// clamp doesn't handle NaN:
clamp(value: number, min: number, max: number): number {
  return Math.min(max, Math.max(min, value));  // NaN passes through!
}
```

## Impact
- User expressions with smoothstep(5, 5, x) get NaN
- Animation interpolation breaks silently

## Suggested Fix
```typescript
smoothstep(edge0: number, edge1: number, x: number): number {
  const range = edge1 - edge0;
  if (!Number.isFinite(range) || range === 0) return x <= edge0 ? 0 : 1;
  const t = mathExpressions.clamp((x - edge0) / range, 0, 1);
  return t * t * (3 - 2 * t);
}
```
