# BUG-026: Unbounded LUT Cache Memory Leak

## Summary
The `lutCache` Map stores parsed LUT data without any size limits or eviction policy. Each unique LUT loaded is cached forever, causing unbounded memory growth if users load many different LUTs during a session.

## Severity: MEDIUM

## Location
- File: /ui/src/services/effects/colorRenderer.ts
- Lines: 1344, 1479
- Function: lutRenderer

## The Bug
```typescript
// Line 1344 - Global cache with no size limit
const lutCache = new Map<string, LUT3D>();

// Line 1479 - Adds to cache unconditionally
lutCache.set(lutData, lut);
```

Each LUT3D object contains:
- title: string
- size: number (typically 17, 33, or 65)
- domainMin/Max: [number, number, number]
- data: Float32Array of size^3 * 3 values

For a 65x65x65 LUT: 65Â³ * 3 * 4 bytes = ~3.3MB per LUT

## Proof of Failure
```typescript
// User loads 100 different LUTs during editing session
for (let i = 0; i < 100; i++) {
  const lutData = generateUniqueLUT(i);  // Different base64 each time
  lutRenderer(input, { lutData, intensity: 100 });
}

// lutCache now holds 100 LUTs
// Memory: 100 * 3.3MB = 330MB just in LUT cache
// No way to free this memory except page refresh
```

## Impact
- Memory grows unbounded during long editing sessions
- Browser may become sluggish or crash with OOM
- Affects users who experiment with many LUTs
- Medium severity because it requires many unique LUTs to trigger

## Current Mitigation
`clearLUTCache()` function exists (line 1527) but:
- Must be called manually
- No automatic eviction
- Not called anywhere in the codebase

## Suggested Fix
Implement LRU cache with size limit:

```typescript
const MAX_LUT_CACHE_SIZE = 20;  // ~66MB max
const lutCache = new Map<string, LUT3D>();
const lutAccessOrder: string[] = [];

function cacheLUT(key: string, lut: LUT3D): void {
  // Remove oldest if at capacity
  if (lutCache.size >= MAX_LUT_CACHE_SIZE && !lutCache.has(key)) {
    const oldest = lutAccessOrder.shift();
    if (oldest) lutCache.delete(oldest);
  }

  // Update access order
  const idx = lutAccessOrder.indexOf(key);
  if (idx !== -1) lutAccessOrder.splice(idx, 1);
  lutAccessOrder.push(key);

  lutCache.set(key, lut);
}
```

Or use a proper LRU cache library.
