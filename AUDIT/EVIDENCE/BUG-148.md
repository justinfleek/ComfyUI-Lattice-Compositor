# BUG-148: applyPathFollowing() t Clamp Bypassed by NaN (SYSTEMIC-005)

## Summary
applyPathFollowing() uses Math.max/min to clamp the path parameter t, but NaN bypasses this clamp. NaN t then propagates to spline queries and look-ahead calculations.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/CameraLayer.ts
- Lines: 522, 525, 536
- Function: applyPathFollowing()

## Crash Path Trace
```
Function: applyPathFollowing(frame, pathFollowing, camera)

Line 508 (if autoAdvance):
  t = (frame * pathFollowing.autoAdvanceSpeed) % 1;
  - autoAdvanceSpeed=NaN → t=NaN

Line 511 (if not autoAdvance):
  t = interpolateProperty(pathFollowing.parameter, frame, ...);
  - parameter.value=NaN → t=NaN

Line 522:
  t = Math.max(0, Math.min(1, t));
  - t=NaN → Math.min(1, NaN) = NaN → Math.max(0, NaN) = NaN
  - Clamp FAILS - NaN passes through

Line 525:
  const pathResult = this.splineProvider(pathFollowing.pathLayerId, t, frame);
  - t=NaN passed to splineProvider

Line 536:
  const lookAheadT = Math.min(1, t + pathFollowing.lookAhead);
  - t=NaN → NaN + lookAhead = NaN → Math.min(1, NaN) = NaN
  - lookAheadT=NaN passed to splineProvider

Result: SILENT CORRUPTION (SYSTEMIC-005) - NaN propagates through path calculations
```

## Code Evidence
```typescript
// Line 503-525
let t: number;

if (pathFollowing.autoAdvance) {
  t = (frame * pathFollowing.autoAdvanceSpeed) % 1;  // NaN source 1
} else {
  t = interpolateProperty(pathFollowing.parameter, frame, this.compositionFps, this.id);  // NaN source 2
}

// ... audio modifier ...

// Clamp t to valid range
t = Math.max(0, Math.min(1, t));  // FAILS for NaN

// Query spline for current position
const pathResult = this.splineProvider(pathFollowing.pathLayerId, t, frame);  // NaN passed
```

## Impact
- Camera position becomes NaN
- Camera orientation becomes NaN
- Path following completely broken
- No error message

## Suggested Fix
```typescript
// Clamp t to valid range WITH NaN check
if (!Number.isFinite(t)) {
  console.warn(`applyPathFollowing: invalid t=${t}, using 0`);
  t = 0;
} else {
  t = Math.max(0, Math.min(1, t));
}
```
