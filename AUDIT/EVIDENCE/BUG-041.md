# BUG-041: NaN/Infinity Config Values Corrupt Depthflow Rendering

## Summary
The `updateDepthflowConfig()` function uses `Object.assign()` to merge updates without validation. NaN or Infinity values in config parameters (zoom, offsetX, rotation, etc.) are stored directly and later corrupt rendering when the depthflow renderer uses them for canvas transforms.

## Severity: LOW

## Location
- File: /ui/src/stores/actions/depthflowActions.ts
- Lines: 91
- Function: updateDepthflowConfig

## The Bug
```typescript
export function updateDepthflowConfig(
  store: DepthflowStore,
  layerId: string,
  updates: Partial<DepthflowLayerData['config']>  // No validation
): void {
  const layer = store.getActiveCompLayers().find(l => l.id === layerId);
  if (!layer || layer.type !== 'depthflow') return;

  const data = layer.data as DepthflowLayerData;
  Object.assign(data.config, updates);  // Line 91 - NaN passes through!
  store.project.meta.modified = new Date().toISOString();
}
```

## Config Parameters Affected
All numeric config values can be corrupted:
- `zoom`: Used for scale transform
- `offsetX`, `offsetY`: Used for translate
- `rotation`: Used for rotate transform
- `depthScale`: Used for depth calculations
- `focusDepth`: Used for focus plane
- `dollyZoom`, `orbitRadius`, `orbitSpeed`, `swingAmplitude`, `swingFrequency`, `edgeDilation`

## Proof of Failure
```typescript
// Expression returns NaN (e.g., 0/0 or Math.sqrt(-1))
const expressionResult = evaluateExpression("0/0");  // NaN

// Update config with NaN
updateDepthflowConfig(store, layerId, { zoom: expressionResult });
// config.zoom = NaN (stored!)

// Later, in depthflow renderer:
ctx.scale(config.zoom, config.zoom);  // ctx.scale(NaN, NaN)
// Result: No visible output, canvas transform is invalid

// Or in depth calculations:
const depth = z * config.depthScale;  // z * NaN = NaN
// Result: All depth values become NaN, 3D effect breaks
```

## Chain of Corruption
1. Expression or API call produces NaN
2. NaN stored in config via `Object.assign()`
3. Renderer reads config value
4. Canvas operations with NaN produce no/corrupted output
5. User sees blank/broken depthflow layer

## Impact
- Depthflow layer renders incorrectly or not at all
- No error thrown - silent visual corruption
- Low severity because NaN values require upstream expression bug
- But expressions CAN produce NaN (e.g., division by zero, sqrt of negative)

## Suggested Fix
Validate config values before assignment:
```typescript
export function updateDepthflowConfig(
  store: DepthflowStore,
  layerId: string,
  updates: Partial<DepthflowLayerData['config']>
): void {
  const layer = store.getActiveCompLayers().find(l => l.id === layerId);
  if (!layer || layer.type !== 'depthflow') return;

  // Validate numeric values
  const validatedUpdates: Partial<DepthflowLayerData['config']> = {};
  for (const [key, value] of Object.entries(updates)) {
    if (typeof value === 'number' && !Number.isFinite(value)) {
      console.warn(`Invalid ${key} value: ${value}, ignoring`);
      continue;
    }
    validatedUpdates[key] = value;
  }

  const data = layer.data as DepthflowLayerData;
  Object.assign(data.config, validatedUpdates);
  store.project.meta.modified = new Date().toISOString();
}
```
