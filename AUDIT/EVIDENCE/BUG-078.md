# BUG-078: NaN Copies Bypasses Comparison Guard in ShapeLayer

## Summary
In ShapeLayer, the `copies` parameter for offsetPaths and repeater operators is guarded by `if (copies <= 1)`. NaN fails this comparison (`NaN <= 1` is false), allowing NaN to propagate to shape operations.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/ShapeLayer.ts
- Lines: 495, 598
- Functions: applyOperator (offsetPaths case), applyRepeater

## The Bug
```typescript
// Line 491-495 - offsetPaths
const copies = this.getAnimatedValue(offset.copies);
if (copies <= 1) {
  // This branch NOT taken when copies is NaN!
  return paths.map(p => offsetPath(p, amount, offset.lineJoin, miter));
} else {
  // NaN copies passed to offsetPathMultiple
  return paths.flatMap(p =>
    ShapeOperations.offsetPathMultiple(p, amount, copies, copyOff, offset.lineJoin, miter)
  );
}

// Line 597-598 - repeater
const copies = Math.floor(this.getAnimatedValue(repeater.copies));
// Math.floor(NaN) = NaN, NaN <= 1 is false!
if (copies <= 1) return paths;
// NaN copies passed to applyRepeater
```

JavaScript behavior:
- `NaN <= 1` → false (comparison with NaN always false)
- `Math.floor(NaN)` → NaN
- Guard is bypassed, NaN propagates

## Proof of Failure
```typescript
const shapeLayer = new ShapeLayer({
  data: {
    contents: [
      { type: 'rectangle', ... },
      {
        type: 'repeater',
        copies: { value: NaN },  // Corrupt data
        // ...
      }
    ]
  }
});

shapeLayer.evaluateFrame(0);
// Line 597: copies = Math.floor(NaN) = NaN
// Line 598: NaN <= 1 = false, guard bypassed!
// Line 608: applyRepeater(paths, NaN, ...) - undefined behavior
```

## Impact
- Shape operations receive NaN copies parameter
- Downstream functions may produce corrupted shapes or crash
- Low severity: Requires NaN in animated value (rare)

## Related: SYSTEMIC-005
NaN bypasses comparison guards - same pattern as BUG-051, BUG-072.

## Suggested Fix
```typescript
// Line 495
const copies = this.getAnimatedValue(offset.copies);
if (!Number.isFinite(copies) || copies <= 1) {
  return paths.map(p => offsetPath(p, amount, offset.lineJoin, miter));
}

// Line 597
const copies = Math.floor(this.getAnimatedValue(repeater.copies));
if (!Number.isFinite(copies) || copies <= 1) return paths;
```
