# BUG-122: AudioLayer.getAudioTimeForFrame() fps=0 Division by Zero

## Summary
The `getAudioTimeForFrame(frame, fps)` method divides by the fps parameter without validation. When fps=0, this produces Infinity, corrupting audio timing calculations and causing undefined playback behavior.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/AudioLayer.ts
- Lines: 182-186
- Function: getAudioTimeForFrame

## The Bug
```typescript
// Lines 182-186
getAudioTimeForFrame(frame: number, fps: number): number {
  const layerTime = frame / fps;  // Division by fps - if fps=0: Infinity!
  const audioTime = (layerTime - this.audioData.startTime) * this.audioData.speed;
  return Math.max(0, audioTime);
}
```

## Proof of Failure
```typescript
const audioLayer = new AudioLayer(layerData);
audioLayer.initializePlayback(audioBuffer);

// Attack: fps = 0
const audioTime = audioLayer.getAudioTimeForFrame(100, 0);
// layerTime = 100 / 0 = Infinity
// audioTime = (Infinity - startTime) * speed = Infinity
// Math.max(0, Infinity) = Infinity
// Returns: Infinity

// Used in startPlayback():
audioLayer.startPlayback(100, 0);
// audioTime = Infinity
// source.start(0, Infinity) - undefined WebAudio behavior
// May throw or play from end of buffer

// Attack: fps = NaN
audioLayer.startPlayback(100, NaN);
// layerTime = 100 / NaN = NaN
// audioTime = NaN
// source.start(0, NaN) - undefined behavior
```

## Impact
- WebAudio API receives Infinity/NaN seek positions
- Audio playback starts at wrong position or fails
- Low severity: fps typically provided by composition, not user input

## Related
- SYSTEMIC-003: Division by zero / fps=0 pattern
- 14A: Numeric inputs - 0, NaN testing

## Suggested Fix
```typescript
getAudioTimeForFrame(frame: number, fps: number): number {
  // Guard against invalid fps
  if (!Number.isFinite(fps) || fps <= 0) {
    console.warn('AudioLayer.getAudioTimeForFrame: Invalid fps');
    return 0;
  }

  const layerTime = frame / fps;
  const audioTime = (layerTime - this.audioData.startTime) * this.audioData.speed;
  return Math.max(0, audioTime);
}
```
