# BUG-112: TextLayer.setFontSize() No Validation

## Summary
The `setFontSize(size)` method accepts the size parameter without validation. Zero, negative, NaN, or Infinity values are passed directly to Troika text rendering and used as divisors in stroke width calculations, causing rendering failures or division by zero.

## Severity: MEDIUM

## Location
- File: /ui/src/engine/layers/TextLayer.ts
- Lines: 752-770
- Function: setFontSize

## The Bug
```typescript
// Lines 752-770
setFontSize(size: number): void {
  this.textData.fontSize = size;  // No validation!
  this.textMesh.fontSize = size;  // Troika receives bad value
  this.textMesh.sync();
  this.characterWidthsDirty = true;

  for (const charMesh of this.characterMeshes) {
    charMesh.fontSize = size;
    charMesh.sync();
  }

  if (this.perCharacterGroup) {
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    } else {
      this.createCharacterMeshes();
    }
  }
}
```

## Related Vulnerability
```typescript
// Line 814 in setStroke():
const outlineWidth = width > 0 ? width / this.textData.fontSize : 0;
// If fontSize was set to 0: width / 0 = Infinity
```

## Proof of Failure
```typescript
const textLayer = new TextLayer(layerData, resources);

// Attack 1: fontSize = 0
textLayer.setFontSize(0);
// this.textData.fontSize = 0
// Later, in setStroke(): outlineWidth = width / 0 = Infinity
// Troika renders nothing (0-height glyphs)

// Attack 2: fontSize = NaN
textLayer.setFontSize(NaN);
// Troika receives NaN fontSize
// All glyph calculations produce NaN
// Text disappears or renders corrupted

// Attack 3: fontSize = -50
textLayer.setFontSize(-50);
// Negative font size - undefined rendering behavior
// Glyphs may render inverted or not at all

// Attack 4: fontSize = Infinity
textLayer.setFontSize(Infinity);
// Infinite font size
// Memory exhaustion attempting to create infinitely large glyphs
// Browser may crash
```

## Impact
- Division by zero in stroke calculations (creates Infinity outlineWidth)
- Text rendering fails completely with 0/NaN/negative sizes
- Memory exhaustion with Infinity
- Medium severity: Usually set from UI with bounded values, but can come from animation interpolation

## Related
- BUG-113: setStroke division by fontSize (direct consequence)
- SYSTEMIC-003: Division by zero pattern
- 14A: Numeric inputs - 0, NaN, Infinity, negative testing

## Suggested Fix
```typescript
setFontSize(size: number): void {
  // Validate font size
  if (!Number.isFinite(size) || size <= 0) {
    console.warn('TextLayer.setFontSize: Invalid size, using 72');
    size = 72;  // Default
  }
  // Clamp to reasonable range
  size = Math.min(size, 10000);  // Reasonable max

  this.textData.fontSize = size;
  this.textMesh.fontSize = size;
  // ... rest of method
}
```
