# BUG-114: TextLayer.setPathOffset() No Validation

## Summary
The `setPathOffset(offset)` method accepts the offset parameter without validation. The expected range is 0-100 (percentage), but negative values, values >100, NaN, and Infinity are passed directly to path calculations, causing text placement issues.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/TextLayer.ts
- Lines: 865-872
- Function: setPathOffset

## The Bug
```typescript
// Lines 865-872
setPathOffset(offset: number): void {
  this.textData.pathOffset = offset;  // No validation!
  this.pathConfig.offset = offset;

  if (this.textOnPath.hasPath()) {
    this.updatePathLayout();  // Bad offset used in calculations
  }
}
```

## Proof of Failure
```typescript
const textLayer = new TextLayer(layerData, resources);
textLayer.setPathFromControlPoints(pathPoints, false);

// Attack 1: Negative offset
textLayer.setPathOffset(-50);
// Text positioned before path start
// May be off-screen or at invalid position

// Attack 2: Offset > 100
textLayer.setPathOffset(200);
// Text positioned beyond path end
// Depending on TextOnPathService, may wrap or be invisible

// Attack 3: NaN offset
textLayer.setPathOffset(NaN);
// pathConfig.offset = NaN
// Path calculations: startT = NaN / 100 = NaN
// All character positions become NaN
// Text disappears

// Attack 4: Infinity offset
textLayer.setPathOffset(Infinity);
// startT = Infinity / 100 = Infinity
// Characters positioned at Infinity
// Text disappears
```

## Impact
- Text positioned incorrectly on path
- NaN causes text to disappear completely
- Low severity: Usually set from animated slider (0-100 clamped)
- Animation interpolation could produce out-of-range values

## Related
- BUG-111: SplineLayer trim properties similar pattern
- 14A: Numeric inputs - NaN, Infinity, out-of-range testing
- 14G: Boundary conditions

## Suggested Fix
```typescript
setPathOffset(offset: number): void {
  // Validate and clamp offset
  if (!Number.isFinite(offset)) {
    console.warn('TextLayer.setPathOffset: Invalid offset');
    return;
  }
  // Clamp to valid range (though >100 could be intentional for wrapping)
  offset = Math.max(0, Math.min(200, offset));  // Allow some overflow for animation

  this.textData.pathOffset = offset;
  this.pathConfig.offset = offset;

  if (this.textOnPath.hasPath()) {
    this.updatePathLayout();
  }
}
```
