# BUG-153: Shader Division by Zoom=0

## Summary
The fragment shader divides UV coordinates by zoom uniform without checking for zero. When zoom=0 is passed via updateConfig() or animation, shader produces division by zero resulting in undefined GPU behavior.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/DepthflowLayer.ts
- Lines: 63 (shader), 297-298 (uniform setter)
- Function: depthflowFragmentShader, updateConfig()

## Crash Path Trace
```
Entry: updateConfig({ zoom: 0 })

Line 297-298:
  if (config.zoom !== undefined) {
    this.material.uniforms.zoom.value = config.zoom;  // zoom=0 stored
  }

Shader Line 63:
  vec2 zoomedUV = (vUv - 0.5) / zoom + 0.5;
    - zoom=0 â†’ division by zero
    - Result: GPU-dependent (black screen, NaN colors, driver crash)

Also triggered via:
  Line 439: this.material.uniforms.zoom.value = zoom;  // Preset zoom=0
  Line 453: this.material.uniforms.zoom.value = props['zoom'] as number;  // Evaluated zoom=0
  Line 474: this.material.uniforms.zoom.value += audioMod.depthflowZoom;  // 1 + (-1) = 0

Result: SILENT CORRUPTION - GPU behavior undefined for division by zero
```

## Code Evidence
```glsl
// Shader Lines 62-63
// Apply zoom (perspective effect - closer objects move more)
vec2 zoomedUV = (vUv - 0.5) / zoom + 0.5;  // NO validation for zoom=0
```

```typescript
// Line 297-298 - No validation
if (config.zoom !== undefined) {
  this.material.uniforms.zoom.value = config.zoom;  // zoom=0 stored to GPU
}

// Line 439 - No validation
this.material.uniforms.zoom.value = zoom;  // Preset result stored directly

// Line 474 - Additive can result in zero
if (audioMod.depthflowZoom !== undefined && audioMod.depthflowZoom !== 0) {
  this.material.uniforms.zoom.value += audioMod.depthflowZoom;  // 1 + (-1) = 0
}
```

## Impact
- GPU division by zero produces undefined results
- May cause black screen, white screen, or visual artifacts
- Some GPUs may crash or hang
- SYSTEMIC-003 applies: All zoom uniform paths lack validation

## Suggested Fix
```typescript
// Validate zoom before setting uniform
const safeZoom = Math.max(0.001, zoom);  // Never allow zero
this.material.uniforms.zoom.value = safeZoom;

// Or in shader (less efficient):
float safeZoom = max(zoom, 0.001);
vec2 zoomedUV = (vUv - 0.5) / safeZoom + 0.5;
```
