# BUG-108: SplineLayer.getPointAt/getTangentAt NaN Bypass

## Summary
The `getPointAt(t)` and `getTangentAt(t)` methods attempt to clamp the parameter `t` to [0, 1] using `Math.max(0, Math.min(1, t))`. However, if `t` is NaN, both `Math.min` and `Math.max` return NaN, allowing NaN to pass through to the curve methods.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/SplineLayer.ts
- Lines: 610-621
- Functions: getPointAt, getTangentAt

## The Bug
```typescript
// Lines 610-613
getPointAt(t: number): THREE.Vector3 | null {
  if (!this.curve) return null;
  return this.curve.getPointAt(Math.max(0, Math.min(1, t)));  // NaN passes through!
}

// Lines 618-621
getTangentAt(t: number): THREE.Vector3 | null {
  if (!this.curve) return null;
  return this.curve.getTangentAt(Math.max(0, Math.min(1, t)));  // Same bug!
}
```

## Proof of Failure
```typescript
const spline = new SplineLayer(layerData);

// NaN comparison behavior:
console.log(Math.min(1, NaN));  // NaN - NOT 1!
console.log(Math.max(0, NaN));  // NaN - NOT 0!
console.log(Math.max(0, Math.min(1, NaN)));  // NaN - passes through!

// Attack:
const point = spline.getPointAt(NaN);
// curve.getPointAt(NaN) called
// THREE.js CurvePath behavior with NaN: undefined behavior
// May return Vector3 with NaN components

const tangent = spline.getTangentAt(NaN);
// Same issue - tangent vector with NaN components

// Downstream: used in getTransformAt() for text-on-path
// Rotation calculation: Math.atan2(NaN, NaN) â†’ NaN
// Text placement completely broken
```

## Impact
- NaN propagates to curve calculations
- Vector3 results may contain NaN components
- Used by TextLayer for text-on-path placement
- Low severity: Requires explicit NaN input, most callers use valid 0-1 values

## Related
- SYSTEMIC-005: NaN bypass via comparison operators
- 14A: Numeric inputs - NaN testing
- 14T: Math edge cases

## Suggested Fix
```typescript
getPointAt(t: number): THREE.Vector3 | null {
  if (!this.curve) return null;
  if (!Number.isFinite(t)) {
    return this.curve.getPointAt(0);  // Default to start
  }
  return this.curve.getPointAt(Math.max(0, Math.min(1, t)));
}

getTangentAt(t: number): THREE.Vector3 | null {
  if (!this.curve) return null;
  if (!Number.isFinite(t)) {
    return this.curve.getTangentAt(0);  // Default to start
  }
  return this.curve.getTangentAt(Math.max(0, Math.min(1, t)));
}
```
