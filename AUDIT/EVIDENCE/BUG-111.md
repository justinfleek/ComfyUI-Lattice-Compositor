# BUG-111: SplineLayer Trim Properties No Range Validation

## Summary
The `setTrimStart()`, `setTrimEnd()`, and `setTrimOffset()` methods accept values without validating they are in expected ranges. Trim start/end expect 0-100%, but negative, >100, NaN, or Infinity values are passed directly to the `trimPath()` function causing undefined behavior.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/SplineLayer.ts
- Lines: 795-816
- Functions: setTrimStart, setTrimEnd, setTrimOffset

## The Bug
```typescript
// Lines 795-798
setTrimStart(value: number): void {
  this.trimStartProp = value;  // No validation!
  this.lastPointsHash = '';
}

// Lines 804-807
setTrimEnd(value: number): void {
  this.trimEndProp = value;  // No validation!
  this.lastPointsHash = '';
}

// Lines 813-816
setTrimOffset(value: number): void {
  this.trimOffsetProp = value;  // No validation!
  this.lastPointsHash = '';
}
```

## Proof of Failure
```typescript
const spline = new SplineLayer(layerData);

// Attack 1: Negative trim start
spline.setTrimStart(-50);
// In onEvaluateFrame: trimPath(path, -50, 100, 0)
// trimPath expects 0-100, negative may cause:
// - Negative array indices
// - Underflow in calculations
// - Path appears fully visible or corrupted

// Attack 2: Trim end > 100
spline.setTrimEnd(200);
// trimPath(path, 0, 200, 0)
// Reading beyond path length
// May wrap around or access invalid indices

// Attack 3: Start > End
spline.setTrimStart(80);
spline.setTrimEnd(20);
// trimPath(path, 80, 20, 0)
// Inverted range - undefined behavior
// Path may render backwards or not at all

// Attack 4: NaN trim values
spline.setTrimStart(NaN);
// trimPath calculations with NaN
// Path geometry becomes corrupted

// Attack 5: Infinity offset
spline.setTrimOffset(Infinity);
// Offset wraps using modulo? Infinity % 360 = NaN
// Rotation calculations fail
```

## Impact
- Path trimming produces undefined results
- Visual corruption of spline rendering
- Low severity: Usually set from UI with bounded sliders
- trimPath() from shapeOperations may have its own validation

## Related
- 14A: Numeric inputs - NaN, Infinity, negative testing
- 14G: Boundary conditions - values outside expected range
- BUG-106: Similar unbounded parameter pattern

## Suggested Fix
```typescript
setTrimStart(value: number): void {
  if (!Number.isFinite(value)) {
    console.warn('SplineLayer.setTrimStart: Invalid value');
    return;
  }
  // Clamp to valid range
  this.trimStartProp = Math.max(0, Math.min(100, value));
  this.lastPointsHash = '';
}

setTrimEnd(value: number): void {
  if (!Number.isFinite(value)) {
    console.warn('SplineLayer.setTrimEnd: Invalid value');
    return;
  }
  this.trimEndProp = Math.max(0, Math.min(100, value));
  this.lastPointsHash = '';
}

setTrimOffset(value: number): void {
  if (!Number.isFinite(value)) {
    console.warn('SplineLayer.setTrimOffset: Invalid value');
    return;
  }
  // Offset can be any angle, but normalize to reasonable range
  this.trimOffsetProp = value % 360;
  this.lastPointsHash = '';
}
```
