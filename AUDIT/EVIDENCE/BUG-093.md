# BUG-093: BaseLayer.computeMotionPath() Memory Exhaustion

## Summary
`computeMotionPath()` creates one THREE.Vector3 object per frame between start and end. For compositions with large frame counts (e.g., 1,000,000 frames for long-form content), this allocates millions of Vector3 objects, causing memory exhaustion.

## Severity: MEDIUM

## Location
- File: /ui/src/engine/layers/BaseLayer.ts
- Lines: 1586-1593
- Function: computeMotionPath

## The Bug
```typescript
// Lines 1586-1593
this.motionPathPoints = [];

for (let frame = start; frame <= end; frame++) {
  const pos = this.evaluator.evaluate(this.transform.position, frame);
  // Creates a new Vector3 for EVERY frame
  this.motionPathPoints.push(new THREE.Vector3(pos.x, -pos.y, pos.z ?? 0));
}
```

## Memory Analysis
```
Vector3 size: ~24 bytes (3 x 64-bit floats)
Array overhead: ~8 bytes per element

For 100,000 frames:
- Vector3 objects: 100,000 * 24 = 2.4 MB
- Array storage: 100,000 * 8 = 0.8 MB
- Total: ~3.2 MB

For 1,000,000 frames:
- Total: ~32 MB just for motion path

For 10,000,000 frames (long documentary):
- Total: ~320 MB for ONE layer's motion path
```

## Proof of Failure
```typescript
// User creates 2-hour composition at 60fps
// 2 hours * 60 minutes * 60 seconds * 60 fps = 432,000 frames

const layer = new ImageLayer(layerData);
layer.inPoint = 0;
layer.outPoint = 432000;  // 2 hours at 60fps

layer.setMotionPathVisible(true);
// -> computeMotionPath() called
// -> Allocates 432,000 Vector3 objects
// -> ~14 MB for ONE layer
// -> With 50 layers, ~700 MB just for motion paths
```

## Impact
- Memory exhaustion for long compositions
- Browser tab crash
- System slowdown

## Related
- BUG-091: Same function, different issue (infinite loop)

## Suggested Fix
```typescript
computeMotionPath(startFrame?: number, endFrame?: number): void {
  const start = startFrame ?? this.inPoint;
  const end = endFrame ?? this.outPoint;

  // Limit maximum points to prevent memory exhaustion
  const MAX_PATH_POINTS = 10000;
  const frameRange = end - start;

  // Sample at regular intervals if range is too large
  const step = frameRange > MAX_PATH_POINTS
    ? Math.ceil(frameRange / MAX_PATH_POINTS)
    : 1;

  this.motionPathPoints = [];
  for (let frame = start; frame <= end; frame += step) {
    const pos = this.evaluator.evaluate(this.transform.position, frame);
    this.motionPathPoints.push(new THREE.Vector3(pos.x, -pos.y, pos.z ?? 0));
  }

  this.rebuildMotionPath();
}
```
