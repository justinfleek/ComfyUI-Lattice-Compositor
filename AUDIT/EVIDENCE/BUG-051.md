# BUG-051: NaN Frame Not Caught by Math.max/min Clamping

## Summary
The `setFrame()` and `jumpFrames()` functions use `Math.max(0, Math.min(frame, frameCount - 1))` to clamp frame values. However, `Math.min(NaN, x)` returns NaN, and `Math.max(0, NaN)` also returns NaN. NaN frames propagate through and corrupt `comp.currentFrame`.

## Severity: LOW

## Location
- File: /ui/src/stores/actions/playbackActions.ts
- Lines: 66, 133
- Functions: setFrame, jumpFrames

## The Bug
```typescript
// setFrame() - Line 66
export function setFrame(store: PlaybackStore, frame: number): void {
  const comp = store.getActiveComp();
  if (!comp) return;

  // Line 66 - Math operations don't catch NaN
  const newFrame = Math.max(0, Math.min(frame, comp.settings.frameCount - 1));
  // If frame = NaN:
  //   Math.min(NaN, 80) = NaN
  //   Math.max(0, NaN) = NaN
  //   newFrame = NaN

  // ...
  comp.currentFrame = newFrame;  // Line 75 - NaN stored!
}

// jumpFrames() - Line 133
export function jumpFrames(store: PlaybackStore, n: number): void {
  const comp = store.getActiveComp();
  if (!comp) return;

  // Line 133 - Same issue
  const newFrame = Math.max(0, Math.min(comp.currentFrame + n, comp.settings.frameCount - 1));
  // If n = NaN:
  //   currentFrame + NaN = NaN
  //   Math.min(NaN, 80) = NaN
  //   Math.max(0, NaN) = NaN

  // ...
  comp.currentFrame = newFrame;  // NaN stored!
}
```

## Proof of Failure
```typescript
// Set frame to NaN
setFrame(store, NaN);
// newFrame = Math.max(0, Math.min(NaN, 80))
//          = Math.max(0, NaN)
//          = NaN
// comp.currentFrame = NaN

// Now all frame-dependent operations fail:
nextFrame(store);
// if (NaN < 80 - 1) → if (false) → no increment
// currentFrame stays NaN

prevFrame(store);
// if (NaN > 0) → if (false) → no decrement
// currentFrame stays NaN

// Timeline rendering fails - can't render frame NaN
// Playback fails - can't calculate next frame from NaN
```

## Two Vectors for NaN
1. `frame` parameter is NaN directly
2. `comp.settings.frameCount` is NaN/undefined → `NaN - 1 = NaN`

## Impact
- Timeline becomes unusable after NaN frame
- Playback fails
- Rendering fails
- Low severity because NaN requires upstream bug

## Suggested Fix
Validate frame before using:
```typescript
export function setFrame(store: PlaybackStore, frame: number): void {
  const comp = store.getActiveComp();
  if (!comp) return;

  // Validate frame
  if (!Number.isFinite(frame)) {
    console.warn('setFrame: Invalid frame number', frame);
    return;
  }

  const newFrame = Math.max(0, Math.min(frame, comp.settings.frameCount - 1));
  // ... rest of function
}
```

Or use Number.isNaN check with fallback:
```typescript
const newFrame = Number.isNaN(frame)
  ? comp.currentFrame  // Keep current if NaN
  : Math.max(0, Math.min(frame, comp.settings.frameCount - 1));
```
