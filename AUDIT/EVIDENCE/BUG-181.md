# BUG-181: Math.max Doesn't Protect Against NaN in gaussRandom()

## Summary
gaussRandom() attempts to clamp u1 with Math.max(0.0001, ...) but Math.max returns NaN when any argument is NaN, defeating the protection.

## Severity: MEDIUM

## Location
- File: ui/src/services/expressions/expressionEvaluator.ts
- Lines: 153-162
- Function: mathExpressions.gaussRandom()

## The Bug
```typescript
gaussRandom(mean: number = 0, stdDev: number = 1, seed: number = 12345): number {
  const seededRand = (s: number) => {
    const x = Math.sin(s * 12.9898) * 43758.5453;
    return x - Math.floor(x);
  };
  const u1 = Math.max(0.0001, seededRand(seed));  // FAILS if seededRand returns NaN
  const u2 = seededRand(seed + 1);
  const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  return mean + z0 * stdDev;
}
```

**Crash Path with seed=NaN:**
1. `seededRand(NaN)`:
   - `Math.sin(NaN * 12.9898)` = `Math.sin(NaN)` = NaN
   - `NaN * 43758.5453` = NaN
   - `NaN - Math.floor(NaN)` = `NaN - NaN` = NaN
   - Returns NaN
2. `Math.max(0.0001, NaN)` = NaN (Math.max with ANY NaN returns NaN!)
3. `u1 = NaN`
4. `Math.log(NaN)` = NaN
5. `Math.sqrt(-2 * NaN)` = `Math.sqrt(NaN)` = NaN
6. `NaN * Math.cos(...)` = NaN
7. `mean + NaN * stdDev` = NaN
8. Returns NaN

**Why Math.max doesn't protect:**
```javascript
Math.max(0.0001, NaN)  // Returns NaN, not 0.0001!
Math.max(NaN, 0.0001)  // Returns NaN
Math.max(5, NaN, 10)   // Returns NaN
```

## Code Evidence
```typescript
// Lines 153-162
gaussRandom(mean: number = 0, stdDev: number = 1, seed: number = 12345): number {
  const seededRand = (s: number) => {
    const x = Math.sin(s * 12.9898) * 43758.5453;
    return x - Math.floor(x);
  };
  const u1 = Math.max(0.0001, seededRand(seed));  // Bug: NaN not caught
  const u2 = seededRand(seed + 1);
  const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  return mean + z0 * stdDev;
}
```

## Impact
- Expression `random.gauss(0, 1, NaN)` returns NaN
- Procedural generation with corrupted seed fails silently
- Animation jitter/noise becomes NaN

## Test Cases
```javascript
mathExpressions.gaussRandom(0, 1, NaN)       // Returns NaN
mathExpressions.gaussRandom(NaN, 1, 12345)   // Returns NaN
mathExpressions.gaussRandom(0, NaN, 12345)   // Returns NaN
mathExpressions.gaussRandom(0, 1, Infinity)  // Returns NaN (sin(Infinity) = NaN)
```

## Suggested Fix
```typescript
gaussRandom(mean: number = 0, stdDev: number = 1, seed: number = 12345): number {
  // Validate all inputs
  if (!Number.isFinite(mean)) mean = 0;
  if (!Number.isFinite(stdDev)) stdDev = 1;
  if (!Number.isFinite(seed)) seed = 12345;

  const seededRand = (s: number) => {
    const x = Math.sin(s * 12.9898) * 43758.5453;
    const result = x - Math.floor(x);
    return Number.isFinite(result) ? result : 0.5;
  };
  const u1Raw = seededRand(seed);
  const u1 = Number.isFinite(u1Raw) ? Math.max(0.0001, u1Raw) : 0.5;
  const u2 = seededRand(seed + 1);
  const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  return mean + z0 * stdDev;
}
```
