# BUG-168: ProceduralMatteLayer.renderPattern() Division by compositionFps=0

## Summary
renderPattern() divides frame number by compositionFps to calculate animation time. When fps=0, this produces Infinity or NaN, corrupting all animated matte patterns.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/ProceduralMatteLayer.ts
- Lines: 186
- Function: renderPattern()

## Crash Path Trace
```
Function: renderPattern(frame: number)

Line 186:
  const time = this.matteData.animation.enabled ? (frame * speed / this.compositionFps + phase) : 0;

Test cases:
  - compositionFps=0, frame=30, speed=1:
    - 30 * 1 / 0 = Infinity
    - time = Infinity + phase = Infinity

  - compositionFps=0, frame=0, speed=1:
    - 0 * 1 / 0 = NaN (0/0)
    - time = NaN + phase = NaN

Downstream effects (time passed to pattern renderers):
  - Line 250: angle + time * 360 = angle + Infinity = Infinity
  - Line 280: radius + time * 0.5 = radius + Infinity = Infinity
  - Line 299: rotation + time * 360 = Infinity
  - All animated patterns receive corrupted time values

Result: SILENT CORRUPTION (SYSTEMIC-003) - all animated patterns produce garbage
```

## Code Evidence
```typescript
// Line 186
const time = this.matteData.animation.enabled
  ? (frame * speed / this.compositionFps + phase)  // DIV/0 if fps=0
  : 0;

// Line 250 - example downstream usage
const angle: number = this.matteEvaluator.evaluate(params.angle!, frame) + time * 360;
// If time=Infinity: angle = Infinity â†’ Math.cos(Infinity) = NaN
```

## Impact
- All animated matte patterns fail when fps=0
- Gradient angles become NaN (Math.cos/sin fail)
- Radii become Infinity (oversized patterns)
- SYSTEMIC-003: fps=0 division pattern
- Composition can have fps=0 during initialization or misconfiguration

## Suggested Fix
```typescript
const fps = this.compositionFps || 30;  // Default to 30 if zero
const time = this.matteData.animation.enabled
  ? (frame * speed / fps + phase)
  : 0;
```
