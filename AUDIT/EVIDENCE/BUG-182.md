# BUG-182: NaN Bypasses Normalization in expressionEase()

## Summary
expressionEase() divides by (tMax - tMin) without validation. NaN inputs bypass the Math.max/min clamping and propagate to output.

## Severity: MEDIUM

## Location
- File: ui/src/services/expressions/expressionEvaluator.ts
- Lines: 173-192
- Function: expressionEase()

## The Bug
```typescript
export function expressionEase(
  t: number,
  tMin: number,
  tMax: number,
  vMin: number | number[],
  vMax: number | number[]
): number | number[] {
  let normalized = (t - tMin) / (tMax - tMin);  // div/0 possible!
  normalized = Math.max(0, Math.min(1, normalized));  // NaN not clamped!
  // ...
}
```

**Crash Path with tMin = tMax:**
1. `(t - tMin) / (tMax - tMin)` = `(t - tMin) / 0`
2. If `t = tMin`: `0 / 0` = NaN
3. If `t > tMin`: `positive / 0` = Infinity
4. If `t < tMin`: `negative / 0` = -Infinity
5. `Math.max(0, Math.min(1, NaN))` = NaN (NaN not clamped)
6. `Math.max(0, Math.min(1, Infinity))` = 1 (OK)
7. `Math.max(0, Math.min(1, -Infinity))` = 0 (OK)

**But NaN is the dangerous case:**
- User sets keyframe at same time twice
- `ease(5, 5, 5, 0, 100)` â†’ NaN

**Crash Path with NaN inputs:**
1. `t = NaN`: `(NaN - tMin) / (tMax - tMin)` = NaN / number = NaN
2. `tMin = NaN`: `(t - NaN) / (tMax - NaN)` = NaN / NaN = NaN
3. Math.max/min don't clamp NaN
4. Returns NaN

## Code Evidence
```typescript
// Lines 173-192
export function expressionEase(
  t: number,
  tMin: number,
  tMax: number,
  vMin: number | number[],
  vMax: number | number[]
): number | number[] {
  let normalized = (t - tMin) / (tMax - tMin);
  normalized = Math.max(0, Math.min(1, normalized));

  const eased = normalized < 0.5
    ? 4 * normalized * normalized * normalized
    : 1 - Math.pow(-2 * normalized + 2, 3) / 2;

  if (Array.isArray(vMin) && Array.isArray(vMax)) {
    return vMin.map((v, i) => v + (vMax[i] - v) * eased);
  }

  return (vMin as number) + ((vMax as number) - (vMin as number)) * eased;
}
```

## Impact
- Core easing function used throughout animation system
- NaN corrupts interpolated values
- Keyframes at same time cause rendering failures

## Test Cases
```javascript
expressionEase(5, 5, 5, 0, 100)     // Returns NaN (tMin = tMax)
expressionEase(NaN, 0, 10, 0, 100) // Returns NaN
expressionEase(5, NaN, 10, 0, 100) // Returns NaN
expressionEase(5, 0, 10, NaN, 100) // Returns NaN (vMin corrupts output)
```

## Suggested Fix
```typescript
export function expressionEase(
  t: number,
  tMin: number,
  tMax: number,
  vMin: number | number[],
  vMax: number | number[]
): number | number[] {
  // Validate inputs
  if (!Number.isFinite(t) || !Number.isFinite(tMin) || !Number.isFinite(tMax)) {
    return vMin;  // Return start value on invalid input
  }

  const range = tMax - tMin;
  if (range === 0) {
    // No time range - return end value if at/past tMin, start otherwise
    return t >= tMin ? vMax : vMin;
  }

  let normalized = (t - tMin) / range;
  normalized = Math.max(0, Math.min(1, normalized));

  const eased = normalized < 0.5
    ? 4 * normalized * normalized * normalized
    : 1 - Math.pow(-2 * normalized + 2, 3) / 2;

  if (Array.isArray(vMin) && Array.isArray(vMax)) {
    return vMin.map((v, i) => {
      const vStart = Number.isFinite(v) ? v : 0;
      const vEnd = Number.isFinite(vMax[i]) ? vMax[i] : vStart;
      return vStart + (vEnd - vStart) * eased;
    });
  }

  const vStart = Number.isFinite(vMin as number) ? (vMin as number) : 0;
  const vEnd = Number.isFinite(vMax as number) ? (vMax as number) : vStart;
  return vStart + (vEnd - vStart) * eased;
}
```
