# BUG-045: Division by Zero in insertKeyframeOnPath

## Summary
The `insertKeyframeOnPath()` function calculates interpolation parameter `t` using division by `(after.frame - before.frame)`. When two consecutive keyframes have the same frame number (can happen after editing), this produces division by zero.

## Severity: LOW

## Location
- File: /ui/src/stores/actions/keyframeActions.ts
- Lines: 958
- Function: insertKeyframeOnPath

## The Bug
```typescript
export function insertKeyframeOnPath(
  store: KeyframeStore,
  layerId: string,
  frame: number
): string | null {
  // ...

  // Find surrounding keyframes
  const { before, after } = findSurroundingKeyframes(positionProp, frame);
  if (!before || !after) return null;

  // Line 958 - Division by zero when frames are equal
  const t = (frame - before.frame) / (after.frame - before.frame);
  // If before.frame === after.frame:
  // denominator = 0
  // t = (frame - X) / 0 = Infinity or -Infinity or NaN

  const beforeVal = before.value as { x: number; y: number; z?: number };
  const afterVal = after.value as { x: number; y: number; z?: number };

  // Line 962-966 - Interpolation with Infinity t
  const interpolatedValue = {
    x: beforeVal.x + (afterVal.x - beforeVal.x) * t,  // NaN or Infinity
    y: beforeVal.y + (afterVal.y - beforeVal.y) * t,  // NaN or Infinity
    z: (beforeVal.z ?? 0) + ((afterVal.z ?? 0) - (beforeVal.z ?? 0)) * t  // NaN or Infinity
  };

  // Creates keyframe with NaN/Infinity position values
  const newKf = addKeyframe(store, layerId, 'transform.position', interpolatedValue, frame);
  // ...
}
```

## Proof of Failure
```typescript
// Scenario: Two keyframes at same frame (can happen via data corruption or import)
const property = {
  keyframes: [
    { frame: 0, value: { x: 0, y: 0 } },
    { frame: 10, value: { x: 100, y: 100 } },  // before
    { frame: 10, value: { x: 200, y: 200 } },  // after (same frame!)
    { frame: 20, value: { x: 300, y: 300 } }
  ]
};

insertKeyframeOnPath(store, layerId, 10);
// findSurroundingKeyframes returns keyframes at frame 10
// before.frame = 10, after.frame = 10
// t = (10 - 10) / (10 - 10) = 0 / 0 = NaN

// interpolatedValue = {
//   x: 100 + (200 - 100) * NaN = NaN,
//   y: 100 + (200 - 100) * NaN = NaN
// }

// Creates keyframe with NaN position â†’ rendering corrupted
```

## How Same-Frame Keyframes Occur
1. Project file corruption during save
2. Import from external format with duplicate times
3. Rounding errors when scaling keyframe timing
4. Manual editing of project JSON

## Impact
- New keyframe created with NaN/Infinity position
- Layer position becomes corrupted
- Motion path rendering fails
- Low severity because requires same-frame keyframes (edge case)

## Suggested Fix
Check for zero denominator:
```typescript
const frameDelta = after.frame - before.frame;
if (frameDelta === 0) {
  // Keyframes at same frame - use before value or return null
  storeLogger.warn('insertKeyframeOnPath: Surrounding keyframes have same frame');
  return null;
}
const t = (frame - before.frame) / frameDelta;
```
