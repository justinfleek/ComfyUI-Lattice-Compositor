# BUG-170: ProceduralMatteLayer Pattern Renderers Division by Zero

## Summary
Multiple pattern rendering methods divide by user-controllable parameters (tilesX, tilesY, slats, blockSize). When these are zero, division by zero produces Infinity, causing infinite loops or memory exhaustion.

## Severity: MEDIUM

## Location
- File: /ui/src/engine/layers/ProceduralMatteLayer.ts
- Lines: 390-391 (checkerboard), 524 (venetianBlinds), 550-551 (dissolve)
- Functions: renderCheckerboard(), renderVenetianBlinds(), renderDissolve()

## Crash Path Trace
```
Function: renderCheckerboard()

Line 386-387:
  const tilesX: number = params.tilesX ? this.matteEvaluator.evaluate(params.tilesX, frame) : 8;
  const tilesY: number = params.tilesY ? this.matteEvaluator.evaluate(params.tilesY, frame) : 8;

Line 390-391:
  const tileW = w / tilesX;  // tilesX=0 → tileW=Infinity
  const tileH = h / tilesY;  // tilesY=0 → tileH=Infinity

Line 399-400:
  for (let y = -1; y <= tilesY + 1; y++) {    // tilesY=0 → loops -1 to 1
    for (let x = -1; x <= tilesX + 1; x++) {  // tilesX=0 → loops -1 to 1
      ctx.fillRect(x * tileW, y * tileH, tileW, tileH);  // fillRect with Infinity
    }
  }
  - Canvas fillRect with Infinity dimensions → undefined behavior

---

Function: renderVenetianBlinds()

Line 520:
  const slats = params.slats ? this.matteEvaluator.evaluate(params.slats, frame) : 10;

Line 524:
  const slatHeight = h / slats;  // slats=0 → slatHeight=Infinity

Line 532:
  for (let i = 0; i < slats; i++) {  // slats=0 → loop doesn't run (safe)
    ctx.fillRect(0, i * slatHeight, w, openAmount);
  }
  - Loop doesn't run when slats=0, but slatHeight=Infinity is still calculated

---

Function: renderDissolve()

Line 543:
  const blockSize = params.blockSize ? this.matteEvaluator.evaluate(params.blockSize, frame) : 4;

Line 550-551:
  const blocksX = Math.ceil(w / blockSize);  // blockSize=0 → w/0=Infinity → Infinity
  const blocksY = Math.ceil(h / blockSize);  // blockSize=0 → h/0=Infinity → Infinity

Line 553-554:
  for (let by = 0; by < blocksY; by++) {      // INFINITE LOOP
    for (let bx = 0; bx < blocksX; bx++) {    // INFINITE LOOP
      // Process block...
    }
  }

Result: INFINITE LOOP - browser freezes, tab crashes
```

## Code Evidence
```typescript
// renderCheckerboard() - Lines 390-391
const tileW = w / tilesX;  // No validation
const tileH = h / tilesY;  // No validation

// renderVenetianBlinds() - Line 524
const slatHeight = h / slats;  // No validation

// renderDissolve() - Lines 550-551
const blocksX = Math.ceil(w / blockSize);  // blockSize=0 → Infinity
const blocksY = Math.ceil(h / blockSize);  // blockSize=0 → Infinity
```

## Impact
- **renderDissolve with blockSize=0**: INFINITE LOOP → browser freeze
- **renderCheckerboard with tiles=0**: Canvas fillRect with Infinity → undefined
- User can animate blockSize/tiles to zero, triggering crash
- This is the most severe bug in this file - can freeze the application

## Suggested Fix
```typescript
// renderCheckerboard
const tilesX = Math.max(1, params.tilesX ? ... : 8);
const tilesY = Math.max(1, params.tilesY ? ... : 8);

// renderVenetianBlinds
const slats = Math.max(1, params.slats ? ... : 10);

// renderDissolve
const blockSize = Math.max(1, params.blockSize ? ... : 4);
```
