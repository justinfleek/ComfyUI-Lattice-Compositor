# BUG-180: Division by Zero in mod()

## Summary
The mod() function implements modulo but doesn't validate divisor, causing NaN when b=0.

## Severity: MEDIUM

## Location
- File: ui/src/services/expressions/expressionEvaluator.ts
- Lines: 125-127
- Function: mathExpressions.mod()

## The Bug
```typescript
mod(a: number, b: number): number {
  return ((a % b) + b) % b;
}
```

**Crash Path with b=0:**
1. `a % 0` = NaN (JavaScript spec: any number mod 0 = NaN)
2. `NaN + 0` = NaN
3. `NaN % 0` = NaN
4. Returns NaN

**Crash Path with b=NaN:**
1. `a % NaN` = NaN
2. `NaN + NaN` = NaN
3. `NaN % NaN` = NaN
4. Returns NaN

**Edge case with b=Infinity:**
1. `a % Infinity` = a (for finite a)
2. `a + Infinity` = Infinity
3. `Infinity % Infinity` = NaN
4. Returns NaN (unexpected!)

## Code Evidence
```typescript
// Lines 125-127
mod(a: number, b: number): number {
  return ((a % b) + b) % b;
}
```

## Why This Pattern Exists
This is a "proper" modulo that handles negative numbers correctly:
- JavaScript `%` is remainder, not modulo
- `-5 % 3` = -2 in JS, but mathematically should be 1
- `(((-5) % 3) + 3) % 3` = `((-2) + 3) % 3` = `1 % 3` = 1 âœ“

But it doesn't handle edge cases.

## Impact
- Expression `mod(frame, 0)` returns NaN
- Used for cycling animations, wrap-around effects
- NaN corrupts animation state

## Test Cases
```javascript
mathExpressions.mod(5, 0)        // Returns NaN, should return 0 or throw
mathExpressions.mod(5, NaN)      // Returns NaN
mathExpressions.mod(NaN, 3)      // Returns NaN
mathExpressions.mod(5, Infinity) // Returns NaN (unexpected!)
mathExpressions.mod(-5, 3)       // Returns 1 (correct)
```

## Suggested Fix
```typescript
mod(a: number, b: number): number {
  if (!Number.isFinite(a) || !Number.isFinite(b) || b === 0) return 0;
  return ((a % b) + b) % b;
}
```
