# BUG-077: Division by Zero in ProceduralMatteLayer Levels (inputRange=0)

## Summary
In ProceduralMatteLayer.applyLevels(), when inputWhite equals inputBlack, inputRange becomes 0, causing division by zero and NaN propagation through all pixel values.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/ProceduralMatteLayer.ts
- Lines: 644, 651
- Function: applyLevels

## The Bug
```typescript
// Line 644
const inputRange = inputWhite - inputBlack;

// Line 651
value = Math.max(0, Math.min(255, (value - inputBlack) / inputRange * 255));
// If inputRange = 0, this produces NaN!
```

When inputWhite === inputBlack (e.g., both 128):
- `inputRange = 128 - 128 = 0`
- `(value - 128) / 0 = Infinity or -Infinity`
- `Math.max(0, Math.min(255, Infinity)) = 255` or with NaN → NaN

## Proof of Failure
```typescript
const matteLayer = new ProceduralMatteLayer({
  data: {
    // ...
    levels: {
      inputBlack: { value: 128 },
      inputWhite: { value: 128 },  // Same as inputBlack!
      gamma: { value: 1 },
      outputBlack: { value: 0 },
      outputWhite: { value: 255 },
    },
  }
});

matteLayer.evaluateFrame(0);
// Line 644: inputRange = 0
// Line 651: (128 - 128) / 0 = NaN
// All pixels become NaN → canvas corruption
```

## Impact
- Canvas output corrupted with NaN pixel values
- Pattern unusable as matte
- Low severity: Requires inputWhite === inputBlack

## Related: BUG-025
Same pattern in effects/levels.ts - division by inputRange without validation.

## Suggested Fix
```typescript
const inputRange = inputWhite - inputBlack;
if (inputRange === 0) {
  // All input values collapse to single output
  for (let i = 0; i < data.length; i += 4) {
    data[i] = data[i + 1] = data[i + 2] = outputBlack;
  }
  this.renderCtx.putImageData(imageData, 0, 0);
  return;
}
```
