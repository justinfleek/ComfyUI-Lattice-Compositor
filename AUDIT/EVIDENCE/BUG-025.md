# BUG-025: Levels Effect NaN When inputWhite Equals inputBlack

## Summary
The `levelsRenderer()` function divides by `inputRange = inputWhite - inputBlack`. When both values are equal, `inputRange = 0` causes division by zero for the exact input value, producing NaN which becomes 0 instead of the expected output level.

## Severity: LOW

## Location
- File: /ui/src/services/effects/colorRenderer.ts
- Lines: 273-288
- Function: levelsRenderer

## The Bug
```typescript
const inputRange = inputWhite - inputBlack;  // If both equal, inputRange = 0

for (let i = 0; i < 256; i++) {
  let value = (i - inputBlack) / inputRange;  // Division by inputRange
  // For i === inputBlack: (0) / 0 = NaN
  // For i > inputBlack: positive / 0 = +Infinity → clamped to 1
  // For i < inputBlack: negative / 0 = -Infinity → clamped to 0

  value = Math.max(0, Math.min(1, value));  // NaN stays NaN
  value = Math.pow(value, 1 / gamma);        // Math.pow(NaN, x) = NaN
  value = outputBlack + value * outputRange; // NaN propagates
  lut[i] = Math.round(value);                // Math.round(NaN) = NaN → 0 in Uint8Array
}
```

## Proof of Failure
```typescript
const params = {
  input_black: 128,
  input_white: 128,  // Same as input_black!
  output_black: 0,
  output_white: 255
};

levelsRenderer(input, params);
// Expected: Pixels < 128 → 0, Pixels >= 128 → 255 (threshold effect)
// Actual: Pixels < 128 → 0, Pixels > 128 → 255, Pixels === 128 → 0 (WRONG!)

// A pixel with value 128 should become either 0 or 255, not 0 specifically
// This causes a dark artifact at exactly the threshold value
```

## Impact
- Pixels exactly at the threshold value become 0 (black) instead of expected output
- Creates subtle visual artifacts when using levels as a threshold
- Low severity because it only affects exact-match pixel values
- Edge case where user sets identical input black/white values

## Suggested Fix
Guard against zero range:
```typescript
const inputRange = inputWhite - inputBlack;
if (inputRange === 0) {
  // Treat as threshold: below = outputBlack, at/above = outputWhite
  for (let i = 0; i < 256; i++) {
    lut[i] = i >= inputBlack ? outputWhite : outputBlack;
  }
} else {
  // Normal levels calculation
  for (let i = 0; i < 256; i++) {
    let value = (i - inputBlack) / inputRange;
    // ... rest of calculation
  }
}
```
