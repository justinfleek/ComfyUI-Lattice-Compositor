# BUG-047: clearAudio Doesn't Dispose audioReactiveMapper

## Summary
The `clearAudio` function resets audio state but doesn't dispose the `audioReactiveMapper` instance. If AudioReactiveMapper holds resources (event listeners, timers, etc.), they leak when audio is cleared.

## Severity: MEDIUM

## Location
- File: /ui/src/stores/actions/audioActions.ts
- Lines: 118-124
- Function: `clearAudio`

## The Bug
The function clears references but doesn't call dispose() on the mapper.

## Code Evidence
```typescript
// Lines 118-124
export function clearAudio(store: AudioStore): void {
  cancelAudioLoad(store);
  store.audioFile = null;
  store.audioBuffer = null;
  store.audioAnalysis = null;
  store.audioMappings.clear();
  // Missing: store.audioReactiveMapper?.dispose();
  // Missing: store.audioReactiveMapper = null;
}
```

## Related: initializeAudioReactiveMapper
```typescript
// Lines 269-283
export function initializeAudioReactiveMapper(store: AudioStore): void {
  if (!store.audioAnalysis) return;

  // Creates new mapper WITHOUT disposing old one
  store.audioReactiveMapper = new AudioReactiveMapper(store.audioAnalysis);
  // ...
}
```

## Crash Path Trace
```
1. User loads audio file A
2. initializeAudioReactiveMapper() creates mapper instance #1
3. User clears audio via clearAudio()
4. audioFile, audioBuffer, audioAnalysis set to null
5. audioReactiveMapper still references instance #1 (not disposed)
6. User loads audio file B
7. initializeAudioReactiveMapper() creates mapper instance #2
8. Instance #1 is orphaned - if it has listeners, they're never removed
9. Repeat N times -> N orphaned mappers leaking resources
```

## Impact
- Memory leak (orphaned mapper instances)
- Potential event listener leaks
- Performance degradation over time
- May cause unexpected behavior if old mapper responds to events

## Suggested Fix
```typescript
export function clearAudio(store: AudioStore): void {
  cancelAudioLoad(store);
  store.audioFile = null;
  store.audioBuffer = null;
  store.audioAnalysis = null;
  store.audioMappings.clear();
  
  // BUG-047 FIX: Dispose mapper before clearing
  if (store.audioReactiveMapper?.dispose) {
    store.audioReactiveMapper.dispose();
  }
  store.audioReactiveMapper = null;
}
```

Also fix initializeAudioReactiveMapper:
```typescript
export function initializeAudioReactiveMapper(store: AudioStore): void {
  if (!store.audioAnalysis) return;

  // BUG-047 FIX: Dispose existing mapper first
  if (store.audioReactiveMapper?.dispose) {
    store.audioReactiveMapper.dispose();
  }

  store.audioReactiveMapper = new AudioReactiveMapper(store.audioAnalysis);
  // ...
}
```
