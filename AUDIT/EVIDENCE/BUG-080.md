# BUG-080: Infinite Loop in computeMotionPath When outPoint is Infinity

## Summary
In BaseLayer.computeMotionPath(), the loop iterates from start frame to end frame. If outPoint is Infinity (from corrupt project data), the loop runs forever.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/BaseLayer.ts
- Line: 1589
- Function: computeMotionPath

## The Bug
```typescript
// Lines 1582-1596
computeMotionPath(startFrame?: number, endFrame?: number): void {
  const start = startFrame ?? this.inPoint;
  const end = endFrame ?? this.outPoint;  // outPoint could be Infinity!

  this.motionPathPoints = [];

  // Sample position at each frame
  for (let frame = start; frame <= end; frame++) {  // Infinite if end = Infinity!
    const pos = this.evaluator.evaluate(this.transform.position, frame);
    this.motionPathPoints.push(new THREE.Vector3(pos.x, -pos.y, pos.z ?? 0));
  }
  // ...
}
```

If `this.outPoint` is Infinity (from corrupt layer data), the loop never terminates.

## Proof of Failure
```typescript
const layerData = {
  // ...
  outPoint: Infinity,  // Corrupt or malicious data
};
const layer = new ImageLayer(layerData);

layer.computeMotionPath();
// Line 1589: for (frame = 0; frame <= Infinity; frame++) - INFINITE LOOP!
// Browser hangs, tab crashes
```

## Impact
- Browser tab hangs/crashes
- Denial of service via corrupt project file
- Low severity: Requires Infinity outPoint (rare)

## Related: SYSTEMIC-006
Unbounded loop parameters - same pattern as BUG-068, BUG-069, BUG-076.

## Suggested Fix
```typescript
computeMotionPath(startFrame?: number, endFrame?: number): void {
  const start = startFrame ?? this.inPoint;
  const end = endFrame ?? this.outPoint;

  // Validate bounds
  if (!Number.isFinite(start) || !Number.isFinite(end) || end < start) {
    console.warn('[BaseLayer] Invalid motion path bounds');
    return;
  }

  // Cap at reasonable limit
  const maxFrames = 10000;
  const cappedEnd = Math.min(end, start + maxFrames);

  this.motionPathPoints = [];
  for (let frame = start; frame <= cappedEnd; frame++) {
    // ...
  }
}
```
