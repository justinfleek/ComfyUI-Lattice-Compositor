# BUG-155: onApplyEvaluatedState() Stores NaN Values Directly to Uniforms

## Summary
onApplyEvaluatedState() assigns evaluated property values directly to shader uniforms without validation. NaN values from expressions or drivers corrupt rendering.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/DepthflowLayer.ts
- Lines: 448-468
- Function: onApplyEvaluatedState()

## Crash Path Trace
```
Function: onApplyEvaluatedState(state: EvaluatedLayer)

Line 452-453:
  if (props['zoom'] !== undefined) {
    this.material.uniforms.zoom.value = props['zoom'] as number;  // NaN stored
  }

Line 456-459:
  if (props['offsetX'] !== undefined || props['offsetY'] !== undefined) {
    const offsetX = (props['offsetX'] as number) ?? this.material.uniforms.offset.value.x;
    const offsetY = (props['offsetY'] as number) ?? this.material.uniforms.offset.value.y;
    this.material.uniforms.offset.value.set(offsetX, offsetY);  // NaN stored
  }

Line 462-463:
  if (props['rotation'] !== undefined) {
    this.material.uniforms.rotation.value = THREE.MathUtils.degToRad(props['rotation'] as number);
      // degToRad(NaN) = NaN stored
  }

Line 466-467:
  if (props['depthScale'] !== undefined) {
    this.material.uniforms.depthScale.value = props['depthScale'] as number;  // NaN stored
  }

Test cases:
  - props['zoom']=NaN → uniform zoom=NaN → shader produces NaN colors
  - props['rotation']=NaN → degToRad(NaN)=NaN → shader rotation corrupt
  - props['depthScale']=NaN → displacement=NaN → pixels displaced to NaN coords

Result: SILENT CORRUPTION - shader uniforms receive NaN from expressions
```

## Code Evidence
```typescript
// Lines 448-468
protected override onApplyEvaluatedState(state: import('../MotionEngine').EvaluatedLayer): void {
  const props = state.properties;

  // Apply evaluated depthflow properties
  if (props['zoom'] !== undefined) {
    this.material.uniforms.zoom.value = props['zoom'] as number;  // No validation
  }

  if (props['offsetX'] !== undefined || props['offsetY'] !== undefined) {
    const offsetX = (props['offsetX'] as number) ?? this.material.uniforms.offset.value.x;
    const offsetY = (props['offsetY'] as number) ?? this.material.uniforms.offset.value.y;
    this.material.uniforms.offset.value.set(offsetX, offsetY);  // No validation
  }

  if (props['rotation'] !== undefined) {
    this.material.uniforms.rotation.value = THREE.MathUtils.degToRad(props['rotation'] as number);  // No validation
  }

  if (props['depthScale'] !== undefined) {
    this.material.uniforms.depthScale.value = props['depthScale'] as number;  // No validation
  }
  // ...
}
```

## Impact
- Expression evaluation can return NaN (division by zero, sqrt of negative, etc.)
- NaN values propagate directly to shader uniforms
- Shader produces corrupted/black output
- SYSTEMIC-005: NaN bypass pattern

## Suggested Fix
```typescript
if (props['zoom'] !== undefined) {
  const zoom = props['zoom'] as number;
  if (Number.isFinite(zoom) && zoom > 0) {
    this.material.uniforms.zoom.value = zoom;
  }
}
```
