# BUG-130: PathLayer.getPointAt/getTangentAt NaN Bypass

## Summary
The `getPointAt(t)` and `getTangentAt(t)` methods use `Math.max(0, Math.min(1, t))` for clamping. NaN bypasses these checks and propagates to curve calculations.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/PathLayer.ts
- Lines: 233-236, 241-244
- Functions: getPointAt, getTangentAt

## The Bug
```typescript
// Lines 233-236
getPointAt(t: number): THREE.Vector3 | null {
  if (!this.curve) return null;
  return this.curve.getPointAt(Math.max(0, Math.min(1, t)));
  //                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  // NaN bypasses! Math.max(0, Math.min(1, NaN)) = NaN
}

// Lines 241-244
getTangentAt(t: number): THREE.Vector3 | null {
  if (!this.curve) return null;
  return this.curve.getTangentAt(Math.max(0, Math.min(1, t)));  // Same issue
}
```

## Proof of Failure
```typescript
const pathLayer = new PathLayer(layerData);
// (path with valid control points)

// NaN comparison behavior:
console.log(Math.min(1, NaN));  // NaN
console.log(Math.max(0, NaN));  // NaN

// Attack: t = NaN
const point = pathLayer.getPointAt(NaN);
// curve.getPointAt(NaN) - undefined behavior
// Three.js may return NaN Vector3 or throw
```

## Impact
- NaN t value produces undefined curve result
- Used by TextLayer for text-on-path positioning
- Used by CameraLayer for camera path following
- Low severity: t typically comes from 0-1 animation

## Related
- BUG-108: SplineLayer.getPointAt/getTangentAt NaN bypass (identical pattern)
- SYSTEMIC-005: NaN bypass via comparison operators

## Suggested Fix
```typescript
getPointAt(t: number): THREE.Vector3 | null {
  if (!this.curve) return null;

  // Guard against NaN
  if (!Number.isFinite(t)) {
    t = 0;
  }

  return this.curve.getPointAt(Math.max(0, Math.min(1, t)));
}
```
