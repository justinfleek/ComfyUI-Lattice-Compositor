# BUG-048: createPathAnimator Overwrites Existing Animator Without Disposal

## Summary
The `createPathAnimator` function directly sets a new animator in the Map, overwriting any existing animator for that layer without disposing it first. If AudioPathAnimator holds resources, they leak.

## Severity: MEDIUM

## Location
- File: /ui/src/stores/actions/audioActions.ts
- Lines: 297-298
- Function: `createPathAnimator`

## The Bug
Line 298 overwrites without checking for existing animator.

## Code Evidence
```typescript
// Lines 292-299
export function createPathAnimator(
  store: AudioStore,
  layerId: string,
  config: Partial<PathAnimatorConfig> = {}
): void {
  const animator = new AudioPathAnimator(config);
  store.pathAnimators.set(layerId, animator);  // Overwrites existing!
}
```

## Crash Path Trace
```
1. createPathAnimator(store, 'layer1', { speed: 1.0 }) 
2. store.pathAnimators.set('layer1', animator#1)
3. animator#1 holds reference to SVG path, event listeners
4. User changes path animation config
5. createPathAnimator(store, 'layer1', { speed: 2.0 })
6. store.pathAnimators.set('layer1', animator#2)
7. animator#1 is orphaned - resources not released
8. Map.set() returns undefined, old animator garbage collected eventually
9. BUT: If animator#1 registered window listeners, they remain!
```

## Impact
- Resource leak (orphaned animator instances)
- Event listener leaks if animator registers global listeners
- Memory accumulation over time
- May cause performance issues in long sessions

## Suggested Fix
```typescript
export function createPathAnimator(
  store: AudioStore,
  layerId: string,
  config: Partial<PathAnimatorConfig> = {}
): void {
  // BUG-048 FIX: Dispose existing animator first
  const existing = store.pathAnimators.get(layerId);
  if (existing?.dispose) {
    existing.dispose();
  }
  
  const animator = new AudioPathAnimator(config);
  store.pathAnimators.set(layerId, animator);
}
```
