# BUG-035: Cache Key Collision with NaN/Infinity Frame Numbers

## Summary
Neither `cacheActions.ts` nor `frameCache.ts` validates frame parameters. When `frame = NaN` or `frame = Infinity`, all such frames map to the same cache key, causing data corruption where different frames overwrite each other.

## Severity: MEDIUM

## Location
- File: /ui/src/stores/actions/cacheActions.ts (wrapper - no validation)
- File: /ui/src/services/frameCache.ts
- Lines: 246-248 (getCacheKey), 254, 318, 401, 478, 485
- Functions: getCacheKey, get, set, has, startPreCache

## The Bug

### frameCache.ts - No input validation
```typescript
// Line 246-248 - No validation, just string interpolation
private getCacheKey(frame: number, compositionId: string): string {
  return `${compositionId}:${frame}`;  // NaN → "comp:NaN", Infinity → "comp:Infinity"
}

// Line 254 - Passes through without validation
get(frame: number, compositionId: string, currentStateHash?: string): ImageData | null {
  const key = this.getCacheKey(frame, compositionId);
  // ...
}

// Line 318 - Passes through without validation
async set(frame: number, compositionId: string, imageData: ImageData, stateHash: string): Promise<void> {
  const key = this.getCacheKey(frame, compositionId);
  // ...
}
```

### Pre-cache compounds the problem
```typescript
// Lines 475-490 - NaN/Infinity propagates through arithmetic
for (let i = 1; i <= window; i++) {
  if (direction !== 'backward') {
    this.preCacheQueue.push({
      frame: currentFrame + i,  // NaN + 1 = NaN, Infinity + 1 = Infinity
      compositionId,
      priority: window - i,
    });
  }
  if (direction !== 'forward') {
    this.preCacheQueue.push({
      frame: currentFrame - i,  // NaN - 1 = NaN, Infinity - 1 = Infinity
      compositionId,
      priority: window - i,
    });
  }
}
// Result: All entries in queue have same "NaN" or "Infinity" key
// Each cache.set() overwrites the previous one
```

### cacheActions.ts - No validation either
```typescript
// Line 63 - Passes frame directly to cache
return cache.get(frame, store.activeCompositionId, store.projectStateHash);

// Line 77 - Same
await cache.set(frame, store.activeCompositionId, imageData, store.projectStateHash);
```

## Proof of Failure
```typescript
const cache = new FrameCache();

// Cache frame NaN
await cache.set(NaN, "comp1", imageDataA, "hash1");
console.log(cache.has(NaN, "comp1"));  // true

// Cache another "frame NaN" - actually same key!
await cache.set(NaN, "comp1", imageDataB, "hash1");  // OVERWRITES imageDataA!

// Only one entry exists
console.log(cache.getStats().cachedFrames);  // 1, not 2

// Retrieve - gets imageDataB, not imageDataA
const result = cache.get(NaN, "comp1", "hash1");  // imageDataB (data corruption)
```

## Impact
- Multiple different frames with NaN values all stored under same key
- Last write wins - previous frame data silently lost
- Pre-cache with NaN currentFrame creates queue of identical keys, each overwriting the previous
- Silent data corruption - no error thrown, just wrong data returned
- Medium severity because NaN/Infinity frame requires upstream bug, but chain is unvalidated

## Suggested Fix
Add validation in getCacheKey or public methods:
```typescript
private getCacheKey(frame: number, compositionId: string): string {
  if (!Number.isFinite(frame)) {
    throw new Error(`Invalid frame number: ${frame}`);
  }
  if (frame < 0) {
    throw new Error(`Frame number cannot be negative: ${frame}`);
  }
  return `${compositionId}:${frame}`;
}
```

Or defensively in cacheActions.ts:
```typescript
export function getCachedFrame(store: CacheStore, frame: number): ImageData | null {
  if (!Number.isFinite(frame) || frame < 0) return null;
  // ...
}
```
