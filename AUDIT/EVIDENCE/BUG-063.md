# BUG-063: Division by Zero in getModulation() When binding.max === binding.min

## Summary
The `getModulation()` function divides by `(binding.max - binding.min)` without clamping the result. When max equals min, this produces Â±Infinity. Note: `applyModulation()` handles this correctly with Math.max/min clamps at line 106, but `getModulation()` at line 156 does not.

## Severity: LOW

## Location
- File: /ui/src/engine/particles/ParticleAudioReactive.ts
- Lines: 156-157
- Function: getModulation

## The Bug
```typescript
// Lines 156-157 - No clamp, unlike applyModulation() at line 106
getModulation(target: string, targetId: string, parameter: string): number | undefined {
  for (const binding of this.audioBindings) {
    if (binding.target === target && binding.targetId === targetId && binding.parameter === parameter) {
      const featureValue = this.audioFeatures.get(binding.feature) ?? 0;
      const t = (featureValue - binding.min) / (binding.max - binding.min);  // No clamp!
      return binding.outputMin + t * (binding.outputMax - binding.outputMin);
    }
  }
  return undefined;
}
```

Compare to properly-clamped version in applyModulation() at line 106:
```typescript
// Line 106 - Has proper clamping
const t = Math.max(0, Math.min(1, (smoothed - binding.min) / (binding.max - binding.min)));
```

## Proof of Failure
```typescript
const audio = new ParticleAudioReactive();
audio.setBindings([{
  feature: 'amplitude',
  target: 'emitter',
  targetId: 'test',
  parameter: 'emitRate',
  min: 0.5,
  max: 0.5,  // Same as min!
  outputMin: 10,
  outputMax: 100
}]);
audio.setFeature('amplitude', 0.3); // Below min

const mod = audio.getModulation('emitter', 'test', 'emitRate');
// Line 156: (0.3 - 0.5) / (0.5 - 0.5) = -0.2 / 0 = -Infinity
// Line 157: 10 + (-Infinity) * 90 = -Infinity

console.log(mod); // -Infinity
```

## Impact
- Callers querying audio modulation values receive Infinity
- Low severity: Edge case configuration (binding.max === binding.min is unusual)
- Inconsistent with applyModulation() which handles the same case correctly

## Suggested Fix
```typescript
getModulation(target: string, targetId: string, parameter: string): number | undefined {
  for (const binding of this.audioBindings) {
    if (binding.target === target && binding.targetId === targetId && binding.parameter === parameter) {
      const featureValue = this.audioFeatures.get(binding.feature) ?? 0;
      // Add clamp to match applyModulation() behavior
      const range = binding.max - binding.min;
      const t = range !== 0
        ? Math.max(0, Math.min(1, (featureValue - binding.min) / range))
        : 0.5; // Default to midpoint when range is 0
      return binding.outputMin + t * (binding.outputMax - binding.outputMin);
    }
  }
  return undefined;
}
```
