# BUG-084: NaN Transform Values Propagate to Three.js Causing Render Corruption

## Summary
In BaseLayer.applyTransform(), NaN values from the evaluator or driven values are passed directly to Three.js group.position/rotation/scale.set() methods without validation. This corrupts the layer's transform matrix and causes rendering issues.

## Severity: MEDIUM (Defense-in-depth gap)

## Location
- File: /ui/src/engine/layers/BaseLayer.ts
- Lines: 382-397
- Function: applyTransform

## The Bug
```typescript
protected applyTransform(transform: {
  position: { x: number; y: number; z: number };
  rotation: { x: number; y: number; z: number };
  scale: { x: number; y: number; z: number };
  origin: { x: number; y: number; z: number };
}): void {
  const { position, rotation, scale, origin } = transform;

  // Line 382-386: No NaN validation!
  this.group.position.set(
    position.x - origin.x,      // If position.x is NaN, result is NaN
    -(position.y - origin.y),   // NaN propagates
    position.z - origin.z
  );

  // Line 390-394: No NaN validation!
  this.group.rotation.set(
    THREE.MathUtils.degToRad(rotation.x),  // degToRad(NaN) = NaN
    THREE.MathUtils.degToRad(rotation.y),
    THREE.MathUtils.degToRad(-rotation.z)
  );

  // Line 397: No NaN validation!
  this.group.scale.set(scale.x, scale.y, scale.z);  // NaN scale corrupts mesh
}
```

## How NaN Reaches applyTransform
```typescript
// Line 273-276 in evaluateTransform:
const basePosition = this.evaluator.evaluate(this.transform.position, frame);
let posX = this.getDrivenOrBase('transform.position.x', basePosition.x);
// If evaluator returns NaN or drivenValues contains NaN, posX is NaN

// Line 345-366: NaN values passed to applyTransform
this.applyTransform({
  position: { x: position.x, ...},  // NaN propagates
  // ...
});
```

## Sources of NaN
1. **KeyframeEvaluator** returning NaN from malformed keyframes
2. **Expression system** producing NaN from math errors (0/0, sqrt(-1), etc.)
3. **Driven values** set to NaN from property drivers
4. **Audio reactive values** containing NaN

## Proof of Failure
```typescript
const layer = new ImageLayer(layerData);

// Simulate expression producing NaN
layer.drivenValues.set('transform.position.x', NaN);
layer.evaluateFrame(0);

// Line 274: posX = NaN (from getDrivenOrBase)
// Line 382: group.position.set(NaN, ...)
// Three.js: Layer position corrupted, may disappear or render at wrong location
```

## Impact
- Layer disappears or renders at wrong position
- Transform matrix becomes invalid
- Child layers inherit corrupted transforms
- Medium severity: Common when expressions have math errors

## Related
- SYSTEMIC-005: NaN bypasses comparison guards
- BUG-082, BUG-083: Other NaN bypass issues in BaseLayer

## Suggested Fix (Defense-in-Depth)
```typescript
protected applyTransform(transform: {...}): void {
  const { position, rotation, scale, origin } = transform;

  // Validate and sanitize values
  const safePos = {
    x: Number.isFinite(position.x - origin.x) ? position.x - origin.x : 0,
    y: Number.isFinite(position.y - origin.y) ? -(position.y - origin.y) : 0,
    z: Number.isFinite(position.z - origin.z) ? position.z - origin.z : 0,
  };

  const safeRot = {
    x: Number.isFinite(rotation.x) ? THREE.MathUtils.degToRad(rotation.x) : 0,
    y: Number.isFinite(rotation.y) ? THREE.MathUtils.degToRad(rotation.y) : 0,
    z: Number.isFinite(rotation.z) ? THREE.MathUtils.degToRad(-rotation.z) : 0,
  };

  const safeScale = {
    x: Number.isFinite(scale.x) ? scale.x : 1,
    y: Number.isFinite(scale.y) ? scale.y : 1,
    z: Number.isFinite(scale.z) ? scale.z : 1,
  };

  this.group.position.set(safePos.x, safePos.y, safePos.z);
  this.group.rotation.set(safeRot.x, safeRot.y, safeRot.z);
  this.group.scale.set(safeScale.x, safeScale.y, safeScale.z);
  this.group.updateMatrix();
}
```
