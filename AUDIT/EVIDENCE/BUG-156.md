# BUG-156: Audio Modifier NaN Values Added to Uniforms Without Validation

## Summary
onApplyEvaluatedState() adds audio-reactive modifier values to uniforms without validation. NaN audio values corrupt rendering when added to existing uniform values.

## Severity: LOW

## Location
- File: /ui/src/engine/layers/DepthflowLayer.ts
- Lines: 470-492
- Function: onApplyEvaluatedState()

## Crash Path Trace
```
Function: onApplyEvaluatedState(state: EvaluatedLayer)

Line 471: const audioMod = this.currentAudioModifiers;

Line 473-475:
  if (audioMod.depthflowZoom !== undefined && audioMod.depthflowZoom !== 0) {
    this.material.uniforms.zoom.value += audioMod.depthflowZoom;
      // 1.0 + NaN = NaN stored
  }

Line 477-479:
  if (audioMod.depthflowOffsetX !== undefined && audioMod.depthflowOffsetX !== 0) {
    this.material.uniforms.offset.value.x += audioMod.depthflowOffsetX;
      // 0.0 + NaN = NaN stored
  }

Line 481-483:
  if (audioMod.depthflowOffsetY !== undefined && audioMod.depthflowOffsetY !== 0) {
    this.material.uniforms.offset.value.y += audioMod.depthflowOffsetY;
      // 0.0 + NaN = NaN stored
  }

Line 485-488:
  if (audioMod.depthflowRotation !== undefined && audioMod.depthflowRotation !== 0) {
    this.material.uniforms.rotation.value += THREE.MathUtils.degToRad(audioMod.depthflowRotation);
      // degToRad(NaN) = NaN, any_value + NaN = NaN
  }

Line 490-492:
  if (audioMod.depthflowDepthScale !== undefined && audioMod.depthflowDepthScale !== 0) {
    this.material.uniforms.depthScale.value += audioMod.depthflowDepthScale;
      // 0.1 + NaN = NaN stored
  }

Test cases:
  - audioMod.depthflowZoom=NaN → check passes (NaN !== 0 is true) → zoom becomes NaN
  - audioMod.depthflowRotation=NaN → degToRad(NaN)=NaN → rotation becomes NaN
  - Normal value + NaN = NaN → corrupts previously valid uniform

Result: SILENT CORRUPTION - audio NaN values propagate through additive operations
```

## Code Evidence
```typescript
// Lines 470-492
// BUG-094 fix: Apply audio-reactive modifiers (additive to base values)
const audioMod = this.currentAudioModifiers;

if (audioMod.depthflowZoom !== undefined && audioMod.depthflowZoom !== 0) {
  this.material.uniforms.zoom.value += audioMod.depthflowZoom;  // += NaN = NaN
}

if (audioMod.depthflowOffsetX !== undefined && audioMod.depthflowOffsetX !== 0) {
  this.material.uniforms.offset.value.x += audioMod.depthflowOffsetX;  // += NaN = NaN
}

if (audioMod.depthflowOffsetY !== undefined && audioMod.depthflowOffsetY !== 0) {
  this.material.uniforms.offset.value.y += audioMod.depthflowOffsetY;  // += NaN = NaN
}

if (audioMod.depthflowRotation !== undefined && audioMod.depthflowRotation !== 0) {
  // Add rotation in radians (convert from degrees)
  this.material.uniforms.rotation.value += THREE.MathUtils.degToRad(audioMod.depthflowRotation);
}

if (audioMod.depthflowDepthScale !== undefined && audioMod.depthflowDepthScale !== 0) {
  this.material.uniforms.depthScale.value += audioMod.depthflowDepthScale;  // += NaN = NaN
}
```

## Impact
- Audio analysis can produce NaN values (empty audio, corrupt data)
- NaN !== 0 is true, so check doesn't filter NaN
- Adding NaN to any number produces NaN
- All uniform values become NaN, rendering completely corrupted
- SYSTEMIC-005: NaN bypass pattern

## Suggested Fix
```typescript
if (audioMod.depthflowZoom !== undefined && Number.isFinite(audioMod.depthflowZoom) && audioMod.depthflowZoom !== 0) {
  this.material.uniforms.zoom.value += audioMod.depthflowZoom;
}
```
