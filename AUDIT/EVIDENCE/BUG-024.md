# BUG-024: Division by Zero at Center Pixel in Chromatic Aberration

## Summary
The `applyChromaticAberration()` function calculates radial offsets by dividing by the distance from center. At the exact center pixel (dist=0), this causes division by zero, producing NaN coordinates and a black/corrupted center pixel.

## Severity: LOW

## Location
- File: /ui/src/services/effects/cinematicBloom.ts
- Lines: 386-390
- Function: applyChromaticAberration

## The Bug
```typescript
// Lines 377-390
const dx = x - centerX;
const dy = y - centerY;
const dist = Math.sqrt(dx * dx + dy * dy);  // At center: dist = 0
const normalizedDist = dist / maxDist;

const offset = amount * normalizedDist;  // At center: offset = 0

// These divide by dist (which is 0 at center)
const rxR = Math.round(x + dx * offset / dist);  // 0 * 0 / 0 = NaN
const ryR = Math.round(y + dy * offset / dist);  // NaN
const rxB = Math.round(x - dx * offset / dist);  // NaN
const ryB = Math.round(y - dy * offset / dist);  // NaN
```

## Proof of Failure
```typescript
// For center pixel where x = centerX, y = centerY:
const dx = 0, dy = 0;
const dist = Math.sqrt(0 + 0) = 0;
const offset = amount * 0 = 0;

const rxR = Math.round(x + 0 * 0 / 0);  // NaN
const clampedX = Math.max(0, Math.min(width-1, NaN));  // NaN
const idxR = (NaN * width + NaN) * 4;  // NaN
const red = data[NaN];  // undefined
dst[idx] = undefined;  // becomes 0 in Uint8ClampedArray

// Center pixel's red channel becomes 0 instead of original value
```

## Impact
- Center pixel's red channel is corrupted (set to 0)
- Single pixel artifact at exact center of image
- Low severity because it only affects 1 pixel
- Visually negligible in most cases

## Suggested Fix
Guard against zero distance:
```typescript
if (dist === 0) {
  // Center pixel - no offset needed
  dst[idx] = data[idx];
  dst[idx + 1] = data[idx + 1];
  dst[idx + 2] = data[idx + 2];
  dst[idx + 3] = data[idx + 3];
  continue;
}
```
