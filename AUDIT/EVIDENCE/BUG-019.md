# BUG-019: Excessive Use of `any` Types Disables Type Safety

## Summary
The types.ts file uses `any` in 7 locations, completely bypassing TypeScript's type checking. This is the root cause that enables all the division-by-zero, NaN propagation, and invalid input bugs found throughout the codebase. Proper branded types or constrained types would catch these issues at compile time.

## Severity: MEDIUM

## Location
- File: /ui/src/services/expressions/types.ts
- Lines: 39, 42, 45, 69, 90, 129, 130

## The Bug
```typescript
// Line 39 - keyframes can contain anything
keyframes: Keyframe<any>[];

// Line 42 - external data completely untyped
data?: Record<string, any>;

// Line 45 - expression params completely untyped
params?: Record<string, any>;

// Line 69 - effect parameters partially typed but uses broad union
parameters: Record<string, number | number[] | string | boolean>;

// Line 90 - expression params completely untyped
params: Record<string, any>;

// Lines 129-130 - colors completely untyped
fillColor: any;
strokeColor: any;
```

## Root Cause Analysis
Every runtime bug found exists because invalid values can reach the code:

| Bug | Root Cause | Type Fix |
|-----|-----------|----------|
| BUG-001,002,003,004,007,008,009,013 | Division by zero | `PositiveNumber` branded type |
| BUG-006 | Sandbox escape | Proper code validation type |
| BUG-010 | Circular parents | `LayerReference` with validation |
| BUG-011 | scale=0 corruption | `NonZeroNumber` or proper scale type |
| BUG-012 | octaves=Infinity | `FinitePositiveInteger` type |
| BUG-014 | Invalid loop type | Proper union type for `type` param |
| BUG-015 | Array + number | Proper overloads or generic constraints |
| BUG-016 | Negative gravity | `PositiveNumber` branded type |
| BUG-017 | Special chars | N/A (string escaping issue) |
| BUG-018 | Missing max values | Proper array length constraints |

## Impact
- TypeScript's primary benefit (compile-time type safety) is completely disabled
- Invalid data flows through the entire expression system unchecked
- Every runtime validation bug is a symptom of this root cause
- Developers get no IDE warnings when passing invalid values

## Suggested Fix
Use branded types or template literal types:

```typescript
// Branded types for numeric constraints
type PositiveNumber = number & { __brand: 'positive' };
type NonZeroNumber = number & { __brand: 'nonzero' };
type FiniteNumber = number & { __brand: 'finite' };

// Helper to create branded values with runtime validation
function asPositive(n: number): PositiveNumber {
  if (n <= 0 || !Number.isFinite(n)) {
    throw new Error(`Expected positive number, got ${n}`);
  }
  return n as PositiveNumber;
}

// Proper color type
interface Color {
  r: number; // 0-1
  g: number; // 0-1
  b: number; // 0-1
  a: number; // 0-1
}

// Then in ExpressionContext:
fps: PositiveNumber;  // Can't be 0, NaN, negative, or Infinity
```

## Systemic Nature
This is not an isolated bug - it's a systemic design flaw that enables most other bugs in the expression system. Fixing the types would:
1. Prevent invalid values at compile time
2. Force explicit validation at system boundaries
3. Provide IDE autocomplete and warnings
4. Document expected value constraints
