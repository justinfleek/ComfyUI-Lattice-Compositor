---
description: MANDATORY rules for Haskell ports - ZERO escapes of ANY kind
alwaysApply: true
---

# Haskell Port Rules - ZERO ESCAPES

**ðŸš¨ CRITICAL: These rules are MANDATORY for ALL Haskell ports. No exceptions.**

## Forbidden Patterns - IMMEDIATE VIOLATION

### Type Escapes
- âŒ `any` (TypeScript) / `forall a. a` (Haskell) without constraints
- âŒ `unknown` (TypeScript) / untyped values
- âŒ Type assertions: `as Type`, `as unknown as`
- âŒ Non-null assertions: `!` (TypeScript)
- âŒ Nullish coalescing: `??` (TypeScript)
- âŒ Logical OR defaults: `||` (TypeScript)
- âŒ TypeScript ignore: `@ts-ignore`, `@ts-expect-error`

### Haskell-Specific Forbidden Patterns
- âŒ `error "message"` - Use `Either Text a` or custom error types
- âŒ `undefined` - Use `Maybe` or explicit initialization
- âŒ `unsafePerformIO` - Use proper `IO` monad
- âŒ `unsafeCoerce` - Use proper type conversions
- âŒ `unsafePartial` - Handle all cases explicitly
- âŒ `userError` - Use `Either Text a` or custom error types
- âŒ `throwIO` with string - Use `Either Text a` or custom error types
- âŒ Partial functions: `head`, `tail`, `init`, `last`, `fromJust`, `!!`
- âŒ `catch` that swallows errors - Always return `Either Text a`

## Required Patterns

### Error Handling
- âœ… **ALWAYS** use `Either Text a` for error handling
- âœ… **NEVER** use `userError`, `error`, `throwIO` with strings
- âœ… **NEVER** use `SomeException` in public APIs - convert to `Text`
- âœ… Match existing patterns: See `Lattice.Utils.Validation` for reference

### Type Safety
- âœ… Explicit types at ALL function boundaries
- âœ… Use `Maybe` for optional values (never `null`/`undefined`)
- âœ… Use sum types for discriminated unions
- âœ… Use `Either` for error handling
- âœ… Validate all numeric inputs (use `isFinite`, bounds checking)

## Verification Checklist

Before submitting ANY port:
- [ ] No `error`, `undefined`, `userError`, `throwIO` with strings
- [ ] No `unsafe*` functions
- [ ] No partial functions (`head`, `tail`, `fromJust`, etc.)
- [ ] All public APIs use `Either Text a` for errors
- [ ] All types explicit at function boundaries
- [ ] All numeric inputs validated
- [ ] Matches existing codebase patterns (`Validation.hs`)

## Reference Files

- `src/lattice/Utils/Validation.hs` - Error handling pattern
- `src/lattice/Utils/NumericSafety.hs` - Numeric validation pattern
- `src/lattice/Utils/Retry.hs` - Correct retry implementation
- `src/lattice/Utils/CircuitBreaker.hs` - Correct circuit breaker implementation

## Examples

**âŒ WRONG:**
```haskell
retry :: IO a -> RetryOptions -> IO (Either SomeException a)
retry fn options = do
  result <- catch (Right <$> fn) (\e -> return (Left e))
  case result of
    Left e -> return (Left (userError "Failed"))  -- FORBIDDEN
    Right v -> return (Right v)
```

**âœ… CORRECT:**
```haskell
retry :: IO a -> RetryOptions -> IO (Either Text a)
retry fn options = do
  result <- catch (Right <$> fn) (\e -> return (Left (T.pack (show e))))
  case result of
    Left errMsg -> return (Left errMsg)  -- Explicit Text
    Right v -> return (Right v)
```
