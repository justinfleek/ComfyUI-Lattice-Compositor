var aw = Object.defineProperty;
var lw = (i, e, n) => e in i ? aw(i, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : i[e] = n;
var Xe = (i, e, n) => lw(i, typeof e != "symbol" ? e + "" : e, n);
/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function so(i) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const n of i.split(",")) e[n] = 1;
  return (n) => n in e;
}
const Et = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, aa = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], vn = () => {
}, ty = () => !1, Jl = (i) => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && // uppercase letter
(i.charCodeAt(2) > 122 || i.charCodeAt(2) < 97), bc = (i) => i.startsWith("onUpdate:"), en = Object.assign, Cf = (i, e) => {
  const n = i.indexOf(e);
  n > -1 && i.splice(n, 1);
}, uw = Object.prototype.hasOwnProperty, xt = (i, e) => uw.call(i, e), We = Array.isArray, gs = (i) => Ql(i) === "[object Map]", xa = (i) => Ql(i) === "[object Set]", Rp = (i) => Ql(i) === "[object Date]", qe = (i) => typeof i == "function", jt = (i) => typeof i == "string", Gi = (i) => typeof i == "symbol", wt = (i) => i !== null && typeof i == "object", kf = (i) => (wt(i) || qe(i)) && qe(i.then) && qe(i.catch), ny = Object.prototype.toString, Ql = (i) => ny.call(i), Of = (i) => Ql(i).slice(8, -1), iy = (i) => Ql(i) === "[object Object]", nd = (i) => jt(i) && i !== "NaN" && i[0] !== "-" && "" + parseInt(i, 10) === i, tl = /* @__PURE__ */ so(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), cw = /* @__PURE__ */ so(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), id = (i) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = i(n));
}, dw = /-\w/g, Hn = id(
  (i) => i.replace(dw, (e) => e.slice(1).toUpperCase())
), hw = /\B([A-Z])/g, to = id(
  (i) => i.replace(hw, "-$1").toLowerCase()
), Os = id((i) => i.charAt(0).toUpperCase() + i.slice(1)), Co = id(
  (i) => i ? `on${Os(i)}` : ""
), Vo = (i, e) => !Object.is(i, e), Ks = (i, ...e) => {
  for (let n = 0; n < i.length; n++)
    i[n](...e);
}, wc = (i, e, n, r = !1) => {
  Object.defineProperty(i, e, {
    configurable: !0,
    enumerable: !1,
    writable: r,
    value: n
  });
}, rd = (i) => {
  const e = parseFloat(i);
  return isNaN(e) ? i : e;
}, fw = (i) => {
  const e = jt(i) ? Number(i) : NaN;
  return isNaN(e) ? i : e;
};
let Np;
const eu = () => Np || (Np = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Pt(i) {
  if (We(i)) {
    const e = {};
    for (let n = 0; n < i.length; n++) {
      const r = i[n], o = jt(r) ? vw(r) : Pt(r);
      if (o)
        for (const s in o)
          e[s] = o[s];
    }
    return e;
  } else if (jt(i) || wt(i))
    return i;
}
const pw = /;(?![^(]*\))/g, mw = /:([^]+)/, gw = /\/\*[^]*?\*\//g;
function vw(i) {
  const e = {};
  return i.replace(gw, "").split(pw).forEach((n) => {
    if (n) {
      const r = n.split(mw);
      r.length > 1 && (e[r[0].trim()] = r[1].trim());
    }
  }), e;
}
function _e(i) {
  let e = "";
  if (jt(i))
    e = i;
  else if (We(i))
    for (let n = 0; n < i.length; n++) {
      const r = _e(i[n]);
      r && (e += r + " ");
    }
  else if (wt(i))
    for (const n in i)
      i[n] && (e += n + " ");
  return e.trim();
}
function yw(i) {
  if (!i) return null;
  let { class: e, style: n } = i;
  return e && !jt(e) && (i.class = _e(e)), n && (i.style = Pt(n)), i;
}
const bw = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", ww = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", _w = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", xw = /* @__PURE__ */ so(bw), Sw = /* @__PURE__ */ so(ww), Cw = /* @__PURE__ */ so(_w), kw = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Ow = /* @__PURE__ */ so(kw);
function ry(i) {
  return !!i || i === "";
}
function Ew(i, e) {
  if (i.length !== e.length) return !1;
  let n = !0;
  for (let r = 0; n && r < i.length; r++)
    n = tu(i[r], e[r]);
  return n;
}
function tu(i, e) {
  if (i === e) return !0;
  let n = Rp(i), r = Rp(e);
  if (n || r)
    return n && r ? i.getTime() === e.getTime() : !1;
  if (n = Gi(i), r = Gi(e), n || r)
    return i === e;
  if (n = We(i), r = We(e), n || r)
    return n && r ? Ew(i, e) : !1;
  if (n = wt(i), r = wt(e), n || r) {
    if (!n || !r)
      return !1;
    const o = Object.keys(i).length, s = Object.keys(e).length;
    if (o !== s)
      return !1;
    for (const a in i) {
      const l = i.hasOwnProperty(a), u = e.hasOwnProperty(a);
      if (l && !u || !l && u || !tu(i[a], e[a]))
        return !1;
    }
  }
  return String(i) === String(e);
}
function Ef(i, e) {
  return i.findIndex((n) => tu(n, e));
}
const oy = (i) => !!(i && i.__v_isRef === !0), Q = (i) => jt(i) ? i : i == null ? "" : We(i) || wt(i) && (i.toString === ny || !qe(i.toString)) ? oy(i) ? Q(i.value) : JSON.stringify(i, sy, 2) : String(i), sy = (i, e) => oy(e) ? sy(i, e.value) : gs(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (n, [r, o], s) => (n[Ld(r, s) + " =>"] = o, n),
    {}
  )
} : xa(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((n) => Ld(n))
} : Gi(e) ? Ld(e) : wt(e) && !We(e) && !iy(e) ? String(e) : e, Ld = (i, e = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Gi(i) ? `Symbol(${(n = i.description) != null ? n : e})` : i
  );
};
/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function ci(i, ...e) {
  console.warn(`[Vue warn] ${i}`, ...e);
}
let Pn;
class ay {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Pn, !e && Pn && (this.index = (Pn.scopes || (Pn.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].pause();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].resume();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const n = Pn;
      try {
        return Pn = this, e();
      } finally {
        Pn = n;
      }
    } else process.env.NODE_ENV !== "production" && ci("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Pn, Pn = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Pn = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let n, r;
      for (n = 0, r = this.effects.length; n < r; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, r = this.cleanups.length; n < r; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, r = this.scopes.length; n < r; n++)
          this.scopes[n].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const o = this.parent.scopes.pop();
        o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function ly(i) {
  return new ay(i);
}
function uy() {
  return Pn;
}
function Tw(i, e = !1) {
  Pn ? Pn.cleanups.push(i) : process.env.NODE_ENV !== "production" && !e && ci(
    "onScopeDispose() is called when there is no active effect scope to be associated with."
  );
}
let Ot;
const Ad = /* @__PURE__ */ new WeakSet();
class cy {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Pn && Pn.active && Pn.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Ad.has(this) && (Ad.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || hy(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, zp(this), fy(this);
    const e = Ot, n = Bi;
    Ot = this, Bi = !0;
    try {
      return this.fn();
    } finally {
      process.env.NODE_ENV !== "production" && Ot !== this && ci(
        "Active effect was not restored correctly - this is likely a Vue internal bug."
      ), py(this), Ot = e, Bi = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        $f(e);
      this.deps = this.depsTail = void 0, zp(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Ad.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    wh(this) && this.run();
  }
  get dirty() {
    return wh(this);
  }
}
let dy = 0, nl, il;
function hy(i, e = !1) {
  if (i.flags |= 8, e) {
    i.next = il, il = i;
    return;
  }
  i.next = nl, nl = i;
}
function Tf() {
  dy++;
}
function Df() {
  if (--dy > 0)
    return;
  if (il) {
    let e = il;
    for (il = void 0; e; ) {
      const n = e.next;
      e.next = void 0, e.flags &= -9, e = n;
    }
  }
  let i;
  for (; nl; ) {
    let e = nl;
    for (nl = void 0; e; ) {
      const n = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (r) {
          i || (i = r);
        }
      e = n;
    }
  }
  if (i) throw i;
}
function fy(i) {
  for (let e = i.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function py(i) {
  let e, n = i.depsTail, r = n;
  for (; r; ) {
    const o = r.prevDep;
    r.version === -1 ? (r === n && (n = o), $f(r), Dw(r)) : e = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = o;
  }
  i.deps = e, i.depsTail = n;
}
function wh(i) {
  for (let e = i.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (my(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!i._dirty;
}
function my(i) {
  if (i.flags & 4 && !(i.flags & 16) || (i.flags &= -17, i.globalVersion === vl) || (i.globalVersion = vl, !i.isSSR && i.flags & 128 && (!i.deps && !i._dirty || !wh(i))))
    return;
  i.flags |= 2;
  const e = i.dep, n = Ot, r = Bi;
  Ot = i, Bi = !0;
  try {
    fy(i);
    const o = i.fn(i._value);
    (e.version === 0 || Vo(o, i._value)) && (i.flags |= 128, i._value = o, e.version++);
  } catch (o) {
    throw e.version++, o;
  } finally {
    Ot = n, Bi = r, py(i), i.flags &= -3;
  }
}
function $f(i, e = !1) {
  const { dep: n, prevSub: r, nextSub: o } = i;
  if (r && (r.nextSub = o, i.prevSub = void 0), o && (o.prevSub = r, i.nextSub = void 0), process.env.NODE_ENV !== "production" && n.subsHead === i && (n.subsHead = o), n.subs === i && (n.subs = r, !r && n.computed)) {
    n.computed.flags &= -5;
    for (let s = n.computed.deps; s; s = s.nextDep)
      $f(s, !0);
  }
  !e && !--n.sc && n.map && n.map.delete(n.key);
}
function Dw(i) {
  const { prevDep: e, nextDep: n } = i;
  e && (e.nextDep = n, i.prevDep = void 0), n && (n.prevDep = e, i.nextDep = void 0);
}
let Bi = !0;
const gy = [];
function Xi() {
  gy.push(Bi), Bi = !1;
}
function Yi() {
  const i = gy.pop();
  Bi = i === void 0 ? !0 : i;
}
function zp(i) {
  const { cleanup: e } = i;
  if (i.cleanup = void 0, e) {
    const n = Ot;
    Ot = void 0;
    try {
      e();
    } finally {
      Ot = n;
    }
  }
}
let vl = 0;
class $w {
  constructor(e, n) {
    this.sub = e, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Mf {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0, process.env.NODE_ENV !== "production" && (this.subsHead = void 0);
  }
  track(e) {
    if (!Ot || !Bi || Ot === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== Ot)
      n = this.activeLink = new $w(Ot, this), Ot.deps ? (n.prevDep = Ot.depsTail, Ot.depsTail.nextDep = n, Ot.depsTail = n) : Ot.deps = Ot.depsTail = n, vy(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const r = n.nextDep;
      r.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = r), n.prevDep = Ot.depsTail, n.nextDep = void 0, Ot.depsTail.nextDep = n, Ot.depsTail = n, Ot.deps === n && (Ot.deps = r);
    }
    return process.env.NODE_ENV !== "production" && Ot.onTrack && Ot.onTrack(
      en(
        {
          effect: Ot
        },
        e
      )
    ), n;
  }
  trigger(e) {
    this.version++, vl++, this.notify(e);
  }
  notify(e) {
    Tf();
    try {
      if (process.env.NODE_ENV !== "production")
        for (let n = this.subsHead; n; n = n.nextSub)
          n.sub.onTrigger && !(n.sub.flags & 8) && n.sub.onTrigger(
            en(
              {
                effect: n.sub
              },
              e
            )
          );
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      Df();
    }
  }
}
function vy(i) {
  if (i.dep.sc++, i.sub.flags & 4) {
    const e = i.dep.computed;
    if (e && !i.dep.subs) {
      e.flags |= 20;
      for (let r = e.deps; r; r = r.nextDep)
        vy(r);
    }
    const n = i.dep.subs;
    n !== i && (i.prevSub = n, n && (n.nextSub = i)), process.env.NODE_ENV !== "production" && i.dep.subsHead === void 0 && (i.dep.subsHead = i), i.dep.subs = i;
  }
}
const _c = /* @__PURE__ */ new WeakMap(), vs = Symbol(
  process.env.NODE_ENV !== "production" ? "Object iterate" : ""
), _h = Symbol(
  process.env.NODE_ENV !== "production" ? "Map keys iterate" : ""
), yl = Symbol(
  process.env.NODE_ENV !== "production" ? "Array iterate" : ""
);
function gn(i, e, n) {
  if (Bi && Ot) {
    let r = _c.get(i);
    r || _c.set(i, r = /* @__PURE__ */ new Map());
    let o = r.get(n);
    o || (r.set(n, o = new Mf()), o.map = r, o.key = n), process.env.NODE_ENV !== "production" ? o.track({
      target: i,
      type: e,
      key: n
    }) : o.track();
  }
}
function fr(i, e, n, r, o, s) {
  const a = _c.get(i);
  if (!a) {
    vl++;
    return;
  }
  const l = (u) => {
    u && (process.env.NODE_ENV !== "production" ? u.trigger({
      target: i,
      type: e,
      key: n,
      newValue: r,
      oldValue: o,
      oldTarget: s
    }) : u.trigger());
  };
  if (Tf(), e === "clear")
    a.forEach(l);
  else {
    const u = We(i), c = u && nd(n);
    if (u && n === "length") {
      const d = Number(r);
      a.forEach((h, p) => {
        (p === "length" || p === yl || !Gi(p) && p >= d) && l(h);
      });
    } else
      switch ((n !== void 0 || a.has(void 0)) && l(a.get(n)), c && l(a.get(yl)), e) {
        case "add":
          u ? c && l(a.get("length")) : (l(a.get(vs)), gs(i) && l(a.get(_h)));
          break;
        case "delete":
          u || (l(a.get(vs)), gs(i) && l(a.get(_h)));
          break;
        case "set":
          gs(i) && l(a.get(vs));
          break;
      }
  }
  Df();
}
function Mw(i, e) {
  const n = _c.get(i);
  return n && n.get(e);
}
function Ns(i) {
  const e = et(i);
  return e === i ? e : (gn(e, "iterate", yl), Ln(i) ? e : e.map(qi));
}
function od(i) {
  return gn(i = et(i), "iterate", yl), i;
}
function ko(i, e) {
  return Ki(i) ? Hi(i) ? ga(qi(e)) : ga(e) : qi(e);
}
const Pw = {
  __proto__: null,
  [Symbol.iterator]() {
    return Vd(this, Symbol.iterator, (i) => ko(this, i));
  },
  concat(...i) {
    return Ns(this).concat(
      ...i.map((e) => We(e) ? Ns(e) : e)
    );
  },
  entries() {
    return Vd(this, "entries", (i) => (i[1] = ko(this, i[1]), i));
  },
  every(i, e) {
    return Pr(this, "every", i, e, void 0, arguments);
  },
  filter(i, e) {
    return Pr(
      this,
      "filter",
      i,
      e,
      (n) => n.map((r) => ko(this, r)),
      arguments
    );
  },
  find(i, e) {
    return Pr(
      this,
      "find",
      i,
      e,
      (n) => ko(this, n),
      arguments
    );
  },
  findIndex(i, e) {
    return Pr(this, "findIndex", i, e, void 0, arguments);
  },
  findLast(i, e) {
    return Pr(
      this,
      "findLast",
      i,
      e,
      (n) => ko(this, n),
      arguments
    );
  },
  findLastIndex(i, e) {
    return Pr(this, "findLastIndex", i, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(i, e) {
    return Pr(this, "forEach", i, e, void 0, arguments);
  },
  includes(...i) {
    return Fd(this, "includes", i);
  },
  indexOf(...i) {
    return Fd(this, "indexOf", i);
  },
  join(i) {
    return Ns(this).join(i);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...i) {
    return Fd(this, "lastIndexOf", i);
  },
  map(i, e) {
    return Pr(this, "map", i, e, void 0, arguments);
  },
  pop() {
    return Ia(this, "pop");
  },
  push(...i) {
    return Ia(this, "push", i);
  },
  reduce(i, ...e) {
    return Bp(this, "reduce", i, e);
  },
  reduceRight(i, ...e) {
    return Bp(this, "reduceRight", i, e);
  },
  shift() {
    return Ia(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(i, e) {
    return Pr(this, "some", i, e, void 0, arguments);
  },
  splice(...i) {
    return Ia(this, "splice", i);
  },
  toReversed() {
    return Ns(this).toReversed();
  },
  toSorted(i) {
    return Ns(this).toSorted(i);
  },
  toSpliced(...i) {
    return Ns(this).toSpliced(...i);
  },
  unshift(...i) {
    return Ia(this, "unshift", i);
  },
  values() {
    return Vd(this, "values", (i) => ko(this, i));
  }
};
function Vd(i, e, n) {
  const r = od(i), o = r[e]();
  return r !== i && !Ln(i) && (o._next = o.next, o.next = () => {
    const s = o._next();
    return s.done || (s.value = n(s.value)), s;
  }), o;
}
const Iw = Array.prototype;
function Pr(i, e, n, r, o, s) {
  const a = od(i), l = a !== i && !Ln(i), u = a[e];
  if (u !== Iw[e]) {
    const h = u.apply(i, s);
    return l ? qi(h) : h;
  }
  let c = n;
  a !== i && (l ? c = function(h, p) {
    return n.call(this, ko(i, h), p, i);
  } : n.length > 2 && (c = function(h, p) {
    return n.call(this, h, p, i);
  }));
  const d = u.call(a, c, r);
  return l && o ? o(d) : d;
}
function Bp(i, e, n, r) {
  const o = od(i);
  let s = n;
  return o !== i && (Ln(i) ? n.length > 3 && (s = function(a, l, u) {
    return n.call(this, a, l, u, i);
  }) : s = function(a, l, u) {
    return n.call(this, a, ko(i, l), u, i);
  }), o[e](s, ...r);
}
function Fd(i, e, n) {
  const r = et(i);
  gn(r, "iterate", yl);
  const o = r[e](...n);
  return (o === -1 || o === !1) && ma(n[0]) ? (n[0] = et(n[0]), r[e](...n)) : o;
}
function Ia(i, e, n = []) {
  Xi(), Tf();
  const r = et(i)[e].apply(i, n);
  return Df(), Yi(), r;
}
const Lw = /* @__PURE__ */ so("__proto__,__v_isRef,__isVue"), yy = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((i) => i !== "arguments" && i !== "caller").map((i) => Symbol[i]).filter(Gi)
);
function Aw(i) {
  Gi(i) || (i = String(i));
  const e = et(this);
  return gn(e, "has", i), e.hasOwnProperty(i);
}
class by {
  constructor(e = !1, n = !1) {
    this._isReadonly = e, this._isShallow = n;
  }
  get(e, n, r) {
    if (n === "__v_skip") return e.__v_skip;
    const o = this._isReadonly, s = this._isShallow;
    if (n === "__v_isReactive")
      return !o;
    if (n === "__v_isReadonly")
      return o;
    if (n === "__v_isShallow")
      return s;
    if (n === "__v_raw")
      return r === (o ? s ? ky : Cy : s ? Sy : xy).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(r) ? e : void 0;
    const a = We(e);
    if (!o) {
      let u;
      if (a && (u = Pw[n]))
        return u;
      if (n === "hasOwnProperty")
        return Aw;
    }
    const l = Reflect.get(
      e,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      At(e) ? e : r
    );
    if ((Gi(n) ? yy.has(n) : Lw(n)) || (o || gn(e, "get", n), s))
      return l;
    if (At(l)) {
      const u = a && nd(n) ? l : l.value;
      return o && wt(u) ? xc(u) : u;
    }
    return wt(l) ? o ? xc(l) : zo(l) : l;
  }
}
class wy extends by {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, n, r, o) {
    let s = e[n];
    const a = We(e) && nd(n);
    if (!this._isShallow) {
      const c = Ki(s);
      if (!Ln(r) && !Ki(r) && (s = et(s), r = et(r)), !a && At(s) && !At(r))
        return c ? (process.env.NODE_ENV !== "production" && ci(
          `Set operation on key "${String(n)}" failed: target is readonly.`,
          e[n]
        ), !0) : (s.value = r, !0);
    }
    const l = a ? Number(n) < e.length : xt(e, n), u = Reflect.set(
      e,
      n,
      r,
      At(e) ? e : o
    );
    return e === et(o) && (l ? Vo(r, s) && fr(e, "set", n, r, s) : fr(e, "add", n, r)), u;
  }
  deleteProperty(e, n) {
    const r = xt(e, n), o = e[n], s = Reflect.deleteProperty(e, n);
    return s && r && fr(e, "delete", n, void 0, o), s;
  }
  has(e, n) {
    const r = Reflect.has(e, n);
    return (!Gi(n) || !yy.has(n)) && gn(e, "has", n), r;
  }
  ownKeys(e) {
    return gn(
      e,
      "iterate",
      We(e) ? "length" : vs
    ), Reflect.ownKeys(e);
  }
}
class _y extends by {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, n) {
    return process.env.NODE_ENV !== "production" && ci(
      `Set operation on key "${String(n)}" failed: target is readonly.`,
      e
    ), !0;
  }
  deleteProperty(e, n) {
    return process.env.NODE_ENV !== "production" && ci(
      `Delete operation on key "${String(n)}" failed: target is readonly.`,
      e
    ), !0;
  }
}
const Vw = /* @__PURE__ */ new wy(), Fw = /* @__PURE__ */ new _y(), jw = /* @__PURE__ */ new wy(!0), Rw = /* @__PURE__ */ new _y(!0), xh = (i) => i, vu = (i) => Reflect.getPrototypeOf(i);
function Nw(i, e, n) {
  return function(...r) {
    const o = this.__v_raw, s = et(o), a = gs(s), l = i === "entries" || i === Symbol.iterator && a, u = i === "keys" && a, c = o[i](...r), d = n ? xh : e ? ga : qi;
    return !e && gn(
      s,
      "iterate",
      u ? _h : vs
    ), {
      // iterator protocol
      next() {
        const { value: h, done: p } = c.next();
        return p ? { value: h, done: p } : {
          value: l ? [d(h[0]), d(h[1])] : d(h),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function yu(i) {
  return function(...e) {
    if (process.env.NODE_ENV !== "production") {
      const n = e[0] ? `on key "${e[0]}" ` : "";
      ci(
        `${Os(i)} operation ${n}failed: target is readonly.`,
        et(this)
      );
    }
    return i === "delete" ? !1 : i === "clear" ? void 0 : this;
  };
}
function zw(i, e) {
  const n = {
    get(o) {
      const s = this.__v_raw, a = et(s), l = et(o);
      i || (Vo(o, l) && gn(a, "get", o), gn(a, "get", l));
      const { has: u } = vu(a), c = e ? xh : i ? ga : qi;
      if (u.call(a, o))
        return c(s.get(o));
      if (u.call(a, l))
        return c(s.get(l));
      s !== a && s.get(o);
    },
    get size() {
      const o = this.__v_raw;
      return !i && gn(et(o), "iterate", vs), o.size;
    },
    has(o) {
      const s = this.__v_raw, a = et(s), l = et(o);
      return i || (Vo(o, l) && gn(a, "has", o), gn(a, "has", l)), o === l ? s.has(o) : s.has(o) || s.has(l);
    },
    forEach(o, s) {
      const a = this, l = a.__v_raw, u = et(l), c = e ? xh : i ? ga : qi;
      return !i && gn(u, "iterate", vs), l.forEach((d, h) => o.call(s, c(d), c(h), a));
    }
  };
  return en(
    n,
    i ? {
      add: yu("add"),
      set: yu("set"),
      delete: yu("delete"),
      clear: yu("clear")
    } : {
      add(o) {
        !e && !Ln(o) && !Ki(o) && (o = et(o));
        const s = et(this);
        return vu(s).has.call(s, o) || (s.add(o), fr(s, "add", o, o)), this;
      },
      set(o, s) {
        !e && !Ln(s) && !Ki(s) && (s = et(s));
        const a = et(this), { has: l, get: u } = vu(a);
        let c = l.call(a, o);
        c ? process.env.NODE_ENV !== "production" && Hp(a, l, o) : (o = et(o), c = l.call(a, o));
        const d = u.call(a, o);
        return a.set(o, s), c ? Vo(s, d) && fr(a, "set", o, s, d) : fr(a, "add", o, s), this;
      },
      delete(o) {
        const s = et(this), { has: a, get: l } = vu(s);
        let u = a.call(s, o);
        u ? process.env.NODE_ENV !== "production" && Hp(s, a, o) : (o = et(o), u = a.call(s, o));
        const c = l ? l.call(s, o) : void 0, d = s.delete(o);
        return u && fr(s, "delete", o, void 0, c), d;
      },
      clear() {
        const o = et(this), s = o.size !== 0, a = process.env.NODE_ENV !== "production" ? gs(o) ? new Map(o) : new Set(o) : void 0, l = o.clear();
        return s && fr(
          o,
          "clear",
          void 0,
          void 0,
          a
        ), l;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((o) => {
    n[o] = Nw(o, i, e);
  }), n;
}
function sd(i, e) {
  const n = zw(i, e);
  return (r, o, s) => o === "__v_isReactive" ? !i : o === "__v_isReadonly" ? i : o === "__v_raw" ? r : Reflect.get(
    xt(n, o) && o in r ? n : r,
    o,
    s
  );
}
const Bw = {
  get: /* @__PURE__ */ sd(!1, !1)
}, Hw = {
  get: /* @__PURE__ */ sd(!1, !0)
}, Uw = {
  get: /* @__PURE__ */ sd(!0, !1)
}, Ww = {
  get: /* @__PURE__ */ sd(!0, !0)
};
function Hp(i, e, n) {
  const r = et(n);
  if (r !== n && e.call(i, r)) {
    const o = Of(i);
    ci(
      `Reactive ${o} contains both the raw and reactive versions of the same object${o === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const xy = /* @__PURE__ */ new WeakMap(), Sy = /* @__PURE__ */ new WeakMap(), Cy = /* @__PURE__ */ new WeakMap(), ky = /* @__PURE__ */ new WeakMap();
function Gw(i) {
  switch (i) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Xw(i) {
  return i.__v_skip || !Object.isExtensible(i) ? 0 : Gw(Of(i));
}
function zo(i) {
  return Ki(i) ? i : ad(
    i,
    !1,
    Vw,
    Bw,
    xy
  );
}
function Yw(i) {
  return ad(
    i,
    !1,
    jw,
    Hw,
    Sy
  );
}
function xc(i) {
  return ad(
    i,
    !0,
    Fw,
    Uw,
    Cy
  );
}
function gr(i) {
  return ad(
    i,
    !0,
    Rw,
    Ww,
    ky
  );
}
function ad(i, e, n, r, o) {
  if (!wt(i))
    return process.env.NODE_ENV !== "production" && ci(
      `value cannot be made ${e ? "readonly" : "reactive"}: ${String(
        i
      )}`
    ), i;
  if (i.__v_raw && !(e && i.__v_isReactive))
    return i;
  const s = Xw(i);
  if (s === 0)
    return i;
  const a = o.get(i);
  if (a)
    return a;
  const l = new Proxy(
    i,
    s === 2 ? r : n
  );
  return o.set(i, l), l;
}
function Hi(i) {
  return Ki(i) ? Hi(i.__v_raw) : !!(i && i.__v_isReactive);
}
function Ki(i) {
  return !!(i && i.__v_isReadonly);
}
function Ln(i) {
  return !!(i && i.__v_isShallow);
}
function ma(i) {
  return i ? !!i.__v_raw : !1;
}
function et(i) {
  const e = i && i.__v_raw;
  return e ? et(e) : i;
}
function ji(i) {
  return !xt(i, "__v_skip") && Object.isExtensible(i) && wc(i, "__v_skip", !0), i;
}
const qi = (i) => wt(i) ? zo(i) : i, ga = (i) => wt(i) ? xc(i) : i;
function At(i) {
  return i ? i.__v_isRef === !0 : !1;
}
function re(i) {
  return Kw(i, !1);
}
function Kw(i, e) {
  return At(i) ? i : new qw(i, e);
}
class qw {
  constructor(e, n) {
    this.dep = new Mf(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? e : et(e), this._value = n ? e : qi(e), this.__v_isShallow = n;
  }
  get value() {
    return process.env.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track(), this._value;
  }
  set value(e) {
    const n = this._rawValue, r = this.__v_isShallow || Ln(e) || Ki(e);
    e = r ? e : et(e), Vo(e, n) && (this._rawValue = e, this._value = r ? e : qi(e), process.env.NODE_ENV !== "production" ? this.dep.trigger({
      target: this,
      type: "set",
      key: "value",
      newValue: e,
      oldValue: n
    }) : this.dep.trigger());
  }
}
function ze(i) {
  return At(i) ? i.value : i;
}
const Zw = {
  get: (i, e, n) => e === "__v_raw" ? i : ze(Reflect.get(i, e, n)),
  set: (i, e, n, r) => {
    const o = i[e];
    return At(o) && !At(n) ? (o.value = n, !0) : Reflect.set(i, e, n, r);
  }
};
function Oy(i) {
  return Hi(i) ? i : new Proxy(i, Zw);
}
function Up(i) {
  process.env.NODE_ENV !== "production" && !ma(i) && ci("toRefs() expects a reactive object but received a plain one.");
  const e = We(i) ? new Array(i.length) : {};
  for (const n in i)
    e[n] = Ey(i, n);
  return e;
}
class Jw {
  constructor(e, n, r) {
    this._object = e, this._key = n, this._defaultValue = r, this.__v_isRef = !0, this._value = void 0, this._raw = et(e);
    let o = !0, s = e;
    if (!We(e) || !nd(String(n)))
      do
        o = !ma(s) || Ln(s);
      while (o && (s = s.__v_raw));
    this._shallow = o;
  }
  get value() {
    let e = this._object[this._key];
    return this._shallow && (e = ze(e)), this._value = e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    if (this._shallow && At(this._raw[this._key])) {
      const n = this._object[this._key];
      if (At(n)) {
        n.value = e;
        return;
      }
    }
    this._object[this._key] = e;
  }
  get dep() {
    return Mw(this._raw, this._key);
  }
}
class Qw {
  constructor(e) {
    this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function jd(i, e, n) {
  return At(i) ? i : qe(i) ? new Qw(i) : wt(i) && arguments.length > 1 ? Ey(i, e, n) : re(i);
}
function Ey(i, e, n) {
  return new Jw(i, e, n);
}
class e_ {
  constructor(e, n, r) {
    this.fn = e, this.setter = n, this._value = void 0, this.dep = new Mf(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = vl - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = r;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Ot !== this)
      return hy(this, !0), !0;
    process.env.NODE_ENV;
  }
  get value() {
    const e = process.env.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    return my(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter ? this.setter(e) : process.env.NODE_ENV !== "production" && ci("Write operation failed: computed value is readonly");
  }
}
function t_(i, e, n = !1) {
  let r, o;
  qe(i) ? r = i : (r = i.get, o = i.set);
  const s = new e_(r, o, n);
  return process.env.NODE_ENV, s;
}
const bu = {}, Sc = /* @__PURE__ */ new WeakMap();
let is;
function n_(i, e = !1, n = is) {
  if (n) {
    let r = Sc.get(n);
    r || Sc.set(n, r = []), r.push(i);
  } else process.env.NODE_ENV !== "production" && !e && ci(
    "onWatcherCleanup() was called when there was no active watcher to associate with."
  );
}
function i_(i, e, n = Et) {
  const { immediate: r, deep: o, once: s, scheduler: a, augmentJob: l, call: u } = n, c = (b) => {
    (n.onWarn || ci)(
      "Invalid watch source: ",
      b,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, d = (b) => o ? b : Ln(b) || o === !1 || o === 0 ? Gr(b, 1) : Gr(b);
  let h, p, m, v, y = !1, w = !1;
  if (At(i) ? (p = () => i.value, y = Ln(i)) : Hi(i) ? (p = () => d(i), y = !0) : We(i) ? (w = !0, y = i.some((b) => Hi(b) || Ln(b)), p = () => i.map((b) => {
    if (At(b))
      return b.value;
    if (Hi(b))
      return d(b);
    if (qe(b))
      return u ? u(b, 2) : b();
    process.env.NODE_ENV !== "production" && c(b);
  })) : qe(i) ? e ? p = u ? () => u(i, 2) : i : p = () => {
    if (m) {
      Xi();
      try {
        m();
      } finally {
        Yi();
      }
    }
    const b = is;
    is = h;
    try {
      return u ? u(i, 3, [v]) : i(v);
    } finally {
      is = b;
    }
  } : (p = vn, process.env.NODE_ENV !== "production" && c(i)), e && o) {
    const b = p, C = o === !0 ? 1 / 0 : o;
    p = () => Gr(b(), C);
  }
  const g = uy(), k = () => {
    h.stop(), g && g.active && Cf(g.effects, h);
  };
  if (s && e) {
    const b = e;
    e = (...C) => {
      b(...C), k();
    };
  }
  let _ = w ? new Array(i.length).fill(bu) : bu;
  const S = (b) => {
    if (!(!(h.flags & 1) || !h.dirty && !b))
      if (e) {
        const C = h.run();
        if (o || y || (w ? C.some((x, I) => Vo(x, _[I])) : Vo(C, _))) {
          m && m();
          const x = is;
          is = h;
          try {
            const I = [
              C,
              // pass undefined as the old value when it's changed for the first time
              _ === bu ? void 0 : w && _[0] === bu ? [] : _,
              v
            ];
            _ = C, u ? u(e, 3, I) : (
              // @ts-expect-error
              e(...I)
            );
          } finally {
            is = x;
          }
        }
      } else
        h.run();
  };
  return l && l(S), h = new cy(p), h.scheduler = a ? () => a(S, !1) : S, v = (b) => n_(b, !1, h), m = h.onStop = () => {
    const b = Sc.get(h);
    if (b) {
      if (u)
        u(b, 4);
      else
        for (const C of b) C();
      Sc.delete(h);
    }
  }, process.env.NODE_ENV !== "production" && (h.onTrack = n.onTrack, h.onTrigger = n.onTrigger), e ? r ? S(!0) : _ = h.run() : a ? a(S.bind(null, !0), !0) : h.run(), k.pause = h.pause.bind(h), k.resume = h.resume.bind(h), k.stop = k, k;
}
function Gr(i, e = 1 / 0, n) {
  if (e <= 0 || !wt(i) || i.__v_skip || (n = n || /* @__PURE__ */ new Map(), (n.get(i) || 0) >= e))
    return i;
  if (n.set(i, e), e--, At(i))
    Gr(i.value, e, n);
  else if (We(i))
    for (let r = 0; r < i.length; r++)
      Gr(i[r], e, n);
  else if (xa(i) || gs(i))
    i.forEach((r) => {
      Gr(r, e, n);
    });
  else if (iy(i)) {
    for (const r in i)
      Gr(i[r], e, n);
    for (const r of Object.getOwnPropertySymbols(i))
      Object.prototype.propertyIsEnumerable.call(i, r) && Gr(i[r], e, n);
  }
  return i;
}
/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const ys = [];
function rc(i) {
  ys.push(i);
}
function oc() {
  ys.pop();
}
let Rd = !1;
function Oe(i, ...e) {
  if (Rd) return;
  Rd = !0, Xi();
  const n = ys.length ? ys[ys.length - 1].component : null, r = n && n.appContext.config.warnHandler, o = r_();
  if (r)
    Sa(
      r,
      n,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        i + e.map((s) => {
          var a, l;
          return (l = (a = s.toString) == null ? void 0 : a.call(s)) != null ? l : JSON.stringify(s);
        }).join(""),
        n && n.proxy,
        o.map(
          ({ vnode: s }) => `at <${au(n, s.type)}>`
        ).join(`
`),
        o
      ]
    );
  else {
    const s = [`[Vue warn]: ${i}`, ...e];
    o.length && s.push(`
`, ...o_(o)), console.warn(...s);
  }
  Yi(), Rd = !1;
}
function r_() {
  let i = ys[ys.length - 1];
  if (!i)
    return [];
  const e = [];
  for (; i; ) {
    const n = e[0];
    n && n.vnode === i ? n.recurseCount++ : e.push({
      vnode: i,
      recurseCount: 0
    });
    const r = i.component && i.component.parent;
    i = r && r.vnode;
  }
  return e;
}
function o_(i) {
  const e = [];
  return i.forEach((n, r) => {
    e.push(...r === 0 ? [] : [`
`], ...s_(n));
  }), e;
}
function s_({ vnode: i, recurseCount: e }) {
  const n = e > 0 ? `... (${e} recursive calls)` : "", r = i.component ? i.component.parent == null : !1, o = ` at <${au(
    i.component,
    i.type,
    r
  )}`, s = ">" + n;
  return i.props ? [o, ...a_(i.props), s] : [o + s];
}
function a_(i) {
  const e = [], n = Object.keys(i);
  return n.slice(0, 3).forEach((r) => {
    e.push(...Ty(r, i[r]));
  }), n.length > 3 && e.push(" ..."), e;
}
function Ty(i, e, n) {
  return jt(e) ? (e = JSON.stringify(e), n ? e : [`${i}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? n ? e : [`${i}=${e}`] : At(e) ? (e = Ty(i, et(e.value), !0), n ? e : [`${i}=Ref<`, e, ">"]) : qe(e) ? [`${i}=fn${e.name ? `<${e.name}>` : ""}`] : (e = et(e), n ? e : [`${i}=`, e]);
}
function l_(i, e) {
  process.env.NODE_ENV !== "production" && i !== void 0 && (typeof i != "number" ? Oe(`${e} is not a valid number - got ${JSON.stringify(i)}.`) : isNaN(i) && Oe(`${e} is NaN - the duration expression might be incorrect.`));
}
const Pf = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function Sa(i, e, n, r) {
  try {
    return r ? i(...r) : i();
  } catch (o) {
    nu(o, e, n);
  }
}
function Zi(i, e, n, r) {
  if (qe(i)) {
    const o = Sa(i, e, n, r);
    return o && kf(o) && o.catch((s) => {
      nu(s, e, n);
    }), o;
  }
  if (We(i)) {
    const o = [];
    for (let s = 0; s < i.length; s++)
      o.push(Zi(i[s], e, n, r));
    return o;
  } else process.env.NODE_ENV !== "production" && Oe(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof i}`
  );
}
function nu(i, e, n, r = !0) {
  const o = e ? e.vnode : null, { errorHandler: s, throwUnhandledErrorInProduction: a } = e && e.appContext.config || Et;
  if (e) {
    let l = e.parent;
    const u = e.proxy, c = process.env.NODE_ENV !== "production" ? Pf[n] : `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; l; ) {
      const d = l.ec;
      if (d) {
        for (let h = 0; h < d.length; h++)
          if (d[h](i, u, c) === !1)
            return;
      }
      l = l.parent;
    }
    if (s) {
      Xi(), Sa(s, null, 10, [
        i,
        u,
        c
      ]), Yi();
      return;
    }
  }
  u_(i, n, o, r, a);
}
function u_(i, e, n, r = !0, o = !1) {
  if (process.env.NODE_ENV !== "production") {
    const s = Pf[e];
    if (n && rc(n), Oe(`Unhandled error${s ? ` during execution of ${s}` : ""}`), n && oc(), r)
      throw i;
    console.error(i);
  } else {
    if (o)
      throw i;
    console.error(i);
  }
}
const zn = [];
let cr = -1;
const la = [];
let Oo = null, qs = 0;
const Dy = /* @__PURE__ */ Promise.resolve();
let Cc = null;
const c_ = 100;
function Es(i) {
  const e = Cc || Dy;
  return i ? e.then(this ? i.bind(this) : i) : e;
}
function d_(i) {
  let e = cr + 1, n = zn.length;
  for (; e < n; ) {
    const r = e + n >>> 1, o = zn[r], s = bl(o);
    s < i || s === i && o.flags & 2 ? e = r + 1 : n = r;
  }
  return e;
}
function ld(i) {
  if (!(i.flags & 1)) {
    const e = bl(i), n = zn[zn.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(i.flags & 2) && e >= bl(n) ? zn.push(i) : zn.splice(d_(e), 0, i), i.flags |= 1, $y();
  }
}
function $y() {
  Cc || (Cc = Dy.then(Iy));
}
function My(i) {
  We(i) ? la.push(...i) : Oo && i.id === -1 ? Oo.splice(qs + 1, 0, i) : i.flags & 1 || (la.push(i), i.flags |= 1), $y();
}
function Wp(i, e, n = cr + 1) {
  for (process.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()); n < zn.length; n++) {
    const r = zn[n];
    if (r && r.flags & 2) {
      if (i && r.id !== i.uid || process.env.NODE_ENV !== "production" && If(e, r))
        continue;
      zn.splice(n, 1), n--, r.flags & 4 && (r.flags &= -2), r(), r.flags & 4 || (r.flags &= -2);
    }
  }
}
function Py(i) {
  if (la.length) {
    const e = [...new Set(la)].sort(
      (n, r) => bl(n) - bl(r)
    );
    if (la.length = 0, Oo) {
      Oo.push(...e);
      return;
    }
    for (Oo = e, process.env.NODE_ENV !== "production" && (i = i || /* @__PURE__ */ new Map()), qs = 0; qs < Oo.length; qs++) {
      const n = Oo[qs];
      process.env.NODE_ENV !== "production" && If(i, n) || (n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2);
    }
    Oo = null, qs = 0;
  }
}
const bl = (i) => i.id == null ? i.flags & 2 ? -1 : 1 / 0 : i.id;
function Iy(i) {
  process.env.NODE_ENV !== "production" && (i = i || /* @__PURE__ */ new Map());
  const e = process.env.NODE_ENV !== "production" ? (n) => If(i, n) : vn;
  try {
    for (cr = 0; cr < zn.length; cr++) {
      const n = zn[cr];
      if (n && !(n.flags & 8)) {
        if (process.env.NODE_ENV !== "production" && e(n))
          continue;
        n.flags & 4 && (n.flags &= -2), Sa(
          n,
          n.i,
          n.i ? 15 : 14
        ), n.flags & 4 || (n.flags &= -2);
      }
    }
  } finally {
    for (; cr < zn.length; cr++) {
      const n = zn[cr];
      n && (n.flags &= -2);
    }
    cr = -1, zn.length = 0, Py(i), Cc = null, (zn.length || la.length) && Iy(i);
  }
}
function If(i, e) {
  const n = i.get(e) || 0;
  if (n > c_) {
    const r = e.i, o = r && Hf(r.type);
    return nu(
      `Maximum recursive updates exceeded${o ? ` in component <${o}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    ), !0;
  }
  return i.set(e, n + 1), !1;
}
let Ri = !1;
const sc = /* @__PURE__ */ new Map();
process.env.NODE_ENV !== "production" && (eu().__VUE_HMR_RUNTIME__ = {
  createRecord: Nd(Ly),
  rerender: Nd(p_),
  reload: Nd(m_)
});
const Ts = /* @__PURE__ */ new Map();
function h_(i) {
  const e = i.type.__hmrId;
  let n = Ts.get(e);
  n || (Ly(e, i.type), n = Ts.get(e)), n.instances.add(i);
}
function f_(i) {
  Ts.get(i.type.__hmrId).instances.delete(i);
}
function Ly(i, e) {
  return Ts.has(i) ? !1 : (Ts.set(i, {
    initialDef: kc(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function kc(i) {
  return S0(i) ? i.__vccOpts : i;
}
function p_(i, e) {
  const n = Ts.get(i);
  n && (n.initialDef.render = e, [...n.instances].forEach((r) => {
    e && (r.render = e, kc(r.type).render = e), r.renderCache = [], Ri = !0, r.job.flags & 8 || r.update(), Ri = !1;
  }));
}
function m_(i, e) {
  const n = Ts.get(i);
  if (!n) return;
  e = kc(e), Gp(n.initialDef, e);
  const r = [...n.instances];
  for (let o = 0; o < r.length; o++) {
    const s = r[o], a = kc(s.type);
    let l = sc.get(a);
    l || (a !== n.initialDef && Gp(a, e), sc.set(a, l = /* @__PURE__ */ new Set())), l.add(s), s.appContext.propsCache.delete(s.type), s.appContext.emitsCache.delete(s.type), s.appContext.optionsCache.delete(s.type), s.ceReload ? (l.add(s), s.ceReload(e.styles), l.delete(s)) : s.parent ? ld(() => {
      s.job.flags & 8 || (Ri = !0, s.parent.update(), Ri = !1, l.delete(s));
    }) : s.appContext.reload ? s.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    ), s.root.ce && s !== s.root && s.root.ce._removeChildStyle(a);
  }
  My(() => {
    sc.clear();
  });
}
function Gp(i, e) {
  en(i, e);
  for (const n in i)
    n !== "__file" && !(n in e) && delete i[n];
}
function Nd(i) {
  return (e, n) => {
    try {
      return i(e, n);
    } catch (r) {
      console.error(r), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let Vi, Ya = [], Sh = !1;
function iu(i, ...e) {
  Vi ? Vi.emit(i, ...e) : Sh || Ya.push({ event: i, args: e });
}
function Lf(i, e) {
  var n, r;
  Vi = i, Vi ? (Vi.enabled = !0, Ya.forEach(({ event: o, args: s }) => Vi.emit(o, ...s)), Ya = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((r = (n = window.navigator) == null ? void 0 : n.userAgent) != null && r.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((s) => {
    Lf(s, e);
  }), setTimeout(() => {
    Vi || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Sh = !0, Ya = []);
  }, 3e3)) : (Sh = !0, Ya = []);
}
function g_(i, e) {
  iu("app:init", i, e, {
    Fragment: Fe,
    Text: ou,
    Comment: ln,
    Static: al
  });
}
function v_(i) {
  iu("app:unmount", i);
}
const y_ = /* @__PURE__ */ Af(
  "component:added"
  /* COMPONENT_ADDED */
), Ay = /* @__PURE__ */ Af(
  "component:updated"
  /* COMPONENT_UPDATED */
), b_ = /* @__PURE__ */ Af(
  "component:removed"
  /* COMPONENT_REMOVED */
), w_ = (i) => {
  Vi && typeof Vi.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !Vi.cleanupBuffer(i) && b_(i);
};
// @__NO_SIDE_EFFECTS__
function Af(i) {
  return (e) => {
    iu(
      i,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
const __ = /* @__PURE__ */ Vy(
  "perf:start"
  /* PERFORMANCE_START */
), x_ = /* @__PURE__ */ Vy(
  "perf:end"
  /* PERFORMANCE_END */
);
function Vy(i) {
  return (e, n, r) => {
    iu(i, e.appContext.app, e.uid, e, n, r);
  };
}
function S_(i, e, n) {
  iu(
    "component:emit",
    i.appContext.app,
    i,
    e,
    n
  );
}
let pn = null, Fy = null;
function Oc(i) {
  const e = pn;
  return pn = i, Fy = i && i.type.__scopeId || null, e;
}
function Wt(i, e = pn, n) {
  if (!e || i._n)
    return i;
  const r = (...o) => {
    r._d && Pc(-1);
    const s = Oc(e);
    let a;
    try {
      a = i(...o);
    } finally {
      Oc(s), r._d && Pc(1);
    }
    return process.env.NODE_ENV !== "production" && Ay(e), a;
  };
  return r._n = !0, r._c = !0, r._d = !0, r;
}
function jy(i) {
  cw(i) && Oe("Do not use built-in directive ids as custom directive id: " + i);
}
function ot(i, e) {
  if (pn === null)
    return process.env.NODE_ENV !== "production" && Oe("withDirectives can only be used inside render functions."), i;
  const n = dd(pn), r = i.dirs || (i.dirs = []);
  for (let o = 0; o < e.length; o++) {
    let [s, a, l, u = Et] = e[o];
    s && (qe(s) && (s = {
      mounted: s,
      updated: s
    }), s.deep && Gr(a), r.push({
      dir: s,
      instance: n,
      value: a,
      oldValue: void 0,
      arg: l,
      modifiers: u
    }));
  }
  return i;
}
function Zo(i, e, n, r) {
  const o = i.dirs, s = e && e.dirs;
  for (let a = 0; a < o.length; a++) {
    const l = o[a];
    s && (l.oldValue = s[a].value);
    let u = l.dir[r];
    u && (Xi(), Zi(u, n, 8, [
      i.el,
      l,
      i,
      e
    ]), Yi());
  }
}
const Ry = Symbol("_vte"), Ny = (i) => i.__isTeleport, bs = (i) => i && (i.disabled || i.disabled === ""), Xp = (i) => i && (i.defer || i.defer === ""), Yp = (i) => typeof SVGElement < "u" && i instanceof SVGElement, Kp = (i) => typeof MathMLElement == "function" && i instanceof MathMLElement, Ch = (i, e) => {
  const n = i && i.to;
  if (jt(n))
    if (e) {
      const r = e(n);
      return process.env.NODE_ENV !== "production" && !r && !bs(i) && Oe(
        `Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), r;
    } else
      return process.env.NODE_ENV !== "production" && Oe(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return process.env.NODE_ENV !== "production" && !n && !bs(i) && Oe(`Invalid Teleport target: ${n}`), n;
}, zy = {
  name: "Teleport",
  __isTeleport: !0,
  process(i, e, n, r, o, s, a, l, u, c) {
    const {
      mc: d,
      pc: h,
      pbc: p,
      o: { insert: m, querySelector: v, createText: y, createComment: w }
    } = c, g = bs(e.props);
    let { shapeFlag: k, children: _, dynamicChildren: S } = e;
    if (process.env.NODE_ENV !== "production" && Ri && (u = !1, S = null), i == null) {
      const b = e.el = process.env.NODE_ENV !== "production" ? w("teleport start") : y(""), C = e.anchor = process.env.NODE_ENV !== "production" ? w("teleport end") : y("");
      m(b, n, r), m(C, n, r);
      const x = (F, B) => {
        k & 16 && d(
          _,
          F,
          B,
          o,
          s,
          a,
          l,
          u
        );
      }, I = () => {
        const F = e.target = Ch(e.props, v), B = By(F, e, y, m);
        F ? (a !== "svg" && Yp(F) ? a = "svg" : a !== "mathml" && Kp(F) && (a = "mathml"), o && o.isCE && (o.ce._teleportTargets || (o.ce._teleportTargets = /* @__PURE__ */ new Set())).add(F), g || (x(F, B), ac(e, !1))) : process.env.NODE_ENV !== "production" && !g && Oe(
          "Invalid Teleport target on mount:",
          F,
          `(${typeof F})`
        );
      };
      g && (x(n, C), ac(e, !0)), Xp(e.props) ? (e.el.__isMounted = !1, Rn(() => {
        I(), delete e.el.__isMounted;
      }, s)) : I();
    } else {
      if (Xp(e.props) && i.el.__isMounted === !1) {
        Rn(() => {
          zy.process(
            i,
            e,
            n,
            r,
            o,
            s,
            a,
            l,
            u,
            c
          );
        }, s);
        return;
      }
      e.el = i.el, e.targetStart = i.targetStart;
      const b = e.anchor = i.anchor, C = e.target = i.target, x = e.targetAnchor = i.targetAnchor, I = bs(i.props), F = I ? n : C, B = I ? b : x;
      if (a === "svg" || Yp(C) ? a = "svg" : (a === "mathml" || Kp(C)) && (a = "mathml"), S ? (p(
        i.dynamicChildren,
        S,
        F,
        o,
        s,
        a,
        l
      ), sl(i, e, process.env.NODE_ENV === "production")) : u || h(
        i,
        e,
        F,
        B,
        o,
        s,
        a,
        l,
        !1
      ), g)
        I ? e.props && i.props && e.props.to !== i.props.to && (e.props.to = i.props.to) : wu(
          e,
          n,
          b,
          c,
          1
        );
      else if ((e.props && e.props.to) !== (i.props && i.props.to)) {
        const X = e.target = Ch(
          e.props,
          v
        );
        X ? wu(
          e,
          X,
          null,
          c,
          0
        ) : process.env.NODE_ENV !== "production" && Oe(
          "Invalid Teleport target on update:",
          C,
          `(${typeof C})`
        );
      } else I && wu(
        e,
        C,
        x,
        c,
        1
      );
      ac(e, g);
    }
  },
  remove(i, e, n, { um: r, o: { remove: o } }, s) {
    const {
      shapeFlag: a,
      children: l,
      anchor: u,
      targetStart: c,
      targetAnchor: d,
      target: h,
      props: p
    } = i;
    if (h && (o(c), o(d)), s && o(u), a & 16) {
      const m = s || !bs(p);
      for (let v = 0; v < l.length; v++) {
        const y = l[v];
        r(
          y,
          e,
          n,
          m,
          !!y.dynamicChildren
        );
      }
    }
  },
  move: wu,
  hydrate: C_
};
function wu(i, e, n, { o: { insert: r }, m: o }, s = 2) {
  s === 0 && r(i.targetAnchor, e, n);
  const { el: a, anchor: l, shapeFlag: u, children: c, props: d } = i, h = s === 2;
  if (h && r(a, e, n), (!h || bs(d)) && u & 16)
    for (let p = 0; p < c.length; p++)
      o(
        c[p],
        e,
        n,
        2
      );
  h && r(l, e, n);
}
function C_(i, e, n, r, o, s, {
  o: { nextSibling: a, parentNode: l, querySelector: u, insert: c, createText: d }
}, h) {
  function p(y, w, g, k) {
    w.anchor = h(
      a(y),
      w,
      l(y),
      n,
      r,
      o,
      s
    ), w.targetStart = g, w.targetAnchor = k;
  }
  const m = e.target = Ch(
    e.props,
    u
  ), v = bs(e.props);
  if (m) {
    const y = m._lpa || m.firstChild;
    if (e.shapeFlag & 16)
      if (v)
        p(
          i,
          e,
          y,
          y && a(y)
        );
      else {
        e.anchor = a(i);
        let w = y;
        for (; w; ) {
          if (w && w.nodeType === 8) {
            if (w.data === "teleport start anchor")
              e.targetStart = w;
            else if (w.data === "teleport anchor") {
              e.targetAnchor = w, m._lpa = e.targetAnchor && a(e.targetAnchor);
              break;
            }
          }
          w = a(w);
        }
        e.targetAnchor || By(m, e, d, c), h(
          y && a(y),
          e,
          m,
          n,
          r,
          o,
          s
        );
      }
    ac(e, v);
  } else v && e.shapeFlag & 16 && p(i, e, i, a(i));
  return e.anchor && a(e.anchor);
}
const k_ = zy;
function ac(i, e) {
  const n = i.ctx;
  if (n && n.ut) {
    let r, o;
    for (e ? (r = i.el, o = i.anchor) : (r = i.targetStart, o = i.targetAnchor); r && r !== o; )
      r.nodeType === 1 && r.setAttribute("data-v-owner", n.uid), r = r.nextSibling;
    n.ut();
  }
}
function By(i, e, n, r) {
  const o = e.targetStart = n(""), s = e.targetAnchor = n("");
  return o[Ry] = s, i && (r(o, i), r(s, i)), s;
}
const zr = Symbol("_leaveCb"), _u = Symbol("_enterCb");
function O_() {
  const i = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return Wn(() => {
    i.isMounted = !0;
  }), qy(() => {
    i.isUnmounting = !0;
  }), i;
}
const fi = [Function, Array], Hy = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: fi,
  onEnter: fi,
  onAfterEnter: fi,
  onEnterCancelled: fi,
  // leave
  onBeforeLeave: fi,
  onLeave: fi,
  onAfterLeave: fi,
  onLeaveCancelled: fi,
  // appear
  onBeforeAppear: fi,
  onAppear: fi,
  onAfterAppear: fi,
  onAppearCancelled: fi
}, Uy = (i) => {
  const e = i.subTree;
  return e.component ? Uy(e.component) : e;
}, E_ = {
  name: "BaseTransition",
  props: Hy,
  setup(i, { slots: e }) {
    const n = jo(), r = O_();
    return () => {
      const o = e.default && Xy(e.default(), !0);
      if (!o || !o.length)
        return;
      const s = Wy(o), a = et(i), { mode: l } = a;
      if (process.env.NODE_ENV !== "production" && l && l !== "in-out" && l !== "out-in" && l !== "default" && Oe(`invalid <transition> mode: ${l}`), r.isLeaving)
        return zd(s);
      const u = qp(s);
      if (!u)
        return zd(s);
      let c = kh(
        u,
        a,
        r,
        n,
        // #11061, ensure enterHooks is fresh after clone
        (h) => c = h
      );
      u.type !== ln && wl(u, c);
      let d = n.subTree && qp(n.subTree);
      if (d && d.type !== ln && !ss(d, u) && Uy(n).type !== ln) {
        let h = kh(
          d,
          a,
          r,
          n
        );
        if (wl(d, h), l === "out-in" && u.type !== ln)
          return r.isLeaving = !0, h.afterLeave = () => {
            r.isLeaving = !1, n.job.flags & 8 || n.update(), delete h.afterLeave, d = void 0;
          }, zd(s);
        l === "in-out" && u.type !== ln ? h.delayLeave = (p, m, v) => {
          const y = Gy(
            r,
            d
          );
          y[String(d.key)] = d, p[zr] = () => {
            m(), p[zr] = void 0, delete c.delayedLeave, d = void 0;
          }, c.delayedLeave = () => {
            v(), delete c.delayedLeave, d = void 0;
          };
        } : d = void 0;
      } else d && (d = void 0);
      return s;
    };
  }
};
function Wy(i) {
  let e = i[0];
  if (i.length > 1) {
    let n = !1;
    for (const r of i)
      if (r.type !== ln) {
        if (process.env.NODE_ENV !== "production" && n) {
          Oe(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        if (e = r, n = !0, process.env.NODE_ENV === "production") break;
      }
  }
  return e;
}
const T_ = E_;
function Gy(i, e) {
  const { leavingVNodes: n } = i;
  let r = n.get(e.type);
  return r || (r = /* @__PURE__ */ Object.create(null), n.set(e.type, r)), r;
}
function kh(i, e, n, r, o) {
  const {
    appear: s,
    mode: a,
    persisted: l = !1,
    onBeforeEnter: u,
    onEnter: c,
    onAfterEnter: d,
    onEnterCancelled: h,
    onBeforeLeave: p,
    onLeave: m,
    onAfterLeave: v,
    onLeaveCancelled: y,
    onBeforeAppear: w,
    onAppear: g,
    onAfterAppear: k,
    onAppearCancelled: _
  } = e, S = String(i.key), b = Gy(n, i), C = (F, B) => {
    F && Zi(
      F,
      r,
      9,
      B
    );
  }, x = (F, B) => {
    const X = B[1];
    C(F, B), We(F) ? F.every((j) => j.length <= 1) && X() : F.length <= 1 && X();
  }, I = {
    mode: a,
    persisted: l,
    beforeEnter(F) {
      let B = u;
      if (!n.isMounted)
        if (s)
          B = w || u;
        else
          return;
      F[zr] && F[zr](
        !0
        /* cancelled */
      );
      const X = b[S];
      X && ss(i, X) && X.el[zr] && X.el[zr](), C(B, [F]);
    },
    enter(F) {
      let B = c, X = d, j = h;
      if (!n.isMounted)
        if (s)
          B = g || c, X = k || d, j = _ || h;
        else
          return;
      let ee = !1;
      const ie = F[_u] = (M) => {
        ee || (ee = !0, M ? C(j, [F]) : C(X, [F]), I.delayedLeave && I.delayedLeave(), F[_u] = void 0);
      };
      B ? x(B, [F, ie]) : ie();
    },
    leave(F, B) {
      const X = String(i.key);
      if (F[_u] && F[_u](
        !0
        /* cancelled */
      ), n.isUnmounting)
        return B();
      C(p, [F]);
      let j = !1;
      const ee = F[zr] = (ie) => {
        j || (j = !0, B(), ie ? C(y, [F]) : C(v, [F]), F[zr] = void 0, b[X] === i && delete b[X]);
      };
      b[X] = i, m ? x(m, [F, ee]) : ee();
    },
    clone(F) {
      const B = kh(
        F,
        e,
        n,
        r,
        o
      );
      return o && o(B), B;
    }
  };
  return I;
}
function zd(i) {
  if (ru(i))
    return i = xr(i), i.children = null, i;
}
function qp(i) {
  if (!ru(i))
    return Ny(i.type) && i.children ? Wy(i.children) : i;
  if (i.component)
    return i.component.subTree;
  const { shapeFlag: e, children: n } = i;
  if (n) {
    if (e & 16)
      return n[0];
    if (e & 32 && qe(n.default))
      return n.default();
  }
}
function wl(i, e) {
  i.shapeFlag & 6 && i.component ? (i.transition = e, wl(i.component.subTree, e)) : i.shapeFlag & 128 ? (i.ssContent.transition = e.clone(i.ssContent), i.ssFallback.transition = e.clone(i.ssFallback)) : i.transition = e;
}
function Xy(i, e = !1, n) {
  let r = [], o = 0;
  for (let s = 0; s < i.length; s++) {
    let a = i[s];
    const l = n == null ? a.key : String(n) + String(a.key != null ? a.key : s);
    a.type === Fe ? (a.patchFlag & 128 && o++, r = r.concat(
      Xy(a.children, e, l)
    )) : (e || a.type !== ln) && r.push(l != null ? xr(a, { key: l }) : a);
  }
  if (o > 1)
    for (let s = 0; s < r.length; s++)
      r[s].patchFlag = -2;
  return r;
}
// @__NO_SIDE_EFFECTS__
function tn(i, e) {
  return qe(i) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    en({ name: i.name }, e, { setup: i })
  ) : i;
}
function D_() {
  const i = jo();
  return i ? (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++ : (process.env.NODE_ENV !== "production" && Oe(
    "useId() is called when there is no active component instance to be associated with."
  ), "");
}
function Yy(i) {
  i.ids = [i.ids[0] + i.ids[2]++ + "-", 0, 0];
}
const Zp = /* @__PURE__ */ new WeakSet(), Ec = /* @__PURE__ */ new WeakMap();
function rl(i, e, n, r, o = !1) {
  if (We(i)) {
    i.forEach(
      (y, w) => rl(
        y,
        e && (We(e) ? e[w] : e),
        n,
        r,
        o
      )
    );
    return;
  }
  if (ua(r) && !o) {
    r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && rl(i, e, n, r.component.subTree);
    return;
  }
  const s = r.shapeFlag & 4 ? dd(r.component) : r.el, a = o ? null : s, { i: l, r: u } = i;
  if (process.env.NODE_ENV !== "production" && !l) {
    Oe(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const c = e && e.r, d = l.refs === Et ? l.refs = {} : l.refs, h = l.setupState, p = et(h), m = h === Et ? ty : (y) => process.env.NODE_ENV !== "production" && (xt(p, y) && !At(p[y]) && Oe(
    `Template ref "${y}" used on a non-ref value. It will not work in the production build.`
  ), Zp.has(p[y])) ? !1 : xt(p, y), v = (y) => process.env.NODE_ENV === "production" || !Zp.has(y);
  if (c != null && c !== u) {
    if (Jp(e), jt(c))
      d[c] = null, m(c) && (h[c] = null);
    else if (At(c)) {
      v(c) && (c.value = null);
      const y = e;
      y.k && (d[y.k] = null);
    }
  }
  if (qe(u))
    Sa(u, l, 12, [a, d]);
  else {
    const y = jt(u), w = At(u);
    if (y || w) {
      const g = () => {
        if (i.f) {
          const k = y ? m(u) ? h[u] : d[u] : v(u) || !i.k ? u.value : d[i.k];
          if (o)
            We(k) && Cf(k, s);
          else if (We(k))
            k.includes(s) || k.push(s);
          else if (y)
            d[u] = [s], m(u) && (h[u] = d[u]);
          else {
            const _ = [s];
            v(u) && (u.value = _), i.k && (d[i.k] = _);
          }
        } else y ? (d[u] = a, m(u) && (h[u] = a)) : w ? (v(u) && (u.value = a), i.k && (d[i.k] = a)) : process.env.NODE_ENV !== "production" && Oe("Invalid template ref type:", u, `(${typeof u})`);
      };
      if (a) {
        const k = () => {
          g(), Ec.delete(i);
        };
        k.id = -1, Ec.set(i, k), Rn(k, n);
      } else
        Jp(i), g();
    } else process.env.NODE_ENV !== "production" && Oe("Invalid template ref type:", u, `(${typeof u})`);
  }
}
function Jp(i) {
  const e = Ec.get(i);
  e && (e.flags |= 8, Ec.delete(i));
}
eu().requestIdleCallback;
eu().cancelIdleCallback;
const ua = (i) => !!i.type.__asyncLoader, ru = (i) => i.type.__isKeepAlive;
function $_(i, e) {
  Ky(i, "a", e);
}
function M_(i, e) {
  Ky(i, "da", e);
}
function Ky(i, e, n = hn) {
  const r = i.__wdc || (i.__wdc = () => {
    let o = n;
    for (; o; ) {
      if (o.isDeactivated)
        return;
      o = o.parent;
    }
    return i();
  });
  if (ud(e, r, n), n) {
    let o = n.parent;
    for (; o && o.parent; )
      ru(o.parent.vnode) && P_(r, e, n, o), o = o.parent;
  }
}
function P_(i, e, n, r) {
  const o = ud(
    e,
    i,
    r,
    !0
    /* prepend */
  );
  Qi(() => {
    Cf(r[e], o);
  }, n);
}
function ud(i, e, n = hn, r = !1) {
  if (n) {
    const o = n[i] || (n[i] = []), s = e.__weh || (e.__weh = (...a) => {
      Xi();
      const l = su(n), u = Zi(e, n, i, a);
      return l(), Yi(), u;
    });
    return r ? o.unshift(s) : o.push(s), s;
  } else if (process.env.NODE_ENV !== "production") {
    const o = Co(Pf[i].replace(/ hook$/, ""));
    Oe(
      `${o} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const ao = (i) => (e, n = hn) => {
  (!xl || i === "sp") && ud(i, (...r) => e(...r), n);
}, I_ = ao("bm"), Wn = ao("m"), L_ = ao(
  "bu"
), A_ = ao("u"), qy = ao(
  "bum"
), Qi = ao("um"), V_ = ao(
  "sp"
), F_ = ao("rtg"), j_ = ao("rtc");
function R_(i, e = hn) {
  ud("ec", i, e);
}
const Tc = "components", N_ = "directives";
function Tn(i, e) {
  return Ff(Tc, i, !0, e) || i;
}
const Zy = Symbol.for("v-ndc");
function vr(i) {
  return jt(i) ? Ff(Tc, i, !1) || i : i || Zy;
}
function Vf(i) {
  return Ff(N_, i);
}
function Ff(i, e, n = !0, r = !1) {
  const o = pn || hn;
  if (o) {
    const s = o.type;
    if (i === Tc) {
      const l = Hf(
        s,
        !1
      );
      if (l && (l === e || l === Hn(e) || l === Os(Hn(e))))
        return s;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      Qp(o[i] || s[i], e) || // global registration
      Qp(o.appContext[i], e)
    );
    if (!a && r)
      return s;
    if (process.env.NODE_ENV !== "production" && n && !a) {
      const l = i === Tc ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      Oe(`Failed to resolve ${i.slice(0, -1)}: ${e}${l}`);
    }
    return a;
  } else process.env.NODE_ENV !== "production" && Oe(
    `resolve${Os(i.slice(0, -1))} can only be used in render() or setup().`
  );
}
function Qp(i, e) {
  return i && (i[e] || i[Hn(e)] || i[Os(Hn(e))]);
}
function Ke(i, e, n, r) {
  let o;
  const s = n, a = We(i);
  if (a || jt(i)) {
    const l = a && Hi(i);
    let u = !1, c = !1;
    l && (u = !Ln(i), c = Ki(i), i = od(i)), o = new Array(i.length);
    for (let d = 0, h = i.length; d < h; d++)
      o[d] = e(
        u ? c ? ga(qi(i[d])) : qi(i[d]) : i[d],
        d,
        void 0,
        s
      );
  } else if (typeof i == "number") {
    process.env.NODE_ENV !== "production" && !Number.isInteger(i) && Oe(`The v-for range expect an integer value but got ${i}.`), o = new Array(i);
    for (let l = 0; l < i; l++)
      o[l] = e(l + 1, l, void 0, s);
  } else if (wt(i))
    if (i[Symbol.iterator])
      o = Array.from(
        i,
        (l, u) => e(l, u, void 0, s)
      );
    else {
      const l = Object.keys(i);
      o = new Array(l.length);
      for (let u = 0, c = l.length; u < c; u++) {
        const d = l[u];
        o[u] = e(i[d], d, u, s);
      }
    }
  else
    o = [];
  return o;
}
function z_(i, e) {
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (We(r))
      for (let o = 0; o < r.length; o++)
        i[r[o].name] = r[o].fn;
    else r && (i[r.name] = r.key ? (...o) => {
      const s = r.fn(...o);
      return s && (s.key = r.key), s;
    } : r.fn);
  }
  return i;
}
function it(i, e, n = {}, r, o) {
  if (pn.ce || pn.parent && ua(pn.parent) && pn.parent.ce) {
    const c = Object.keys(n).length > 0;
    return e !== "default" && (n.name = e), $(), st(
      Fe,
      null,
      [Ve("slot", n, r && r())],
      c ? -2 : 64
    );
  }
  let s = i[e];
  process.env.NODE_ENV !== "production" && s && s.length > 1 && (Oe(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), s = () => []), s && s._c && (s._d = !1), $();
  const a = s && Jy(s(n)), l = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  a && a.key, u = st(
    Fe,
    {
      key: (l && !Gi(l) ? l : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!a && r ? "_fb" : "")
    },
    a || (r ? r() : []),
    a && i._ === 1 ? 64 : -2
  );
  return u.scopeId && (u.slotScopeIds = [u.scopeId + "-s"]), s && s._c && (s._d = !0), u;
}
function Jy(i) {
  return i.some((e) => Ds(e) ? !(e.type === ln || e.type === Fe && !Jy(e.children)) : !0) ? i : null;
}
function xu(i, e) {
  const n = {};
  if (process.env.NODE_ENV !== "production" && !wt(i))
    return Oe("v-on with no argument expects an object value."), n;
  for (const r in i)
    n[/[A-Z]/.test(r) ? `on:${r}` : Co(r)] = i[r];
  return n;
}
const Oh = (i) => i ? _0(i) ? dd(i) : Oh(i.parent) : null, ws = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ en(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => process.env.NODE_ENV !== "production" ? gr(i.props) : i.props,
    $attrs: (i) => process.env.NODE_ENV !== "production" ? gr(i.attrs) : i.attrs,
    $slots: (i) => process.env.NODE_ENV !== "production" ? gr(i.slots) : i.slots,
    $refs: (i) => process.env.NODE_ENV !== "production" ? gr(i.refs) : i.refs,
    $parent: (i) => Oh(i.parent),
    $root: (i) => Oh(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => t0(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      ld(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = Es.bind(i.proxy)),
    $watch: (i) => ix.bind(i)
  })
), jf = (i) => i === "_" || i === "$", Bd = (i, e) => i !== Et && !i.__isScriptSetup && xt(i, e), Qy = {
  get({ _: i }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: n, setupState: r, data: o, props: s, accessCache: a, type: l, appContext: u } = i;
    if (process.env.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    if (e[0] !== "$") {
      const p = a[e];
      if (p !== void 0)
        switch (p) {
          case 1:
            return r[e];
          case 2:
            return o[e];
          case 4:
            return n[e];
          case 3:
            return s[e];
        }
      else {
        if (Bd(r, e))
          return a[e] = 1, r[e];
        if (o !== Et && xt(o, e))
          return a[e] = 2, o[e];
        if (xt(s, e))
          return a[e] = 3, s[e];
        if (n !== Et && xt(n, e))
          return a[e] = 4, n[e];
        Eh && (a[e] = 0);
      }
    }
    const c = ws[e];
    let d, h;
    if (c)
      return e === "$attrs" ? (gn(i.attrs, "get", ""), process.env.NODE_ENV !== "production" && $c()) : process.env.NODE_ENV !== "production" && e === "$slots" && gn(i, "get", e), c(i);
    if (
      // css module (injected by vue-loader)
      (d = l.__cssModules) && (d = d[e])
    )
      return d;
    if (n !== Et && xt(n, e))
      return a[e] = 4, n[e];
    if (
      // global properties
      h = u.config.globalProperties, xt(h, e)
    )
      return h[e];
    process.env.NODE_ENV !== "production" && pn && (!jt(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (o !== Et && jf(e[0]) && xt(o, e) ? Oe(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : i === pn && Oe(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: i }, e, n) {
    const { data: r, setupState: o, ctx: s } = i;
    return Bd(o, e) ? (o[e] = n, !0) : process.env.NODE_ENV !== "production" && o.__isScriptSetup && xt(o, e) ? (Oe(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : r !== Et && xt(r, e) ? (r[e] = n, !0) : xt(i.props, e) ? (process.env.NODE_ENV !== "production" && Oe(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in i ? (process.env.NODE_ENV !== "production" && Oe(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : (process.env.NODE_ENV !== "production" && e in i.appContext.config.globalProperties ? Object.defineProperty(s, e, {
      enumerable: !0,
      configurable: !0,
      value: n
    }) : s[e] = n, !0);
  },
  has({
    _: { data: i, setupState: e, accessCache: n, ctx: r, appContext: o, props: s, type: a }
  }, l) {
    let u;
    return !!(n[l] || i !== Et && l[0] !== "$" && xt(i, l) || Bd(e, l) || xt(s, l) || xt(r, l) || xt(ws, l) || xt(o.config.globalProperties, l) || (u = a.__cssModules) && u[l]);
  },
  defineProperty(i, e, n) {
    return n.get != null ? i._.accessCache[e] = 0 : xt(n, "value") && this.set(i, e, n.value, null), Reflect.defineProperty(i, e, n);
  }
};
process.env.NODE_ENV !== "production" && (Qy.ownKeys = (i) => (Oe(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(i)));
function B_(i) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => i
  }), Object.keys(ws).forEach((n) => {
    Object.defineProperty(e, n, {
      configurable: !0,
      enumerable: !1,
      get: () => ws[n](i),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: vn
    });
  }), e;
}
function H_(i) {
  const {
    ctx: e,
    propsOptions: [n]
  } = i;
  n && Object.keys(n).forEach((r) => {
    Object.defineProperty(e, r, {
      enumerable: !0,
      configurable: !0,
      get: () => i.props[r],
      set: vn
    });
  });
}
function U_(i) {
  const { ctx: e, setupState: n } = i;
  Object.keys(et(n)).forEach((r) => {
    if (!n.__isScriptSetup) {
      if (jf(r[0])) {
        Oe(
          `setup() return property ${JSON.stringify(
            r
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(e, r, {
        enumerable: !0,
        configurable: !0,
        get: () => n[r],
        set: vn
      });
    }
  });
}
function em(i) {
  return We(i) ? i.reduce(
    (e, n) => (e[n] = null, e),
    {}
  ) : i;
}
function W_() {
  const i = /* @__PURE__ */ Object.create(null);
  return (e, n) => {
    i[n] ? Oe(`${e} property "${n}" is already defined in ${i[n]}.`) : i[n] = e;
  };
}
let Eh = !0;
function G_(i) {
  const e = t0(i), n = i.proxy, r = i.ctx;
  Eh = !1, e.beforeCreate && tm(e.beforeCreate, i, "bc");
  const {
    // state
    data: o,
    computed: s,
    methods: a,
    watch: l,
    provide: u,
    inject: c,
    // lifecycle
    created: d,
    beforeMount: h,
    mounted: p,
    beforeUpdate: m,
    updated: v,
    activated: y,
    deactivated: w,
    beforeDestroy: g,
    beforeUnmount: k,
    destroyed: _,
    unmounted: S,
    render: b,
    renderTracked: C,
    renderTriggered: x,
    errorCaptured: I,
    serverPrefetch: F,
    // public API
    expose: B,
    inheritAttrs: X,
    // assets
    components: j,
    directives: ee,
    filters: ie
  } = e, M = process.env.NODE_ENV !== "production" ? W_() : null;
  if (process.env.NODE_ENV !== "production") {
    const [R] = i.propsOptions;
    if (R)
      for (const V in R)
        M("Props", V);
  }
  if (c && X_(c, r, M), a)
    for (const R in a) {
      const V = a[R];
      qe(V) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(r, R, {
        value: V.bind(n),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : r[R] = V.bind(n), process.env.NODE_ENV !== "production" && M("Methods", R)) : process.env.NODE_ENV !== "production" && Oe(
        `Method "${R}" has type "${typeof V}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (o) {
    process.env.NODE_ENV !== "production" && !qe(o) && Oe(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const R = o.call(n, n);
    if (process.env.NODE_ENV !== "production" && kf(R) && Oe(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !wt(R))
      process.env.NODE_ENV !== "production" && Oe("data() should return an object.");
    else if (i.data = zo(R), process.env.NODE_ENV !== "production")
      for (const V in R)
        M("Data", V), jf(V[0]) || Object.defineProperty(r, V, {
          configurable: !0,
          enumerable: !0,
          get: () => R[V],
          set: vn
        });
  }
  if (Eh = !0, s)
    for (const R in s) {
      const V = s[R], ae = qe(V) ? V.bind(n, n) : qe(V.get) ? V.get.bind(n, n) : vn;
      process.env.NODE_ENV !== "production" && ae === vn && Oe(`Computed property "${R}" has no getter.`);
      const $e = !qe(V) && qe(V.set) ? V.set.bind(n) : process.env.NODE_ENV !== "production" ? () => {
        Oe(
          `Write operation failed: computed property "${R}" is readonly.`
        );
      } : vn, N = Ee({
        get: ae,
        set: $e
      });
      Object.defineProperty(r, R, {
        enumerable: !0,
        configurable: !0,
        get: () => N.value,
        set: (me) => N.value = me
      }), process.env.NODE_ENV !== "production" && M("Computed", R);
    }
  if (l)
    for (const R in l)
      e0(l[R], r, n, R);
  if (u) {
    const R = qe(u) ? u.call(n) : u;
    Reflect.ownKeys(R).forEach((V) => {
      Q_(V, R[V]);
    });
  }
  d && tm(d, i, "c");
  function W(R, V) {
    We(V) ? V.forEach((ae) => R(ae.bind(n))) : V && R(V.bind(n));
  }
  if (W(I_, h), W(Wn, p), W(L_, m), W(A_, v), W($_, y), W(M_, w), W(R_, I), W(j_, C), W(F_, x), W(qy, k), W(Qi, S), W(V_, F), We(B))
    if (B.length) {
      const R = i.exposed || (i.exposed = {});
      B.forEach((V) => {
        Object.defineProperty(R, V, {
          get: () => n[V],
          set: (ae) => n[V] = ae,
          enumerable: !0
        });
      });
    } else i.exposed || (i.exposed = {});
  b && i.render === vn && (i.render = b), X != null && (i.inheritAttrs = X), j && (i.components = j), ee && (i.directives = ee), F && Yy(i);
}
function X_(i, e, n = vn) {
  We(i) && (i = Th(i));
  for (const r in i) {
    const o = i[r];
    let s;
    wt(o) ? "default" in o ? s = ol(
      o.from || r,
      o.default,
      !0
    ) : s = ol(o.from || r) : s = ol(o), At(s) ? Object.defineProperty(e, r, {
      enumerable: !0,
      configurable: !0,
      get: () => s.value,
      set: (a) => s.value = a
    }) : e[r] = s, process.env.NODE_ENV !== "production" && n("Inject", r);
  }
}
function tm(i, e, n) {
  Zi(
    We(i) ? i.map((r) => r.bind(e.proxy)) : i.bind(e.proxy),
    e,
    n
  );
}
function e0(i, e, n, r) {
  let o = r.includes(".") ? r0(n, r) : () => n[r];
  if (jt(i)) {
    const s = e[i];
    qe(s) ? Lt(o, s) : process.env.NODE_ENV !== "production" && Oe(`Invalid watch handler specified by key "${i}"`, s);
  } else if (qe(i))
    Lt(o, i.bind(n));
  else if (wt(i))
    if (We(i))
      i.forEach((s) => e0(s, e, n, r));
    else {
      const s = qe(i.handler) ? i.handler.bind(n) : e[i.handler];
      qe(s) ? Lt(o, s, i) : process.env.NODE_ENV !== "production" && Oe(`Invalid watch handler specified by key "${i.handler}"`, s);
    }
  else process.env.NODE_ENV !== "production" && Oe(`Invalid watch option: "${r}"`, i);
}
function t0(i) {
  const e = i.type, { mixins: n, extends: r } = e, {
    mixins: o,
    optionsCache: s,
    config: { optionMergeStrategies: a }
  } = i.appContext, l = s.get(e);
  let u;
  return l ? u = l : !o.length && !n && !r ? u = e : (u = {}, o.length && o.forEach(
    (c) => Dc(u, c, a, !0)
  ), Dc(u, e, a)), wt(e) && s.set(e, u), u;
}
function Dc(i, e, n, r = !1) {
  const { mixins: o, extends: s } = e;
  s && Dc(i, s, n, !0), o && o.forEach(
    (a) => Dc(i, a, n, !0)
  );
  for (const a in e)
    if (r && a === "expose")
      process.env.NODE_ENV !== "production" && Oe(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const l = Y_[a] || n && n[a];
      i[a] = l ? l(i[a], e[a]) : e[a];
    }
  return i;
}
const Y_ = {
  data: nm,
  props: im,
  emits: im,
  // objects
  methods: Ka,
  computed: Ka,
  // lifecycle
  beforeCreate: jn,
  created: jn,
  beforeMount: jn,
  mounted: jn,
  beforeUpdate: jn,
  updated: jn,
  beforeDestroy: jn,
  beforeUnmount: jn,
  destroyed: jn,
  unmounted: jn,
  activated: jn,
  deactivated: jn,
  errorCaptured: jn,
  serverPrefetch: jn,
  // assets
  components: Ka,
  directives: Ka,
  // watch
  watch: q_,
  // provide / inject
  provide: nm,
  inject: K_
};
function nm(i, e) {
  return e ? i ? function() {
    return en(
      qe(i) ? i.call(this, this) : i,
      qe(e) ? e.call(this, this) : e
    );
  } : e : i;
}
function K_(i, e) {
  return Ka(Th(i), Th(e));
}
function Th(i) {
  if (We(i)) {
    const e = {};
    for (let n = 0; n < i.length; n++)
      e[i[n]] = i[n];
    return e;
  }
  return i;
}
function jn(i, e) {
  return i ? [...new Set([].concat(i, e))] : e;
}
function Ka(i, e) {
  return i ? en(/* @__PURE__ */ Object.create(null), i, e) : e;
}
function im(i, e) {
  return i ? We(i) && We(e) ? [.../* @__PURE__ */ new Set([...i, ...e])] : en(
    /* @__PURE__ */ Object.create(null),
    em(i),
    em(e ?? {})
  ) : e;
}
function q_(i, e) {
  if (!i) return e;
  if (!e) return i;
  const n = en(/* @__PURE__ */ Object.create(null), i);
  for (const r in e)
    n[r] = jn(i[r], e[r]);
  return n;
}
function n0() {
  return {
    app: null,
    config: {
      isNativeTag: ty,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Z_ = 0;
function J_(i, e) {
  return function(r, o = null) {
    qe(r) || (r = en({}, r)), o != null && !wt(o) && (process.env.NODE_ENV !== "production" && Oe("root props passed to app.mount() must be an object."), o = null);
    const s = n0(), a = /* @__PURE__ */ new WeakSet(), l = [];
    let u = !1;
    const c = s.app = {
      _uid: Z_++,
      _component: r,
      _props: o,
      _container: null,
      _context: s,
      _instance: null,
      version: pm,
      get config() {
        return s.config;
      },
      set config(d) {
        process.env.NODE_ENV !== "production" && Oe(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(d, ...h) {
        return a.has(d) ? process.env.NODE_ENV !== "production" && Oe("Plugin has already been applied to target app.") : d && qe(d.install) ? (a.add(d), d.install(c, ...h)) : qe(d) ? (a.add(d), d(c, ...h)) : process.env.NODE_ENV !== "production" && Oe(
          'A plugin must either be a function or an object with an "install" function.'
        ), c;
      },
      mixin(d) {
        return s.mixins.includes(d) ? process.env.NODE_ENV !== "production" && Oe(
          "Mixin has already been applied to target app" + (d.name ? `: ${d.name}` : "")
        ) : s.mixins.push(d), c;
      },
      component(d, h) {
        return process.env.NODE_ENV !== "production" && Ih(d, s.config), h ? (process.env.NODE_ENV !== "production" && s.components[d] && Oe(`Component "${d}" has already been registered in target app.`), s.components[d] = h, c) : s.components[d];
      },
      directive(d, h) {
        return process.env.NODE_ENV !== "production" && jy(d), h ? (process.env.NODE_ENV !== "production" && s.directives[d] && Oe(`Directive "${d}" has already been registered in target app.`), s.directives[d] = h, c) : s.directives[d];
      },
      mount(d, h, p) {
        if (u)
          process.env.NODE_ENV !== "production" && Oe(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          process.env.NODE_ENV !== "production" && d.__vue_app__ && Oe(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const m = c._ceVNode || Ve(r, o);
          return m.appContext = s, p === !0 ? p = "svg" : p === !1 && (p = void 0), process.env.NODE_ENV !== "production" && (s.reload = () => {
            const v = xr(m);
            v.el = null, i(v, d, p);
          }), i(m, d, p), u = !0, c._container = d, d.__vue_app__ = c, process.env.NODE_ENV !== "production" && (c._instance = m.component, g_(c, pm)), dd(m.component);
        }
      },
      onUnmount(d) {
        process.env.NODE_ENV !== "production" && typeof d != "function" && Oe(
          `Expected function as first argument to app.onUnmount(), but got ${typeof d}`
        ), l.push(d);
      },
      unmount() {
        u ? (Zi(
          l,
          c._instance,
          16
        ), i(null, c._container), process.env.NODE_ENV !== "production" && (c._instance = null, v_(c)), delete c._container.__vue_app__) : process.env.NODE_ENV !== "production" && Oe("Cannot unmount an app that is not mounted.");
      },
      provide(d, h) {
        return process.env.NODE_ENV !== "production" && d in s.provides && (xt(s.provides, d) ? Oe(
          `App already provides property with key "${String(d)}". It will be overwritten with the new value.`
        ) : Oe(
          `App already provides property with key "${String(d)}" inherited from its parent element. It will be overwritten with the new value.`
        )), s.provides[d] = h, c;
      },
      runWithContext(d) {
        const h = _s;
        _s = c;
        try {
          return d();
        } finally {
          _s = h;
        }
      }
    };
    return c;
  };
}
let _s = null;
function Q_(i, e) {
  if (process.env.NODE_ENV !== "production" && (!hn || hn.isMounted) && Oe("provide() can only be used inside setup()."), hn) {
    let n = hn.provides;
    const r = hn.parent && hn.parent.provides;
    r === n && (n = hn.provides = Object.create(r)), n[i] = e;
  }
}
function ol(i, e, n = !1) {
  const r = jo();
  if (r || _s) {
    let o = _s ? _s._context.provides : r ? r.parent == null || r.ce ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
    if (o && i in o)
      return o[i];
    if (arguments.length > 1)
      return n && qe(e) ? e.call(r && r.proxy) : e;
    process.env.NODE_ENV !== "production" && Oe(`injection "${String(i)}" not found.`);
  } else process.env.NODE_ENV !== "production" && Oe("inject() can only be used inside setup() or functional components.");
}
function ex() {
  return !!(jo() || _s);
}
const tx = Symbol.for("v-scx"), nx = () => {
  {
    const i = ol(tx);
    return i || process.env.NODE_ENV !== "production" && Oe(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), i;
  }
};
function Lt(i, e, n) {
  return process.env.NODE_ENV !== "production" && !qe(e) && Oe(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), i0(i, e, n);
}
function i0(i, e, n = Et) {
  const { immediate: r, deep: o, flush: s, once: a } = n;
  process.env.NODE_ENV !== "production" && !e && (r !== void 0 && Oe(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), o !== void 0 && Oe(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), a !== void 0 && Oe(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const l = en({}, n);
  process.env.NODE_ENV !== "production" && (l.onWarn = Oe);
  const u = e && r || !e && s !== "post";
  let c;
  if (xl) {
    if (s === "sync") {
      const m = nx();
      c = m.__watcherHandles || (m.__watcherHandles = []);
    } else if (!u) {
      const m = () => {
      };
      return m.stop = vn, m.resume = vn, m.pause = vn, m;
    }
  }
  const d = hn;
  l.call = (m, v, y) => Zi(m, d, v, y);
  let h = !1;
  s === "post" ? l.scheduler = (m) => {
    Rn(m, d && d.suspense);
  } : s !== "sync" && (h = !0, l.scheduler = (m, v) => {
    v ? m() : ld(m);
  }), l.augmentJob = (m) => {
    e && (m.flags |= 4), h && (m.flags |= 2, d && (m.id = d.uid, m.i = d));
  };
  const p = i_(i, e, l);
  return xl && (c ? c.push(p) : u && p()), p;
}
function ix(i, e, n) {
  const r = this.proxy, o = jt(i) ? i.includes(".") ? r0(r, i) : () => r[i] : i.bind(r, r);
  let s;
  qe(e) ? s = e : (s = e.handler, n = e);
  const a = su(this), l = i0(o, s.bind(r), n);
  return a(), l;
}
function r0(i, e) {
  const n = e.split(".");
  return () => {
    let r = i;
    for (let o = 0; o < n.length && r; o++)
      r = r[n[o]];
    return r;
  };
}
const rx = (i, e) => e === "modelValue" || e === "model-value" ? i.modelModifiers : i[`${e}Modifiers`] || i[`${Hn(e)}Modifiers`] || i[`${to(e)}Modifiers`];
function ox(i, e, ...n) {
  if (i.isUnmounted) return;
  const r = i.vnode.props || Et;
  if (process.env.NODE_ENV !== "production") {
    const {
      emitsOptions: d,
      propsOptions: [h]
    } = i;
    if (d)
      if (!(e in d))
        (!h || !(Co(Hn(e)) in h)) && Oe(
          `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${Co(Hn(e))}" prop.`
        );
      else {
        const p = d[e];
        qe(p) && (p(...n) || Oe(
          `Invalid event arguments: event validation failed for event "${e}".`
        ));
      }
  }
  let o = n;
  const s = e.startsWith("update:"), a = s && rx(r, e.slice(7));
  if (a && (a.trim && (o = n.map((d) => jt(d) ? d.trim() : d)), a.number && (o = n.map(rd))), process.env.NODE_ENV !== "production" && S_(i, e, o), process.env.NODE_ENV !== "production") {
    const d = e.toLowerCase();
    d !== e && r[Co(d)] && Oe(
      `Event "${d}" is emitted in component ${au(
        i,
        i.type
      )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${to(
        e
      )}" instead of "${e}".`
    );
  }
  let l, u = r[l = Co(e)] || // also try camelCase event handler (#2249)
  r[l = Co(Hn(e))];
  !u && s && (u = r[l = Co(to(e))]), u && Zi(
    u,
    i,
    6,
    o
  );
  const c = r[l + "Once"];
  if (c) {
    if (!i.emitted)
      i.emitted = {};
    else if (i.emitted[l])
      return;
    i.emitted[l] = !0, Zi(
      c,
      i,
      6,
      o
    );
  }
}
const sx = /* @__PURE__ */ new WeakMap();
function o0(i, e, n = !1) {
  const r = n ? sx : e.emitsCache, o = r.get(i);
  if (o !== void 0)
    return o;
  const s = i.emits;
  let a = {}, l = !1;
  if (!qe(i)) {
    const u = (c) => {
      const d = o0(c, e, !0);
      d && (l = !0, en(a, d));
    };
    !n && e.mixins.length && e.mixins.forEach(u), i.extends && u(i.extends), i.mixins && i.mixins.forEach(u);
  }
  return !s && !l ? (wt(i) && r.set(i, null), null) : (We(s) ? s.forEach((u) => a[u] = null) : en(a, s), wt(i) && r.set(i, a), a);
}
function cd(i, e) {
  return !i || !Jl(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), xt(i, e[0].toLowerCase() + e.slice(1)) || xt(i, to(e)) || xt(i, e));
}
let Dh = !1;
function $c() {
  Dh = !0;
}
function rm(i) {
  const {
    type: e,
    vnode: n,
    proxy: r,
    withProxy: o,
    propsOptions: [s],
    slots: a,
    attrs: l,
    emit: u,
    render: c,
    renderCache: d,
    props: h,
    data: p,
    setupState: m,
    ctx: v,
    inheritAttrs: y
  } = i, w = Oc(i);
  let g, k;
  process.env.NODE_ENV !== "production" && (Dh = !1);
  try {
    if (n.shapeFlag & 4) {
      const b = o || r, C = process.env.NODE_ENV !== "production" && m.__isScriptSetup ? new Proxy(b, {
        get(x, I, F) {
          return Oe(
            `Property '${String(
              I
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(x, I, F);
        }
      }) : b;
      g = Li(
        c.call(
          C,
          b,
          d,
          process.env.NODE_ENV !== "production" ? gr(h) : h,
          m,
          p,
          v
        )
      ), k = l;
    } else {
      const b = e;
      process.env.NODE_ENV !== "production" && l === h && $c(), g = Li(
        b.length > 1 ? b(
          process.env.NODE_ENV !== "production" ? gr(h) : h,
          process.env.NODE_ENV !== "production" ? {
            get attrs() {
              return $c(), gr(l);
            },
            slots: a,
            emit: u
          } : { attrs: l, slots: a, emit: u }
        ) : b(
          process.env.NODE_ENV !== "production" ? gr(h) : h,
          null
        )
      ), k = e.props ? l : ax(l);
    }
  } catch (b) {
    ll.length = 0, nu(b, i, 1), g = Ve(ln);
  }
  let _ = g, S;
  if (process.env.NODE_ENV !== "production" && g.patchFlag > 0 && g.patchFlag & 2048 && ([_, S] = s0(g)), k && y !== !1) {
    const b = Object.keys(k), { shapeFlag: C } = _;
    if (b.length) {
      if (C & 7)
        s && b.some(bc) && (k = lx(
          k,
          s
        )), _ = xr(_, k, !1, !0);
      else if (process.env.NODE_ENV !== "production" && !Dh && _.type !== ln) {
        const x = Object.keys(l), I = [], F = [];
        for (let B = 0, X = x.length; B < X; B++) {
          const j = x[B];
          Jl(j) ? bc(j) || I.push(j[2].toLowerCase() + j.slice(3)) : F.push(j);
        }
        F.length && Oe(
          `Extraneous non-props attributes (${F.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
        ), I.length && Oe(
          `Extraneous non-emits event listeners (${I.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return n.dirs && (process.env.NODE_ENV !== "production" && !om(_) && Oe(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), _ = xr(_, null, !1, !0), _.dirs = _.dirs ? _.dirs.concat(n.dirs) : n.dirs), n.transition && (process.env.NODE_ENV !== "production" && !om(_) && Oe(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), wl(_, n.transition)), process.env.NODE_ENV !== "production" && S ? S(_) : g = _, Oc(w), g;
}
const s0 = (i) => {
  const e = i.children, n = i.dynamicChildren, r = Rf(e, !1);
  if (r) {
    if (process.env.NODE_ENV !== "production" && r.patchFlag > 0 && r.patchFlag & 2048)
      return s0(r);
  } else return [i, void 0];
  const o = e.indexOf(r), s = n ? n.indexOf(r) : -1, a = (l) => {
    e[o] = l, n && (s > -1 ? n[s] = l : l.patchFlag > 0 && (i.dynamicChildren = [...n, l]));
  };
  return [Li(r), a];
};
function Rf(i, e = !0) {
  let n;
  for (let r = 0; r < i.length; r++) {
    const o = i[r];
    if (Ds(o)) {
      if (o.type !== ln || o.children === "v-if") {
        if (n)
          return;
        if (n = o, process.env.NODE_ENV !== "production" && e && n.patchFlag > 0 && n.patchFlag & 2048)
          return Rf(n.children);
      }
    } else
      return;
  }
  return n;
}
const ax = (i) => {
  let e;
  for (const n in i)
    (n === "class" || n === "style" || Jl(n)) && ((e || (e = {}))[n] = i[n]);
  return e;
}, lx = (i, e) => {
  const n = {};
  for (const r in i)
    (!bc(r) || !(r.slice(9) in e)) && (n[r] = i[r]);
  return n;
}, om = (i) => i.shapeFlag & 7 || i.type === ln;
function ux(i, e, n) {
  const { props: r, children: o, component: s } = i, { props: a, children: l, patchFlag: u } = e, c = s.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (o || l) && Ri || e.dirs || e.transition)
    return !0;
  if (n && u >= 0) {
    if (u & 1024)
      return !0;
    if (u & 16)
      return r ? sm(r, a, c) : !!a;
    if (u & 8) {
      const d = e.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        const p = d[h];
        if (a[p] !== r[p] && !cd(c, p))
          return !0;
      }
    }
  } else
    return (o || l) && (!l || !l.$stable) ? !0 : r === a ? !1 : r ? a ? sm(r, a, c) : !0 : !!a;
  return !1;
}
function sm(i, e, n) {
  const r = Object.keys(e);
  if (r.length !== Object.keys(i).length)
    return !0;
  for (let o = 0; o < r.length; o++) {
    const s = r[o];
    if (e[s] !== i[s] && !cd(n, s))
      return !0;
  }
  return !1;
}
function cx({ vnode: i, parent: e }, n) {
  for (; e; ) {
    const r = e.subTree;
    if (r.suspense && r.suspense.activeBranch === i && (r.el = i.el), r === i)
      (i = e.vnode).el = n, e = e.parent;
    else
      break;
  }
}
const a0 = {}, l0 = () => Object.create(a0), u0 = (i) => Object.getPrototypeOf(i) === a0;
function dx(i, e, n, r = !1) {
  const o = {}, s = l0();
  i.propsDefaults = /* @__PURE__ */ Object.create(null), c0(i, e, o, s);
  for (const a in i.propsOptions[0])
    a in o || (o[a] = void 0);
  process.env.NODE_ENV !== "production" && h0(e || {}, o, i), n ? i.props = r ? o : Yw(o) : i.type.props ? i.props = o : i.props = s, i.attrs = s;
}
function hx(i) {
  for (; i; ) {
    if (i.type.__hmrId) return !0;
    i = i.parent;
  }
}
function fx(i, e, n, r) {
  const {
    props: o,
    attrs: s,
    vnode: { patchFlag: a }
  } = i, l = et(o), [u] = i.propsOptions;
  let c = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(process.env.NODE_ENV !== "production" && hx(i)) && (r || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const d = i.vnode.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        let p = d[h];
        if (cd(i.emitsOptions, p))
          continue;
        const m = e[p];
        if (u)
          if (xt(s, p))
            m !== s[p] && (s[p] = m, c = !0);
          else {
            const v = Hn(p);
            o[v] = $h(
              u,
              l,
              v,
              m,
              i,
              !1
            );
          }
        else
          m !== s[p] && (s[p] = m, c = !0);
      }
    }
  } else {
    c0(i, e, o, s) && (c = !0);
    let d;
    for (const h in l)
      (!e || // for camelCase
      !xt(e, h) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((d = to(h)) === h || !xt(e, d))) && (u ? n && // for camelCase
      (n[h] !== void 0 || // for kebab-case
      n[d] !== void 0) && (o[h] = $h(
        u,
        l,
        h,
        void 0,
        i,
        !0
      )) : delete o[h]);
    if (s !== l)
      for (const h in s)
        (!e || !xt(e, h)) && (delete s[h], c = !0);
  }
  c && fr(i.attrs, "set", ""), process.env.NODE_ENV !== "production" && h0(e || {}, o, i);
}
function c0(i, e, n, r) {
  const [o, s] = i.propsOptions;
  let a = !1, l;
  if (e)
    for (let u in e) {
      if (tl(u))
        continue;
      const c = e[u];
      let d;
      o && xt(o, d = Hn(u)) ? !s || !s.includes(d) ? n[d] = c : (l || (l = {}))[d] = c : cd(i.emitsOptions, u) || (!(u in r) || c !== r[u]) && (r[u] = c, a = !0);
    }
  if (s) {
    const u = et(n), c = l || Et;
    for (let d = 0; d < s.length; d++) {
      const h = s[d];
      n[h] = $h(
        o,
        u,
        h,
        c[h],
        i,
        !xt(c, h)
      );
    }
  }
  return a;
}
function $h(i, e, n, r, o, s) {
  const a = i[n];
  if (a != null) {
    const l = xt(a, "default");
    if (l && r === void 0) {
      const u = a.default;
      if (a.type !== Function && !a.skipFactory && qe(u)) {
        const { propsDefaults: c } = o;
        if (n in c)
          r = c[n];
        else {
          const d = su(o);
          r = c[n] = u.call(
            null,
            e
          ), d();
        }
      } else
        r = u;
      o.ce && o.ce._setProp(n, r);
    }
    a[
      0
      /* shouldCast */
    ] && (s && !l ? r = !1 : a[
      1
      /* shouldCastTrue */
    ] && (r === "" || r === to(n)) && (r = !0));
  }
  return r;
}
const px = /* @__PURE__ */ new WeakMap();
function d0(i, e, n = !1) {
  const r = n ? px : e.propsCache, o = r.get(i);
  if (o)
    return o;
  const s = i.props, a = {}, l = [];
  let u = !1;
  if (!qe(i)) {
    const d = (h) => {
      u = !0;
      const [p, m] = d0(h, e, !0);
      en(a, p), m && l.push(...m);
    };
    !n && e.mixins.length && e.mixins.forEach(d), i.extends && d(i.extends), i.mixins && i.mixins.forEach(d);
  }
  if (!s && !u)
    return wt(i) && r.set(i, aa), aa;
  if (We(s))
    for (let d = 0; d < s.length; d++) {
      process.env.NODE_ENV !== "production" && !jt(s[d]) && Oe("props must be strings when using array syntax.", s[d]);
      const h = Hn(s[d]);
      am(h) && (a[h] = Et);
    }
  else if (s) {
    process.env.NODE_ENV !== "production" && !wt(s) && Oe("invalid props options", s);
    for (const d in s) {
      const h = Hn(d);
      if (am(h)) {
        const p = s[d], m = a[h] = We(p) || qe(p) ? { type: p } : en({}, p), v = m.type;
        let y = !1, w = !0;
        if (We(v))
          for (let g = 0; g < v.length; ++g) {
            const k = v[g], _ = qe(k) && k.name;
            if (_ === "Boolean") {
              y = !0;
              break;
            } else _ === "String" && (w = !1);
          }
        else
          y = qe(v) && v.name === "Boolean";
        m[
          0
          /* shouldCast */
        ] = y, m[
          1
          /* shouldCastTrue */
        ] = w, (y || xt(m, "default")) && l.push(h);
      }
    }
  }
  const c = [a, l];
  return wt(i) && r.set(i, c), c;
}
function am(i) {
  return i[0] !== "$" && !tl(i) ? !0 : (process.env.NODE_ENV !== "production" && Oe(`Invalid prop name: "${i}" is a reserved property.`), !1);
}
function mx(i) {
  return i === null ? "null" : typeof i == "function" ? i.name || "" : typeof i == "object" && i.constructor && i.constructor.name || "";
}
function h0(i, e, n) {
  const r = et(e), o = n.propsOptions[0], s = Object.keys(i).map((a) => Hn(a));
  for (const a in o) {
    let l = o[a];
    l != null && gx(
      a,
      r[a],
      l,
      process.env.NODE_ENV !== "production" ? gr(r) : r,
      !s.includes(a)
    );
  }
}
function gx(i, e, n, r, o) {
  const { type: s, required: a, validator: l, skipCheck: u } = n;
  if (a && o) {
    Oe('Missing required prop: "' + i + '"');
    return;
  }
  if (!(e == null && !a)) {
    if (s != null && s !== !0 && !u) {
      let c = !1;
      const d = We(s) ? s : [s], h = [];
      for (let p = 0; p < d.length && !c; p++) {
        const { valid: m, expectedType: v } = yx(e, d[p]);
        h.push(v || ""), c = m;
      }
      if (!c) {
        Oe(bx(i, e, h));
        return;
      }
    }
    l && !l(e, r) && Oe('Invalid prop: custom validator check failed for prop "' + i + '".');
  }
}
const vx = /* @__PURE__ */ so(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function yx(i, e) {
  let n;
  const r = mx(e);
  if (r === "null")
    n = i === null;
  else if (vx(r)) {
    const o = typeof i;
    n = o === r.toLowerCase(), !n && o === "object" && (n = i instanceof e);
  } else r === "Object" ? n = wt(i) : r === "Array" ? n = We(i) : n = i instanceof e;
  return {
    valid: n,
    expectedType: r
  };
}
function bx(i, e, n) {
  if (n.length === 0)
    return `Prop type [] for prop "${i}" won't match anything. Did you mean to use type Array instead?`;
  let r = `Invalid prop: type check failed for prop "${i}". Expected ${n.map(Os).join(" | ")}`;
  const o = n[0], s = Of(e), a = lm(e, o), l = lm(e, s);
  return n.length === 1 && um(o) && !wx(o, s) && (r += ` with value ${a}`), r += `, got ${s} `, um(s) && (r += `with value ${l}.`), r;
}
function lm(i, e) {
  return e === "String" ? `"${i}"` : e === "Number" ? `${Number(i)}` : `${i}`;
}
function um(i) {
  return ["string", "number", "boolean"].some((n) => i.toLowerCase() === n);
}
function wx(...i) {
  return i.some((e) => e.toLowerCase() === "boolean");
}
const Nf = (i) => i === "_" || i === "_ctx" || i === "$stable", zf = (i) => We(i) ? i.map(Li) : [Li(i)], _x = (i, e, n) => {
  if (e._n)
    return e;
  const r = Wt((...o) => (process.env.NODE_ENV !== "production" && hn && !(n === null && pn) && !(n && n.root !== hn.root) && Oe(
    `Slot "${i}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), zf(e(...o))), n);
  return r._c = !1, r;
}, f0 = (i, e, n) => {
  const r = i._ctx;
  for (const o in i) {
    if (Nf(o)) continue;
    const s = i[o];
    if (qe(s))
      e[o] = _x(o, s, r);
    else if (s != null) {
      process.env.NODE_ENV !== "production" && Oe(
        `Non-function value encountered for slot "${o}". Prefer function slots for better performance.`
      );
      const a = zf(s);
      e[o] = () => a;
    }
  }
}, p0 = (i, e) => {
  process.env.NODE_ENV !== "production" && !ru(i.vnode) && Oe(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const n = zf(e);
  i.slots.default = () => n;
}, Mh = (i, e, n) => {
  for (const r in e)
    (n || !Nf(r)) && (i[r] = e[r]);
}, xx = (i, e, n) => {
  const r = i.slots = l0();
  if (i.vnode.shapeFlag & 32) {
    const o = e._;
    o ? (Mh(r, e, n), n && wc(r, "_", o, !0)) : f0(e, r);
  } else e && p0(i, e);
}, Sx = (i, e, n) => {
  const { vnode: r, slots: o } = i;
  let s = !0, a = Et;
  if (r.shapeFlag & 32) {
    const l = e._;
    l ? process.env.NODE_ENV !== "production" && Ri ? (Mh(o, e, n), fr(i, "set", "$slots")) : n && l === 1 ? s = !1 : Mh(o, e, n) : (s = !e.$stable, f0(e, o)), a = e;
  } else e && (p0(i, e), a = { default: 1 });
  if (s)
    for (const l in o)
      !Nf(l) && a[l] == null && delete o[l];
};
let La, Br;
function zs(i, e) {
  i.appContext.config.performance && Mc() && Br.mark(`vue-${e}-${i.uid}`), process.env.NODE_ENV !== "production" && __(i, e, Mc() ? Br.now() : Date.now());
}
function Bs(i, e) {
  if (i.appContext.config.performance && Mc()) {
    const n = `vue-${e}-${i.uid}`, r = n + ":end", o = `<${au(i, i.type)}> ${e}`;
    Br.mark(r), Br.measure(o, n, r), Br.clearMeasures(o), Br.clearMarks(n), Br.clearMarks(r);
  }
  process.env.NODE_ENV !== "production" && x_(i, e, Mc() ? Br.now() : Date.now());
}
function Mc() {
  return La !== void 0 || (typeof window < "u" && window.performance ? (La = !0, Br = window.performance) : La = !1), La;
}
function Cx() {
  const i = [];
  if (process.env.NODE_ENV !== "production" && i.length) {
    const e = i.length > 1;
    console.warn(
      `Feature flag${e ? "s" : ""} ${i.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const Rn = Dx;
function kx(i) {
  return Ox(i);
}
function Ox(i, e) {
  Cx();
  const n = eu();
  n.__VUE__ = !0, process.env.NODE_ENV !== "production" && Lf(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
  const {
    insert: r,
    remove: o,
    patchProp: s,
    createElement: a,
    createText: l,
    createComment: u,
    setText: c,
    setElementText: d,
    parentNode: h,
    nextSibling: p,
    setScopeId: m = vn,
    insertStaticContent: v
  } = i, y = (D, P, G, ne = null, se = null, ge = null, Se = void 0, be = null, xe = process.env.NODE_ENV !== "production" && Ri ? !1 : !!P.dynamicChildren) => {
    if (D === P)
      return;
    D && !ss(D, P) && (ne = Ce(D), we(D, se, ge, !0), D = null), P.patchFlag === -2 && (xe = !1, P.dynamicChildren = null);
    const { type: q, ref: J, shapeFlag: ue } = P;
    switch (q) {
      case ou:
        w(D, P, G, ne);
        break;
      case ln:
        g(D, P, G, ne);
        break;
      case al:
        D == null ? k(P, G, ne, Se) : process.env.NODE_ENV !== "production" && _(D, P, G, Se);
        break;
      case Fe:
        ee(
          D,
          P,
          G,
          ne,
          se,
          ge,
          Se,
          be,
          xe
        );
        break;
      default:
        ue & 1 ? C(
          D,
          P,
          G,
          ne,
          se,
          ge,
          Se,
          be,
          xe
        ) : ue & 6 ? ie(
          D,
          P,
          G,
          ne,
          se,
          ge,
          Se,
          be,
          xe
        ) : ue & 64 || ue & 128 ? q.process(
          D,
          P,
          G,
          ne,
          se,
          ge,
          Se,
          be,
          xe,
          E
        ) : process.env.NODE_ENV !== "production" && Oe("Invalid VNode type:", q, `(${typeof q})`);
    }
    J != null && se ? rl(J, D && D.ref, ge, P || D, !P) : J == null && D && D.ref != null && rl(D.ref, null, ge, D, !0);
  }, w = (D, P, G, ne) => {
    if (D == null)
      r(
        P.el = l(P.children),
        G,
        ne
      );
    else {
      const se = P.el = D.el;
      P.children !== D.children && c(se, P.children);
    }
  }, g = (D, P, G, ne) => {
    D == null ? r(
      P.el = u(P.children || ""),
      G,
      ne
    ) : P.el = D.el;
  }, k = (D, P, G, ne) => {
    [D.el, D.anchor] = v(
      D.children,
      P,
      G,
      ne,
      D.el,
      D.anchor
    );
  }, _ = (D, P, G, ne) => {
    if (P.children !== D.children) {
      const se = p(D.anchor);
      b(D), [P.el, P.anchor] = v(
        P.children,
        G,
        se,
        ne
      );
    } else
      P.el = D.el, P.anchor = D.anchor;
  }, S = ({ el: D, anchor: P }, G, ne) => {
    let se;
    for (; D && D !== P; )
      se = p(D), r(D, G, ne), D = se;
    r(P, G, ne);
  }, b = ({ el: D, anchor: P }) => {
    let G;
    for (; D && D !== P; )
      G = p(D), o(D), D = G;
    o(P);
  }, C = (D, P, G, ne, se, ge, Se, be, xe) => {
    if (P.type === "svg" ? Se = "svg" : P.type === "math" && (Se = "mathml"), D == null)
      x(
        P,
        G,
        ne,
        se,
        ge,
        Se,
        be,
        xe
      );
    else {
      const q = D.el && D.el._isVueCE ? D.el : null;
      try {
        q && q._beginPatch(), B(
          D,
          P,
          se,
          ge,
          Se,
          be,
          xe
        );
      } finally {
        q && q._endPatch();
      }
    }
  }, x = (D, P, G, ne, se, ge, Se, be) => {
    let xe, q;
    const { props: J, shapeFlag: ue, transition: Ae, dirs: je } = D;
    if (xe = D.el = a(
      D.type,
      ge,
      J && J.is,
      J
    ), ue & 8 ? d(xe, D.children) : ue & 16 && F(
      D.children,
      xe,
      null,
      ne,
      se,
      Hd(D, ge),
      Se,
      be
    ), je && Zo(D, null, ne, "created"), I(xe, D, D.scopeId, Se, ne), J) {
      for (const ft in J)
        ft !== "value" && !tl(ft) && s(xe, ft, null, J[ft], ge, ne);
      "value" in J && s(xe, "value", null, J.value, ge), (q = J.onVnodeBeforeMount) && or(q, ne, D);
    }
    process.env.NODE_ENV !== "production" && (wc(xe, "__vnode", D, !0), wc(xe, "__vueParentComponent", ne, !0)), je && Zo(D, null, ne, "beforeMount");
    const Ge = Ex(se, Ae);
    Ge && Ae.beforeEnter(xe), r(xe, P, G), ((q = J && J.onVnodeMounted) || Ge || je) && Rn(() => {
      q && or(q, ne, D), Ge && Ae.enter(xe), je && Zo(D, null, ne, "mounted");
    }, se);
  }, I = (D, P, G, ne, se) => {
    if (G && m(D, G), ne)
      for (let ge = 0; ge < ne.length; ge++)
        m(D, ne[ge]);
    if (se) {
      let ge = se.subTree;
      if (process.env.NODE_ENV !== "production" && ge.patchFlag > 0 && ge.patchFlag & 2048 && (ge = Rf(ge.children) || ge), P === ge || g0(ge.type) && (ge.ssContent === P || ge.ssFallback === P)) {
        const Se = se.vnode;
        I(
          D,
          Se,
          Se.scopeId,
          Se.slotScopeIds,
          se.parent
        );
      }
    }
  }, F = (D, P, G, ne, se, ge, Se, be, xe = 0) => {
    for (let q = xe; q < D.length; q++) {
      const J = D[q] = be ? Eo(D[q]) : Li(D[q]);
      y(
        null,
        J,
        P,
        G,
        ne,
        se,
        ge,
        Se,
        be
      );
    }
  }, B = (D, P, G, ne, se, ge, Se) => {
    const be = P.el = D.el;
    process.env.NODE_ENV !== "production" && (be.__vnode = P);
    let { patchFlag: xe, dynamicChildren: q, dirs: J } = P;
    xe |= D.patchFlag & 16;
    const ue = D.props || Et, Ae = P.props || Et;
    let je;
    if (G && Jo(G, !1), (je = Ae.onVnodeBeforeUpdate) && or(je, G, P, D), J && Zo(P, D, G, "beforeUpdate"), G && Jo(G, !0), process.env.NODE_ENV !== "production" && Ri && (xe = 0, Se = !1, q = null), (ue.innerHTML && Ae.innerHTML == null || ue.textContent && Ae.textContent == null) && d(be, ""), q ? (X(
      D.dynamicChildren,
      q,
      be,
      G,
      ne,
      Hd(P, se),
      ge
    ), process.env.NODE_ENV !== "production" && sl(D, P)) : Se || ae(
      D,
      P,
      be,
      null,
      G,
      ne,
      Hd(P, se),
      ge,
      !1
    ), xe > 0) {
      if (xe & 16)
        j(be, ue, Ae, G, se);
      else if (xe & 2 && ue.class !== Ae.class && s(be, "class", null, Ae.class, se), xe & 4 && s(be, "style", ue.style, Ae.style, se), xe & 8) {
        const Ge = P.dynamicProps;
        for (let ft = 0; ft < Ge.length; ft++) {
          const at = Ge[ft], nn = ue[at], Gt = Ae[at];
          (Gt !== nn || at === "value") && s(be, at, nn, Gt, se, G);
        }
      }
      xe & 1 && D.children !== P.children && d(be, P.children);
    } else !Se && q == null && j(be, ue, Ae, G, se);
    ((je = Ae.onVnodeUpdated) || J) && Rn(() => {
      je && or(je, G, P, D), J && Zo(P, D, G, "updated");
    }, ne);
  }, X = (D, P, G, ne, se, ge, Se) => {
    for (let be = 0; be < P.length; be++) {
      const xe = D[be], q = P[be], J = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        xe.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (xe.type === Fe || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !ss(xe, q) || // - In the case of a component, it could contain anything.
        xe.shapeFlag & 198) ? h(xe.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          G
        )
      );
      y(
        xe,
        q,
        J,
        null,
        ne,
        se,
        ge,
        Se,
        !0
      );
    }
  }, j = (D, P, G, ne, se) => {
    if (P !== G) {
      if (P !== Et)
        for (const ge in P)
          !tl(ge) && !(ge in G) && s(
            D,
            ge,
            P[ge],
            null,
            se,
            ne
          );
      for (const ge in G) {
        if (tl(ge)) continue;
        const Se = G[ge], be = P[ge];
        Se !== be && ge !== "value" && s(D, ge, be, Se, se, ne);
      }
      "value" in G && s(D, "value", P.value, G.value, se);
    }
  }, ee = (D, P, G, ne, se, ge, Se, be, xe) => {
    const q = P.el = D ? D.el : l(""), J = P.anchor = D ? D.anchor : l("");
    let { patchFlag: ue, dynamicChildren: Ae, slotScopeIds: je } = P;
    process.env.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (Ri || ue & 2048) && (ue = 0, xe = !1, Ae = null), je && (be = be ? be.concat(je) : je), D == null ? (r(q, G, ne), r(J, G, ne), F(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      P.children || [],
      G,
      J,
      se,
      ge,
      Se,
      be,
      xe
    )) : ue > 0 && ue & 64 && Ae && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    D.dynamicChildren ? (X(
      D.dynamicChildren,
      Ae,
      G,
      se,
      ge,
      Se,
      be
    ), process.env.NODE_ENV !== "production" ? sl(D, P) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (P.key != null || se && P === se.subTree) && sl(
        D,
        P,
        !0
        /* shallow */
      )
    )) : ae(
      D,
      P,
      G,
      J,
      se,
      ge,
      Se,
      be,
      xe
    );
  }, ie = (D, P, G, ne, se, ge, Se, be, xe) => {
    P.slotScopeIds = be, D == null ? P.shapeFlag & 512 ? se.ctx.activate(
      P,
      G,
      ne,
      Se,
      xe
    ) : M(
      P,
      G,
      ne,
      se,
      ge,
      Se,
      xe
    ) : W(D, P, xe);
  }, M = (D, P, G, ne, se, ge, Se) => {
    const be = D.component = Ax(
      D,
      ne,
      se
    );
    if (process.env.NODE_ENV !== "production" && be.type.__hmrId && h_(be), process.env.NODE_ENV !== "production" && (rc(D), zs(be, "mount")), ru(D) && (be.ctx.renderer = E), process.env.NODE_ENV !== "production" && zs(be, "init"), Fx(be, !1, Se), process.env.NODE_ENV !== "production" && Bs(be, "init"), process.env.NODE_ENV !== "production" && Ri && (D.el = null), be.asyncDep) {
      if (se && se.registerDep(be, R, Se), !D.el) {
        const xe = be.subTree = Ve(ln);
        g(null, xe, P, G), D.placeholder = xe.el;
      }
    } else
      R(
        be,
        D,
        P,
        G,
        se,
        ge,
        Se
      );
    process.env.NODE_ENV !== "production" && (oc(), Bs(be, "mount"));
  }, W = (D, P, G) => {
    const ne = P.component = D.component;
    if (ux(D, P, G))
      if (ne.asyncDep && !ne.asyncResolved) {
        process.env.NODE_ENV !== "production" && rc(P), V(ne, P, G), process.env.NODE_ENV !== "production" && oc();
        return;
      } else
        ne.next = P, ne.update();
    else
      P.el = D.el, ne.vnode = P;
  }, R = (D, P, G, ne, se, ge, Se) => {
    const be = () => {
      if (D.isMounted) {
        let { next: ue, bu: Ae, u: je, parent: Ge, vnode: ft } = D;
        {
          const _n = m0(D);
          if (_n) {
            ue && (ue.el = ft.el, V(D, ue, Se)), _n.asyncDep.then(() => {
              D.isUnmounted || be();
            });
            return;
          }
        }
        let at = ue, nn;
        process.env.NODE_ENV !== "production" && rc(ue || D.vnode), Jo(D, !1), ue ? (ue.el = ft.el, V(D, ue, Se)) : ue = ft, Ae && Ks(Ae), (nn = ue.props && ue.props.onVnodeBeforeUpdate) && or(nn, Ge, ue, ft), Jo(D, !0), process.env.NODE_ENV !== "production" && zs(D, "render");
        const Gt = rm(D);
        process.env.NODE_ENV !== "production" && Bs(D, "render");
        const wn = D.subTree;
        D.subTree = Gt, process.env.NODE_ENV !== "production" && zs(D, "patch"), y(
          wn,
          Gt,
          // parent may have changed if it's in a teleport
          h(wn.el),
          // anchor may have changed if it's in a fragment
          Ce(wn),
          D,
          se,
          ge
        ), process.env.NODE_ENV !== "production" && Bs(D, "patch"), ue.el = Gt.el, at === null && cx(D, Gt.el), je && Rn(je, se), (nn = ue.props && ue.props.onVnodeUpdated) && Rn(
          () => or(nn, Ge, ue, ft),
          se
        ), process.env.NODE_ENV !== "production" && Ay(D), process.env.NODE_ENV !== "production" && oc();
      } else {
        let ue;
        const { el: Ae, props: je } = P, { bm: Ge, m: ft, parent: at, root: nn, type: Gt } = D, wn = ua(P);
        Jo(D, !1), Ge && Ks(Ge), !wn && (ue = je && je.onVnodeBeforeMount) && or(ue, at, P), Jo(D, !0);
        {
          nn.ce && // @ts-expect-error _def is private
          nn.ce._def.shadowRoot !== !1 && nn.ce._injectChildStyle(Gt), process.env.NODE_ENV !== "production" && zs(D, "render");
          const _n = D.subTree = rm(D);
          process.env.NODE_ENV !== "production" && Bs(D, "render"), process.env.NODE_ENV !== "production" && zs(D, "patch"), y(
            null,
            _n,
            G,
            ne,
            D,
            se,
            ge
          ), process.env.NODE_ENV !== "production" && Bs(D, "patch"), P.el = _n.el;
        }
        if (ft && Rn(ft, se), !wn && (ue = je && je.onVnodeMounted)) {
          const _n = P;
          Rn(
            () => or(ue, at, _n),
            se
          );
        }
        (P.shapeFlag & 256 || at && ua(at.vnode) && at.vnode.shapeFlag & 256) && D.a && Rn(D.a, se), D.isMounted = !0, process.env.NODE_ENV !== "production" && y_(D), P = G = ne = null;
      }
    };
    D.scope.on();
    const xe = D.effect = new cy(be);
    D.scope.off();
    const q = D.update = xe.run.bind(xe), J = D.job = xe.runIfDirty.bind(xe);
    J.i = D, J.id = D.uid, xe.scheduler = () => ld(J), Jo(D, !0), process.env.NODE_ENV !== "production" && (xe.onTrack = D.rtc ? (ue) => Ks(D.rtc, ue) : void 0, xe.onTrigger = D.rtg ? (ue) => Ks(D.rtg, ue) : void 0), q();
  }, V = (D, P, G) => {
    P.component = D;
    const ne = D.vnode.props;
    D.vnode = P, D.next = null, fx(D, P.props, ne, G), Sx(D, P.children, G), Xi(), Wp(D), Yi();
  }, ae = (D, P, G, ne, se, ge, Se, be, xe = !1) => {
    const q = D && D.children, J = D ? D.shapeFlag : 0, ue = P.children, { patchFlag: Ae, shapeFlag: je } = P;
    if (Ae > 0) {
      if (Ae & 128) {
        N(
          q,
          ue,
          G,
          ne,
          se,
          ge,
          Se,
          be,
          xe
        );
        return;
      } else if (Ae & 256) {
        $e(
          q,
          ue,
          G,
          ne,
          se,
          ge,
          Se,
          be,
          xe
        );
        return;
      }
    }
    je & 8 ? (J & 16 && Re(q, se, ge), ue !== q && d(G, ue)) : J & 16 ? je & 16 ? N(
      q,
      ue,
      G,
      ne,
      se,
      ge,
      Se,
      be,
      xe
    ) : Re(q, se, ge, !0) : (J & 8 && d(G, ""), je & 16 && F(
      ue,
      G,
      ne,
      se,
      ge,
      Se,
      be,
      xe
    ));
  }, $e = (D, P, G, ne, se, ge, Se, be, xe) => {
    D = D || aa, P = P || aa;
    const q = D.length, J = P.length, ue = Math.min(q, J);
    let Ae;
    for (Ae = 0; Ae < ue; Ae++) {
      const je = P[Ae] = xe ? Eo(P[Ae]) : Li(P[Ae]);
      y(
        D[Ae],
        je,
        G,
        null,
        se,
        ge,
        Se,
        be,
        xe
      );
    }
    q > J ? Re(
      D,
      se,
      ge,
      !0,
      !1,
      ue
    ) : F(
      P,
      G,
      ne,
      se,
      ge,
      Se,
      be,
      xe,
      ue
    );
  }, N = (D, P, G, ne, se, ge, Se, be, xe) => {
    let q = 0;
    const J = P.length;
    let ue = D.length - 1, Ae = J - 1;
    for (; q <= ue && q <= Ae; ) {
      const je = D[q], Ge = P[q] = xe ? Eo(P[q]) : Li(P[q]);
      if (ss(je, Ge))
        y(
          je,
          Ge,
          G,
          null,
          se,
          ge,
          Se,
          be,
          xe
        );
      else
        break;
      q++;
    }
    for (; q <= ue && q <= Ae; ) {
      const je = D[ue], Ge = P[Ae] = xe ? Eo(P[Ae]) : Li(P[Ae]);
      if (ss(je, Ge))
        y(
          je,
          Ge,
          G,
          null,
          se,
          ge,
          Se,
          be,
          xe
        );
      else
        break;
      ue--, Ae--;
    }
    if (q > ue) {
      if (q <= Ae) {
        const je = Ae + 1, Ge = je < J ? P[je].el : ne;
        for (; q <= Ae; )
          y(
            null,
            P[q] = xe ? Eo(P[q]) : Li(P[q]),
            G,
            Ge,
            se,
            ge,
            Se,
            be,
            xe
          ), q++;
      }
    } else if (q > Ae)
      for (; q <= ue; )
        we(D[q], se, ge, !0), q++;
    else {
      const je = q, Ge = q, ft = /* @__PURE__ */ new Map();
      for (q = Ge; q <= Ae; q++) {
        const It = P[q] = xe ? Eo(P[q]) : Li(P[q]);
        It.key != null && (process.env.NODE_ENV !== "production" && ft.has(It.key) && Oe(
          "Duplicate keys found during update:",
          JSON.stringify(It.key),
          "Make sure keys are unique."
        ), ft.set(It.key, q));
      }
      let at, nn = 0;
      const Gt = Ae - Ge + 1;
      let wn = !1, _n = 0;
      const kn = new Array(Gt);
      for (q = 0; q < Gt; q++) kn[q] = 0;
      for (q = je; q <= ue; q++) {
        const It = D[q];
        if (nn >= Gt) {
          we(It, se, ge, !0);
          continue;
        }
        let mn;
        if (It.key != null)
          mn = ft.get(It.key);
        else
          for (at = Ge; at <= Ae; at++)
            if (kn[at - Ge] === 0 && ss(It, P[at])) {
              mn = at;
              break;
            }
        mn === void 0 ? we(It, se, ge, !0) : (kn[mn - Ge] = q + 1, mn >= _n ? _n = mn : wn = !0, y(
          It,
          P[mn],
          G,
          null,
          se,
          ge,
          Se,
          be,
          xe
        ), nn++);
      }
      const rn = wn ? Tx(kn) : aa;
      for (at = rn.length - 1, q = Gt - 1; q >= 0; q--) {
        const It = Ge + q, mn = P[It], Vn = P[It + 1], Or = It + 1 < J ? (
          // #13559, fallback to el placeholder for unresolved async component
          Vn.el || Vn.placeholder
        ) : ne;
        kn[q] === 0 ? y(
          null,
          mn,
          G,
          Or,
          se,
          ge,
          Se,
          be,
          xe
        ) : wn && (at < 0 || q !== rn[at] ? me(mn, G, Or, 2) : at--);
      }
    }
  }, me = (D, P, G, ne, se = null) => {
    const { el: ge, type: Se, transition: be, children: xe, shapeFlag: q } = D;
    if (q & 6) {
      me(D.component.subTree, P, G, ne);
      return;
    }
    if (q & 128) {
      D.suspense.move(P, G, ne);
      return;
    }
    if (q & 64) {
      Se.move(D, P, G, E);
      return;
    }
    if (Se === Fe) {
      r(ge, P, G);
      for (let ue = 0; ue < xe.length; ue++)
        me(xe[ue], P, G, ne);
      r(D.anchor, P, G);
      return;
    }
    if (Se === al) {
      S(D, P, G);
      return;
    }
    if (ne !== 2 && q & 1 && be)
      if (ne === 0)
        be.beforeEnter(ge), r(ge, P, G), Rn(() => be.enter(ge), se);
      else {
        const { leave: ue, delayLeave: Ae, afterLeave: je } = be, Ge = () => {
          D.ctx.isUnmounted ? o(ge) : r(ge, P, G);
        }, ft = () => {
          ge._isLeaving && ge[zr](
            !0
            /* cancelled */
          ), ue(ge, () => {
            Ge(), je && je();
          });
        };
        Ae ? Ae(ge, Ge, ft) : ft();
      }
    else
      r(ge, P, G);
  }, we = (D, P, G, ne = !1, se = !1) => {
    const {
      type: ge,
      props: Se,
      ref: be,
      children: xe,
      dynamicChildren: q,
      shapeFlag: J,
      patchFlag: ue,
      dirs: Ae,
      cacheIndex: je
    } = D;
    if (ue === -2 && (se = !1), be != null && (Xi(), rl(be, null, G, D, !0), Yi()), je != null && (P.renderCache[je] = void 0), J & 256) {
      P.ctx.deactivate(D);
      return;
    }
    const Ge = J & 1 && Ae, ft = !ua(D);
    let at;
    if (ft && (at = Se && Se.onVnodeBeforeUnmount) && or(at, P, D), J & 6)
      Me(D.component, G, ne);
    else {
      if (J & 128) {
        D.suspense.unmount(G, ne);
        return;
      }
      Ge && Zo(D, null, P, "beforeUnmount"), J & 64 ? D.type.remove(
        D,
        P,
        G,
        E,
        ne
      ) : q && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !q.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (ge !== Fe || ue > 0 && ue & 64) ? Re(
        q,
        P,
        G,
        !1,
        !0
      ) : (ge === Fe && ue & 384 || !se && J & 16) && Re(xe, P, G), ne && fe(D);
    }
    (ft && (at = Se && Se.onVnodeUnmounted) || Ge) && Rn(() => {
      at && or(at, P, D), Ge && Zo(D, null, P, "unmounted");
    }, G);
  }, fe = (D) => {
    const { type: P, el: G, anchor: ne, transition: se } = D;
    if (P === Fe) {
      process.env.NODE_ENV !== "production" && D.patchFlag > 0 && D.patchFlag & 2048 && se && !se.persisted ? D.children.forEach((Se) => {
        Se.type === ln ? o(Se.el) : fe(Se);
      }) : te(G, ne);
      return;
    }
    if (P === al) {
      b(D);
      return;
    }
    const ge = () => {
      o(G), se && !se.persisted && se.afterLeave && se.afterLeave();
    };
    if (D.shapeFlag & 1 && se && !se.persisted) {
      const { leave: Se, delayLeave: be } = se, xe = () => Se(G, ge);
      be ? be(D.el, ge, xe) : xe();
    } else
      ge();
  }, te = (D, P) => {
    let G;
    for (; D !== P; )
      G = p(D), o(D), D = G;
    o(P);
  }, Me = (D, P, G) => {
    process.env.NODE_ENV !== "production" && D.type.__hmrId && f_(D);
    const { bum: ne, scope: se, job: ge, subTree: Se, um: be, m: xe, a: q } = D;
    cm(xe), cm(q), ne && Ks(ne), se.stop(), ge && (ge.flags |= 8, we(Se, D, P, G)), be && Rn(be, P), Rn(() => {
      D.isUnmounted = !0;
    }, P), process.env.NODE_ENV !== "production" && w_(D);
  }, Re = (D, P, G, ne = !1, se = !1, ge = 0) => {
    for (let Se = ge; Se < D.length; Se++)
      we(D[Se], P, G, ne, se);
  }, Ce = (D) => {
    if (D.shapeFlag & 6)
      return Ce(D.component.subTree);
    if (D.shapeFlag & 128)
      return D.suspense.next();
    const P = p(D.anchor || D.el), G = P && P[Ry];
    return G ? p(G) : P;
  };
  let le = !1;
  const T = (D, P, G) => {
    D == null ? P._vnode && we(P._vnode, null, null, !0) : y(
      P._vnode || null,
      D,
      P,
      null,
      null,
      null,
      G
    ), P._vnode = D, le || (le = !0, Wp(), Py(), le = !1);
  }, E = {
    p: y,
    um: we,
    m: me,
    r: fe,
    mt: M,
    mc: F,
    pc: ae,
    pbc: X,
    n: Ce,
    o: i
  };
  return {
    render: T,
    hydrate: void 0,
    createApp: J_(T)
  };
}
function Hd({ type: i, props: e }, n) {
  return n === "svg" && i === "foreignObject" || n === "mathml" && i === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n;
}
function Jo({ effect: i, job: e }, n) {
  n ? (i.flags |= 32, e.flags |= 4) : (i.flags &= -33, e.flags &= -5);
}
function Ex(i, e) {
  return (!i || i && !i.pendingBranch) && e && !e.persisted;
}
function sl(i, e, n = !1) {
  const r = i.children, o = e.children;
  if (We(r) && We(o))
    for (let s = 0; s < r.length; s++) {
      const a = r[s];
      let l = o[s];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = o[s] = Eo(o[s]), l.el = a.el), !n && l.patchFlag !== -2 && sl(a, l)), l.type === ou && // avoid cached text nodes retaining detached dom nodes
      l.patchFlag !== -1 && (l.el = a.el), l.type === ln && !l.el && (l.el = a.el), process.env.NODE_ENV !== "production" && l.el && (l.el.__vnode = l);
    }
}
function Tx(i) {
  const e = i.slice(), n = [0];
  let r, o, s, a, l;
  const u = i.length;
  for (r = 0; r < u; r++) {
    const c = i[r];
    if (c !== 0) {
      if (o = n[n.length - 1], i[o] < c) {
        e[r] = o, n.push(r);
        continue;
      }
      for (s = 0, a = n.length - 1; s < a; )
        l = s + a >> 1, i[n[l]] < c ? s = l + 1 : a = l;
      c < i[n[s]] && (s > 0 && (e[r] = n[s - 1]), n[s] = r);
    }
  }
  for (s = n.length, a = n[s - 1]; s-- > 0; )
    n[s] = a, a = e[a];
  return n;
}
function m0(i) {
  const e = i.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : m0(e);
}
function cm(i) {
  if (i)
    for (let e = 0; e < i.length; e++)
      i[e].flags |= 8;
}
const g0 = (i) => i.__isSuspense;
function Dx(i, e) {
  e && e.pendingBranch ? We(i) ? e.effects.push(...i) : e.effects.push(i) : My(i);
}
const Fe = Symbol.for("v-fgt"), ou = Symbol.for("v-txt"), ln = Symbol.for("v-cmt"), al = Symbol.for("v-stc"), ll = [];
let ai = null;
function $(i = !1) {
  ll.push(ai = i ? null : []);
}
function $x() {
  ll.pop(), ai = ll[ll.length - 1] || null;
}
let _l = 1;
function Pc(i, e = !1) {
  _l += i, i < 0 && ai && e && (ai.hasOnce = !0);
}
function v0(i) {
  return i.dynamicChildren = _l > 0 ? ai || aa : null, $x(), _l > 0 && ai && ai.push(i), i;
}
function A(i, e, n, r, o, s) {
  return v0(
    f(
      i,
      e,
      n,
      r,
      o,
      s,
      !0
    )
  );
}
function st(i, e, n, r, o) {
  return v0(
    Ve(
      i,
      e,
      n,
      r,
      o,
      !0
    )
  );
}
function Ds(i) {
  return i ? i.__v_isVNode === !0 : !1;
}
function ss(i, e) {
  if (process.env.NODE_ENV !== "production" && e.shapeFlag & 6 && i.component) {
    const n = sc.get(e.type);
    if (n && n.has(i.component))
      return i.shapeFlag &= -257, e.shapeFlag &= -513, !1;
  }
  return i.type === e.type && i.key === e.key;
}
const Mx = (...i) => b0(
  ...i
), y0 = ({ key: i }) => i ?? null, lc = ({
  ref: i,
  ref_key: e,
  ref_for: n
}) => (typeof i == "number" && (i = "" + i), i != null ? jt(i) || At(i) || qe(i) ? { i: pn, r: i, k: e, f: !!n } : i : null);
function f(i, e = null, n = null, r = 0, o = null, s = i === Fe ? 0 : 1, a = !1, l = !1) {
  const u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: i,
    props: e,
    key: e && y0(e),
    ref: e && lc(e),
    scopeId: Fy,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: r,
    dynamicProps: o,
    dynamicChildren: null,
    appContext: null,
    ctx: pn
  };
  return l ? (Bf(u, n), s & 128 && i.normalize(u)) : n && (u.shapeFlag |= jt(n) ? 8 : 16), process.env.NODE_ENV !== "production" && u.key !== u.key && Oe("VNode created with invalid key (NaN). VNode type:", u.type), _l > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  ai && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (u.patchFlag > 0 || s & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  u.patchFlag !== 32 && ai.push(u), u;
}
const Ve = process.env.NODE_ENV !== "production" ? Mx : b0;
function b0(i, e = null, n = null, r = 0, o = null, s = !1) {
  if ((!i || i === Zy) && (process.env.NODE_ENV !== "production" && !i && Oe(`Invalid vnode type when creating vnode: ${i}.`), i = ln), Ds(i)) {
    const l = xr(
      i,
      e,
      !0
      /* mergeRef: true */
    );
    return n && Bf(l, n), _l > 0 && !s && ai && (l.shapeFlag & 6 ? ai[ai.indexOf(i)] = l : ai.push(l)), l.patchFlag = -2, l;
  }
  if (S0(i) && (i = i.__vccOpts), e) {
    e = Px(e);
    let { class: l, style: u } = e;
    l && !jt(l) && (e.class = _e(l)), wt(u) && (ma(u) && !We(u) && (u = en({}, u)), e.style = Pt(u));
  }
  const a = jt(i) ? 1 : g0(i) ? 128 : Ny(i) ? 64 : wt(i) ? 4 : qe(i) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && a & 4 && ma(i) && (i = et(i), Oe(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    i
  )), f(
    i,
    e,
    n,
    r,
    o,
    a,
    s,
    !0
  );
}
function Px(i) {
  return i ? ma(i) || u0(i) ? en({}, i) : i : null;
}
function xr(i, e, n = !1, r = !1) {
  const { props: o, ref: s, patchFlag: a, children: l, transition: u } = i, c = e ? ke(o || {}, e) : o, d = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: i.type,
    props: c,
    key: c && y0(c),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && s ? We(s) ? s.concat(lc(e)) : [s, lc(e)] : lc(e)
    ) : s,
    scopeId: i.scopeId,
    slotScopeIds: i.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && a === -1 && We(l) ? l.map(w0) : l,
    target: i.target,
    targetStart: i.targetStart,
    targetAnchor: i.targetAnchor,
    staticCount: i.staticCount,
    shapeFlag: i.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && i.type !== Fe ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: i.dynamicProps,
    dynamicChildren: i.dynamicChildren,
    appContext: i.appContext,
    dirs: i.dirs,
    transition: u,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: i.component,
    suspense: i.suspense,
    ssContent: i.ssContent && xr(i.ssContent),
    ssFallback: i.ssFallback && xr(i.ssFallback),
    placeholder: i.placeholder,
    el: i.el,
    anchor: i.anchor,
    ctx: i.ctx,
    ce: i.ce
  };
  return u && r && wl(
    d,
    u.clone(d)
  ), d;
}
function w0(i) {
  const e = xr(i);
  return We(i.children) && (e.children = i.children.map(w0)), e;
}
function vt(i = " ", e = 0) {
  return Ve(ou, null, i, e);
}
function va(i, e) {
  const n = Ve(al, null, i);
  return n.staticCount = e, n;
}
function ve(i = "", e = !1) {
  return e ? ($(), st(ln, null, i)) : Ve(ln, null, i);
}
function Li(i) {
  return i == null || typeof i == "boolean" ? Ve(ln) : We(i) ? Ve(
    Fe,
    null,
    // #3666, avoid reference pollution when reusing vnode
    i.slice()
  ) : Ds(i) ? Eo(i) : Ve(ou, null, String(i));
}
function Eo(i) {
  return i.el === null && i.patchFlag !== -1 || i.memo ? i : xr(i);
}
function Bf(i, e) {
  let n = 0;
  const { shapeFlag: r } = i;
  if (e == null)
    e = null;
  else if (We(e))
    n = 16;
  else if (typeof e == "object")
    if (r & 65) {
      const o = e.default;
      o && (o._c && (o._d = !1), Bf(i, o()), o._c && (o._d = !0));
      return;
    } else {
      n = 32;
      const o = e._;
      !o && !u0(e) ? e._ctx = pn : o === 3 && pn && (pn.slots._ === 1 ? e._ = 1 : (e._ = 2, i.patchFlag |= 1024));
    }
  else qe(e) ? (e = { default: e, _ctx: pn }, n = 32) : (e = String(e), r & 64 ? (n = 16, e = [vt(e)]) : n = 8);
  i.children = e, i.shapeFlag |= n;
}
function ke(...i) {
  const e = {};
  for (let n = 0; n < i.length; n++) {
    const r = i[n];
    for (const o in r)
      if (o === "class")
        e.class !== r.class && (e.class = _e([e.class, r.class]));
      else if (o === "style")
        e.style = Pt([e.style, r.style]);
      else if (Jl(o)) {
        const s = e[o], a = r[o];
        a && s !== a && !(We(s) && s.includes(a)) && (e[o] = s ? [].concat(s, a) : a);
      } else o !== "" && (e[o] = r[o]);
  }
  return e;
}
function or(i, e, n, r = null) {
  Zi(i, e, 7, [
    n,
    r
  ]);
}
const Ix = n0();
let Lx = 0;
function Ax(i, e, n) {
  const r = i.type, o = (e ? e.appContext : i.appContext) || Ix, s = {
    uid: Lx++,
    vnode: i,
    type: r,
    parent: e,
    appContext: o,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new ay(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(o.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: d0(r, o),
    emitsOptions: o0(r, o),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Et,
    // inheritAttrs
    inheritAttrs: r.inheritAttrs,
    // state
    ctx: Et,
    data: Et,
    props: Et,
    attrs: Et,
    slots: Et,
    refs: Et,
    setupState: Et,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return process.env.NODE_ENV !== "production" ? s.ctx = B_(s) : s.ctx = { _: s }, s.root = e ? e.root : s, s.emit = ox.bind(null, s), i.ce && i.ce(s), s;
}
let hn = null;
const jo = () => hn || pn;
let Ic, Ph;
{
  const i = eu(), e = (n, r) => {
    let o;
    return (o = i[n]) || (o = i[n] = []), o.push(r), (s) => {
      o.length > 1 ? o.forEach((a) => a(s)) : o[0](s);
    };
  };
  Ic = e(
    "__VUE_INSTANCE_SETTERS__",
    (n) => hn = n
  ), Ph = e(
    "__VUE_SSR_SETTERS__",
    (n) => xl = n
  );
}
const su = (i) => {
  const e = hn;
  return Ic(i), i.scope.on(), () => {
    i.scope.off(), Ic(e);
  };
}, dm = () => {
  hn && hn.scope.off(), Ic(null);
}, Vx = /* @__PURE__ */ so("slot,component");
function Ih(i, { isNativeTag: e }) {
  (Vx(i) || e(i)) && Oe(
    "Do not use built-in or reserved HTML elements as component id: " + i
  );
}
function _0(i) {
  return i.vnode.shapeFlag & 4;
}
let xl = !1;
function Fx(i, e = !1, n = !1) {
  e && Ph(e);
  const { props: r, children: o } = i.vnode, s = _0(i);
  dx(i, r, s, e), xx(i, o, n || e);
  const a = s ? jx(i, e) : void 0;
  return e && Ph(!1), a;
}
function jx(i, e) {
  const n = i.type;
  if (process.env.NODE_ENV !== "production") {
    if (n.name && Ih(n.name, i.appContext.config), n.components) {
      const o = Object.keys(n.components);
      for (let s = 0; s < o.length; s++)
        Ih(o[s], i.appContext.config);
    }
    if (n.directives) {
      const o = Object.keys(n.directives);
      for (let s = 0; s < o.length; s++)
        jy(o[s]);
    }
    n.compilerOptions && Rx() && Oe(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  i.accessCache = /* @__PURE__ */ Object.create(null), i.proxy = new Proxy(i.ctx, Qy), process.env.NODE_ENV !== "production" && H_(i);
  const { setup: r } = n;
  if (r) {
    Xi();
    const o = i.setupContext = r.length > 1 ? zx(i) : null, s = su(i), a = Sa(
      r,
      i,
      0,
      [
        process.env.NODE_ENV !== "production" ? gr(i.props) : i.props,
        o
      ]
    ), l = kf(a);
    if (Yi(), s(), (l || i.sp) && !ua(i) && Yy(i), l) {
      if (a.then(dm, dm), e)
        return a.then((u) => {
          hm(i, u, e);
        }).catch((u) => {
          nu(u, i, 0);
        });
      if (i.asyncDep = a, process.env.NODE_ENV !== "production" && !i.suspense) {
        const u = au(i, n);
        Oe(
          `Component <${u}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      hm(i, a, e);
  } else
    x0(i, e);
}
function hm(i, e, n) {
  qe(e) ? i.type.__ssrInlineRender ? i.ssrRender = e : i.render = e : wt(e) ? (process.env.NODE_ENV !== "production" && Ds(e) && Oe(
    "setup() should not return VNodes directly - return a render function instead."
  ), process.env.NODE_ENV !== "production" && (i.devtoolsRawSetupState = e), i.setupState = Oy(e), process.env.NODE_ENV !== "production" && U_(i)) : process.env.NODE_ENV !== "production" && e !== void 0 && Oe(
    `setup() should return an object. Received: ${e === null ? "null" : typeof e}`
  ), x0(i, n);
}
const Rx = () => !0;
function x0(i, e, n) {
  const r = i.type;
  i.render || (i.render = r.render || vn);
  {
    const o = su(i);
    Xi();
    try {
      G_(i);
    } finally {
      Yi(), o();
    }
  }
  process.env.NODE_ENV !== "production" && !r.render && i.render === vn && !e && (r.template ? Oe(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : Oe("Component is missing template or render function: ", r));
}
const fm = process.env.NODE_ENV !== "production" ? {
  get(i, e) {
    return $c(), gn(i, "get", ""), i[e];
  },
  set() {
    return Oe("setupContext.attrs is readonly."), !1;
  },
  deleteProperty() {
    return Oe("setupContext.attrs is readonly."), !1;
  }
} : {
  get(i, e) {
    return gn(i, "get", ""), i[e];
  }
};
function Nx(i) {
  return new Proxy(i.slots, {
    get(e, n) {
      return gn(i, "get", "$slots"), e[n];
    }
  });
}
function zx(i) {
  const e = (n) => {
    if (process.env.NODE_ENV !== "production" && (i.exposed && Oe("expose() should be called only once per setup()."), n != null)) {
      let r = typeof n;
      r === "object" && (We(n) ? r = "array" : At(n) && (r = "ref")), r !== "object" && Oe(
        `expose() should be passed a plain object, received ${r}.`
      );
    }
    i.exposed = n || {};
  };
  if (process.env.NODE_ENV !== "production") {
    let n, r;
    return Object.freeze({
      get attrs() {
        return n || (n = new Proxy(i.attrs, fm));
      },
      get slots() {
        return r || (r = Nx(i));
      },
      get emit() {
        return (o, ...s) => i.emit(o, ...s);
      },
      expose: e
    });
  } else
    return {
      attrs: new Proxy(i.attrs, fm),
      slots: i.slots,
      emit: i.emit,
      expose: e
    };
}
function dd(i) {
  return i.exposed ? i.exposeProxy || (i.exposeProxy = new Proxy(Oy(ji(i.exposed)), {
    get(e, n) {
      if (n in e)
        return e[n];
      if (n in ws)
        return ws[n](i);
    },
    has(e, n) {
      return n in e || n in ws;
    }
  })) : i.proxy;
}
const Bx = /(?:^|[-_])\w/g, Hx = (i) => i.replace(Bx, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function Hf(i, e = !0) {
  return qe(i) ? i.displayName || i.name : i.name || e && i.__name;
}
function au(i, e, n = !1) {
  let r = Hf(e);
  if (!r && e.__file) {
    const o = e.__file.match(/([^/\\]+)\.\w+$/);
    o && (r = o[1]);
  }
  if (!r && i) {
    const o = (s) => {
      for (const a in s)
        if (s[a] === e)
          return a;
    };
    r = o(i.components) || i.parent && o(
      i.parent.type.components
    ) || o(i.appContext.components);
  }
  return r ? Hx(r) : n ? "App" : "Anonymous";
}
function S0(i) {
  return qe(i) && "__vccOpts" in i;
}
const Ee = (i, e) => {
  const n = t_(i, e, xl);
  if (process.env.NODE_ENV !== "production") {
    const r = jo();
    r && r.appContext.config.warnRecursiveComputed && (n._warnRecursive = !0);
  }
  return n;
};
function Ux(i, e, n) {
  try {
    Pc(-1);
    const r = arguments.length;
    return r === 2 ? wt(e) && !We(e) ? Ds(e) ? Ve(i, null, [e]) : Ve(i, e) : Ve(i, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && Ds(n) && (n = [n]), Ve(i, e, n));
  } finally {
    Pc(1);
  }
}
function Wx() {
  if (process.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const i = { style: "color:#3ba776" }, e = { style: "color:#1677ff" }, n = { style: "color:#f5222d" }, r = { style: "color:#eb2f96" }, o = {
    __vue_custom_formatter: !0,
    header(h) {
      if (!wt(h))
        return null;
      if (h.__isVue)
        return ["div", i, "VueInstance"];
      if (At(h)) {
        Xi();
        const p = h.value;
        return Yi(), [
          "div",
          {},
          ["span", i, d(h)],
          "<",
          l(p),
          ">"
        ];
      } else {
        if (Hi(h))
          return [
            "div",
            {},
            ["span", i, Ln(h) ? "ShallowReactive" : "Reactive"],
            "<",
            l(h),
            `>${Ki(h) ? " (readonly)" : ""}`
          ];
        if (Ki(h))
          return [
            "div",
            {},
            ["span", i, Ln(h) ? "ShallowReadonly" : "Readonly"],
            "<",
            l(h),
            ">"
          ];
      }
      return null;
    },
    hasBody(h) {
      return h && h.__isVue;
    },
    body(h) {
      if (h && h.__isVue)
        return [
          "div",
          {},
          ...s(h.$)
        ];
    }
  };
  function s(h) {
    const p = [];
    h.type.props && h.props && p.push(a("props", et(h.props))), h.setupState !== Et && p.push(a("setup", h.setupState)), h.data !== Et && p.push(a("data", et(h.data)));
    const m = u(h, "computed");
    m && p.push(a("computed", m));
    const v = u(h, "inject");
    return v && p.push(a("injected", v)), p.push([
      "div",
      {},
      [
        "span",
        {
          style: r.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: h }]
    ]), p;
  }
  function a(h, p) {
    return p = en({}, p), Object.keys(p).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        h
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(p).map((m) => [
          "div",
          {},
          ["span", r, m + ": "],
          l(p[m], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function l(h, p = !0) {
    return typeof h == "number" ? ["span", e, h] : typeof h == "string" ? ["span", n, JSON.stringify(h)] : typeof h == "boolean" ? ["span", r, h] : wt(h) ? ["object", { object: p ? et(h) : h }] : ["span", n, String(h)];
  }
  function u(h, p) {
    const m = h.type;
    if (qe(m))
      return;
    const v = {};
    for (const y in h.ctx)
      c(m, y, p) && (v[y] = h.ctx[y]);
    return v;
  }
  function c(h, p, m) {
    const v = h[m];
    if (We(v) && v.includes(p) || wt(v) && p in v || h.extends && c(h.extends, p, m) || h.mixins && h.mixins.some((y) => c(y, p, m)))
      return !0;
  }
  function d(h) {
    return Ln(h) ? "ShallowRef" : h.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(o) : window.devtoolsFormatters = [o];
}
const pm = "3.5.25", br = process.env.NODE_ENV !== "production" ? Oe : vn;
process.env.NODE_ENV;
process.env.NODE_ENV;
/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Lh;
const mm = typeof window < "u" && window.trustedTypes;
if (mm)
  try {
    Lh = /* @__PURE__ */ mm.createPolicy("vue", {
      createHTML: (i) => i
    });
  } catch (i) {
    process.env.NODE_ENV !== "production" && br(`Error creating trusted types policy: ${i}`);
  }
const C0 = Lh ? (i) => Lh.createHTML(i) : (i) => i, Gx = "http://www.w3.org/2000/svg", Xx = "http://www.w3.org/1998/Math/MathML", Rr = typeof document < "u" ? document : null, gm = Rr && /* @__PURE__ */ Rr.createElement("template"), Yx = {
  insert: (i, e, n) => {
    e.insertBefore(i, n || null);
  },
  remove: (i) => {
    const e = i.parentNode;
    e && e.removeChild(i);
  },
  createElement: (i, e, n, r) => {
    const o = e === "svg" ? Rr.createElementNS(Gx, i) : e === "mathml" ? Rr.createElementNS(Xx, i) : n ? Rr.createElement(i, { is: n }) : Rr.createElement(i);
    return i === "select" && r && r.multiple != null && o.setAttribute("multiple", r.multiple), o;
  },
  createText: (i) => Rr.createTextNode(i),
  createComment: (i) => Rr.createComment(i),
  setText: (i, e) => {
    i.nodeValue = e;
  },
  setElementText: (i, e) => {
    i.textContent = e;
  },
  parentNode: (i) => i.parentNode,
  nextSibling: (i) => i.nextSibling,
  querySelector: (i) => Rr.querySelector(i),
  setScopeId(i, e) {
    i.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(i, e, n, r, o, s) {
    const a = n ? n.previousSibling : e.lastChild;
    if (o && (o === s || o.nextSibling))
      for (; e.insertBefore(o.cloneNode(!0), n), !(o === s || !(o = o.nextSibling)); )
        ;
    else {
      gm.innerHTML = C0(
        r === "svg" ? `<svg>${i}</svg>` : r === "mathml" ? `<math>${i}</math>` : i
      );
      const l = gm.content;
      if (r === "svg" || r === "mathml") {
        const u = l.firstChild;
        for (; u.firstChild; )
          l.appendChild(u.firstChild);
        l.removeChild(u);
      }
      e.insertBefore(l, n);
    }
    return [
      // first
      a ? a.nextSibling : e.firstChild,
      // last
      n ? n.previousSibling : e.lastChild
    ];
  }
}, bo = "transition", Aa = "animation", Sl = Symbol("_vtc"), k0 = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, Kx = /* @__PURE__ */ en(
  {},
  Hy,
  k0
), qx = (i) => (i.displayName = "Transition", i.props = Kx, i), Uf = /* @__PURE__ */ qx(
  (i, { slots: e }) => Ux(T_, Zx(i), e)
), Qo = (i, e = []) => {
  We(i) ? i.forEach((n) => n(...e)) : i && i(...e);
}, vm = (i) => i ? We(i) ? i.some((e) => e.length > 1) : i.length > 1 : !1;
function Zx(i) {
  const e = {};
  for (const j in i)
    j in k0 || (e[j] = i[j]);
  if (i.css === !1)
    return e;
  const {
    name: n = "v",
    type: r,
    duration: o,
    enterFromClass: s = `${n}-enter-from`,
    enterActiveClass: a = `${n}-enter-active`,
    enterToClass: l = `${n}-enter-to`,
    appearFromClass: u = s,
    appearActiveClass: c = a,
    appearToClass: d = l,
    leaveFromClass: h = `${n}-leave-from`,
    leaveActiveClass: p = `${n}-leave-active`,
    leaveToClass: m = `${n}-leave-to`
  } = i, v = Jx(o), y = v && v[0], w = v && v[1], {
    onBeforeEnter: g,
    onEnter: k,
    onEnterCancelled: _,
    onLeave: S,
    onLeaveCancelled: b,
    onBeforeAppear: C = g,
    onAppear: x = k,
    onAppearCancelled: I = _
  } = e, F = (j, ee, ie, M) => {
    j._enterCancelled = M, es(j, ee ? d : l), es(j, ee ? c : a), ie && ie();
  }, B = (j, ee) => {
    j._isLeaving = !1, es(j, h), es(j, m), es(j, p), ee && ee();
  }, X = (j) => (ee, ie) => {
    const M = j ? x : k, W = () => F(ee, j, ie);
    Qo(M, [ee, W]), ym(() => {
      es(ee, j ? u : s), Ir(ee, j ? d : l), vm(M) || bm(ee, r, y, W);
    });
  };
  return en(e, {
    onBeforeEnter(j) {
      Qo(g, [j]), Ir(j, s), Ir(j, a);
    },
    onBeforeAppear(j) {
      Qo(C, [j]), Ir(j, u), Ir(j, c);
    },
    onEnter: X(!1),
    onAppear: X(!0),
    onLeave(j, ee) {
      j._isLeaving = !0;
      const ie = () => B(j, ee);
      Ir(j, h), j._enterCancelled ? (Ir(j, p), xm(j)) : (xm(j), Ir(j, p)), ym(() => {
        j._isLeaving && (es(j, h), Ir(j, m), vm(S) || bm(j, r, w, ie));
      }), Qo(S, [j, ie]);
    },
    onEnterCancelled(j) {
      F(j, !1, void 0, !0), Qo(_, [j]);
    },
    onAppearCancelled(j) {
      F(j, !0, void 0, !0), Qo(I, [j]);
    },
    onLeaveCancelled(j) {
      B(j), Qo(b, [j]);
    }
  });
}
function Jx(i) {
  if (i == null)
    return null;
  if (wt(i))
    return [Ud(i.enter), Ud(i.leave)];
  {
    const e = Ud(i);
    return [e, e];
  }
}
function Ud(i) {
  const e = fw(i);
  return process.env.NODE_ENV !== "production" && l_(e, "<transition> explicit duration"), e;
}
function Ir(i, e) {
  e.split(/\s+/).forEach((n) => n && i.classList.add(n)), (i[Sl] || (i[Sl] = /* @__PURE__ */ new Set())).add(e);
}
function es(i, e) {
  e.split(/\s+/).forEach((r) => r && i.classList.remove(r));
  const n = i[Sl];
  n && (n.delete(e), n.size || (i[Sl] = void 0));
}
function ym(i) {
  requestAnimationFrame(() => {
    requestAnimationFrame(i);
  });
}
let Qx = 0;
function bm(i, e, n, r) {
  const o = i._endId = ++Qx, s = () => {
    o === i._endId && r();
  };
  if (n != null)
    return setTimeout(s, n);
  const { type: a, timeout: l, propCount: u } = eS(i, e);
  if (!a)
    return r();
  const c = a + "end";
  let d = 0;
  const h = () => {
    i.removeEventListener(c, p), s();
  }, p = (m) => {
    m.target === i && ++d >= u && h();
  };
  setTimeout(() => {
    d < u && h();
  }, l + 1), i.addEventListener(c, p);
}
function eS(i, e) {
  const n = window.getComputedStyle(i), r = (v) => (n[v] || "").split(", "), o = r(`${bo}Delay`), s = r(`${bo}Duration`), a = wm(o, s), l = r(`${Aa}Delay`), u = r(`${Aa}Duration`), c = wm(l, u);
  let d = null, h = 0, p = 0;
  e === bo ? a > 0 && (d = bo, h = a, p = s.length) : e === Aa ? c > 0 && (d = Aa, h = c, p = u.length) : (h = Math.max(a, c), d = h > 0 ? a > c ? bo : Aa : null, p = d ? d === bo ? s.length : u.length : 0);
  const m = d === bo && /\b(?:transform|all)(?:,|$)/.test(
    r(`${bo}Property`).toString()
  );
  return {
    type: d,
    timeout: h,
    propCount: p,
    hasTransform: m
  };
}
function wm(i, e) {
  for (; i.length < e.length; )
    i = i.concat(i);
  return Math.max(...e.map((n, r) => _m(n) + _m(i[r])));
}
function _m(i) {
  return i === "auto" ? 0 : Number(i.slice(0, -1).replace(",", ".")) * 1e3;
}
function xm(i) {
  return (i ? i.ownerDocument : document).body.offsetHeight;
}
function tS(i, e, n) {
  const r = i[Sl];
  r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? i.removeAttribute("class") : n ? i.setAttribute("class", e) : i.className = e;
}
const Lc = Symbol("_vod"), O0 = Symbol("_vsh"), ts = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(i, { value: e }, { transition: n }) {
    i[Lc] = i.style.display === "none" ? "" : i.style.display, n && e ? n.beforeEnter(i) : Va(i, e);
  },
  mounted(i, { value: e }, { transition: n }) {
    n && e && n.enter(i);
  },
  updated(i, { value: e, oldValue: n }, { transition: r }) {
    !e != !n && (r ? e ? (r.beforeEnter(i), Va(i, !0), r.enter(i)) : r.leave(i, () => {
      Va(i, !1);
    }) : Va(i, e));
  },
  beforeUnmount(i, { value: e }) {
    Va(i, e);
  }
};
function Va(i, e) {
  i.style.display = e ? i[Lc] : "none", i[O0] = !e;
}
const nS = Symbol(process.env.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : ""), iS = /(?:^|;)\s*display\s*:/;
function rS(i, e, n) {
  const r = i.style, o = jt(n);
  let s = !1;
  if (n && !o) {
    if (e)
      if (jt(e))
        for (const a of e.split(";")) {
          const l = a.slice(0, a.indexOf(":")).trim();
          n[l] == null && uc(r, l, "");
        }
      else
        for (const a in e)
          n[a] == null && uc(r, a, "");
    for (const a in n)
      a === "display" && (s = !0), uc(r, a, n[a]);
  } else if (o) {
    if (e !== n) {
      const a = r[nS];
      a && (n += ";" + a), r.cssText = n, s = iS.test(n);
    }
  } else e && i.removeAttribute("style");
  Lc in i && (i[Lc] = s ? r.display : "", i[O0] && (r.display = "none"));
}
const oS = /[^\\];\s*$/, Sm = /\s*!important$/;
function uc(i, e, n) {
  if (We(n))
    n.forEach((r) => uc(i, e, r));
  else if (n == null && (n = ""), process.env.NODE_ENV !== "production" && oS.test(n) && br(
    `Unexpected semicolon at the end of '${e}' style value: '${n}'`
  ), e.startsWith("--"))
    i.setProperty(e, n);
  else {
    const r = sS(i, e);
    Sm.test(n) ? i.setProperty(
      to(r),
      n.replace(Sm, ""),
      "important"
    ) : i[r] = n;
  }
}
const Cm = ["Webkit", "Moz", "ms"], Wd = {};
function sS(i, e) {
  const n = Wd[e];
  if (n)
    return n;
  let r = Hn(e);
  if (r !== "filter" && r in i)
    return Wd[e] = r;
  r = Os(r);
  for (let o = 0; o < Cm.length; o++) {
    const s = Cm[o] + r;
    if (s in i)
      return Wd[e] = s;
  }
  return e;
}
const km = "http://www.w3.org/1999/xlink";
function Om(i, e, n, r, o, s = Ow(e)) {
  r && e.startsWith("xlink:") ? n == null ? i.removeAttributeNS(km, e.slice(6, e.length)) : i.setAttributeNS(km, e, n) : n == null || s && !ry(n) ? i.removeAttribute(e) : i.setAttribute(
    e,
    s ? "" : Gi(n) ? String(n) : n
  );
}
function Em(i, e, n, r, o) {
  if (e === "innerHTML" || e === "textContent") {
    n != null && (i[e] = e === "innerHTML" ? C0(n) : n);
    return;
  }
  const s = i.tagName;
  if (e === "value" && s !== "PROGRESS" && // custom elements may use _value internally
  !s.includes("-")) {
    const l = s === "OPTION" ? i.getAttribute("value") || "" : i.value, u = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      i.type === "checkbox" ? "on" : ""
    ) : String(n);
    (l !== u || !("_value" in i)) && (i.value = u), n == null && i.removeAttribute(e), i._value = n;
    return;
  }
  let a = !1;
  if (n === "" || n == null) {
    const l = typeof i[e];
    l === "boolean" ? n = ry(n) : n == null && l === "string" ? (n = "", a = !0) : l === "number" && (n = 0, a = !0);
  }
  try {
    i[e] = n;
  } catch (l) {
    process.env.NODE_ENV !== "production" && !a && br(
      `Failed setting prop "${e}" on <${s.toLowerCase()}>: value ${n} is invalid.`,
      l
    );
  }
  a && i.removeAttribute(o || e);
}
function Do(i, e, n, r) {
  i.addEventListener(e, n, r);
}
function aS(i, e, n, r) {
  i.removeEventListener(e, n, r);
}
const Tm = Symbol("_vei");
function lS(i, e, n, r, o = null) {
  const s = i[Tm] || (i[Tm] = {}), a = s[e];
  if (r && a)
    a.value = process.env.NODE_ENV !== "production" ? $m(r, e) : r;
  else {
    const [l, u] = uS(e);
    if (r) {
      const c = s[e] = hS(
        process.env.NODE_ENV !== "production" ? $m(r, e) : r,
        o
      );
      Do(i, l, c, u);
    } else a && (aS(i, l, a, u), s[e] = void 0);
  }
}
const Dm = /(?:Once|Passive|Capture)$/;
function uS(i) {
  let e;
  if (Dm.test(i)) {
    e = {};
    let r;
    for (; r = i.match(Dm); )
      i = i.slice(0, i.length - r[0].length), e[r[0].toLowerCase()] = !0;
  }
  return [i[2] === ":" ? i.slice(3) : to(i.slice(2)), e];
}
let Gd = 0;
const cS = /* @__PURE__ */ Promise.resolve(), dS = () => Gd || (cS.then(() => Gd = 0), Gd = Date.now());
function hS(i, e) {
  const n = (r) => {
    if (!r._vts)
      r._vts = Date.now();
    else if (r._vts <= n.attached)
      return;
    Zi(
      fS(r, n.value),
      e,
      5,
      [r]
    );
  };
  return n.value = i, n.attached = dS(), n;
}
function $m(i, e) {
  return qe(i) || We(i) ? i : (br(
    `Wrong type passed as event handler to ${e} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof i}.`
  ), vn);
}
function fS(i, e) {
  if (We(e)) {
    const n = i.stopImmediatePropagation;
    return i.stopImmediatePropagation = () => {
      n.call(i), i._stopped = !0;
    }, e.map(
      (r) => (o) => !o._stopped && r && r(o)
    );
  } else
    return e;
}
const Mm = (i) => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && // lowercase letter
i.charCodeAt(2) > 96 && i.charCodeAt(2) < 123, pS = (i, e, n, r, o, s) => {
  const a = o === "svg";
  e === "class" ? tS(i, r, a) : e === "style" ? rS(i, n, r) : Jl(e) ? bc(e) || lS(i, e, n, r, s) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : mS(i, e, r, a)) ? (Em(i, e, r), !i.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && Om(i, e, r, a, s, e !== "value")) : /* #11081 force set props for possible async custom element */ i._isVueCE && (/[A-Z]/.test(e) || !jt(r)) ? Em(i, Hn(e), r, s, e) : (e === "true-value" ? i._trueValue = r : e === "false-value" && (i._falseValue = r), Om(i, e, r, a));
};
function mS(i, e, n, r) {
  if (r)
    return !!(e === "innerHTML" || e === "textContent" || e in i && Mm(e) && qe(n));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && i.tagName === "IFRAME" || e === "form" || e === "list" && i.tagName === "INPUT" || e === "type" && i.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const o = i.tagName;
    if (o === "IMG" || o === "VIDEO" || o === "CANVAS" || o === "SOURCE")
      return !1;
  }
  return Mm(e) && jt(n) ? !1 : e in i;
}
const ya = (i) => {
  const e = i.props["onUpdate:modelValue"] || !1;
  return We(e) ? (n) => Ks(e, n) : e;
};
function gS(i) {
  i.target.composing = !0;
}
function Pm(i) {
  const e = i.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const qr = Symbol("_assign");
function Im(i, e, n) {
  return e && (i = i.trim()), n && (i = rd(i)), i;
}
const Qt = {
  created(i, { modifiers: { lazy: e, trim: n, number: r } }, o) {
    i[qr] = ya(o);
    const s = r || o.props && o.props.type === "number";
    Do(i, e ? "change" : "input", (a) => {
      a.target.composing || i[qr](Im(i.value, n, s));
    }), (n || s) && Do(i, "change", () => {
      i.value = Im(i.value, n, s);
    }), e || (Do(i, "compositionstart", gS), Do(i, "compositionend", Pm), Do(i, "change", Pm));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(i, { value: e }) {
    i.value = e ?? "";
  },
  beforeUpdate(i, { value: e, oldValue: n, modifiers: { lazy: r, trim: o, number: s } }, a) {
    if (i[qr] = ya(a), i.composing) return;
    const l = (s || i.type === "number") && !/^0\d/.test(i.value) ? rd(i.value) : i.value, u = e ?? "";
    l !== u && (document.activeElement === i && i.type !== "range" && (r && e === n || o && i.value.trim() === u) || (i.value = u));
  }
}, vS = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(i, e, n) {
    i[qr] = ya(n), Do(i, "change", () => {
      const r = i._modelValue, o = Cl(i), s = i.checked, a = i[qr];
      if (We(r)) {
        const l = Ef(r, o), u = l !== -1;
        if (s && !u)
          a(r.concat(o));
        else if (!s && u) {
          const c = [...r];
          c.splice(l, 1), a(c);
        }
      } else if (xa(r)) {
        const l = new Set(r);
        s ? l.add(o) : l.delete(o), a(l);
      } else
        a(E0(i, s));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Lm,
  beforeUpdate(i, e, n) {
    i[qr] = ya(n), Lm(i, e, n);
  }
};
function Lm(i, { value: e, oldValue: n }, r) {
  i._modelValue = e;
  let o;
  if (We(e))
    o = Ef(e, r.props.value) > -1;
  else if (xa(e))
    o = e.has(r.props.value);
  else {
    if (e === n) return;
    o = tu(e, E0(i, !0));
  }
  i.checked !== o && (i.checked = o);
}
const Zr = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(i, { value: e, modifiers: { number: n } }, r) {
    const o = xa(e);
    Do(i, "change", () => {
      const s = Array.prototype.filter.call(i.options, (a) => a.selected).map(
        (a) => n ? rd(Cl(a)) : Cl(a)
      );
      i[qr](
        i.multiple ? o ? new Set(s) : s : s[0]
      ), i._assigning = !0, Es(() => {
        i._assigning = !1;
      });
    }), i[qr] = ya(r);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(i, { value: e }) {
    Am(i, e);
  },
  beforeUpdate(i, e, n) {
    i[qr] = ya(n);
  },
  updated(i, { value: e }) {
    i._assigning || Am(i, e);
  }
};
function Am(i, e) {
  const n = i.multiple, r = We(e);
  if (n && !r && !xa(e)) {
    process.env.NODE_ENV !== "production" && br(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`
    );
    return;
  }
  for (let o = 0, s = i.options.length; o < s; o++) {
    const a = i.options[o], l = Cl(a);
    if (n)
      if (r) {
        const u = typeof l;
        u === "string" || u === "number" ? a.selected = e.some((c) => String(c) === String(l)) : a.selected = Ef(e, l) > -1;
      } else
        a.selected = e.has(l);
    else if (tu(Cl(a), e)) {
      i.selectedIndex !== o && (i.selectedIndex = o);
      return;
    }
  }
  !n && i.selectedIndex !== -1 && (i.selectedIndex = -1);
}
function Cl(i) {
  return "_value" in i ? i._value : i.value;
}
function E0(i, e) {
  const n = e ? "_trueValue" : "_falseValue";
  return n in i ? i[n] : e;
}
const yS = ["ctrl", "shift", "alt", "meta"], bS = {
  stop: (i) => i.stopPropagation(),
  prevent: (i) => i.preventDefault(),
  self: (i) => i.target !== i.currentTarget,
  ctrl: (i) => !i.ctrlKey,
  shift: (i) => !i.shiftKey,
  alt: (i) => !i.altKey,
  meta: (i) => !i.metaKey,
  left: (i) => "button" in i && i.button !== 0,
  middle: (i) => "button" in i && i.button !== 1,
  right: (i) => "button" in i && i.button !== 2,
  exact: (i, e) => yS.some((n) => i[`${n}Key`] && !e.includes(n))
}, tt = (i, e) => {
  const n = i._withMods || (i._withMods = {}), r = e.join(".");
  return n[r] || (n[r] = (o, ...s) => {
    for (let a = 0; a < e.length; a++) {
      const l = bS[e[a]];
      if (l && l(o, e)) return;
    }
    return i(o, ...s);
  });
}, wS = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Ah = (i, e) => {
  const n = i._withKeys || (i._withKeys = {}), r = e.join(".");
  return n[r] || (n[r] = (o) => {
    if (!("key" in o))
      return;
    const s = to(o.key);
    if (e.some(
      (a) => a === s || wS[a] === s
    ))
      return i(o);
  });
}, _S = /* @__PURE__ */ en({ patchProp: pS }, Yx);
let Vm;
function xS() {
  return Vm || (Vm = kx(_S));
}
const SS = (...i) => {
  const e = xS().createApp(...i);
  process.env.NODE_ENV !== "production" && (kS(e), OS(e));
  const { mount: n } = e;
  return e.mount = (r) => {
    const o = ES(r);
    if (!o) return;
    const s = e._component;
    !qe(s) && !s.render && !s.template && (s.template = o.innerHTML), o.nodeType === 1 && (o.textContent = "");
    const a = n(o, !1, CS(o));
    return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), a;
  }, e;
};
function CS(i) {
  if (i instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && i instanceof MathMLElement)
    return "mathml";
}
function kS(i) {
  Object.defineProperty(i.config, "isNativeTag", {
    value: (e) => xw(e) || Sw(e) || Cw(e),
    writable: !1
  });
}
function OS(i) {
  {
    const e = i.config.isCustomElement;
    Object.defineProperty(i.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        br(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const n = i.config.compilerOptions, r = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(i.config, "compilerOptions", {
      get() {
        return br(r), n;
      },
      set() {
        br(r);
      }
    });
  }
}
function ES(i) {
  if (jt(i)) {
    const e = document.querySelector(i);
    return process.env.NODE_ENV !== "production" && !e && br(
      `Failed to mount app: mount target selector "${i}" returned null.`
    ), e;
  }
  return process.env.NODE_ENV !== "production" && window.ShadowRoot && i instanceof window.ShadowRoot && i.mode === "closed" && br(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), i;
}
/**
* vue v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function TS() {
  Wx();
}
process.env.NODE_ENV !== "production" && TS();
function Su(i, e, n) {
  return Array.isArray(i) ? (i.length = Math.max(i.length, e), i.splice(e, 1, n), n) : (i[e] = n, n);
}
function Xd(i, e) {
  if (Array.isArray(i)) {
    i.splice(e, 1);
    return;
  }
  delete i[e];
}
function DS() {
  return T0().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function T0() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const $S = typeof Proxy == "function", MS = "devtools-plugin:setup", PS = "plugin:settings:set";
let Hs, Vh;
function IS() {
  var i;
  return Hs !== void 0 || (typeof window < "u" && window.performance ? (Hs = !0, Vh = window.performance) : typeof globalThis < "u" && (!((i = globalThis.perf_hooks) === null || i === void 0) && i.performance) ? (Hs = !0, Vh = globalThis.perf_hooks.performance) : Hs = !1), Hs;
}
function LS() {
  return IS() ? Vh.now() : Date.now();
}
class AS {
  constructor(e, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e, this.hook = n;
    const r = {};
    if (e.settings)
      for (const a in e.settings) {
        const l = e.settings[a];
        r[a] = l.defaultValue;
      }
    const o = `__vue-devtools-plugin-settings__${e.id}`;
    let s = Object.assign({}, r);
    try {
      const a = localStorage.getItem(o), l = JSON.parse(a);
      Object.assign(s, l);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return s;
      },
      setSettings(a) {
        try {
          localStorage.setItem(o, JSON.stringify(a));
        } catch {
        }
        s = a;
      },
      now() {
        return LS();
      }
    }, n && n.on(PS, (a, l) => {
      a === this.plugin.id && this.fallbacks.setSettings(l);
    }), this.proxiedOn = new Proxy({}, {
      get: (a, l) => this.target ? this.target.on[l] : (...u) => {
        this.onQueue.push({
          method: l,
          args: u
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (a, l) => this.target ? this.target[l] : l === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(l) ? (...u) => (this.targetQueue.push({
        method: l,
        args: u,
        resolve: () => {
        }
      }), this.fallbacks[l](...u)) : (...u) => new Promise((c) => {
        this.targetQueue.push({
          method: l,
          args: u,
          resolve: c
        });
      })
    });
  }
  async setRealTarget(e) {
    this.target = e;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function D0(i, e) {
  const n = i, r = T0(), o = DS(), s = $S && n.enableEarlyProxy;
  if (o && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !s))
    o.emit(MS, i, e);
  else {
    const a = s ? new AS(n, o) : null;
    (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: e,
      proxy: a
    }), a && e(a.proxiedTarget);
  }
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let qa;
const kl = (i) => qa = i, $0 = process.env.NODE_ENV !== "production" ? Symbol("pinia") : (
  /* istanbul ignore next */
  Symbol()
);
function $s(i) {
  return i && typeof i == "object" && Object.prototype.toString.call(i) === "[object Object]" && typeof i.toJSON != "function";
}
var wr;
(function(i) {
  i.direct = "direct", i.patchObject = "patch object", i.patchFunction = "patch function";
})(wr || (wr = {}));
const Po = typeof window < "u", Fm = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : { HTMLElement: null };
function VS(i, { autoBom: e = !1 } = {}) {
  return e && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(i.type) ? new Blob(["\uFEFF", i], { type: i.type }) : i;
}
function Wf(i, e, n) {
  const r = new XMLHttpRequest();
  r.open("GET", i), r.responseType = "blob", r.onload = function() {
    I0(r.response, e, n);
  }, r.onerror = function() {
    console.error("could not download file");
  }, r.send();
}
function M0(i) {
  const e = new XMLHttpRequest();
  e.open("HEAD", i, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function cc(i) {
  try {
    i.dispatchEvent(new MouseEvent("click"));
  } catch {
    const n = document.createEvent("MouseEvents");
    n.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), i.dispatchEvent(n);
  }
}
const dc = typeof navigator == "object" ? navigator : { userAgent: "" }, P0 = /Macintosh/.test(dc.userAgent) && /AppleWebKit/.test(dc.userAgent) && !/Safari/.test(dc.userAgent), I0 = Po ? (
  // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
  typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !P0 ? FS : (
    // Use msSaveOrOpenBlob as a second approach
    "msSaveOrOpenBlob" in dc ? jS : (
      // Fallback to using FileReader and a popup
      RS
    )
  )
) : () => {
};
function FS(i, e = "download", n) {
  const r = document.createElement("a");
  r.download = e, r.rel = "noopener", typeof i == "string" ? (r.href = i, r.origin !== location.origin ? M0(r.href) ? Wf(i, e, n) : (r.target = "_blank", cc(r)) : cc(r)) : (r.href = URL.createObjectURL(i), setTimeout(function() {
    URL.revokeObjectURL(r.href);
  }, 4e4), setTimeout(function() {
    cc(r);
  }, 0));
}
function jS(i, e = "download", n) {
  if (typeof i == "string")
    if (M0(i))
      Wf(i, e, n);
    else {
      const r = document.createElement("a");
      r.href = i, r.target = "_blank", setTimeout(function() {
        cc(r);
      });
    }
  else
    navigator.msSaveOrOpenBlob(VS(i, n), e);
}
function RS(i, e, n, r) {
  if (r = r || open("", "_blank"), r && (r.document.title = r.document.body.innerText = "downloading..."), typeof i == "string")
    return Wf(i, e, n);
  const o = i.type === "application/octet-stream", s = /constructor/i.test(String(Fm.HTMLElement)) || "safari" in Fm, a = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((a || o && s || P0) && typeof FileReader < "u") {
    const l = new FileReader();
    l.onloadend = function() {
      let u = l.result;
      if (typeof u != "string")
        throw r = null, new Error("Wrong reader.result type");
      u = a ? u : u.replace(/^data:[^;]*;/, "data:attachment/file;"), r ? r.location.href = u : location.assign(u), r = null;
    }, l.readAsDataURL(i);
  } else {
    const l = URL.createObjectURL(i);
    r ? r.location.assign(l) : location.href = l, r = null, setTimeout(function() {
      URL.revokeObjectURL(l);
    }, 4e4);
  }
}
function Cn(i, e) {
  const n = " " + i;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(n, e) : e === "error" ? console.error(n) : e === "warn" ? console.warn(n) : console.log(n);
}
function Gf(i) {
  return "_a" in i && "install" in i;
}
function L0() {
  if (!("clipboard" in navigator))
    return Cn("Your browser doesn't support the Clipboard API", "error"), !0;
}
function A0(i) {
  return i instanceof Error && i.message.toLowerCase().includes("document is not focused") ? (Cn('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) : !1;
}
async function NS(i) {
  if (!L0())
    try {
      await navigator.clipboard.writeText(JSON.stringify(i.state.value)), Cn("Global state copied to clipboard.");
    } catch (e) {
      if (A0(e))
        return;
      Cn("Failed to serialize the state. Check the console for more details.", "error"), console.error(e);
    }
}
async function zS(i) {
  if (!L0())
    try {
      V0(i, JSON.parse(await navigator.clipboard.readText())), Cn("Global state pasted from clipboard.");
    } catch (e) {
      if (A0(e))
        return;
      Cn("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(e);
    }
}
async function BS(i) {
  try {
    I0(new Blob([JSON.stringify(i.state.value)], {
      type: "text/plain;charset=utf-8"
    }), "pinia-state.json");
  } catch (e) {
    Cn("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e);
  }
}
let Lr;
function HS() {
  Lr || (Lr = document.createElement("input"), Lr.type = "file", Lr.accept = ".json");
  function i() {
    return new Promise((e, n) => {
      Lr.onchange = async () => {
        const r = Lr.files;
        if (!r)
          return e(null);
        const o = r.item(0);
        return e(o ? { text: await o.text(), file: o } : null);
      }, Lr.oncancel = () => e(null), Lr.onerror = n, Lr.click();
    });
  }
  return i;
}
async function US(i) {
  try {
    const n = await HS()();
    if (!n)
      return;
    const { text: r, file: o } = n;
    V0(i, JSON.parse(r)), Cn(`Global state imported from "${o.name}".`);
  } catch (e) {
    Cn("Failed to import the state from JSON. Check the console for more details.", "error"), console.error(e);
  }
}
function V0(i, e) {
  for (const n in e) {
    const r = i.state.value[n];
    r ? Object.assign(r, e[n]) : i.state.value[n] = e[n];
  }
}
function Di(i) {
  return {
    _custom: {
      display: i
    }
  };
}
const F0 = " Pinia (root)", hc = "_root";
function WS(i) {
  return Gf(i) ? {
    id: hc,
    label: F0
  } : {
    id: i.$id,
    label: i.$id
  };
}
function GS(i) {
  if (Gf(i)) {
    const n = Array.from(i._s.keys()), r = i._s;
    return {
      state: n.map((s) => ({
        editable: !0,
        key: s,
        value: i.state.value[s]
      })),
      getters: n.filter((s) => r.get(s)._getters).map((s) => {
        const a = r.get(s);
        return {
          editable: !1,
          key: s,
          value: a._getters.reduce((l, u) => (l[u] = a[u], l), {})
        };
      })
    };
  }
  const e = {
    state: Object.keys(i.$state).map((n) => ({
      editable: !0,
      key: n,
      value: i.$state[n]
    }))
  };
  return i._getters && i._getters.length && (e.getters = i._getters.map((n) => ({
    editable: !1,
    key: n,
    value: i[n]
  }))), i._customProperties.size && (e.customProperties = Array.from(i._customProperties).map((n) => ({
    editable: !0,
    key: n,
    value: i[n]
  }))), e;
}
function XS(i) {
  return i ? Array.isArray(i) ? i.reduce((e, n) => (e.keys.push(n.key), e.operations.push(n.type), e.oldValue[n.key] = n.oldValue, e.newValue[n.key] = n.newValue, e), {
    oldValue: {},
    keys: [],
    operations: [],
    newValue: {}
  }) : {
    operation: Di(i.type),
    key: Di(i.key),
    oldValue: i.oldValue,
    newValue: i.newValue
  } : {};
}
function YS(i) {
  switch (i) {
    case wr.direct:
      return "mutation";
    case wr.patchFunction:
      return "$patch";
    case wr.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let ta = !0;
const fc = [], rs = "pinia:mutations", In = "pinia", { assign: KS } = Object, Ac = (i) => " " + i;
function qS(i, e) {
  D0({
    id: "dev.esm.pinia",
    label: "Pinia ",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: fc,
    app: i
  }, (n) => {
    typeof n.now != "function" && Cn("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), n.addTimelineLayer({
      id: rs,
      label: "Pinia ",
      color: 15064968
    }), n.addInspector({
      id: In,
      label: "Pinia ",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            NS(e);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: async () => {
            await zS(e), n.sendInspectorTree(In), n.sendInspectorState(In);
          },
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            BS(e);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: async () => {
            await US(e), n.sendInspectorTree(In), n.sendInspectorState(In);
          },
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: 'Reset the state (with "$reset")',
          action: (r) => {
            const o = e._s.get(r);
            o ? typeof o.$reset != "function" ? Cn(`Cannot reset "${r}" store because it doesn't have a "$reset" method implemented.`, "warn") : (o.$reset(), Cn(`Store "${r}" reset.`)) : Cn(`Cannot reset "${r}" store because it wasn't found.`, "warn");
          }
        }
      ]
    }), n.on.inspectComponent((r, o) => {
      const s = r.componentInstance && r.componentInstance.proxy;
      if (s && s._pStores) {
        const a = r.componentInstance.proxy._pStores;
        Object.values(a).forEach((l) => {
          r.instanceData.state.push({
            type: Ac(l.$id),
            key: "state",
            editable: !0,
            value: l._isOptionsAPI ? {
              _custom: {
                value: et(l.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => l.$reset()
                  }
                ]
              }
            } : (
              // NOTE: workaround to unwrap transferred refs
              Object.keys(l.$state).reduce((u, c) => (u[c] = l.$state[c], u), {})
            )
          }), l._getters && l._getters.length && r.instanceData.state.push({
            type: Ac(l.$id),
            key: "getters",
            editable: !1,
            value: l._getters.reduce((u, c) => {
              try {
                u[c] = l[c];
              } catch (d) {
                u[c] = d;
              }
              return u;
            }, {})
          });
        });
      }
    }), n.on.getInspectorTree((r) => {
      if (r.app === i && r.inspectorId === In) {
        let o = [e];
        o = o.concat(Array.from(e._s.values())), r.rootNodes = (r.filter ? o.filter((s) => "$id" in s ? s.$id.toLowerCase().includes(r.filter.toLowerCase()) : F0.toLowerCase().includes(r.filter.toLowerCase())) : o).map(WS);
      }
    }), globalThis.$pinia = e, n.on.getInspectorState((r) => {
      if (r.app === i && r.inspectorId === In) {
        const o = r.nodeId === hc ? e : e._s.get(r.nodeId);
        if (!o)
          return;
        o && (r.nodeId !== hc && (globalThis.$store = et(o)), r.state = GS(o));
      }
    }), n.on.editInspectorState((r, o) => {
      if (r.app === i && r.inspectorId === In) {
        const s = r.nodeId === hc ? e : e._s.get(r.nodeId);
        if (!s)
          return Cn(`store "${r.nodeId}" not found`, "error");
        const { path: a } = r;
        Gf(s) ? a.unshift("state") : (a.length !== 1 || !s._customProperties.has(a[0]) || a[0] in s.$state) && a.unshift("$state"), ta = !1, r.set(s, a, r.state.value), ta = !0;
      }
    }), n.on.editComponentState((r) => {
      if (r.type.startsWith("")) {
        const o = r.type.replace(/^\s*/, ""), s = e._s.get(o);
        if (!s)
          return Cn(`store "${o}" not found`, "error");
        const { path: a } = r;
        if (a[0] !== "state")
          return Cn(`Invalid path for store "${o}":
${a}
Only state can be modified.`);
        a[0] = "$state", ta = !1, r.set(s, a, r.state.value), ta = !0;
      }
    });
  });
}
function ZS(i, e) {
  fc.includes(Ac(e.$id)) || fc.push(Ac(e.$id)), D0({
    id: "dev.esm.pinia",
    label: "Pinia ",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: fc,
    app: i,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: !0
      }
      // useEmojis: {
      //   label: 'Use emojis in messages ',
      //   type: 'boolean',
      //   defaultValue: true,
      // },
    }
  }, (n) => {
    const r = typeof n.now == "function" ? n.now.bind(n) : Date.now;
    e.$onAction(({ after: a, onError: l, name: u, args: c }) => {
      const d = j0++;
      n.addTimelineEvent({
        layerId: rs,
        event: {
          time: r(),
          title: " " + u,
          subtitle: "start",
          data: {
            store: Di(e.$id),
            action: Di(u),
            args: c
          },
          groupId: d
        }
      }), a((h) => {
        Io = void 0, n.addTimelineEvent({
          layerId: rs,
          event: {
            time: r(),
            title: " " + u,
            subtitle: "end",
            data: {
              store: Di(e.$id),
              action: Di(u),
              args: c,
              result: h
            },
            groupId: d
          }
        });
      }), l((h) => {
        Io = void 0, n.addTimelineEvent({
          layerId: rs,
          event: {
            time: r(),
            logType: "error",
            title: " " + u,
            subtitle: "end",
            data: {
              store: Di(e.$id),
              action: Di(u),
              args: c,
              error: h
            },
            groupId: d
          }
        });
      });
    }, !0), e._customProperties.forEach((a) => {
      Lt(() => ze(e[a]), (l, u) => {
        n.notifyComponentUpdate(), n.sendInspectorState(In), ta && n.addTimelineEvent({
          layerId: rs,
          event: {
            time: r(),
            title: "Change",
            subtitle: a,
            data: {
              newValue: l,
              oldValue: u
            },
            groupId: Io
          }
        });
      }, { deep: !0 });
    }), e.$subscribe(({ events: a, type: l }, u) => {
      if (n.notifyComponentUpdate(), n.sendInspectorState(In), !ta)
        return;
      const c = {
        time: r(),
        title: YS(l),
        data: KS({ store: Di(e.$id) }, XS(a)),
        groupId: Io
      };
      l === wr.patchFunction ? c.subtitle = "" : l === wr.patchObject ? c.subtitle = "" : a && !Array.isArray(a) && (c.subtitle = a.type), a && (c.data["rawEvent(s)"] = {
        _custom: {
          display: "DebuggerEvent",
          type: "object",
          tooltip: "raw DebuggerEvent[]",
          value: a
        }
      }), n.addTimelineEvent({
        layerId: rs,
        event: c
      });
    }, { detached: !0, flush: "sync" });
    const o = e._hotUpdate;
    e._hotUpdate = ji((a) => {
      o(a), n.addTimelineEvent({
        layerId: rs,
        event: {
          time: r(),
          title: " " + e.$id,
          subtitle: "HMR update",
          data: {
            store: Di(e.$id),
            info: Di("HMR update")
          }
        }
      }), n.notifyComponentUpdate(), n.sendInspectorTree(In), n.sendInspectorState(In);
    });
    const { $dispose: s } = e;
    e.$dispose = () => {
      s(), n.notifyComponentUpdate(), n.sendInspectorTree(In), n.sendInspectorState(In), n.getSettings().logStoreChanges && Cn(`Disposed "${e.$id}" store `);
    }, n.notifyComponentUpdate(), n.sendInspectorTree(In), n.sendInspectorState(In), n.getSettings().logStoreChanges && Cn(`"${e.$id}" store installed `);
  });
}
let j0 = 0, Io;
function jm(i, e, n) {
  const r = e.reduce((o, s) => (o[s] = et(i)[s], o), {});
  for (const o in r)
    i[o] = function() {
      const s = j0, a = n ? new Proxy(i, {
        get(...u) {
          return Io = s, Reflect.get(...u);
        },
        set(...u) {
          return Io = s, Reflect.set(...u);
        }
      }) : i;
      Io = s;
      const l = r[o].apply(a, arguments);
      return Io = void 0, l;
    };
}
function JS({ app: i, store: e, options: n }) {
  if (!e.$id.startsWith("__hot:")) {
    if (e._isOptionsAPI = !!n.state, !e._p._testing) {
      jm(e, Object.keys(n.actions), e._isOptionsAPI);
      const r = e._hotUpdate;
      et(e)._hotUpdate = function(o) {
        r.apply(this, arguments), jm(e, Object.keys(o._hmrPayload.actions), !!e._isOptionsAPI);
      };
    }
    ZS(
      i,
      // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
      e
    );
  }
}
function QS() {
  const i = ly(!0), e = i.run(() => re({}));
  let n = [], r = [];
  const o = ji({
    install(s) {
      kl(o), o._a = s, s.provide($0, o), s.config.globalProperties.$pinia = o, process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && Po && qS(s, o), r.forEach((a) => n.push(a)), r = [];
    },
    use(s) {
      return this._a ? n.push(s) : r.push(s), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: i,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && Po && typeof Proxy < "u" && o.use(JS), o;
}
function R0(i, e) {
  for (const n in e) {
    const r = e[n];
    if (!(n in i))
      continue;
    const o = i[n];
    $s(o) && $s(r) && !At(r) && !Hi(r) ? i[n] = R0(o, r) : i[n] = r;
  }
  return i;
}
const N0 = () => {
};
function Rm(i, e, n, r = N0) {
  i.push(e);
  const o = () => {
    const s = i.indexOf(e);
    s > -1 && (i.splice(s, 1), r());
  };
  return !n && uy() && Tw(o), o;
}
function Us(i, ...e) {
  i.slice().forEach((n) => {
    n(...e);
  });
}
const eC = (i) => i(), Nm = Symbol(), Yd = Symbol();
function Fh(i, e) {
  i instanceof Map && e instanceof Map ? e.forEach((n, r) => i.set(r, n)) : i instanceof Set && e instanceof Set && e.forEach(i.add, i);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const r = e[n], o = i[n];
    $s(o) && $s(r) && i.hasOwnProperty(n) && !At(r) && !Hi(r) ? i[n] = Fh(o, r) : i[n] = r;
  }
  return i;
}
const tC = process.env.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : (
  /* istanbul ignore next */
  Symbol()
);
function nC(i) {
  return !$s(i) || !i.hasOwnProperty(tC);
}
const { assign: vi } = Object;
function zm(i) {
  return !!(At(i) && i.effect);
}
function Bm(i, e, n, r) {
  const { state: o, actions: s, getters: a } = e, l = n.state.value[i];
  let u;
  function c() {
    !l && (process.env.NODE_ENV === "production" || !r) && (n.state.value[i] = o ? o() : {});
    const d = process.env.NODE_ENV !== "production" && r ? (
      // use ref() to unwrap refs inside state TODO: check if this is still necessary
      Up(re(o ? o() : {}).value)
    ) : Up(n.state.value[i]);
    return vi(d, s, Object.keys(a || {}).reduce((h, p) => (process.env.NODE_ENV !== "production" && p in d && console.warn(`[]: A getter cannot have the same name as another state property. Rename one of them. Found with "${p}" in store "${i}".`), h[p] = ji(Ee(() => {
      kl(n);
      const m = n._s.get(i);
      return a[p].call(m, m);
    })), h), {}));
  }
  return u = jh(i, c, e, n, r, !0), u;
}
function jh(i, e, n = {}, r, o, s) {
  let a;
  const l = vi({ actions: {} }, n);
  if (process.env.NODE_ENV !== "production" && !r._e.active)
    throw new Error("Pinia destroyed");
  const u = { deep: !0 };
  process.env.NODE_ENV !== "production" && (u.onTrigger = (B) => {
    c ? m = B : c == !1 && !x._hotUpdating && (Array.isArray(m) ? m.push(B) : console.error(" debuggerEvents should be an array. This is most likely an internal Pinia bug."));
  });
  let c, d, h = [], p = [], m;
  const v = r.state.value[i];
  !s && !v && (process.env.NODE_ENV === "production" || !o) && (r.state.value[i] = {});
  const y = re({});
  let w;
  function g(B) {
    let X;
    c = d = !1, process.env.NODE_ENV !== "production" && (m = []), typeof B == "function" ? (B(r.state.value[i]), X = {
      type: wr.patchFunction,
      storeId: i,
      events: m
    }) : (Fh(r.state.value[i], B), X = {
      type: wr.patchObject,
      payload: B,
      storeId: i,
      events: m
    });
    const j = w = Symbol();
    Es().then(() => {
      w === j && (c = !0);
    }), d = !0, Us(h, X, r.state.value[i]);
  }
  const k = s ? function() {
    const { state: X } = n, j = X ? X() : {};
    this.$patch((ee) => {
      vi(ee, j);
    });
  } : (
    /* istanbul ignore next */
    process.env.NODE_ENV !== "production" ? () => {
      throw new Error(`: Store "${i}" is built using the setup syntax and does not implement $reset().`);
    } : N0
  );
  function _() {
    a.stop(), h = [], p = [], r._s.delete(i);
  }
  const S = (B, X = "") => {
    if (Nm in B)
      return B[Yd] = X, B;
    const j = function() {
      kl(r);
      const ee = Array.from(arguments), ie = [], M = [];
      function W(ae) {
        ie.push(ae);
      }
      function R(ae) {
        M.push(ae);
      }
      Us(p, {
        args: ee,
        name: j[Yd],
        store: x,
        after: W,
        onError: R
      });
      let V;
      try {
        V = B.apply(this && this.$id === i ? this : x, ee);
      } catch (ae) {
        throw Us(M, ae), ae;
      }
      return V instanceof Promise ? V.then((ae) => (Us(ie, ae), ae)).catch((ae) => (Us(M, ae), Promise.reject(ae))) : (Us(ie, V), V);
    };
    return j[Nm] = !0, j[Yd] = X, j;
  }, b = /* @__PURE__ */ ji({
    actions: {},
    getters: {},
    state: [],
    hotState: y
  }), C = {
    _p: r,
    // _s: scope,
    $id: i,
    $onAction: Rm.bind(null, p),
    $patch: g,
    $reset: k,
    $subscribe(B, X = {}) {
      const j = Rm(h, B, X.detached, () => ee()), ee = a.run(() => Lt(() => r.state.value[i], (ie) => {
        (X.flush === "sync" ? d : c) && B({
          storeId: i,
          type: wr.direct,
          events: m
        }, ie);
      }, vi({}, u, X)));
      return j;
    },
    $dispose: _
  }, x = zo(process.env.NODE_ENV !== "production" || process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && Po ? vi(
    {
      _hmrPayload: b,
      _customProperties: ji(/* @__PURE__ */ new Set())
      // devtools custom properties
    },
    C
    // must be added later
    // setupStore
  ) : C);
  r._s.set(i, x);
  const F = (r._a && r._a.runWithContext || eC)(() => r._e.run(() => (a = ly()).run(() => e({ action: S }))));
  for (const B in F) {
    const X = F[B];
    if (At(X) && !zm(X) || Hi(X))
      process.env.NODE_ENV !== "production" && o ? Su(y.value, B, jd(F, B)) : s || (v && nC(X) && (At(X) ? X.value = v[B] : Fh(X, v[B])), r.state.value[i][B] = X), process.env.NODE_ENV !== "production" && b.state.push(B);
    else if (typeof X == "function") {
      const j = process.env.NODE_ENV !== "production" && o ? X : S(X, B);
      F[B] = j, process.env.NODE_ENV !== "production" && (b.actions[B] = X), l.actions[B] = X;
    } else process.env.NODE_ENV !== "production" && zm(X) && (b.getters[B] = s ? (
      // @ts-expect-error
      n.getters[B]
    ) : X, Po && (F._getters || // @ts-expect-error: same
    (F._getters = ji([]))).push(B));
  }
  if (vi(x, F), vi(et(x), F), Object.defineProperty(x, "$state", {
    get: () => process.env.NODE_ENV !== "production" && o ? y.value : r.state.value[i],
    set: (B) => {
      if (process.env.NODE_ENV !== "production" && o)
        throw new Error("cannot set hotState");
      g((X) => {
        vi(X, B);
      });
    }
  }), process.env.NODE_ENV !== "production" && (x._hotUpdate = ji((B) => {
    x._hotUpdating = !0, B._hmrPayload.state.forEach((X) => {
      if (X in x.$state) {
        const j = B.$state[X], ee = x.$state[X];
        typeof j == "object" && $s(j) && $s(ee) ? R0(j, ee) : B.$state[X] = ee;
      }
      Su(x, X, jd(B.$state, X));
    }), Object.keys(x.$state).forEach((X) => {
      X in B.$state || Xd(x, X);
    }), c = !1, d = !1, r.state.value[i] = jd(B._hmrPayload, "hotState"), d = !0, Es().then(() => {
      c = !0;
    });
    for (const X in B._hmrPayload.actions) {
      const j = B[X];
      Su(x, X, S(j, X));
    }
    for (const X in B._hmrPayload.getters) {
      const j = B._hmrPayload.getters[X], ee = s ? (
        // special handling of options api
        Ee(() => (kl(r), j.call(x, x)))
      ) : j;
      Su(x, X, ee);
    }
    Object.keys(x._hmrPayload.getters).forEach((X) => {
      X in B._hmrPayload.getters || Xd(x, X);
    }), Object.keys(x._hmrPayload.actions).forEach((X) => {
      X in B._hmrPayload.actions || Xd(x, X);
    }), x._hmrPayload = B._hmrPayload, x._getters = B._getters, x._hotUpdating = !1;
  })), process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && Po) {
    const B = {
      writable: !0,
      configurable: !0,
      // avoid warning on devtools trying to display this property
      enumerable: !1
    };
    ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((X) => {
      Object.defineProperty(x, X, vi({ value: x[X] }, B));
    });
  }
  return r._p.forEach((B) => {
    if (process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && Po) {
      const X = a.run(() => B({
        store: x,
        app: r._a,
        pinia: r,
        options: l
      }));
      Object.keys(X || {}).forEach((j) => x._customProperties.add(j)), vi(x, X);
    } else
      vi(x, a.run(() => B({
        store: x,
        app: r._a,
        pinia: r,
        options: l
      })));
  }), process.env.NODE_ENV !== "production" && x.$state && typeof x.$state == "object" && typeof x.$state.constructor == "function" && !x.$state.constructor.toString().includes("[native code]") && console.warn(`[]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${x.$id}".`), v && s && n.hydrate && n.hydrate(x.$state, v), c = !0, d = !0, x;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function iC(i, e, n) {
  let r, o;
  const s = typeof e == "function";
  r = i, o = s ? n : e;
  function a(l, u) {
    const c = ex();
    if (l = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    (process.env.NODE_ENV === "test" && qa && qa._testing ? null : l) || (c ? ol($0, null) : null), l && kl(l), process.env.NODE_ENV !== "production" && !qa)
      throw new Error(`[]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
    l = qa, l._s.has(r) || (s ? jh(r, e, o, l) : Bm(r, o, l), process.env.NODE_ENV !== "production" && (a._pinia = l));
    const d = l._s.get(r);
    if (process.env.NODE_ENV !== "production" && u) {
      const h = "__hot:" + r, p = s ? jh(h, e, o, l, !0) : Bm(h, vi({}, o), l, !0);
      u._hotUpdate(p), delete l.state.value[h], l._s.delete(h);
    }
    if (process.env.NODE_ENV !== "production" && Po) {
      const h = jo();
      if (h && h.proxy && // avoid adding stores that are just built for hot module replacement
      !u) {
        const p = h.proxy, m = "_pStores" in p ? p._pStores : p._pStores = {};
        m[r] = d;
      }
    }
    return d;
  }
  return a.$id = r, a;
}
var rC = Object.defineProperty, Hm = Object.getOwnPropertySymbols, oC = Object.prototype.hasOwnProperty, sC = Object.prototype.propertyIsEnumerable, Um = (i, e, n) => e in i ? rC(i, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : i[e] = n, aC = (i, e) => {
  for (var n in e || (e = {})) oC.call(e, n) && Um(i, n, e[n]);
  if (Hm) for (var n of Hm(e)) sC.call(e, n) && Um(i, n, e[n]);
  return i;
};
function Ji(i) {
  return i == null || i === "" || Array.isArray(i) && i.length === 0 || !(i instanceof Date) && typeof i == "object" && Object.keys(i).length === 0;
}
function Rh(i, e, n = /* @__PURE__ */ new WeakSet()) {
  if (i === e) return !0;
  if (!i || !e || typeof i != "object" || typeof e != "object" || n.has(i) || n.has(e)) return !1;
  n.add(i).add(e);
  let r = Array.isArray(i), o = Array.isArray(e), s, a, l;
  if (r && o) {
    if (a = i.length, a != e.length) return !1;
    for (s = a; s-- !== 0; ) if (!Rh(i[s], e[s], n)) return !1;
    return !0;
  }
  if (r != o) return !1;
  let u = i instanceof Date, c = e instanceof Date;
  if (u != c) return !1;
  if (u && c) return i.getTime() == e.getTime();
  let d = i instanceof RegExp, h = e instanceof RegExp;
  if (d != h) return !1;
  if (d && h) return i.toString() == e.toString();
  let p = Object.keys(i);
  if (a = p.length, a !== Object.keys(e).length) return !1;
  for (s = a; s-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(e, p[s])) return !1;
  for (s = a; s-- !== 0; ) if (l = p[s], !Rh(i[l], e[l], n)) return !1;
  return !0;
}
function lC(i, e) {
  return Rh(i, e);
}
function hd(i) {
  return typeof i == "function" && "call" in i && "apply" in i;
}
function gt(i) {
  return !Ji(i);
}
function Hr(i, e) {
  if (!i || !e) return null;
  try {
    let n = i[e];
    if (gt(n)) return n;
  } catch {
  }
  if (Object.keys(i).length) {
    if (hd(e)) return e(i);
    if (e.indexOf(".") === -1) return i[e];
    {
      let n = e.split("."), r = i;
      for (let o = 0, s = n.length; o < s; ++o) {
        if (r == null) return null;
        r = r[n[o]];
      }
      return r;
    }
  }
  return null;
}
function z0(i, e, n) {
  return n ? Hr(i, n) === Hr(e, n) : lC(i, e);
}
function _r(i, e = !0) {
  return i instanceof Object && i.constructor === Object && (e || Object.keys(i).length !== 0);
}
function B0(i = {}, e = {}) {
  let n = aC({}, i);
  return Object.keys(e).forEach((r) => {
    let o = r;
    _r(e[o]) && o in i && _r(i[o]) ? n[o] = B0(i[o], e[o]) : n[o] = e[o];
  }), n;
}
function uC(...i) {
  return i.reduce((e, n, r) => r === 0 ? n : B0(e, n), {});
}
function Wm(i, e) {
  let n = -1;
  if (gt(i)) try {
    n = i.findLastIndex(e);
  } catch {
    n = i.lastIndexOf([...i].reverse().find(e));
  }
  return n;
}
function li(i, ...e) {
  return hd(i) ? i(...e) : i;
}
function Jn(i, e = !0) {
  return typeof i == "string" && (e || i !== "");
}
function pr(i) {
  return Jn(i) ? i.replace(/(-|_)/g, "").toLowerCase() : i;
}
function Xf(i, e = "", n = {}) {
  let r = pr(e).split("."), o = r.shift();
  if (o) {
    if (_r(i)) {
      let s = Object.keys(i).find((a) => pr(a) === o) || "";
      return Xf(li(i[s], n), r.join("."), n);
    }
    return;
  }
  return li(i, n);
}
function H0(i, e = !0) {
  return Array.isArray(i) && (e || i.length !== 0);
}
function cC(i) {
  return gt(i) && !isNaN(i);
}
function dC(i = "") {
  return gt(i) && i.length === 1 && !!i.match(/\S| /);
}
function xs(i, e) {
  if (e) {
    let n = e.test(i);
    return e.lastIndex = 0, n;
  }
  return !1;
}
function hC(...i) {
  return uC(...i);
}
function ul(i) {
  return i && i.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "").replace(/ {2,}/g, " ").replace(/ ([{:}]) /g, "$1").replace(/([;,]) /g, "$1").replace(/ !/g, "!").replace(/: /g, ":").trim();
}
function pi(i) {
  if (i && /[\xC0-\xFF\u0100-\u017E]/.test(i)) {
    let e = { A: /[\xC0-\xC5\u0100\u0102\u0104]/g, AE: /[\xC6]/g, C: /[\xC7\u0106\u0108\u010A\u010C]/g, D: /[\xD0\u010E\u0110]/g, E: /[\xC8-\xCB\u0112\u0114\u0116\u0118\u011A]/g, G: /[\u011C\u011E\u0120\u0122]/g, H: /[\u0124\u0126]/g, I: /[\xCC-\xCF\u0128\u012A\u012C\u012E\u0130]/g, IJ: /[\u0132]/g, J: /[\u0134]/g, K: /[\u0136]/g, L: /[\u0139\u013B\u013D\u013F\u0141]/g, N: /[\xD1\u0143\u0145\u0147\u014A]/g, O: /[\xD2-\xD6\xD8\u014C\u014E\u0150]/g, OE: /[\u0152]/g, R: /[\u0154\u0156\u0158]/g, S: /[\u015A\u015C\u015E\u0160]/g, T: /[\u0162\u0164\u0166]/g, U: /[\xD9-\xDC\u0168\u016A\u016C\u016E\u0170\u0172]/g, W: /[\u0174]/g, Y: /[\xDD\u0176\u0178]/g, Z: /[\u0179\u017B\u017D]/g, a: /[\xE0-\xE5\u0101\u0103\u0105]/g, ae: /[\xE6]/g, c: /[\xE7\u0107\u0109\u010B\u010D]/g, d: /[\u010F\u0111]/g, e: /[\xE8-\xEB\u0113\u0115\u0117\u0119\u011B]/g, g: /[\u011D\u011F\u0121\u0123]/g, i: /[\xEC-\xEF\u0129\u012B\u012D\u012F\u0131]/g, ij: /[\u0133]/g, j: /[\u0135]/g, k: /[\u0137,\u0138]/g, l: /[\u013A\u013C\u013E\u0140\u0142]/g, n: /[\xF1\u0144\u0146\u0148\u014B]/g, p: /[\xFE]/g, o: /[\xF2-\xF6\xF8\u014D\u014F\u0151]/g, oe: /[\u0153]/g, r: /[\u0155\u0157\u0159]/g, s: /[\u015B\u015D\u015F\u0161]/g, t: /[\u0163\u0165\u0167]/g, u: /[\xF9-\xFC\u0169\u016B\u016D\u016F\u0171\u0173]/g, w: /[\u0175]/g, y: /[\xFD\xFF\u0177]/g, z: /[\u017A\u017C\u017E]/g };
    for (let n in e) i = i.replace(e[n], n);
  }
  return i;
}
function fC(i) {
  return Jn(i, !1) ? i[0].toUpperCase() + i.slice(1) : i;
}
function U0(i) {
  return Jn(i) ? i.replace(/(_)/g, "-").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() : i;
}
function Yf() {
  let i = /* @__PURE__ */ new Map();
  return { on(e, n) {
    let r = i.get(e);
    return r ? r.push(n) : r = [n], i.set(e, r), this;
  }, off(e, n) {
    let r = i.get(e);
    return r && r.splice(r.indexOf(n) >>> 0, 1), this;
  }, emit(e, n) {
    let r = i.get(e);
    r && r.forEach((o) => {
      o(n);
    });
  }, clear() {
    i.clear();
  } };
}
function ui(...i) {
  if (i) {
    let e = [];
    for (let n = 0; n < i.length; n++) {
      let r = i[n];
      if (!r) continue;
      let o = typeof r;
      if (o === "string" || o === "number") e.push(r);
      else if (o === "object") {
        let s = Array.isArray(r) ? [ui(...r)] : Object.entries(r).map(([a, l]) => l ? a : void 0);
        e = s.length ? e.concat(s.filter((a) => !!a)) : e;
      }
    }
    return e.join(" ").trim();
  }
}
function W0(i, e) {
  return i ? i.classList ? i.classList.contains(e) : new RegExp("(^| )" + e + "( |$)", "gi").test(i.className) : !1;
}
function Ms(i, e) {
  if (i && e) {
    let n = (r) => {
      W0(i, r) || (i.classList ? i.classList.add(r) : i.className += " " + r);
    };
    [e].flat().filter(Boolean).forEach((r) => r.split(" ").forEach(n));
  }
}
function pC() {
  return window.innerWidth - document.documentElement.offsetWidth;
}
function mC(i) {
  typeof i == "string" ? Ms(document.body, i || "p-overflow-hidden") : (i != null && i.variableName && document.body.style.setProperty(i.variableName, pC() + "px"), Ms(document.body, (i == null ? void 0 : i.className) || "p-overflow-hidden"));
}
function Ss(i, e) {
  if (i && e) {
    let n = (r) => {
      i.classList ? i.classList.remove(r) : i.className = i.className.replace(new RegExp("(^|\\b)" + r.split(" ").join("|") + "(\\b|$)", "gi"), " ");
    };
    [e].flat().filter(Boolean).forEach((r) => r.split(" ").forEach(n));
  }
}
function gC(i) {
  typeof i == "string" ? Ss(document.body, i || "p-overflow-hidden") : (i != null && i.variableName && document.body.style.removeProperty(i.variableName), Ss(document.body, (i == null ? void 0 : i.className) || "p-overflow-hidden"));
}
function Nh(i) {
  for (let e of document == null ? void 0 : document.styleSheets) try {
    for (let n of e == null ? void 0 : e.cssRules) for (let r of n == null ? void 0 : n.style) if (i.test(r)) return { name: r, value: n.style.getPropertyValue(r).trim() };
  } catch {
  }
  return null;
}
function G0(i) {
  let e = { width: 0, height: 0 };
  if (i) {
    let [n, r] = [i.style.visibility, i.style.display], o = i.getBoundingClientRect();
    i.style.visibility = "hidden", i.style.display = "block", e.width = o.width || i.offsetWidth, e.height = o.height || i.offsetHeight, i.style.display = r, i.style.visibility = n;
  }
  return e;
}
function ca() {
  let i = window, e = document, n = e.documentElement, r = e.getElementsByTagName("body")[0], o = i.innerWidth || n.clientWidth || r.clientWidth, s = i.innerHeight || n.clientHeight || r.clientHeight;
  return { width: o, height: s };
}
function zh(i) {
  return i ? Math.abs(i.scrollLeft) : 0;
}
function Kf() {
  let i = document.documentElement;
  return (window.pageXOffset || zh(i)) - (i.clientLeft || 0);
}
function qf() {
  let i = document.documentElement;
  return (window.pageYOffset || i.scrollTop) - (i.clientTop || 0);
}
function X0(i) {
  return i ? getComputedStyle(i).direction === "rtl" : !1;
}
function Y0(i, e, n = !0) {
  var r, o, s, a;
  if (i) {
    let l = i.offsetParent ? { width: i.offsetWidth, height: i.offsetHeight } : G0(i), u = l.height, c = l.width, d = e.offsetHeight, h = e.offsetWidth, p = e.getBoundingClientRect(), m = qf(), v = Kf(), y = ca(), w, g, k = "top";
    p.top + d + u > y.height ? (w = p.top + m - u, k = "bottom", w < 0 && (w = m)) : w = d + p.top + m, p.left + c > y.width ? g = Math.max(0, p.left + v + h - c) : g = p.left + v, X0(i) ? i.style.insetInlineEnd = g + "px" : i.style.insetInlineStart = g + "px", i.style.top = w + "px", i.style.transformOrigin = k, n && (i.style.marginTop = k === "bottom" ? `calc(${(o = (r = Nh(/-anchor-gutter$/)) == null ? void 0 : r.value) != null ? o : "2px"} * -1)` : (a = (s = Nh(/-anchor-gutter$/)) == null ? void 0 : s.value) != null ? a : "");
  }
}
function K0(i, e) {
  i && (typeof e == "string" ? i.style.cssText = e : Object.entries(e || {}).forEach(([n, r]) => i.style[n] = r));
}
function dr(i, e) {
  return i instanceof HTMLElement ? i.offsetWidth : 0;
}
function q0(i, e, n = !0, r = void 0) {
  var o;
  if (i) {
    let s = i.offsetParent ? { width: i.offsetWidth, height: i.offsetHeight } : G0(i), a = e.offsetHeight, l = e.getBoundingClientRect(), u = ca(), c, d, h = r ?? "top";
    if (!r && l.top + a + s.height > u.height ? (c = -1 * s.height, h = "bottom", l.top + c < 0 && (c = -1 * l.top)) : c = a, s.width > u.width ? d = l.left * -1 : l.left + s.width > u.width ? d = (l.left + s.width - u.width) * -1 : d = 0, i.style.top = c + "px", i.style.insetInlineStart = d + "px", i.style.transformOrigin = h, n) {
      let p = (o = Nh(/-anchor-gutter$/)) == null ? void 0 : o.value;
      i.style.marginTop = h === "bottom" ? `calc(${p ?? "2px"} * -1)` : p ?? "";
    }
  }
}
function Z0(i) {
  if (i) {
    let e = i.parentNode;
    return e && e instanceof ShadowRoot && e.host && (e = e.host), e;
  }
  return null;
}
function J0(i) {
  return !!(i !== null && typeof i < "u" && i.nodeName && Z0(i));
}
function Is(i) {
  return typeof Element < "u" ? i instanceof Element : i !== null && typeof i == "object" && i.nodeType === 1 && typeof i.nodeName == "string";
}
function vC() {
  if (window.getSelection) {
    let i = window.getSelection() || {};
    i.empty ? i.empty() : i.removeAllRanges && i.rangeCount > 0 && i.getRangeAt(0).getClientRects().length > 0 && i.removeAllRanges();
  }
}
function Vc(i, e = {}) {
  if (Is(i)) {
    let n = (r, o) => {
      var s, a;
      let l = (s = i == null ? void 0 : i.$attrs) != null && s[r] ? [(a = i == null ? void 0 : i.$attrs) == null ? void 0 : a[r]] : [];
      return [o].flat().reduce((u, c) => {
        if (c != null) {
          let d = typeof c;
          if (d === "string" || d === "number") u.push(c);
          else if (d === "object") {
            let h = Array.isArray(c) ? n(r, c) : Object.entries(c).map(([p, m]) => r === "style" && (m || m === 0) ? `${p.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()}:${m}` : m ? p : void 0);
            u = h.length ? u.concat(h.filter((p) => !!p)) : u;
          }
        }
        return u;
      }, l);
    };
    Object.entries(e).forEach(([r, o]) => {
      if (o != null) {
        let s = r.match(/^on(.+)/);
        s ? i.addEventListener(s[1].toLowerCase(), o) : r === "p-bind" || r === "pBind" ? Vc(i, o) : (o = r === "class" ? [...new Set(n("class", o))].join(" ").trim() : r === "style" ? n("style", o).join(";").trim() : o, (i.$attrs = i.$attrs || {}) && (i.$attrs[r] = o), i.setAttribute(r, o));
      }
    });
  }
}
function cl(i, e = {}, ...n) {
  if (i) {
    let r = document.createElement(i);
    return Vc(r, e), r.append(...n), r;
  }
}
function yC(i, e) {
  if (i) {
    i.style.opacity = "0";
    let n = +/* @__PURE__ */ new Date(), r = "0", o = function() {
      r = `${+i.style.opacity + ((/* @__PURE__ */ new Date()).getTime() - n) / e}`, i.style.opacity = r, n = +/* @__PURE__ */ new Date(), +r < 1 && ("requestAnimationFrame" in window ? requestAnimationFrame(o) : setTimeout(o, 16));
    };
    o();
  }
}
function bC(i, e) {
  return Is(i) ? Array.from(i.querySelectorAll(e)) : [];
}
function ba(i, e) {
  return Is(i) ? i.matches(e) ? i : i.querySelector(e) : null;
}
function Yn(i, e) {
  i && document.activeElement !== i && i.focus(e);
}
function To(i, e) {
  if (Is(i)) {
    let n = i.getAttribute(e);
    return isNaN(n) ? n === "true" || n === "false" ? n === "true" : n : +n;
  }
}
function Zf(i, e = "") {
  let n = bC(i, `button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [href]:not([tabindex = "-1"]):not([style*="display:none"]):not([hidden])${e},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e}`), r = [];
  for (let o of n) getComputedStyle(o).display != "none" && getComputedStyle(o).visibility != "hidden" && r.push(o);
  return r;
}
function Zs(i, e) {
  let n = Zf(i, e);
  return n.length > 0 ? n[0] : null;
}
function as(i) {
  if (i) {
    let e = i.offsetHeight, n = getComputedStyle(i);
    return e -= parseFloat(n.paddingTop) + parseFloat(n.paddingBottom) + parseFloat(n.borderTopWidth) + parseFloat(n.borderBottomWidth), e;
  }
  return 0;
}
function Q0(i, e) {
  let n = Zf(i, e);
  return n.length > 0 ? n[n.length - 1] : null;
}
function wC(i) {
  if (i) {
    let e = i.getBoundingClientRect();
    return { top: e.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0), left: e.left + (window.pageXOffset || zh(document.documentElement) || zh(document.body) || 0) };
  }
  return { top: "auto", left: "auto" };
}
function Nr(i, e) {
  return i ? i.offsetHeight : 0;
}
function eb(i, e = []) {
  let n = Z0(i);
  return n === null ? e : eb(n, e.concat([n]));
}
function _C(i) {
  let e = [];
  if (i) {
    let n = eb(i), r = /(auto|scroll)/, o = (s) => {
      try {
        let a = window.getComputedStyle(s, null);
        return r.test(a.getPropertyValue("overflow")) || r.test(a.getPropertyValue("overflowX")) || r.test(a.getPropertyValue("overflowY"));
      } catch {
        return !1;
      }
    };
    for (let s of n) {
      let a = s.nodeType === 1 && s.dataset.scrollselectors;
      if (a) {
        let l = a.split(",");
        for (let u of l) {
          let c = ba(s, u);
          c && o(c) && e.push(c);
        }
      }
      s.nodeType !== 9 && o(s) && e.push(s);
    }
  }
  return e;
}
function Gm() {
  if (window.getSelection) return window.getSelection().toString();
  if (document.getSelection) return document.getSelection().toString();
}
function ls(i) {
  if (i) {
    let e = i.offsetWidth, n = getComputedStyle(i);
    return e -= parseFloat(n.paddingLeft) + parseFloat(n.paddingRight) + parseFloat(n.borderLeftWidth) + parseFloat(n.borderRightWidth), e;
  }
  return 0;
}
function xC() {
  return /(android)/i.test(navigator.userAgent);
}
function tb() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function Xm(i, e = "") {
  return Is(i) ? i.matches(`button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e}`) : !1;
}
function Fc(i) {
  return !!(i && i.offsetParent != null);
}
function Jf() {
  return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}
function nb(i, e = "", n) {
  Is(i) && n !== null && n !== void 0 && i.setAttribute(e, n);
}
var Cu = {};
function Za(i = "pui_id_") {
  return Object.hasOwn(Cu, i) || (Cu[i] = 0), Cu[i]++, `${i}${Cu[i]}`;
}
function SC() {
  let i = [], e = (a, l, u = 999) => {
    let c = o(a, l, u), d = c.value + (c.key === a ? 0 : u) + 1;
    return i.push({ key: a, value: d }), d;
  }, n = (a) => {
    i = i.filter((l) => l.value !== a);
  }, r = (a, l) => o(a).value, o = (a, l, u = 0) => [...i].reverse().find((c) => !0) || { key: a, value: u }, s = (a) => a && parseInt(a.style.zIndex, 10) || 0;
  return { get: s, set: (a, l, u) => {
    l && (l.style.zIndex = String(e(a, !0, u)));
  }, clear: (a) => {
    a && (n(s(a)), a.style.zIndex = "");
  }, getCurrent: (a) => r(a) };
}
var Ui = SC(), CC = Object.defineProperty, kC = Object.defineProperties, OC = Object.getOwnPropertyDescriptors, jc = Object.getOwnPropertySymbols, ib = Object.prototype.hasOwnProperty, rb = Object.prototype.propertyIsEnumerable, Ym = (i, e, n) => e in i ? CC(i, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : i[e] = n, Ai = (i, e) => {
  for (var n in e || (e = {})) ib.call(e, n) && Ym(i, n, e[n]);
  if (jc) for (var n of jc(e)) rb.call(e, n) && Ym(i, n, e[n]);
  return i;
}, Kd = (i, e) => kC(i, OC(e)), Ar = (i, e) => {
  var n = {};
  for (var r in i) ib.call(i, r) && e.indexOf(r) < 0 && (n[r] = i[r]);
  if (i != null && jc) for (var r of jc(i)) e.indexOf(r) < 0 && rb.call(i, r) && (n[r] = i[r]);
  return n;
}, EC = Yf(), Dn = EC, Ol = /{([^}]*)}/g, ob = /(\d+\s+[\+\-\*\/]\s+\d+)/g, sb = /var\([^)]+\)/g;
function Km(i) {
  return Jn(i) ? i.replace(/[A-Z]/g, (e, n) => n === 0 ? e : "." + e.toLowerCase()).toLowerCase() : i;
}
function TC(i) {
  return _r(i) && i.hasOwnProperty("$value") && i.hasOwnProperty("$type") ? i.$value : i;
}
function DC(i) {
  return i.replaceAll(/ /g, "").replace(/[^\w]/g, "-");
}
function Bh(i = "", e = "") {
  return DC(`${Jn(i, !1) && Jn(e, !1) ? `${i}-` : i}${e}`);
}
function ab(i = "", e = "") {
  return `--${Bh(i, e)}`;
}
function $C(i = "") {
  let e = (i.match(/{/g) || []).length, n = (i.match(/}/g) || []).length;
  return (e + n) % 2 !== 0;
}
function lb(i, e = "", n = "", r = [], o) {
  if (Jn(i)) {
    let s = i.trim();
    if ($C(s)) return;
    if (xs(s, Ol)) {
      let a = s.replaceAll(Ol, (l) => {
        let u = l.replace(/{|}/g, "").split(".").filter((c) => !r.some((d) => xs(c, d)));
        return `var(${ab(n, U0(u.join("-")))}${gt(o) ? `, ${o}` : ""})`;
      });
      return xs(a.replace(sb, "0"), ob) ? `calc(${a})` : a;
    }
    return s;
  } else if (cC(i)) return i;
}
function MC(i, e, n) {
  Jn(e, !1) && i.push(`${e}:${n};`);
}
function Js(i, e) {
  return i ? `${i}{${e}}` : "";
}
function ub(i, e) {
  if (i.indexOf("dt(") === -1) return i;
  function n(a, l) {
    let u = [], c = 0, d = "", h = null, p = 0;
    for (; c <= a.length; ) {
      let m = a[c];
      if ((m === '"' || m === "'" || m === "`") && a[c - 1] !== "\\" && (h = h === m ? null : m), !h && (m === "(" && p++, m === ")" && p--, (m === "," || c === a.length) && p === 0)) {
        let v = d.trim();
        v.startsWith("dt(") ? u.push(ub(v, l)) : u.push(r(v)), d = "", c++;
        continue;
      }
      m !== void 0 && (d += m), c++;
    }
    return u;
  }
  function r(a) {
    let l = a[0];
    if ((l === '"' || l === "'" || l === "`") && a[a.length - 1] === l) return a.slice(1, -1);
    let u = Number(a);
    return isNaN(u) ? a : u;
  }
  let o = [], s = [];
  for (let a = 0; a < i.length; a++) if (i[a] === "d" && i.slice(a, a + 3) === "dt(") s.push(a), a += 2;
  else if (i[a] === ")" && s.length > 0) {
    let l = s.pop();
    s.length === 0 && o.push([l, a]);
  }
  if (!o.length) return i;
  for (let a = o.length - 1; a >= 0; a--) {
    let [l, u] = o[a], c = i.slice(l + 3, u), d = n(c, e), h = e(...d);
    i = i.slice(0, l) + h + i.slice(u + 1);
  }
  return i;
}
var cb = (i) => {
  var e;
  let n = Mt.getTheme(), r = Hh(n, i, void 0, "variable"), o = (e = r == null ? void 0 : r.match(/--[\w-]+/g)) == null ? void 0 : e[0], s = Hh(n, i, void 0, "value");
  return { name: o, variable: r, value: s };
}, Cs = (...i) => Hh(Mt.getTheme(), ...i), Hh = (i = {}, e, n, r) => {
  if (e) {
    let { variable: o, options: s } = Mt.defaults || {}, { prefix: a, transform: l } = (i == null ? void 0 : i.options) || s || {}, u = xs(e, Ol) ? e : `{${e}}`;
    return r === "value" || Ji(r) && l === "strict" ? Mt.getTokenValue(e) : lb(u, void 0, a, [o.excludedKeyRegex], n);
  }
  return "";
};
function ku(i, ...e) {
  if (i instanceof Array) {
    let n = i.reduce((r, o, s) => {
      var a;
      return r + o + ((a = li(e[s], { dt: Cs })) != null ? a : "");
    }, "");
    return ub(n, Cs);
  }
  return li(i, { dt: Cs });
}
function PC(i, e = {}) {
  let n = Mt.defaults.variable, { prefix: r = n.prefix, selector: o = n.selector, excludedKeyRegex: s = n.excludedKeyRegex } = e, a = [], l = [], u = [{ node: i, path: r }];
  for (; u.length; ) {
    let { node: d, path: h } = u.pop();
    for (let p in d) {
      let m = d[p], v = TC(m), y = xs(p, s) ? Bh(h) : Bh(h, U0(p));
      if (_r(v)) u.push({ node: v, path: y });
      else {
        let w = ab(y), g = lb(v, y, r, [s]);
        MC(l, w, g);
        let k = y;
        r && k.startsWith(r + "-") && (k = k.slice(r.length + 1)), a.push(k.replace(/-/g, "."));
      }
    }
  }
  let c = l.join("");
  return { value: l, tokens: a, declarations: c, css: Js(o, c) };
}
var Ei = { regex: { rules: { class: { pattern: /^\.([a-zA-Z][\w-]*)$/, resolve(i) {
  return { type: "class", selector: i, matched: this.pattern.test(i.trim()) };
} }, attr: { pattern: /^\[(.*)\]$/, resolve(i) {
  return { type: "attr", selector: `:root${i},:host${i}`, matched: this.pattern.test(i.trim()) };
} }, media: { pattern: /^@media (.*)$/, resolve(i) {
  return { type: "media", selector: i, matched: this.pattern.test(i.trim()) };
} }, system: { pattern: /^system$/, resolve(i) {
  return { type: "system", selector: "@media (prefers-color-scheme: dark)", matched: this.pattern.test(i.trim()) };
} }, custom: { resolve(i) {
  return { type: "custom", selector: i, matched: !0 };
} } }, resolve(i) {
  let e = Object.keys(this.rules).filter((n) => n !== "custom").map((n) => this.rules[n]);
  return [i].flat().map((n) => {
    var r;
    return (r = e.map((o) => o.resolve(n)).find((o) => o.matched)) != null ? r : this.rules.custom.resolve(n);
  });
} }, _toVariables(i, e) {
  return PC(i, { prefix: e == null ? void 0 : e.prefix });
}, getCommon({ name: i = "", theme: e = {}, params: n, set: r, defaults: o }) {
  var s, a, l, u, c, d, h;
  let { preset: p, options: m } = e, v, y, w, g, k, _, S;
  if (gt(p) && m.transform !== "strict") {
    let { primitive: b, semantic: C, extend: x } = p, I = C || {}, { colorScheme: F } = I, B = Ar(I, ["colorScheme"]), X = x || {}, { colorScheme: j } = X, ee = Ar(X, ["colorScheme"]), ie = F || {}, { dark: M } = ie, W = Ar(ie, ["dark"]), R = j || {}, { dark: V } = R, ae = Ar(R, ["dark"]), $e = gt(b) ? this._toVariables({ primitive: b }, m) : {}, N = gt(B) ? this._toVariables({ semantic: B }, m) : {}, me = gt(W) ? this._toVariables({ light: W }, m) : {}, we = gt(M) ? this._toVariables({ dark: M }, m) : {}, fe = gt(ee) ? this._toVariables({ semantic: ee }, m) : {}, te = gt(ae) ? this._toVariables({ light: ae }, m) : {}, Me = gt(V) ? this._toVariables({ dark: V }, m) : {}, [Re, Ce] = [(s = $e.declarations) != null ? s : "", $e.tokens], [le, T] = [(a = N.declarations) != null ? a : "", N.tokens || []], [E, L] = [(l = me.declarations) != null ? l : "", me.tokens || []], [D, P] = [(u = we.declarations) != null ? u : "", we.tokens || []], [G, ne] = [(c = fe.declarations) != null ? c : "", fe.tokens || []], [se, ge] = [(d = te.declarations) != null ? d : "", te.tokens || []], [Se, be] = [(h = Me.declarations) != null ? h : "", Me.tokens || []];
    v = this.transformCSS(i, Re, "light", "variable", m, r, o), y = Ce;
    let xe = this.transformCSS(i, `${le}${E}`, "light", "variable", m, r, o), q = this.transformCSS(i, `${D}`, "dark", "variable", m, r, o);
    w = `${xe}${q}`, g = [.../* @__PURE__ */ new Set([...T, ...L, ...P])];
    let J = this.transformCSS(i, `${G}${se}color-scheme:light`, "light", "variable", m, r, o), ue = this.transformCSS(i, `${Se}color-scheme:dark`, "dark", "variable", m, r, o);
    k = `${J}${ue}`, _ = [.../* @__PURE__ */ new Set([...ne, ...ge, ...be])], S = li(p.css, { dt: Cs });
  }
  return { primitive: { css: v, tokens: y }, semantic: { css: w, tokens: g }, global: { css: k, tokens: _ }, style: S };
}, getPreset({ name: i = "", preset: e = {}, options: n, params: r, set: o, defaults: s, selector: a }) {
  var l, u, c;
  let d, h, p;
  if (gt(e) && n.transform !== "strict") {
    let m = i.replace("-directive", ""), v = e, { colorScheme: y, extend: w, css: g } = v, k = Ar(v, ["colorScheme", "extend", "css"]), _ = w || {}, { colorScheme: S } = _, b = Ar(_, ["colorScheme"]), C = y || {}, { dark: x } = C, I = Ar(C, ["dark"]), F = S || {}, { dark: B } = F, X = Ar(F, ["dark"]), j = gt(k) ? this._toVariables({ [m]: Ai(Ai({}, k), b) }, n) : {}, ee = gt(I) ? this._toVariables({ [m]: Ai(Ai({}, I), X) }, n) : {}, ie = gt(x) ? this._toVariables({ [m]: Ai(Ai({}, x), B) }, n) : {}, [M, W] = [(l = j.declarations) != null ? l : "", j.tokens || []], [R, V] = [(u = ee.declarations) != null ? u : "", ee.tokens || []], [ae, $e] = [(c = ie.declarations) != null ? c : "", ie.tokens || []], N = this.transformCSS(m, `${M}${R}`, "light", "variable", n, o, s, a), me = this.transformCSS(m, ae, "dark", "variable", n, o, s, a);
    d = `${N}${me}`, h = [.../* @__PURE__ */ new Set([...W, ...V, ...$e])], p = li(g, { dt: Cs });
  }
  return { css: d, tokens: h, style: p };
}, getPresetC({ name: i = "", theme: e = {}, params: n, set: r, defaults: o }) {
  var s;
  let { preset: a, options: l } = e, u = (s = a == null ? void 0 : a.components) == null ? void 0 : s[i];
  return this.getPreset({ name: i, preset: u, options: l, params: n, set: r, defaults: o });
}, getPresetD({ name: i = "", theme: e = {}, params: n, set: r, defaults: o }) {
  var s, a;
  let l = i.replace("-directive", ""), { preset: u, options: c } = e, d = ((s = u == null ? void 0 : u.components) == null ? void 0 : s[l]) || ((a = u == null ? void 0 : u.directives) == null ? void 0 : a[l]);
  return this.getPreset({ name: l, preset: d, options: c, params: n, set: r, defaults: o });
}, applyDarkColorScheme(i) {
  return !(i.darkModeSelector === "none" || i.darkModeSelector === !1);
}, getColorSchemeOption(i, e) {
  var n;
  return this.applyDarkColorScheme(i) ? this.regex.resolve(i.darkModeSelector === !0 ? e.options.darkModeSelector : (n = i.darkModeSelector) != null ? n : e.options.darkModeSelector) : [];
}, getLayerOrder(i, e = {}, n, r) {
  let { cssLayer: o } = e;
  return o ? `@layer ${li(o.order || o.name || "primeui", n)}` : "";
}, getCommonStyleSheet({ name: i = "", theme: e = {}, params: n, props: r = {}, set: o, defaults: s }) {
  let a = this.getCommon({ name: i, theme: e, params: n, set: o, defaults: s }), l = Object.entries(r).reduce((u, [c, d]) => u.push(`${c}="${d}"`) && u, []).join(" ");
  return Object.entries(a || {}).reduce((u, [c, d]) => {
    if (_r(d) && Object.hasOwn(d, "css")) {
      let h = ul(d.css), p = `${c}-variables`;
      u.push(`<style type="text/css" data-primevue-style-id="${p}" ${l}>${h}</style>`);
    }
    return u;
  }, []).join("");
}, getStyleSheet({ name: i = "", theme: e = {}, params: n, props: r = {}, set: o, defaults: s }) {
  var a;
  let l = { name: i, theme: e, params: n, set: o, defaults: s }, u = (a = i.includes("-directive") ? this.getPresetD(l) : this.getPresetC(l)) == null ? void 0 : a.css, c = Object.entries(r).reduce((d, [h, p]) => d.push(`${h}="${p}"`) && d, []).join(" ");
  return u ? `<style type="text/css" data-primevue-style-id="${i}-variables" ${c}>${ul(u)}</style>` : "";
}, createTokens(i = {}, e, n = "", r = "", o = {}) {
  let s = function(l, u = {}, c = []) {
    if (c.includes(this.path)) return console.warn(`Circular reference detected at ${this.path}`), { colorScheme: l, path: this.path, paths: u, value: void 0 };
    c.push(this.path), u.name = this.path, u.binding || (u.binding = {});
    let d = this.value;
    if (typeof this.value == "string" && Ol.test(this.value)) {
      let h = this.value.trim().replace(Ol, (p) => {
        var m;
        let v = p.slice(1, -1), y = this.tokens[v];
        if (!y) return console.warn(`Token not found for path: ${v}`), "__UNRESOLVED__";
        let w = y.computed(l, u, c);
        return Array.isArray(w) && w.length === 2 ? `light-dark(${w[0].value},${w[1].value})` : (m = w == null ? void 0 : w.value) != null ? m : "__UNRESOLVED__";
      });
      d = ob.test(h.replace(sb, "0")) ? `calc(${h})` : h;
    }
    return Ji(u.binding) && delete u.binding, c.pop(), { colorScheme: l, path: this.path, paths: u, value: d.includes("__UNRESOLVED__") ? void 0 : d };
  }, a = (l, u, c) => {
    Object.entries(l).forEach(([d, h]) => {
      let p = xs(d, e.variable.excludedKeyRegex) ? u : u ? `${u}.${Km(d)}` : Km(d), m = c ? `${c}.${d}` : d;
      _r(h) ? a(h, p, m) : (o[p] || (o[p] = { paths: [], computed: (v, y = {}, w = []) => {
        if (o[p].paths.length === 1) return o[p].paths[0].computed(o[p].paths[0].scheme, y.binding, w);
        if (v && v !== "none") for (let g = 0; g < o[p].paths.length; g++) {
          let k = o[p].paths[g];
          if (k.scheme === v) return k.computed(v, y.binding, w);
        }
        return o[p].paths.map((g) => g.computed(g.scheme, y[g.scheme], w));
      } }), o[p].paths.push({ path: m, value: h, scheme: m.includes("colorScheme.light") ? "light" : m.includes("colorScheme.dark") ? "dark" : "none", computed: s, tokens: o }));
    });
  };
  return a(i, n, r), o;
}, getTokenValue(i, e, n) {
  var r;
  let o = ((l) => l.split(".").filter((u) => !xs(u.toLowerCase(), n.variable.excludedKeyRegex)).join("."))(e), s = e.includes("colorScheme.light") ? "light" : e.includes("colorScheme.dark") ? "dark" : void 0, a = [(r = i[o]) == null ? void 0 : r.computed(s)].flat().filter((l) => l);
  return a.length === 1 ? a[0].value : a.reduce((l = {}, u) => {
    let c = u, { colorScheme: d } = c, h = Ar(c, ["colorScheme"]);
    return l[d] = h, l;
  }, void 0);
}, getSelectorRule(i, e, n, r) {
  return n === "class" || n === "attr" ? Js(gt(e) ? `${i}${e},${i} ${e}` : i, r) : Js(i, Js(e ?? ":root,:host", r));
}, transformCSS(i, e, n, r, o = {}, s, a, l) {
  if (gt(e)) {
    let { cssLayer: u } = o;
    if (r !== "style") {
      let c = this.getColorSchemeOption(o, a);
      e = n === "dark" ? c.reduce((d, { type: h, selector: p }) => (gt(p) && (d += p.includes("[CSS]") ? p.replace("[CSS]", e) : this.getSelectorRule(p, l, h, e)), d), "") : Js(l ?? ":root,:host", e);
    }
    if (u) {
      let c = { name: "primeui" };
      _r(u) && (c.name = li(u.name, { name: i, type: r })), gt(c.name) && (e = Js(`@layer ${c.name}`, e), s == null || s.layerNames(c.name));
    }
    return e;
  }
  return "";
} }, Mt = { defaults: { variable: { prefix: "p", selector: ":root,:host", excludedKeyRegex: /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states|extend|css)$/gi }, options: { prefix: "p", darkModeSelector: "system", cssLayer: !1 } }, _theme: void 0, _layerNames: /* @__PURE__ */ new Set(), _loadedStyleNames: /* @__PURE__ */ new Set(), _loadingStyles: /* @__PURE__ */ new Set(), _tokens: {}, update(i = {}) {
  let { theme: e } = i;
  e && (this._theme = Kd(Ai({}, e), { options: Ai(Ai({}, this.defaults.options), e.options) }), this._tokens = Ei.createTokens(this.preset, this.defaults), this.clearLoadedStyleNames());
}, get theme() {
  return this._theme;
}, get preset() {
  var i;
  return ((i = this.theme) == null ? void 0 : i.preset) || {};
}, get options() {
  var i;
  return ((i = this.theme) == null ? void 0 : i.options) || {};
}, get tokens() {
  return this._tokens;
}, getTheme() {
  return this.theme;
}, setTheme(i) {
  this.update({ theme: i }), Dn.emit("theme:change", i);
}, getPreset() {
  return this.preset;
}, setPreset(i) {
  this._theme = Kd(Ai({}, this.theme), { preset: i }), this._tokens = Ei.createTokens(i, this.defaults), this.clearLoadedStyleNames(), Dn.emit("preset:change", i), Dn.emit("theme:change", this.theme);
}, getOptions() {
  return this.options;
}, setOptions(i) {
  this._theme = Kd(Ai({}, this.theme), { options: i }), this.clearLoadedStyleNames(), Dn.emit("options:change", i), Dn.emit("theme:change", this.theme);
}, getLayerNames() {
  return [...this._layerNames];
}, setLayerNames(i) {
  this._layerNames.add(i);
}, getLoadedStyleNames() {
  return this._loadedStyleNames;
}, isStyleNameLoaded(i) {
  return this._loadedStyleNames.has(i);
}, setLoadedStyleName(i) {
  this._loadedStyleNames.add(i);
}, deleteLoadedStyleName(i) {
  this._loadedStyleNames.delete(i);
}, clearLoadedStyleNames() {
  this._loadedStyleNames.clear();
}, getTokenValue(i) {
  return Ei.getTokenValue(this.tokens, i, this.defaults);
}, getCommon(i = "", e) {
  return Ei.getCommon({ name: i, theme: this.theme, params: e, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
}, getComponent(i = "", e) {
  let n = { name: i, theme: this.theme, params: e, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
  return Ei.getPresetC(n);
}, getDirective(i = "", e) {
  let n = { name: i, theme: this.theme, params: e, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
  return Ei.getPresetD(n);
}, getCustomPreset(i = "", e, n, r) {
  let o = { name: i, preset: e, options: this.options, selector: n, params: r, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
  return Ei.getPreset(o);
}, getLayerOrderCSS(i = "") {
  return Ei.getLayerOrder(i, this.options, { names: this.getLayerNames() }, this.defaults);
}, transformCSS(i = "", e, n = "style", r) {
  return Ei.transformCSS(i, e, r, n, this.options, { layerNames: this.setLayerNames.bind(this) }, this.defaults);
}, getCommonStyleSheet(i = "", e, n = {}) {
  return Ei.getCommonStyleSheet({ name: i, theme: this.theme, params: e, props: n, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
}, getStyleSheet(i, e, n = {}) {
  return Ei.getStyleSheet({ name: i, theme: this.theme, params: e, props: n, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
}, onStyleMounted(i) {
  this._loadingStyles.add(i);
}, onStyleUpdated(i) {
  this._loadingStyles.add(i);
}, onStyleLoaded(i, { name: e }) {
  this._loadingStyles.size && (this._loadingStyles.delete(e), Dn.emit(`theme:${e}:load`, i), !this._loadingStyles.size && Dn.emit("theme:load"));
} }, Mn = {
  STARTS_WITH: "startsWith",
  CONTAINS: "contains",
  NOT_CONTAINS: "notContains",
  ENDS_WITH: "endsWith",
  EQUALS: "equals",
  NOT_EQUALS: "notEquals",
  LESS_THAN: "lt",
  LESS_THAN_OR_EQUAL_TO: "lte",
  GREATER_THAN: "gt",
  GREATER_THAN_OR_EQUAL_TO: "gte",
  DATE_IS: "dateIs",
  DATE_IS_NOT: "dateIsNot",
  DATE_BEFORE: "dateBefore",
  DATE_AFTER: "dateAfter"
};
function qm(i, e) {
  var n = typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (!n) {
    if (Array.isArray(i) || (n = IC(i)) || e) {
      n && (i = n);
      var r = 0, o = function() {
      };
      return { s: o, n: function() {
        return r >= i.length ? { done: !0 } : { done: !1, value: i[r++] };
      }, e: function(c) {
        throw c;
      }, f: o };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s, a = !0, l = !1;
  return { s: function() {
    n = n.call(i);
  }, n: function() {
    var c = n.next();
    return a = c.done, c;
  }, e: function(c) {
    l = !0, s = c;
  }, f: function() {
    try {
      a || n.return == null || n.return();
    } finally {
      if (l) throw s;
    }
  } };
}
function IC(i, e) {
  if (i) {
    if (typeof i == "string") return Zm(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Zm(i, e) : void 0;
  }
}
function Zm(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
var LC = {
  filter: function(e, n, r, o, s) {
    var a = [];
    if (!e)
      return a;
    var l = qm(e), u;
    try {
      for (l.s(); !(u = l.n()).done; ) {
        var c = u.value;
        if (typeof c == "string") {
          if (this.filters[o](c, r, s)) {
            a.push(c);
            continue;
          }
        } else {
          var d = qm(n), h;
          try {
            for (d.s(); !(h = d.n()).done; ) {
              var p = h.value, m = Hr(c, p);
              if (this.filters[o](m, r, s)) {
                a.push(c);
                break;
              }
            }
          } catch (v) {
            d.e(v);
          } finally {
            d.f();
          }
        }
      }
    } catch (v) {
      l.e(v);
    } finally {
      l.f();
    }
    return a;
  },
  filters: {
    startsWith: function(e, n, r) {
      if (n == null || n === "")
        return !0;
      if (e == null)
        return !1;
      var o = pi(n.toString()).toLocaleLowerCase(r), s = pi(e.toString()).toLocaleLowerCase(r);
      return s.slice(0, o.length) === o;
    },
    contains: function(e, n, r) {
      if (n == null || n === "")
        return !0;
      if (e == null)
        return !1;
      var o = pi(n.toString()).toLocaleLowerCase(r), s = pi(e.toString()).toLocaleLowerCase(r);
      return s.indexOf(o) !== -1;
    },
    notContains: function(e, n, r) {
      if (n == null || n === "")
        return !0;
      if (e == null)
        return !1;
      var o = pi(n.toString()).toLocaleLowerCase(r), s = pi(e.toString()).toLocaleLowerCase(r);
      return s.indexOf(o) === -1;
    },
    endsWith: function(e, n, r) {
      if (n == null || n === "")
        return !0;
      if (e == null)
        return !1;
      var o = pi(n.toString()).toLocaleLowerCase(r), s = pi(e.toString()).toLocaleLowerCase(r);
      return s.indexOf(o, s.length - o.length) !== -1;
    },
    equals: function(e, n, r) {
      return n == null || n === "" ? !0 : e == null ? !1 : e.getTime && n.getTime ? e.getTime() === n.getTime() : pi(e.toString()).toLocaleLowerCase(r) == pi(n.toString()).toLocaleLowerCase(r);
    },
    notEquals: function(e, n, r) {
      return n == null || n === "" ? !1 : e == null ? !0 : e.getTime && n.getTime ? e.getTime() !== n.getTime() : pi(e.toString()).toLocaleLowerCase(r) != pi(n.toString()).toLocaleLowerCase(r);
    },
    in: function(e, n) {
      if (n == null || n.length === 0)
        return !0;
      for (var r = 0; r < n.length; r++)
        if (z0(e, n[r]))
          return !0;
      return !1;
    },
    between: function(e, n) {
      return n == null || n[0] == null || n[1] == null ? !0 : e == null ? !1 : e.getTime ? n[0].getTime() <= e.getTime() && e.getTime() <= n[1].getTime() : n[0] <= e && e <= n[1];
    },
    lt: function(e, n) {
      return n == null ? !0 : e == null ? !1 : e.getTime && n.getTime ? e.getTime() < n.getTime() : e < n;
    },
    lte: function(e, n) {
      return n == null ? !0 : e == null ? !1 : e.getTime && n.getTime ? e.getTime() <= n.getTime() : e <= n;
    },
    gt: function(e, n) {
      return n == null ? !0 : e == null ? !1 : e.getTime && n.getTime ? e.getTime() > n.getTime() : e > n;
    },
    gte: function(e, n) {
      return n == null ? !0 : e == null ? !1 : e.getTime && n.getTime ? e.getTime() >= n.getTime() : e >= n;
    },
    dateIs: function(e, n) {
      return n == null ? !0 : e == null ? !1 : e.toDateString() === n.toDateString();
    },
    dateIsNot: function(e, n) {
      return n == null ? !0 : e == null ? !1 : e.toDateString() !== n.toDateString();
    },
    dateBefore: function(e, n) {
      return n == null ? !0 : e == null ? !1 : e.getTime() < n.getTime();
    },
    dateAfter: function(e, n) {
      return n == null ? !0 : e == null ? !1 : e.getTime() > n.getTime();
    }
  },
  register: function(e, n) {
    this.filters[e] = n;
  }
}, AC = `
    *,
    ::before,
    ::after {
        box-sizing: border-box;
    }

    .p-collapsible-enter-active {
        animation: p-animate-collapsible-expand 0.2s ease-out;
        overflow: hidden;
    }

    .p-collapsible-leave-active {
        animation: p-animate-collapsible-collapse 0.2s ease-out;
        overflow: hidden;
    }

    @keyframes p-animate-collapsible-expand {
        from {
            grid-template-rows: 0fr;
        }
        to {
            grid-template-rows: 1fr;
        }
    }

    @keyframes p-animate-collapsible-collapse {
        from {
            grid-template-rows: 1fr;
        }
        to {
            grid-template-rows: 0fr;
        }
    }

    .p-disabled,
    .p-disabled * {
        cursor: default;
        pointer-events: none;
        user-select: none;
    }

    .p-disabled,
    .p-component:disabled {
        opacity: dt('disabled.opacity');
    }

    .pi {
        font-size: dt('icon.size');
    }

    .p-icon {
        width: dt('icon.size');
        height: dt('icon.size');
    }

    .p-overlay-mask {
        background: var(--px-mask-background, dt('mask.background'));
        color: dt('mask.color');
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }

    .p-overlay-mask-enter-active {
        animation: p-animate-overlay-mask-enter dt('mask.transition.duration') forwards;
    }

    .p-overlay-mask-leave-active {
        animation: p-animate-overlay-mask-leave dt('mask.transition.duration') forwards;
    }

    @keyframes p-animate-overlay-mask-enter {
        from {
            background: transparent;
        }
        to {
            background: var(--px-mask-background, dt('mask.background'));
        }
    }
    @keyframes p-animate-overlay-mask-leave {
        from {
            background: var(--px-mask-background, dt('mask.background'));
        }
        to {
            background: transparent;
        }
    }

    .p-anchored-overlay-enter-active {
        animation: p-animate-anchored-overlay-enter 300ms cubic-bezier(.19,1,.22,1);
    }

    .p-anchored-overlay-leave-active {
        animation: p-animate-anchored-overlay-leave 300ms cubic-bezier(.19,1,.22,1);
    }

    @keyframes p-animate-anchored-overlay-enter {
        from {
            opacity: 0;
            transform: scale(0.93);
        }
    }

    @keyframes p-animate-anchored-overlay-leave {
        to {
            opacity: 0;
            transform: scale(0.93);
        }
    }
`;
function El(i) {
  "@babel/helpers - typeof";
  return El = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, El(i);
}
function Jm(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qm(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Jm(Object(n), !0).forEach(function(r) {
      VC(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : Jm(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function VC(i, e, n) {
  return (e = FC(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function FC(i) {
  var e = jC(i, "string");
  return El(e) == "symbol" ? e : e + "";
}
function jC(i, e) {
  if (El(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (El(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
function RC(i) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  jo() && jo().components ? Wn(i) : e ? i() : Es(i);
}
var NC = 0;
function zC(i) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = re(!1), r = re(i), o = re(null), s = tb() ? window.document : void 0, a = e.document, l = a === void 0 ? s : a, u = e.immediate, c = u === void 0 ? !0 : u, d = e.manual, h = d === void 0 ? !1 : d, p = e.name, m = p === void 0 ? "style_".concat(++NC) : p, v = e.id, y = v === void 0 ? void 0 : v, w = e.media, g = w === void 0 ? void 0 : w, k = e.nonce, _ = k === void 0 ? void 0 : k, S = e.first, b = S === void 0 ? !1 : S, C = e.onMounted, x = C === void 0 ? void 0 : C, I = e.onUpdated, F = I === void 0 ? void 0 : I, B = e.onLoad, X = B === void 0 ? void 0 : B, j = e.props, ee = j === void 0 ? {} : j, ie = function() {
  }, M = function(V) {
    var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (l) {
      var $e = Qm(Qm({}, ee), ae), N = $e.name || m, me = $e.id || y, we = $e.nonce || _;
      o.value = l.querySelector('style[data-primevue-style-id="'.concat(N, '"]')) || l.getElementById(me) || l.createElement("style"), o.value.isConnected || (r.value = V || i, Vc(o.value, {
        type: "text/css",
        id: me,
        media: g,
        nonce: we
      }), b ? l.head.prepend(o.value) : l.head.appendChild(o.value), nb(o.value, "data-primevue-style-id", N), Vc(o.value, $e), o.value.onload = function(fe) {
        return X == null ? void 0 : X(fe, {
          name: N
        });
      }, x == null || x(N)), !n.value && (ie = Lt(r, function(fe) {
        o.value.textContent = fe, F == null || F(N);
      }, {
        immediate: !0
      }), n.value = !0);
    }
  }, W = function() {
    !l || !n.value || (ie(), J0(o.value) && l.head.removeChild(o.value), n.value = !1, o.value = null);
  };
  return c && !h && RC(M), {
    id: y,
    name: m,
    el: o,
    css: r,
    unload: W,
    load: M,
    isLoaded: xc(n)
  };
}
function Tl(i) {
  "@babel/helpers - typeof";
  return Tl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Tl(i);
}
var eg, tg, ng, ig;
function rg(i, e) {
  return WC(i) || UC(i, e) || HC(i, e) || BC();
}
function BC() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function HC(i, e) {
  if (i) {
    if (typeof i == "string") return og(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? og(i, e) : void 0;
  }
}
function og(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function UC(i, e) {
  var n = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (n != null) {
    var r, o, s, a, l = [], u = !0, c = !1;
    try {
      if (s = (n = n.call(i)).next, e !== 0) for (; !(u = (r = s.call(n)).done) && (l.push(r.value), l.length !== e); u = !0) ;
    } catch (d) {
      c = !0, o = d;
    } finally {
      try {
        if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return;
      } finally {
        if (c) throw o;
      }
    }
    return l;
  }
}
function WC(i) {
  if (Array.isArray(i)) return i;
}
function sg(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qd(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? sg(Object(n), !0).forEach(function(r) {
      GC(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : sg(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function GC(i, e, n) {
  return (e = XC(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function XC(i) {
  var e = YC(i, "string");
  return Tl(e) == "symbol" ? e : e + "";
}
function YC(i, e) {
  if (Tl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Tl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
function Ou(i, e) {
  return e || (e = i.slice(0)), Object.freeze(Object.defineProperties(i, { raw: { value: Object.freeze(e) } }));
}
var KC = function(e) {
  var n = e.dt;
  return `
.p-hidden-accessible {
    border: 0;
    clip: rect(0 0 0 0);
    height: 1px;
    margin: -1px;
    opacity: 0;
    overflow: hidden;
    padding: 0;
    pointer-events: none;
    position: absolute;
    white-space: nowrap;
    width: 1px;
}

.p-overflow-hidden {
    overflow: hidden;
    padding-right: `.concat(n("scrollbar.width"), `;
}
`);
}, qC = {}, ZC = {}, bt = {
  name: "base",
  css: KC,
  style: AC,
  classes: qC,
  inlineStyles: ZC,
  load: function(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(s) {
      return s;
    }, o = r(ku(eg || (eg = Ou(["", ""])), e));
    return gt(o) ? zC(ul(o), qd({
      name: this.name
    }, n)) : {};
  },
  loadCSS: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.load(this.css, e);
  },
  loadStyle: function() {
    var e = this, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return this.load(this.style, n, function() {
      var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return Mt.transformCSS(n.name || e.name, "".concat(o).concat(ku(tg || (tg = Ou(["", ""])), r)));
    });
  },
  getCommonTheme: function(e) {
    return Mt.getCommon(this.name, e);
  },
  getComponentTheme: function(e) {
    return Mt.getComponent(this.name, e);
  },
  getDirectiveTheme: function(e) {
    return Mt.getDirective(this.name, e);
  },
  getPresetTheme: function(e, n, r) {
    return Mt.getCustomPreset(this.name, e, n, r);
  },
  getLayerOrderThemeCSS: function() {
    return Mt.getLayerOrderCSS(this.name);
  },
  getStyleSheet: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.css) {
      var r = li(this.css, {
        dt: Cs
      }) || "", o = ul(ku(ng || (ng = Ou(["", "", ""])), r, e)), s = Object.entries(n).reduce(function(a, l) {
        var u = rg(l, 2), c = u[0], d = u[1];
        return a.push("".concat(c, '="').concat(d, '"')) && a;
      }, []).join(" ");
      return gt(o) ? '<style type="text/css" data-primevue-style-id="'.concat(this.name, '" ').concat(s, ">").concat(o, "</style>") : "";
    }
    return "";
  },
  getCommonThemeStyleSheet: function(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Mt.getCommonStyleSheet(this.name, e, n);
  },
  getThemeStyleSheet: function(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = [Mt.getStyleSheet(this.name, e, n)];
    if (this.style) {
      var o = this.name === "base" ? "global-style" : "".concat(this.name, "-style"), s = ku(ig || (ig = Ou(["", ""])), li(this.style, {
        dt: Cs
      })), a = ul(Mt.transformCSS(o, s)), l = Object.entries(n).reduce(function(u, c) {
        var d = rg(c, 2), h = d[0], p = d[1];
        return u.push("".concat(h, '="').concat(p, '"')) && u;
      }, []).join(" ");
      gt(a) && r.push('<style type="text/css" data-primevue-style-id="'.concat(o, '" ').concat(l, ">").concat(a, "</style>"));
    }
    return r.join("");
  },
  extend: function(e) {
    return qd(qd({}, this), {}, {
      css: void 0,
      style: void 0
    }, e);
  }
}, Lo = Yf();
function Dl(i) {
  "@babel/helpers - typeof";
  return Dl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Dl(i);
}
function ag(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Eu(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ag(Object(n), !0).forEach(function(r) {
      JC(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : ag(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function JC(i, e, n) {
  return (e = QC(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function QC(i) {
  var e = e2(i, "string");
  return Dl(e) == "symbol" ? e : e + "";
}
function e2(i, e) {
  if (Dl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Dl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var t2 = {
  ripple: !1,
  inputStyle: null,
  inputVariant: null,
  locale: {
    startsWith: "Starts with",
    contains: "Contains",
    notContains: "Not contains",
    endsWith: "Ends with",
    equals: "Equals",
    notEquals: "Not equals",
    noFilter: "No Filter",
    lt: "Less than",
    lte: "Less than or equal to",
    gt: "Greater than",
    gte: "Greater than or equal to",
    dateIs: "Date is",
    dateIsNot: "Date is not",
    dateBefore: "Date is before",
    dateAfter: "Date is after",
    clear: "Clear",
    apply: "Apply",
    matchAll: "Match All",
    matchAny: "Match Any",
    addRule: "Add Rule",
    removeRule: "Remove Rule",
    accept: "Yes",
    reject: "No",
    choose: "Choose",
    upload: "Upload",
    cancel: "Cancel",
    completed: "Completed",
    pending: "Pending",
    fileSizeTypes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"],
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    chooseYear: "Choose Year",
    chooseMonth: "Choose Month",
    chooseDate: "Choose Date",
    prevDecade: "Previous Decade",
    nextDecade: "Next Decade",
    prevYear: "Previous Year",
    nextYear: "Next Year",
    prevMonth: "Previous Month",
    nextMonth: "Next Month",
    prevHour: "Previous Hour",
    nextHour: "Next Hour",
    prevMinute: "Previous Minute",
    nextMinute: "Next Minute",
    prevSecond: "Previous Second",
    nextSecond: "Next Second",
    am: "am",
    pm: "pm",
    today: "Today",
    weekHeader: "Wk",
    firstDayOfWeek: 0,
    showMonthAfterYear: !1,
    dateFormat: "mm/dd/yy",
    weak: "Weak",
    medium: "Medium",
    strong: "Strong",
    passwordPrompt: "Enter a password",
    emptyFilterMessage: "No results found",
    searchMessage: "{0} results are available",
    selectionMessage: "{0} items selected",
    emptySelectionMessage: "No selected item",
    emptySearchMessage: "No results found",
    fileChosenMessage: "{0} files",
    noFileChosenMessage: "No file chosen",
    emptyMessage: "No available options",
    aria: {
      trueLabel: "True",
      falseLabel: "False",
      nullLabel: "Not Selected",
      star: "1 star",
      stars: "{star} stars",
      selectAll: "All items selected",
      unselectAll: "All items unselected",
      close: "Close",
      previous: "Previous",
      next: "Next",
      navigation: "Navigation",
      scrollTop: "Scroll Top",
      moveTop: "Move Top",
      moveUp: "Move Up",
      moveDown: "Move Down",
      moveBottom: "Move Bottom",
      moveToTarget: "Move to Target",
      moveToSource: "Move to Source",
      moveAllToTarget: "Move All to Target",
      moveAllToSource: "Move All to Source",
      pageLabel: "Page {page}",
      firstPageLabel: "First Page",
      lastPageLabel: "Last Page",
      nextPageLabel: "Next Page",
      prevPageLabel: "Previous Page",
      rowsPerPageLabel: "Rows per page",
      jumpToPageDropdownLabel: "Jump to Page Dropdown",
      jumpToPageInputLabel: "Jump to Page Input",
      selectRow: "Row Selected",
      unselectRow: "Row Unselected",
      expandRow: "Row Expanded",
      collapseRow: "Row Collapsed",
      showFilterMenu: "Show Filter Menu",
      hideFilterMenu: "Hide Filter Menu",
      filterOperator: "Filter Operator",
      filterConstraint: "Filter Constraint",
      editRow: "Row Edit",
      saveEdit: "Save Edit",
      cancelEdit: "Cancel Edit",
      listView: "List View",
      gridView: "Grid View",
      slide: "Slide",
      slideNumber: "{slideNumber}",
      zoomImage: "Zoom Image",
      zoomIn: "Zoom In",
      zoomOut: "Zoom Out",
      rotateRight: "Rotate Right",
      rotateLeft: "Rotate Left",
      listLabel: "Option List"
    }
  },
  filterMatchModeOptions: {
    text: [Mn.STARTS_WITH, Mn.CONTAINS, Mn.NOT_CONTAINS, Mn.ENDS_WITH, Mn.EQUALS, Mn.NOT_EQUALS],
    numeric: [Mn.EQUALS, Mn.NOT_EQUALS, Mn.LESS_THAN, Mn.LESS_THAN_OR_EQUAL_TO, Mn.GREATER_THAN, Mn.GREATER_THAN_OR_EQUAL_TO],
    date: [Mn.DATE_IS, Mn.DATE_IS_NOT, Mn.DATE_BEFORE, Mn.DATE_AFTER]
  },
  zIndex: {
    modal: 1100,
    overlay: 1e3,
    menu: 1e3,
    tooltip: 1100
  },
  theme: void 0,
  unstyled: !1,
  pt: void 0,
  ptOptions: {
    mergeSections: !0,
    mergeProps: !1
  },
  csp: {
    nonce: void 0
  }
}, n2 = Symbol();
function i2(i, e) {
  var n = {
    config: zo(e)
  };
  return i.config.globalProperties.$primevue = n, i.provide(n2, n), r2(), o2(i, n), n;
}
var na = [];
function r2() {
  Dn.clear(), na.forEach(function(i) {
    return i == null ? void 0 : i();
  }), na = [];
}
function o2(i, e) {
  var n = re(!1), r = function() {
    var c;
    if (((c = e.config) === null || c === void 0 ? void 0 : c.theme) !== "none" && !Mt.isStyleNameLoaded("common")) {
      var d, h, p = ((d = bt.getCommonTheme) === null || d === void 0 ? void 0 : d.call(bt)) || {}, m = p.primitive, v = p.semantic, y = p.global, w = p.style, g = {
        nonce: (h = e.config) === null || h === void 0 || (h = h.csp) === null || h === void 0 ? void 0 : h.nonce
      };
      bt.load(m == null ? void 0 : m.css, Eu({
        name: "primitive-variables"
      }, g)), bt.load(v == null ? void 0 : v.css, Eu({
        name: "semantic-variables"
      }, g)), bt.load(y == null ? void 0 : y.css, Eu({
        name: "global-variables"
      }, g)), bt.loadStyle(Eu({
        name: "global-style"
      }, g), w), Mt.setLoadedStyleName("common");
    }
  };
  Dn.on("theme:change", function(u) {
    n.value || (i.config.globalProperties.$primevue.config.theme = u, n.value = !0);
  });
  var o = Lt(e.config, function(u, c) {
    Lo.emit("config:change", {
      newValue: u,
      oldValue: c
    });
  }, {
    immediate: !0,
    deep: !0
  }), s = Lt(function() {
    return e.config.ripple;
  }, function(u, c) {
    Lo.emit("config:ripple:change", {
      newValue: u,
      oldValue: c
    });
  }, {
    immediate: !0,
    deep: !0
  }), a = Lt(function() {
    return e.config.theme;
  }, function(u, c) {
    n.value || Mt.setTheme(u), e.config.unstyled || r(), n.value = !1, Lo.emit("config:theme:change", {
      newValue: u,
      oldValue: c
    });
  }, {
    immediate: !0,
    deep: !1
  }), l = Lt(function() {
    return e.config.unstyled;
  }, function(u, c) {
    !u && e.config.theme && r(), Lo.emit("config:unstyled:change", {
      newValue: u,
      oldValue: c
    });
  }, {
    immediate: !0,
    deep: !0
  });
  na.push(o), na.push(s), na.push(a), na.push(l);
}
var s2 = {
  install: function(e, n) {
    var r = hC(t2, n);
    i2(e, r);
  }
}, f9 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function a2(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var Uh = { exports: {} }, dt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lg;
function l2() {
  if (lg) return dt;
  lg = 1;
  var i = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.iterator;
  function p(N) {
    return N === null || typeof N != "object" ? null : (N = h && N[h] || N["@@iterator"], typeof N == "function" ? N : null);
  }
  var m = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, v = Object.assign, y = {};
  function w(N, me, we) {
    this.props = N, this.context = me, this.refs = y, this.updater = we || m;
  }
  w.prototype.isReactComponent = {}, w.prototype.setState = function(N, me) {
    if (typeof N != "object" && typeof N != "function" && N != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, N, me, "setState");
  }, w.prototype.forceUpdate = function(N) {
    this.updater.enqueueForceUpdate(this, N, "forceUpdate");
  };
  function g() {
  }
  g.prototype = w.prototype;
  function k(N, me, we) {
    this.props = N, this.context = me, this.refs = y, this.updater = we || m;
  }
  var _ = k.prototype = new g();
  _.constructor = k, v(_, w.prototype), _.isPureReactComponent = !0;
  var S = Array.isArray, b = Object.prototype.hasOwnProperty, C = { current: null }, x = { key: !0, ref: !0, __self: !0, __source: !0 };
  function I(N, me, we) {
    var fe, te = {}, Me = null, Re = null;
    if (me != null) for (fe in me.ref !== void 0 && (Re = me.ref), me.key !== void 0 && (Me = "" + me.key), me) b.call(me, fe) && !x.hasOwnProperty(fe) && (te[fe] = me[fe]);
    var Ce = arguments.length - 2;
    if (Ce === 1) te.children = we;
    else if (1 < Ce) {
      for (var le = Array(Ce), T = 0; T < Ce; T++) le[T] = arguments[T + 2];
      te.children = le;
    }
    if (N && N.defaultProps) for (fe in Ce = N.defaultProps, Ce) te[fe] === void 0 && (te[fe] = Ce[fe]);
    return { $$typeof: i, type: N, key: Me, ref: Re, props: te, _owner: C.current };
  }
  function F(N, me) {
    return { $$typeof: i, type: N.type, key: me, ref: N.ref, props: N.props, _owner: N._owner };
  }
  function B(N) {
    return typeof N == "object" && N !== null && N.$$typeof === i;
  }
  function X(N) {
    var me = { "=": "=0", ":": "=2" };
    return "$" + N.replace(/[=:]/g, function(we) {
      return me[we];
    });
  }
  var j = /\/+/g;
  function ee(N, me) {
    return typeof N == "object" && N !== null && N.key != null ? X("" + N.key) : me.toString(36);
  }
  function ie(N, me, we, fe, te) {
    var Me = typeof N;
    (Me === "undefined" || Me === "boolean") && (N = null);
    var Re = !1;
    if (N === null) Re = !0;
    else switch (Me) {
      case "string":
      case "number":
        Re = !0;
        break;
      case "object":
        switch (N.$$typeof) {
          case i:
          case e:
            Re = !0;
        }
    }
    if (Re) return Re = N, te = te(Re), N = fe === "" ? "." + ee(Re, 0) : fe, S(te) ? (we = "", N != null && (we = N.replace(j, "$&/") + "/"), ie(te, me, we, "", function(T) {
      return T;
    })) : te != null && (B(te) && (te = F(te, we + (!te.key || Re && Re.key === te.key ? "" : ("" + te.key).replace(j, "$&/") + "/") + N)), me.push(te)), 1;
    if (Re = 0, fe = fe === "" ? "." : fe + ":", S(N)) for (var Ce = 0; Ce < N.length; Ce++) {
      Me = N[Ce];
      var le = fe + ee(Me, Ce);
      Re += ie(Me, me, we, le, te);
    }
    else if (le = p(N), typeof le == "function") for (N = le.call(N), Ce = 0; !(Me = N.next()).done; ) Me = Me.value, le = fe + ee(Me, Ce++), Re += ie(Me, me, we, le, te);
    else if (Me === "object") throw me = String(N), Error("Objects are not valid as a React child (found: " + (me === "[object Object]" ? "object with keys {" + Object.keys(N).join(", ") + "}" : me) + "). If you meant to render a collection of children, use an array instead.");
    return Re;
  }
  function M(N, me, we) {
    if (N == null) return N;
    var fe = [], te = 0;
    return ie(N, fe, "", "", function(Me) {
      return me.call(we, Me, te++);
    }), fe;
  }
  function W(N) {
    if (N._status === -1) {
      var me = N._result;
      me = me(), me.then(function(we) {
        (N._status === 0 || N._status === -1) && (N._status = 1, N._result = we);
      }, function(we) {
        (N._status === 0 || N._status === -1) && (N._status = 2, N._result = we);
      }), N._status === -1 && (N._status = 0, N._result = me);
    }
    if (N._status === 1) return N._result.default;
    throw N._result;
  }
  var R = { current: null }, V = { transition: null }, ae = { ReactCurrentDispatcher: R, ReactCurrentBatchConfig: V, ReactCurrentOwner: C };
  function $e() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return dt.Children = { map: M, forEach: function(N, me, we) {
    M(N, function() {
      me.apply(this, arguments);
    }, we);
  }, count: function(N) {
    var me = 0;
    return M(N, function() {
      me++;
    }), me;
  }, toArray: function(N) {
    return M(N, function(me) {
      return me;
    }) || [];
  }, only: function(N) {
    if (!B(N)) throw Error("React.Children.only expected to receive a single React element child.");
    return N;
  } }, dt.Component = w, dt.Fragment = n, dt.Profiler = o, dt.PureComponent = k, dt.StrictMode = r, dt.Suspense = u, dt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ae, dt.act = $e, dt.cloneElement = function(N, me, we) {
    if (N == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + N + ".");
    var fe = v({}, N.props), te = N.key, Me = N.ref, Re = N._owner;
    if (me != null) {
      if (me.ref !== void 0 && (Me = me.ref, Re = C.current), me.key !== void 0 && (te = "" + me.key), N.type && N.type.defaultProps) var Ce = N.type.defaultProps;
      for (le in me) b.call(me, le) && !x.hasOwnProperty(le) && (fe[le] = me[le] === void 0 && Ce !== void 0 ? Ce[le] : me[le]);
    }
    var le = arguments.length - 2;
    if (le === 1) fe.children = we;
    else if (1 < le) {
      Ce = Array(le);
      for (var T = 0; T < le; T++) Ce[T] = arguments[T + 2];
      fe.children = Ce;
    }
    return { $$typeof: i, type: N.type, key: te, ref: Me, props: fe, _owner: Re };
  }, dt.createContext = function(N) {
    return N = { $$typeof: a, _currentValue: N, _currentValue2: N, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, N.Provider = { $$typeof: s, _context: N }, N.Consumer = N;
  }, dt.createElement = I, dt.createFactory = function(N) {
    var me = I.bind(null, N);
    return me.type = N, me;
  }, dt.createRef = function() {
    return { current: null };
  }, dt.forwardRef = function(N) {
    return { $$typeof: l, render: N };
  }, dt.isValidElement = B, dt.lazy = function(N) {
    return { $$typeof: d, _payload: { _status: -1, _result: N }, _init: W };
  }, dt.memo = function(N, me) {
    return { $$typeof: c, type: N, compare: me === void 0 ? null : me };
  }, dt.startTransition = function(N) {
    var me = V.transition;
    V.transition = {};
    try {
      N();
    } finally {
      V.transition = me;
    }
  }, dt.unstable_act = $e, dt.useCallback = function(N, me) {
    return R.current.useCallback(N, me);
  }, dt.useContext = function(N) {
    return R.current.useContext(N);
  }, dt.useDebugValue = function() {
  }, dt.useDeferredValue = function(N) {
    return R.current.useDeferredValue(N);
  }, dt.useEffect = function(N, me) {
    return R.current.useEffect(N, me);
  }, dt.useId = function() {
    return R.current.useId();
  }, dt.useImperativeHandle = function(N, me, we) {
    return R.current.useImperativeHandle(N, me, we);
  }, dt.useInsertionEffect = function(N, me) {
    return R.current.useInsertionEffect(N, me);
  }, dt.useLayoutEffect = function(N, me) {
    return R.current.useLayoutEffect(N, me);
  }, dt.useMemo = function(N, me) {
    return R.current.useMemo(N, me);
  }, dt.useReducer = function(N, me, we) {
    return R.current.useReducer(N, me, we);
  }, dt.useRef = function(N) {
    return R.current.useRef(N);
  }, dt.useState = function(N) {
    return R.current.useState(N);
  }, dt.useSyncExternalStore = function(N, me, we) {
    return R.current.useSyncExternalStore(N, me, we);
  }, dt.useTransition = function() {
    return R.current.useTransition();
  }, dt.version = "18.3.1", dt;
}
var Ja = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Ja.exports;
var ug;
function u2() {
  return ug || (ug = 1, function(i, e) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var n = "18.3.1", r = Symbol.for("react.element"), o = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), c = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), p = Symbol.for("react.suspense_list"), m = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), w = Symbol.iterator, g = "@@iterator";
      function k(O) {
        if (O === null || typeof O != "object")
          return null;
        var z = w && O[w] || O[g];
        return typeof z == "function" ? z : null;
      }
      var _ = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, S = {
        transition: null
      }, b = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, C = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, x = {}, I = null;
      function F(O) {
        I = O;
      }
      x.setExtraStackFrame = function(O) {
        I = O;
      }, x.getCurrentStack = null, x.getStackAddendum = function() {
        var O = "";
        I && (O += I);
        var z = x.getCurrentStack;
        return z && (O += z() || ""), O;
      };
      var B = !1, X = !1, j = !1, ee = !1, ie = !1, M = {
        ReactCurrentDispatcher: _,
        ReactCurrentBatchConfig: S,
        ReactCurrentOwner: C
      };
      M.ReactDebugCurrentFrame = x, M.ReactCurrentActQueue = b;
      function W(O) {
        {
          for (var z = arguments.length, de = new Array(z > 1 ? z - 1 : 0), ye = 1; ye < z; ye++)
            de[ye - 1] = arguments[ye];
          V("warn", O, de);
        }
      }
      function R(O) {
        {
          for (var z = arguments.length, de = new Array(z > 1 ? z - 1 : 0), ye = 1; ye < z; ye++)
            de[ye - 1] = arguments[ye];
          V("error", O, de);
        }
      }
      function V(O, z, de) {
        {
          var ye = M.ReactDebugCurrentFrame, Ie = ye.getStackAddendum();
          Ie !== "" && (z += "%s", de = de.concat([Ie]));
          var Ze = de.map(function(Ue) {
            return String(Ue);
          });
          Ze.unshift("Warning: " + z), Function.prototype.apply.call(console[O], console, Ze);
        }
      }
      var ae = {};
      function $e(O, z) {
        {
          var de = O.constructor, ye = de && (de.displayName || de.name) || "ReactClass", Ie = ye + "." + z;
          if (ae[Ie])
            return;
          R("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", z, ye), ae[Ie] = !0;
        }
      }
      var N = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(O) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(O, z, de) {
          $e(O, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(O, z, de, ye) {
          $e(O, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(O, z, de, ye) {
          $e(O, "setState");
        }
      }, me = Object.assign, we = {};
      Object.freeze(we);
      function fe(O, z, de) {
        this.props = O, this.context = z, this.refs = we, this.updater = de || N;
      }
      fe.prototype.isReactComponent = {}, fe.prototype.setState = function(O, z) {
        if (typeof O != "object" && typeof O != "function" && O != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, O, z, "setState");
      }, fe.prototype.forceUpdate = function(O) {
        this.updater.enqueueForceUpdate(this, O, "forceUpdate");
      };
      {
        var te = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, Me = function(O, z) {
          Object.defineProperty(fe.prototype, O, {
            get: function() {
              W("%s(...) is deprecated in plain JavaScript React classes. %s", z[0], z[1]);
            }
          });
        };
        for (var Re in te)
          te.hasOwnProperty(Re) && Me(Re, te[Re]);
      }
      function Ce() {
      }
      Ce.prototype = fe.prototype;
      function le(O, z, de) {
        this.props = O, this.context = z, this.refs = we, this.updater = de || N;
      }
      var T = le.prototype = new Ce();
      T.constructor = le, me(T, fe.prototype), T.isPureReactComponent = !0;
      function E() {
        var O = {
          current: null
        };
        return Object.seal(O), O;
      }
      var L = Array.isArray;
      function D(O) {
        return L(O);
      }
      function P(O) {
        {
          var z = typeof Symbol == "function" && Symbol.toStringTag, de = z && O[Symbol.toStringTag] || O.constructor.name || "Object";
          return de;
        }
      }
      function G(O) {
        try {
          return ne(O), !1;
        } catch {
          return !0;
        }
      }
      function ne(O) {
        return "" + O;
      }
      function se(O) {
        if (G(O))
          return R("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", P(O)), ne(O);
      }
      function ge(O, z, de) {
        var ye = O.displayName;
        if (ye)
          return ye;
        var Ie = z.displayName || z.name || "";
        return Ie !== "" ? de + "(" + Ie + ")" : de;
      }
      function Se(O) {
        return O.displayName || "Context";
      }
      function be(O) {
        if (O == null)
          return null;
        if (typeof O.tag == "number" && R("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof O == "function")
          return O.displayName || O.name || null;
        if (typeof O == "string")
          return O;
        switch (O) {
          case s:
            return "Fragment";
          case o:
            return "Portal";
          case l:
            return "Profiler";
          case a:
            return "StrictMode";
          case h:
            return "Suspense";
          case p:
            return "SuspenseList";
        }
        if (typeof O == "object")
          switch (O.$$typeof) {
            case c:
              var z = O;
              return Se(z) + ".Consumer";
            case u:
              var de = O;
              return Se(de._context) + ".Provider";
            case d:
              return ge(O, O.render, "ForwardRef");
            case m:
              var ye = O.displayName || null;
              return ye !== null ? ye : be(O.type) || "Memo";
            case v: {
              var Ie = O, Ze = Ie._payload, Ue = Ie._init;
              try {
                return be(Ue(Ze));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var xe = Object.prototype.hasOwnProperty, q = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, J, ue, Ae;
      Ae = {};
      function je(O) {
        if (xe.call(O, "ref")) {
          var z = Object.getOwnPropertyDescriptor(O, "ref").get;
          if (z && z.isReactWarning)
            return !1;
        }
        return O.ref !== void 0;
      }
      function Ge(O) {
        if (xe.call(O, "key")) {
          var z = Object.getOwnPropertyDescriptor(O, "key").get;
          if (z && z.isReactWarning)
            return !1;
        }
        return O.key !== void 0;
      }
      function ft(O, z) {
        var de = function() {
          J || (J = !0, R("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", z));
        };
        de.isReactWarning = !0, Object.defineProperty(O, "key", {
          get: de,
          configurable: !0
        });
      }
      function at(O, z) {
        var de = function() {
          ue || (ue = !0, R("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", z));
        };
        de.isReactWarning = !0, Object.defineProperty(O, "ref", {
          get: de,
          configurable: !0
        });
      }
      function nn(O) {
        if (typeof O.ref == "string" && C.current && O.__self && C.current.stateNode !== O.__self) {
          var z = be(C.current.type);
          Ae[z] || (R('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', z, O.ref), Ae[z] = !0);
        }
      }
      var Gt = function(O, z, de, ye, Ie, Ze, Ue) {
        var nt = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: O,
          key: z,
          ref: de,
          props: Ue,
          // Record the component responsible for creating this element.
          _owner: Ze
        };
        return nt._store = {}, Object.defineProperty(nt._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(nt, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: ye
        }), Object.defineProperty(nt, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Ie
        }), Object.freeze && (Object.freeze(nt.props), Object.freeze(nt)), nt;
      };
      function wn(O, z, de) {
        var ye, Ie = {}, Ze = null, Ue = null, nt = null, _t = null;
        if (z != null) {
          je(z) && (Ue = z.ref, nn(z)), Ge(z) && (se(z.key), Ze = "" + z.key), nt = z.__self === void 0 ? null : z.__self, _t = z.__source === void 0 ? null : z.__source;
          for (ye in z)
            xe.call(z, ye) && !q.hasOwnProperty(ye) && (Ie[ye] = z[ye]);
        }
        var Ft = arguments.length - 2;
        if (Ft === 1)
          Ie.children = de;
        else if (Ft > 1) {
          for (var Ht = Array(Ft), Ut = 0; Ut < Ft; Ut++)
            Ht[Ut] = arguments[Ut + 2];
          Object.freeze && Object.freeze(Ht), Ie.children = Ht;
        }
        if (O && O.defaultProps) {
          var Yt = O.defaultProps;
          for (ye in Yt)
            Ie[ye] === void 0 && (Ie[ye] = Yt[ye]);
        }
        if (Ze || Ue) {
          var dn = typeof O == "function" ? O.displayName || O.name || "Unknown" : O;
          Ze && ft(Ie, dn), Ue && at(Ie, dn);
        }
        return Gt(O, Ze, Ue, nt, _t, C.current, Ie);
      }
      function _n(O, z) {
        var de = Gt(O.type, z, O.ref, O._self, O._source, O._owner, O.props);
        return de;
      }
      function kn(O, z, de) {
        if (O == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + O + ".");
        var ye, Ie = me({}, O.props), Ze = O.key, Ue = O.ref, nt = O._self, _t = O._source, Ft = O._owner;
        if (z != null) {
          je(z) && (Ue = z.ref, Ft = C.current), Ge(z) && (se(z.key), Ze = "" + z.key);
          var Ht;
          O.type && O.type.defaultProps && (Ht = O.type.defaultProps);
          for (ye in z)
            xe.call(z, ye) && !q.hasOwnProperty(ye) && (z[ye] === void 0 && Ht !== void 0 ? Ie[ye] = Ht[ye] : Ie[ye] = z[ye]);
        }
        var Ut = arguments.length - 2;
        if (Ut === 1)
          Ie.children = de;
        else if (Ut > 1) {
          for (var Yt = Array(Ut), dn = 0; dn < Ut; dn++)
            Yt[dn] = arguments[dn + 2];
          Ie.children = Yt;
        }
        return Gt(O.type, Ze, Ue, nt, _t, Ft, Ie);
      }
      function rn(O) {
        return typeof O == "object" && O !== null && O.$$typeof === r;
      }
      var It = ".", mn = ":";
      function Vn(O) {
        var z = /[=:]/g, de = {
          "=": "=0",
          ":": "=2"
        }, ye = O.replace(z, function(Ie) {
          return de[Ie];
        });
        return "$" + ye;
      }
      var Or = !1, co = /\/+/g;
      function tr(O) {
        return O.replace(co, "$&/");
      }
      function ho(O, z) {
        return typeof O == "object" && O !== null && O.key != null ? (se(O.key), Vn("" + O.key)) : z.toString(36);
      }
      function Er(O, z, de, ye, Ie) {
        var Ze = typeof O;
        (Ze === "undefined" || Ze === "boolean") && (O = null);
        var Ue = !1;
        if (O === null)
          Ue = !0;
        else
          switch (Ze) {
            case "string":
            case "number":
              Ue = !0;
              break;
            case "object":
              switch (O.$$typeof) {
                case r:
                case o:
                  Ue = !0;
              }
          }
        if (Ue) {
          var nt = O, _t = Ie(nt), Ft = ye === "" ? It + ho(nt, 0) : ye;
          if (D(_t)) {
            var Ht = "";
            Ft != null && (Ht = tr(Ft) + "/"), Er(_t, z, Ht, "", function(sw) {
              return sw;
            });
          } else _t != null && (rn(_t) && (_t.key && (!nt || nt.key !== _t.key) && se(_t.key), _t = _n(
            _t,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            de + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (_t.key && (!nt || nt.key !== _t.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              tr("" + _t.key) + "/"
            ) : "") + Ft
          )), z.push(_t));
          return 1;
        }
        var Ut, Yt, dn = 0, En = ye === "" ? It : ye + mn;
        if (D(O))
          for (var gu = 0; gu < O.length; gu++)
            Ut = O[gu], Yt = En + ho(Ut, gu), dn += Er(Ut, z, de, Yt, Ie);
        else {
          var Id = k(O);
          if (typeof Id == "function") {
            var Vp = O;
            Id === Vp.entries && (Or || W("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Or = !0);
            for (var rw = Id.call(Vp), Fp, ow = 0; !(Fp = rw.next()).done; )
              Ut = Fp.value, Yt = En + ho(Ut, ow++), dn += Er(Ut, z, de, Yt, Ie);
          } else if (Ze === "object") {
            var jp = String(O);
            throw new Error("Objects are not valid as a React child (found: " + (jp === "[object Object]" ? "object with keys {" + Object.keys(O).join(", ") + "}" : jp) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return dn;
      }
      function qt(O, z, de) {
        if (O == null)
          return O;
        var ye = [], Ie = 0;
        return Er(O, ye, "", "", function(Ze) {
          return z.call(de, Ze, Ie++);
        }), ye;
      }
      function Ma(O) {
        var z = 0;
        return qt(O, function() {
          z++;
        }), z;
      }
      function As(O, z, de) {
        qt(O, function() {
          z.apply(this, arguments);
        }, de);
      }
      function Tr(O) {
        return qt(O, function(z) {
          return z;
        }) || [];
      }
      function fo(O) {
        if (!rn(O))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return O;
      }
      function nr(O) {
        var z = {
          $$typeof: c,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: O,
          _currentValue2: O,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        z.Provider = {
          $$typeof: u,
          _context: z
        };
        var de = !1, ye = !1, Ie = !1;
        {
          var Ze = {
            $$typeof: c,
            _context: z
          };
          Object.defineProperties(Ze, {
            Provider: {
              get: function() {
                return ye || (ye = !0, R("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), z.Provider;
              },
              set: function(Ue) {
                z.Provider = Ue;
              }
            },
            _currentValue: {
              get: function() {
                return z._currentValue;
              },
              set: function(Ue) {
                z._currentValue = Ue;
              }
            },
            _currentValue2: {
              get: function() {
                return z._currentValue2;
              },
              set: function(Ue) {
                z._currentValue2 = Ue;
              }
            },
            _threadCount: {
              get: function() {
                return z._threadCount;
              },
              set: function(Ue) {
                z._threadCount = Ue;
              }
            },
            Consumer: {
              get: function() {
                return de || (de = !0, R("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), z.Consumer;
              }
            },
            displayName: {
              get: function() {
                return z.displayName;
              },
              set: function(Ue) {
                Ie || (W("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Ue), Ie = !0);
              }
            }
          }), z.Consumer = Ze;
        }
        return z._currentRenderer = null, z._currentRenderer2 = null, z;
      }
      var Dr = -1, xn = 0, H = 1, U = 2;
      function oe(O) {
        if (O._status === Dr) {
          var z = O._result, de = z();
          if (de.then(function(Ze) {
            if (O._status === xn || O._status === Dr) {
              var Ue = O;
              Ue._status = H, Ue._result = Ze;
            }
          }, function(Ze) {
            if (O._status === xn || O._status === Dr) {
              var Ue = O;
              Ue._status = U, Ue._result = Ze;
            }
          }), O._status === Dr) {
            var ye = O;
            ye._status = xn, ye._result = de;
          }
        }
        if (O._status === H) {
          var Ie = O._result;
          return Ie === void 0 && R(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Ie), "default" in Ie || R(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Ie), Ie.default;
        } else
          throw O._result;
      }
      function Pe(O) {
        var z = {
          // We use these fields to store the result.
          _status: Dr,
          _result: O
        }, de = {
          $$typeof: v,
          _payload: z,
          _init: oe
        };
        {
          var ye, Ie;
          Object.defineProperties(de, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return ye;
              },
              set: function(Ze) {
                R("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), ye = Ze, Object.defineProperty(de, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return Ie;
              },
              set: function(Ze) {
                R("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Ie = Ze, Object.defineProperty(de, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return de;
      }
      function he(O) {
        O != null && O.$$typeof === m ? R("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof O != "function" ? R("forwardRef requires a render function but was given %s.", O === null ? "null" : typeof O) : O.length !== 0 && O.length !== 2 && R("forwardRef render functions accept exactly two parameters: props and ref. %s", O.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), O != null && (O.defaultProps != null || O.propTypes != null) && R("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var z = {
          $$typeof: d,
          render: O
        };
        {
          var de;
          Object.defineProperty(z, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return de;
            },
            set: function(ye) {
              de = ye, !O.name && !O.displayName && (O.displayName = ye);
            }
          });
        }
        return z;
      }
      var Le;
      Le = Symbol.for("react.module.reference");
      function He(O) {
        return !!(typeof O == "string" || typeof O == "function" || O === s || O === l || ie || O === a || O === h || O === p || ee || O === y || B || X || j || typeof O == "object" && O !== null && (O.$$typeof === v || O.$$typeof === m || O.$$typeof === u || O.$$typeof === c || O.$$typeof === d || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        O.$$typeof === Le || O.getModuleId !== void 0));
      }
      function ht(O, z) {
        He(O) || R("memo: The first argument must be a component. Instead received: %s", O === null ? "null" : typeof O);
        var de = {
          $$typeof: m,
          type: O,
          compare: z === void 0 ? null : z
        };
        {
          var ye;
          Object.defineProperty(de, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ye;
            },
            set: function(Ie) {
              ye = Ie, !O.name && !O.displayName && (O.displayName = Ie);
            }
          });
        }
        return de;
      }
      function Qe() {
        var O = _.current;
        return O === null && R(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), O;
      }
      function Ye(O) {
        var z = Qe();
        if (O._context !== void 0) {
          var de = O._context;
          de.Consumer === O ? R("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : de.Provider === O && R("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return z.useContext(O);
      }
      function Xt(O) {
        var z = Qe();
        return z.useState(O);
      }
      function po(O, z, de) {
        var ye = Qe();
        return ye.useReducer(O, z, de);
      }
      function Z(O) {
        var z = Qe();
        return z.useRef(O);
      }
      function pe(O, z) {
        var de = Qe();
        return de.useEffect(O, z);
      }
      function Te(O, z) {
        var de = Qe();
        return de.useInsertionEffect(O, z);
      }
      function Be(O, z) {
        var de = Qe();
        return de.useLayoutEffect(O, z);
      }
      function Vt(O, z) {
        var de = Qe();
        return de.useCallback(O, z);
      }
      function ct(O, z) {
        var de = Qe();
        return de.useMemo(O, z);
      }
      function Bt(O, z, de) {
        var ye = Qe();
        return ye.useImperativeHandle(O, z, de);
      }
      function Zt(O, z) {
        {
          var de = Qe();
          return de.useDebugValue(O, z);
        }
      }
      function ii() {
        var O = Qe();
        return O.useTransition();
      }
      function on(O) {
        var z = Qe();
        return z.useDeferredValue(O);
      }
      function sn() {
        var O = Qe();
        return O.useId();
      }
      function di(O, z, de) {
        var ye = Qe();
        return ye.useSyncExternalStore(O, z, de);
      }
      var Fn = 0, Sn, hi, $r, Uo, Mr, mo, Pa;
      function hu() {
      }
      hu.__reactDisabledLog = !0;
      function Dd() {
        {
          if (Fn === 0) {
            Sn = console.log, hi = console.info, $r = console.warn, Uo = console.error, Mr = console.group, mo = console.groupCollapsed, Pa = console.groupEnd;
            var O = {
              configurable: !0,
              enumerable: !0,
              value: hu,
              writable: !0
            };
            Object.defineProperties(console, {
              info: O,
              log: O,
              warn: O,
              error: O,
              group: O,
              groupCollapsed: O,
              groupEnd: O
            });
          }
          Fn++;
        }
      }
      function Dt() {
        {
          if (Fn--, Fn === 0) {
            var O = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: me({}, O, {
                value: Sn
              }),
              info: me({}, O, {
                value: hi
              }),
              warn: me({}, O, {
                value: $r
              }),
              error: me({}, O, {
                value: Uo
              }),
              group: me({}, O, {
                value: Mr
              }),
              groupCollapsed: me({}, O, {
                value: mo
              }),
              groupEnd: me({}, O, {
                value: Pa
              })
            });
          }
          Fn < 0 && R("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var St = M.ReactCurrentDispatcher, go;
      function ri(O, z, de) {
        {
          if (go === void 0)
            try {
              throw Error();
            } catch (Ie) {
              var ye = Ie.stack.trim().match(/\n( *(at )?)/);
              go = ye && ye[1] || "";
            }
          return `
` + go + O;
        }
      }
      var Wo = !1, On;
      {
        var ki = typeof WeakMap == "function" ? WeakMap : Map;
        On = new ki();
      }
      function Oi(O, z) {
        if (!O || Wo)
          return "";
        {
          var de = On.get(O);
          if (de !== void 0)
            return de;
        }
        var ye;
        Wo = !0;
        var Ie = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Ze;
        Ze = St.current, St.current = null, Dd();
        try {
          if (z) {
            var Ue = function() {
              throw Error();
            };
            if (Object.defineProperty(Ue.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Ue, []);
              } catch (En) {
                ye = En;
              }
              Reflect.construct(O, [], Ue);
            } else {
              try {
                Ue.call();
              } catch (En) {
                ye = En;
              }
              O.call(Ue.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (En) {
              ye = En;
            }
            O();
          }
        } catch (En) {
          if (En && ye && typeof En.stack == "string") {
            for (var nt = En.stack.split(`
`), _t = ye.stack.split(`
`), Ft = nt.length - 1, Ht = _t.length - 1; Ft >= 1 && Ht >= 0 && nt[Ft] !== _t[Ht]; )
              Ht--;
            for (; Ft >= 1 && Ht >= 0; Ft--, Ht--)
              if (nt[Ft] !== _t[Ht]) {
                if (Ft !== 1 || Ht !== 1)
                  do
                    if (Ft--, Ht--, Ht < 0 || nt[Ft] !== _t[Ht]) {
                      var Ut = `
` + nt[Ft].replace(" at new ", " at ");
                      return O.displayName && Ut.includes("<anonymous>") && (Ut = Ut.replace("<anonymous>", O.displayName)), typeof O == "function" && On.set(O, Ut), Ut;
                    }
                  while (Ft >= 1 && Ht >= 0);
                break;
              }
          }
        } finally {
          Wo = !1, St.current = Ze, Dt(), Error.prepareStackTrace = Ie;
        }
        var Yt = O ? O.displayName || O.name : "", dn = Yt ? ri(Yt) : "";
        return typeof O == "function" && On.set(O, dn), dn;
      }
      function Go(O, z, de) {
        return Oi(O, !1);
      }
      function Vs(O) {
        var z = O.prototype;
        return !!(z && z.isReactComponent);
      }
      function vo(O, z, de) {
        if (O == null)
          return "";
        if (typeof O == "function")
          return Oi(O, Vs(O));
        if (typeof O == "string")
          return ri(O);
        switch (O) {
          case h:
            return ri("Suspense");
          case p:
            return ri("SuspenseList");
        }
        if (typeof O == "object")
          switch (O.$$typeof) {
            case d:
              return Go(O.render);
            case m:
              return vo(O.type, z, de);
            case v: {
              var ye = O, Ie = ye._payload, Ze = ye._init;
              try {
                return vo(Ze(Ie), z, de);
              } catch {
              }
            }
          }
        return "";
      }
      var Xo = {}, ir = M.ReactDebugCurrentFrame;
      function Yo(O) {
        if (O) {
          var z = O._owner, de = vo(O.type, O._source, z ? z.type : null);
          ir.setExtraStackFrame(de);
        } else
          ir.setExtraStackFrame(null);
      }
      function Fs(O, z, de, ye, Ie) {
        {
          var Ze = Function.call.bind(xe);
          for (var Ue in O)
            if (Ze(O, Ue)) {
              var nt = void 0;
              try {
                if (typeof O[Ue] != "function") {
                  var _t = Error((ye || "React class") + ": " + de + " type `" + Ue + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof O[Ue] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw _t.name = "Invariant Violation", _t;
                }
                nt = O[Ue](z, Ue, ye, de, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Ft) {
                nt = Ft;
              }
              nt && !(nt instanceof Error) && (Yo(Ie), R("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ye || "React class", de, Ue, typeof nt), Yo(null)), nt instanceof Error && !(nt.message in Xo) && (Xo[nt.message] = !0, Yo(Ie), R("Failed %s type: %s", de, nt.message), Yo(null));
            }
        }
      }
      function rr(O) {
        if (O) {
          var z = O._owner, de = vo(O.type, O._source, z ? z.type : null);
          F(de);
        } else
          F(null);
      }
      var yo;
      yo = !1;
      function Ko() {
        if (C.current) {
          var O = be(C.current.type);
          if (O)
            return `

Check the render method of \`` + O + "`.";
        }
        return "";
      }
      function fu(O) {
        if (O !== void 0) {
          var z = O.fileName.replace(/^.*[\\\/]/, ""), de = O.lineNumber;
          return `

Check your code at ` + z + ":" + de + ".";
        }
        return "";
      }
      function js(O) {
        return O != null ? fu(O.__source) : "";
      }
      var qo = {};
      function Y1(O) {
        var z = Ko();
        if (!z) {
          var de = typeof O == "string" ? O : O.displayName || O.name;
          de && (z = `

Check the top-level render call using <` + de + ">.");
        }
        return z;
      }
      function Tp(O, z) {
        if (!(!O._store || O._store.validated || O.key != null)) {
          O._store.validated = !0;
          var de = Y1(z);
          if (!qo[de]) {
            qo[de] = !0;
            var ye = "";
            O && O._owner && O._owner !== C.current && (ye = " It was passed a child from " + be(O._owner.type) + "."), rr(O), R('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', de, ye), rr(null);
          }
        }
      }
      function Dp(O, z) {
        if (typeof O == "object") {
          if (D(O))
            for (var de = 0; de < O.length; de++) {
              var ye = O[de];
              rn(ye) && Tp(ye, z);
            }
          else if (rn(O))
            O._store && (O._store.validated = !0);
          else if (O) {
            var Ie = k(O);
            if (typeof Ie == "function" && Ie !== O.entries)
              for (var Ze = Ie.call(O), Ue; !(Ue = Ze.next()).done; )
                rn(Ue.value) && Tp(Ue.value, z);
          }
        }
      }
      function $p(O) {
        {
          var z = O.type;
          if (z == null || typeof z == "string")
            return;
          var de;
          if (typeof z == "function")
            de = z.propTypes;
          else if (typeof z == "object" && (z.$$typeof === d || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          z.$$typeof === m))
            de = z.propTypes;
          else
            return;
          if (de) {
            var ye = be(z);
            Fs(de, O.props, "prop", ye, O);
          } else if (z.PropTypes !== void 0 && !yo) {
            yo = !0;
            var Ie = be(z);
            R("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ie || "Unknown");
          }
          typeof z.getDefaultProps == "function" && !z.getDefaultProps.isReactClassApproved && R("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function K1(O) {
        {
          for (var z = Object.keys(O.props), de = 0; de < z.length; de++) {
            var ye = z[de];
            if (ye !== "children" && ye !== "key") {
              rr(O), R("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ye), rr(null);
              break;
            }
          }
          O.ref !== null && (rr(O), R("Invalid attribute `ref` supplied to `React.Fragment`."), rr(null));
        }
      }
      function Mp(O, z, de) {
        var ye = He(O);
        if (!ye) {
          var Ie = "";
          (O === void 0 || typeof O == "object" && O !== null && Object.keys(O).length === 0) && (Ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ze = js(z);
          Ze ? Ie += Ze : Ie += Ko();
          var Ue;
          O === null ? Ue = "null" : D(O) ? Ue = "array" : O !== void 0 && O.$$typeof === r ? (Ue = "<" + (be(O.type) || "Unknown") + " />", Ie = " Did you accidentally export a JSX literal instead of a component?") : Ue = typeof O, R("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ue, Ie);
        }
        var nt = wn.apply(this, arguments);
        if (nt == null)
          return nt;
        if (ye)
          for (var _t = 2; _t < arguments.length; _t++)
            Dp(arguments[_t], O);
        return O === s ? K1(nt) : $p(nt), nt;
      }
      var Pp = !1;
      function q1(O) {
        var z = Mp.bind(null, O);
        return z.type = O, Pp || (Pp = !0, W("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(z, "type", {
          enumerable: !1,
          get: function() {
            return W("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: O
            }), O;
          }
        }), z;
      }
      function Z1(O, z, de) {
        for (var ye = kn.apply(this, arguments), Ie = 2; Ie < arguments.length; Ie++)
          Dp(arguments[Ie], ye.type);
        return $p(ye), ye;
      }
      function J1(O, z) {
        var de = S.transition;
        S.transition = {};
        var ye = S.transition;
        S.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          O();
        } finally {
          if (S.transition = de, de === null && ye._updatedFibers) {
            var Ie = ye._updatedFibers.size;
            Ie > 10 && W("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), ye._updatedFibers.clear();
          }
        }
      }
      var Ip = !1, pu = null;
      function Q1(O) {
        if (pu === null)
          try {
            var z = ("require" + Math.random()).slice(0, 7), de = i && i[z];
            pu = de.call(i, "timers").setImmediate;
          } catch {
            pu = function(Ie) {
              Ip === !1 && (Ip = !0, typeof MessageChannel > "u" && R("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var Ze = new MessageChannel();
              Ze.port1.onmessage = Ie, Ze.port2.postMessage(void 0);
            };
          }
        return pu(O);
      }
      var Rs = 0, Lp = !1;
      function Ap(O) {
        {
          var z = Rs;
          Rs++, b.current === null && (b.current = []);
          var de = b.isBatchingLegacy, ye;
          try {
            if (b.isBatchingLegacy = !0, ye = O(), !de && b.didScheduleLegacyUpdate) {
              var Ie = b.current;
              Ie !== null && (b.didScheduleLegacyUpdate = !1, Pd(Ie));
            }
          } catch (Yt) {
            throw mu(z), Yt;
          } finally {
            b.isBatchingLegacy = de;
          }
          if (ye !== null && typeof ye == "object" && typeof ye.then == "function") {
            var Ze = ye, Ue = !1, nt = {
              then: function(Yt, dn) {
                Ue = !0, Ze.then(function(En) {
                  mu(z), Rs === 0 ? $d(En, Yt, dn) : Yt(En);
                }, function(En) {
                  mu(z), dn(En);
                });
              }
            };
            return !Lp && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Ue || (Lp = !0, R("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), nt;
          } else {
            var _t = ye;
            if (mu(z), Rs === 0) {
              var Ft = b.current;
              Ft !== null && (Pd(Ft), b.current = null);
              var Ht = {
                then: function(Yt, dn) {
                  b.current === null ? (b.current = [], $d(_t, Yt, dn)) : Yt(_t);
                }
              };
              return Ht;
            } else {
              var Ut = {
                then: function(Yt, dn) {
                  Yt(_t);
                }
              };
              return Ut;
            }
          }
        }
      }
      function mu(O) {
        O !== Rs - 1 && R("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Rs = O;
      }
      function $d(O, z, de) {
        {
          var ye = b.current;
          if (ye !== null)
            try {
              Pd(ye), Q1(function() {
                ye.length === 0 ? (b.current = null, z(O)) : $d(O, z, de);
              });
            } catch (Ie) {
              de(Ie);
            }
          else
            z(O);
        }
      }
      var Md = !1;
      function Pd(O) {
        if (!Md) {
          Md = !0;
          var z = 0;
          try {
            for (; z < O.length; z++) {
              var de = O[z];
              do
                de = de(!0);
              while (de !== null);
            }
            O.length = 0;
          } catch (ye) {
            throw O = O.slice(z + 1), ye;
          } finally {
            Md = !1;
          }
        }
      }
      var ew = Mp, tw = Z1, nw = q1, iw = {
        map: qt,
        forEach: As,
        count: Ma,
        toArray: Tr,
        only: fo
      };
      e.Children = iw, e.Component = fe, e.Fragment = s, e.Profiler = l, e.PureComponent = le, e.StrictMode = a, e.Suspense = h, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = M, e.act = Ap, e.cloneElement = tw, e.createContext = nr, e.createElement = ew, e.createFactory = nw, e.createRef = E, e.forwardRef = he, e.isValidElement = rn, e.lazy = Pe, e.memo = ht, e.startTransition = J1, e.unstable_act = Ap, e.useCallback = Vt, e.useContext = Ye, e.useDebugValue = Zt, e.useDeferredValue = on, e.useEffect = pe, e.useId = sn, e.useImperativeHandle = Bt, e.useInsertionEffect = Te, e.useLayoutEffect = Be, e.useMemo = ct, e.useReducer = po, e.useRef = Z, e.useState = Xt, e.useSyncExternalStore = di, e.useTransition = ii, e.version = n, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Ja, Ja.exports)), Ja.exports;
}
process.env.NODE_ENV === "production" ? Uh.exports = l2() : Uh.exports = u2();
var yt = Uh.exports;
const Fr = /* @__PURE__ */ a2(yt);
function dl() {
  return dl = Object.assign ? Object.assign.bind() : function(i) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (i[r] = n[r]);
    }
    return i;
  }, dl.apply(null, arguments);
}
var Ao = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function lu(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var cg, dg = {
  exports: {}
};
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
var Zd, hg, fg, c2 = (cg || (cg = 1, Zd = dg, function() {
  var i = {}.hasOwnProperty;
  function e() {
    for (var n = [], r = 0; r < arguments.length; r++) {
      var o = arguments[r];
      if (o) {
        var s = typeof o;
        if (s === "string" || s === "number") n.push(o);
        else if (Array.isArray(o)) {
          if (o.length) {
            var a = e.apply(null, o);
            a && n.push(a);
          }
        } else if (s === "object") if (o.toString === Object.prototype.toString) for (var l in o) i.call(o, l) && o[l] && n.push(l);
        else n.push(o.toString());
      }
    }
    return n.join(" ");
  }
  Zd.exports ? (e.default = e, Zd.exports = e) : window.classNames = e;
}()), dg.exports), Wh = lu(c2), pg, Mi = lu(function() {
  if (fg) return hg;
  fg = 1;
  var i = /^\s+|\s+$/g, e = /^[-+]0x[0-9a-f]+$/i, n = /^0b[01]+$/i, r = /^0o[0-7]+$/i, o = parseInt, s = Object.prototype.toString;
  function a(u) {
    var c = typeof u;
    return !!u && (c == "object" || c == "function");
  }
  function l(u) {
    if (typeof u == "number") return u;
    if (function(h) {
      return typeof h == "symbol" || /* @__PURE__ */ function(p) {
        return !!p && typeof p == "object";
      }(h) && s.call(h) == "[object Symbol]";
    }(u)) return NaN;
    if (a(u)) {
      var c = typeof u.valueOf == "function" ? u.valueOf() : u;
      u = a(c) ? c + "" : c;
    }
    if (typeof u != "string") return u === 0 ? u : +u;
    u = u.replace(i, "");
    var d = n.test(u);
    return d || r.test(u) ? o(u.slice(2), d ? 2 : 8) : e.test(u) ? NaN : +u;
  }
  return hg = function(u, c, d) {
    return d === void 0 && (d = c, c = void 0), d !== void 0 && (d = (d = l(d)) == d ? d : 0), c !== void 0 && (c = (c = l(c)) == c ? c : 0), function(h, p, m) {
      return h == h && (m !== void 0 && (h = h <= m ? h : m), p !== void 0 && (h = h >= p ? h : p)), h;
    }(l(u), c, d);
  };
}()), Jd = {
  exports: {}
}, d2 = (pg || (pg = 1, function(i, e) {
  var n = "__lodash_hash_undefined__", r = 9007199254740991, o = "[object Arguments]", s = "[object Array]", a = "[object Boolean]", l = "[object Date]", u = "[object Error]", c = "[object Function]", d = "[object Map]", h = "[object Number]", p = "[object Object]", m = "[object Promise]", v = "[object RegExp]", y = "[object Set]", w = "[object String]", g = "[object Symbol]", k = "[object WeakMap]", _ = "[object ArrayBuffer]", S = "[object DataView]", b = /^\[object .+?Constructor\]$/, C = /^(?:0|[1-9]\d*)$/, x = {};
  x["[object Float32Array]"] = x["[object Float64Array]"] = x["[object Int8Array]"] = x["[object Int16Array]"] = x["[object Int32Array]"] = x["[object Uint8Array]"] = x["[object Uint8ClampedArray]"] = x["[object Uint16Array]"] = x["[object Uint32Array]"] = !0, x[o] = x[s] = x[_] = x[a] = x[S] = x[l] = x[u] = x[c] = x[d] = x[h] = x[p] = x[v] = x[y] = x[w] = x[k] = !1;
  var I = typeof Ao == "object" && Ao && Ao.Object === Object && Ao, F = typeof self == "object" && self && self.Object === Object && self, B = I || F || Function("return this")(), X = e && !e.nodeType && e, j = X && i && !i.nodeType && i, ee = j && j.exports === X, ie = ee && I.process, M = function() {
    try {
      return ie && ie.binding && ie.binding("util");
    } catch {
    }
  }(), W = M && M.isTypedArray;
  function R(Z, pe) {
    for (var Te = -1, Be = Z == null ? 0 : Z.length; ++Te < Be; ) if (pe(Z[Te], Te, Z)) return !0;
    return !1;
  }
  function V(Z) {
    var pe = -1, Te = Array(Z.size);
    return Z.forEach(function(Be, Vt) {
      Te[++pe] = [Vt, Be];
    }), Te;
  }
  function ae(Z) {
    var pe = -1, Te = Array(Z.size);
    return Z.forEach(function(Be) {
      Te[++pe] = Be;
    }), Te;
  }
  var $e, N, me, we = Array.prototype, fe = Function.prototype, te = Object.prototype, Me = B["__core-js_shared__"], Re = fe.toString, Ce = te.hasOwnProperty, le = ($e = /[^.]+$/.exec(Me && Me.keys && Me.keys.IE_PROTO || "")) ? "Symbol(src)_1." + $e : "", T = te.toString, E = RegExp("^" + Re.call(Ce).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), L = ee ? B.Buffer : void 0, D = B.Symbol, P = B.Uint8Array, G = te.propertyIsEnumerable, ne = we.splice, se = D ? D.toStringTag : void 0, ge = Object.getOwnPropertySymbols, Se = L ? L.isBuffer : void 0, be = (N = Object.keys, me = Object, function(Z) {
    return N(me(Z));
  }), xe = nr(B, "DataView"), q = nr(B, "Map"), J = nr(B, "Promise"), ue = nr(B, "Set"), Ae = nr(B, "WeakMap"), je = nr(Object, "create"), Ge = U(xe), ft = U(q), at = U(J), nn = U(ue), Gt = U(Ae), wn = D ? D.prototype : void 0, _n = wn ? wn.valueOf : void 0;
  function kn(Z) {
    var pe = -1, Te = Z == null ? 0 : Z.length;
    for (this.clear(); ++pe < Te; ) {
      var Be = Z[pe];
      this.set(Be[0], Be[1]);
    }
  }
  function rn(Z) {
    var pe = -1, Te = Z == null ? 0 : Z.length;
    for (this.clear(); ++pe < Te; ) {
      var Be = Z[pe];
      this.set(Be[0], Be[1]);
    }
  }
  function It(Z) {
    var pe = -1, Te = Z == null ? 0 : Z.length;
    for (this.clear(); ++pe < Te; ) {
      var Be = Z[pe];
      this.set(Be[0], Be[1]);
    }
  }
  function mn(Z) {
    var pe = -1, Te = Z == null ? 0 : Z.length;
    for (this.__data__ = new It(); ++pe < Te; ) this.add(Z[pe]);
  }
  function Vn(Z) {
    var pe = this.__data__ = new rn(Z);
    this.size = pe.size;
  }
  function Or(Z, pe) {
    var Te = he(Z), Be = !Te && Pe(Z), Vt = !Te && !Be && Le(Z), ct = !Te && !Be && !Vt && Xt(Z), Bt = Te || Be || Vt || ct, Zt = Bt ? function(sn, di) {
      for (var Fn = -1, Sn = Array(sn); ++Fn < sn; ) Sn[Fn] = di(Fn);
      return Sn;
    }(Z.length, String) : [], ii = Zt.length;
    for (var on in Z) !Ce.call(Z, on) || Bt && (on == "length" || Vt && (on == "offset" || on == "parent") || ct && (on == "buffer" || on == "byteLength" || on == "byteOffset") || H(on, ii)) || Zt.push(on);
    return Zt;
  }
  function co(Z, pe) {
    for (var Te = Z.length; Te--; ) if (oe(Z[Te][0], pe)) return Te;
    return -1;
  }
  function tr(Z) {
    return Z == null ? Z === void 0 ? "[object Undefined]" : "[object Null]" : se && se in Object(Z) ? function(pe) {
      var Te = Ce.call(pe, se), Be = pe[se];
      try {
        pe[se] = void 0;
        var Vt = !0;
      } catch {
      }
      var ct = T.call(pe);
      return Vt && (Te ? pe[se] = Be : delete pe[se]), ct;
    }(Z) : function(pe) {
      return T.call(pe);
    }(Z);
  }
  function ho(Z) {
    return Ye(Z) && tr(Z) == o;
  }
  function Er(Z, pe, Te, Be, Vt) {
    return Z === pe || (Z == null || pe == null || !Ye(Z) && !Ye(pe) ? Z != Z && pe != pe : function(ct, Bt, Zt, ii, on, sn) {
      var di = he(ct), Fn = he(Bt), Sn = di ? s : xn(ct), hi = Fn ? s : xn(Bt), $r = (Sn = Sn == o ? p : Sn) == p, Uo = (hi = hi == o ? p : hi) == p, Mr = Sn == hi;
      if (Mr && Le(ct)) {
        if (!Le(Bt)) return !1;
        di = !0, $r = !1;
      }
      if (Mr && !$r) return sn || (sn = new Vn()), di || Xt(ct) ? As(ct, Bt, Zt, ii, on, sn) : function(Dt, St, go, ri, Wo, On, ki) {
        switch (go) {
          case S:
            if (Dt.byteLength != St.byteLength || Dt.byteOffset != St.byteOffset) return !1;
            Dt = Dt.buffer, St = St.buffer;
          case _:
            return !(Dt.byteLength != St.byteLength || !On(new P(Dt), new P(St)));
          case a:
          case l:
          case h:
            return oe(+Dt, +St);
          case u:
            return Dt.name == St.name && Dt.message == St.message;
          case v:
          case w:
            return Dt == St + "";
          case d:
            var Oi = V;
          case y:
            var Go = 1 & ri;
            if (Oi || (Oi = ae), Dt.size != St.size && !Go) return !1;
            var Vs = ki.get(Dt);
            if (Vs) return Vs == St;
            ri |= 2, ki.set(Dt, St);
            var vo = As(Oi(Dt), Oi(St), ri, Wo, On, ki);
            return ki.delete(Dt), vo;
          case g:
            if (_n) return _n.call(Dt) == _n.call(St);
        }
        return !1;
      }(ct, Bt, Sn, Zt, ii, on, sn);
      if (!(1 & Zt)) {
        var mo = $r && Ce.call(ct, "__wrapped__"), Pa = Uo && Ce.call(Bt, "__wrapped__");
        if (mo || Pa) {
          var hu = mo ? ct.value() : ct, Dd = Pa ? Bt.value() : Bt;
          return sn || (sn = new Vn()), on(hu, Dd, Zt, ii, sn);
        }
      }
      return !!Mr && (sn || (sn = new Vn()), function(Dt, St, go, ri, Wo, On) {
        var ki = 1 & go, Oi = Tr(Dt), Go = Oi.length, Vs = Tr(St), vo = Vs.length;
        if (Go != vo && !ki) return !1;
        for (var Xo = Go; Xo--; ) {
          var ir = Oi[Xo];
          if (!(ki ? ir in St : Ce.call(St, ir))) return !1;
        }
        var Yo = On.get(Dt);
        if (Yo && On.get(St)) return Yo == St;
        var Fs = !0;
        On.set(Dt, St), On.set(St, Dt);
        for (var rr = ki; ++Xo < Go; ) {
          var yo = Dt[ir = Oi[Xo]], Ko = St[ir];
          if (ri) var fu = ki ? ri(Ko, yo, ir, St, Dt, On) : ri(yo, Ko, ir, Dt, St, On);
          if (!(fu === void 0 ? yo === Ko || Wo(yo, Ko, go, ri, On) : fu)) {
            Fs = !1;
            break;
          }
          rr || (rr = ir == "constructor");
        }
        if (Fs && !rr) {
          var js = Dt.constructor, qo = St.constructor;
          js == qo || !("constructor" in Dt) || !("constructor" in St) || typeof js == "function" && js instanceof js && typeof qo == "function" && qo instanceof qo || (Fs = !1);
        }
        return On.delete(Dt), On.delete(St), Fs;
      }(ct, Bt, Zt, ii, on, sn));
    }(Z, pe, Te, Be, Er, Vt));
  }
  function qt(Z) {
    return !(!Qe(Z) || function(pe) {
      return !!le && le in pe;
    }(Z)) && (He(Z) ? E : b).test(U(Z));
  }
  function Ma(Z) {
    if (Te = (pe = Z) && pe.constructor, Be = typeof Te == "function" && Te.prototype || te, pe !== Be) return be(Z);
    var pe, Te, Be, Vt = [];
    for (var ct in Object(Z)) Ce.call(Z, ct) && ct != "constructor" && Vt.push(ct);
    return Vt;
  }
  function As(Z, pe, Te, Be, Vt, ct) {
    var Bt = 1 & Te, Zt = Z.length, ii = pe.length;
    if (Zt != ii && !(Bt && ii > Zt)) return !1;
    var on = ct.get(Z);
    if (on && ct.get(pe)) return on == pe;
    var sn = -1, di = !0, Fn = 2 & Te ? new mn() : void 0;
    for (ct.set(Z, pe), ct.set(pe, Z); ++sn < Zt; ) {
      var Sn = Z[sn], hi = pe[sn];
      if (Be) var $r = Bt ? Be(hi, Sn, sn, pe, Z, ct) : Be(Sn, hi, sn, Z, pe, ct);
      if ($r !== void 0) {
        if ($r) continue;
        di = !1;
        break;
      }
      if (Fn) {
        if (!R(pe, function(Uo, Mr) {
          if (mo = Mr, !Fn.has(mo) && (Sn === Uo || Vt(Sn, Uo, Te, Be, ct))) return Fn.push(Mr);
          var mo;
        })) {
          di = !1;
          break;
        }
      } else if (Sn !== hi && !Vt(Sn, hi, Te, Be, ct)) {
        di = !1;
        break;
      }
    }
    return ct.delete(Z), ct.delete(pe), di;
  }
  function Tr(Z) {
    return function(pe, Te, Be) {
      var Vt = Te(pe);
      return he(pe) ? Vt : function(ct, Bt) {
        for (var Zt = -1, ii = Bt.length, on = ct.length; ++Zt < ii; ) ct[on + Zt] = Bt[Zt];
        return ct;
      }(Vt, Be(pe));
    }(Z, po, Dr);
  }
  function fo(Z, pe) {
    var Te, Be, Vt = Z.__data__;
    return ((Be = typeof (Te = pe)) == "string" || Be == "number" || Be == "symbol" || Be == "boolean" ? Te !== "__proto__" : Te === null) ? Vt[typeof pe == "string" ? "string" : "hash"] : Vt.map;
  }
  function nr(Z, pe) {
    var Te = function(Be, Vt) {
      return Be == null ? void 0 : Be[Vt];
    }(Z, pe);
    return qt(Te) ? Te : void 0;
  }
  kn.prototype.clear = function() {
    this.__data__ = je ? je(null) : {}, this.size = 0;
  }, kn.prototype.delete = function(Z) {
    var pe = this.has(Z) && delete this.__data__[Z];
    return this.size -= pe ? 1 : 0, pe;
  }, kn.prototype.get = function(Z) {
    var pe = this.__data__;
    if (je) {
      var Te = pe[Z];
      return Te === n ? void 0 : Te;
    }
    return Ce.call(pe, Z) ? pe[Z] : void 0;
  }, kn.prototype.has = function(Z) {
    var pe = this.__data__;
    return je ? pe[Z] !== void 0 : Ce.call(pe, Z);
  }, kn.prototype.set = function(Z, pe) {
    var Te = this.__data__;
    return this.size += this.has(Z) ? 0 : 1, Te[Z] = je && pe === void 0 ? n : pe, this;
  }, rn.prototype.clear = function() {
    this.__data__ = [], this.size = 0;
  }, rn.prototype.delete = function(Z) {
    var pe = this.__data__, Te = co(pe, Z);
    return !(Te < 0 || (Te == pe.length - 1 ? pe.pop() : ne.call(pe, Te, 1), --this.size, 0));
  }, rn.prototype.get = function(Z) {
    var pe = this.__data__, Te = co(pe, Z);
    return Te < 0 ? void 0 : pe[Te][1];
  }, rn.prototype.has = function(Z) {
    return co(this.__data__, Z) > -1;
  }, rn.prototype.set = function(Z, pe) {
    var Te = this.__data__, Be = co(Te, Z);
    return Be < 0 ? (++this.size, Te.push([Z, pe])) : Te[Be][1] = pe, this;
  }, It.prototype.clear = function() {
    this.size = 0, this.__data__ = {
      hash: new kn(),
      map: new (q || rn)(),
      string: new kn()
    };
  }, It.prototype.delete = function(Z) {
    var pe = fo(this, Z).delete(Z);
    return this.size -= pe ? 1 : 0, pe;
  }, It.prototype.get = function(Z) {
    return fo(this, Z).get(Z);
  }, It.prototype.has = function(Z) {
    return fo(this, Z).has(Z);
  }, It.prototype.set = function(Z, pe) {
    var Te = fo(this, Z), Be = Te.size;
    return Te.set(Z, pe), this.size += Te.size == Be ? 0 : 1, this;
  }, mn.prototype.add = mn.prototype.push = function(Z) {
    return this.__data__.set(Z, n), this;
  }, mn.prototype.has = function(Z) {
    return this.__data__.has(Z);
  }, Vn.prototype.clear = function() {
    this.__data__ = new rn(), this.size = 0;
  }, Vn.prototype.delete = function(Z) {
    var pe = this.__data__, Te = pe.delete(Z);
    return this.size = pe.size, Te;
  }, Vn.prototype.get = function(Z) {
    return this.__data__.get(Z);
  }, Vn.prototype.has = function(Z) {
    return this.__data__.has(Z);
  }, Vn.prototype.set = function(Z, pe) {
    var Te = this.__data__;
    if (Te instanceof rn) {
      var Be = Te.__data__;
      if (!q || Be.length < 199) return Be.push([Z, pe]), this.size = ++Te.size, this;
      Te = this.__data__ = new It(Be);
    }
    return Te.set(Z, pe), this.size = Te.size, this;
  };
  var Dr = ge ? function(Z) {
    return Z == null ? [] : (Z = Object(Z), function(pe, Te) {
      for (var Be = -1, Vt = pe == null ? 0 : pe.length, ct = 0, Bt = []; ++Be < Vt; ) {
        var Zt = pe[Be];
        Te(Zt, Be, pe) && (Bt[ct++] = Zt);
      }
      return Bt;
    }(ge(Z), function(pe) {
      return G.call(Z, pe);
    }));
  } : function() {
    return [];
  }, xn = tr;
  function H(Z, pe) {
    return !!(pe = pe ?? r) && (typeof Z == "number" || C.test(Z)) && Z > -1 && Z % 1 == 0 && Z < pe;
  }
  function U(Z) {
    if (Z != null) {
      try {
        return Re.call(Z);
      } catch {
      }
      try {
        return Z + "";
      } catch {
      }
    }
    return "";
  }
  function oe(Z, pe) {
    return Z === pe || Z != Z && pe != pe;
  }
  (xe && xn(new xe(new ArrayBuffer(1))) != S || q && xn(new q()) != d || J && xn(J.resolve()) != m || ue && xn(new ue()) != y || Ae && xn(new Ae()) != k) && (xn = function(Z) {
    var pe = tr(Z), Te = pe == p ? Z.constructor : void 0, Be = Te ? U(Te) : "";
    if (Be) switch (Be) {
      case Ge:
        return S;
      case ft:
        return d;
      case at:
        return m;
      case nn:
        return y;
      case Gt:
        return k;
    }
    return pe;
  });
  var Pe = ho(/* @__PURE__ */ function() {
    return arguments;
  }()) ? ho : function(Z) {
    return Ye(Z) && Ce.call(Z, "callee") && !G.call(Z, "callee");
  }, he = Array.isArray, Le = Se || function() {
    return !1;
  };
  function He(Z) {
    if (!Qe(Z)) return !1;
    var pe = tr(Z);
    return pe == c || pe == "[object GeneratorFunction]" || pe == "[object AsyncFunction]" || pe == "[object Proxy]";
  }
  function ht(Z) {
    return typeof Z == "number" && Z > -1 && Z % 1 == 0 && Z <= r;
  }
  function Qe(Z) {
    var pe = typeof Z;
    return Z != null && (pe == "object" || pe == "function");
  }
  function Ye(Z) {
    return Z != null && typeof Z == "object";
  }
  var Xt = W ? /* @__PURE__ */ function(Z) {
    return function(pe) {
      return Z(pe);
    };
  }(W) : function(Z) {
    return Ye(Z) && ht(Z.length) && !!x[tr(Z)];
  };
  function po(Z) {
    return (pe = Z) != null && ht(pe.length) && !He(pe) ? Or(Z) : Ma(Z);
    var pe;
  }
  i.exports = function(Z, pe) {
    return Er(Z, pe);
  };
}(Jd, Jd.exports)), Jd.exports), h2 = lu(d2);
function mg(i, e, n) {
  return i[e] ? i[e][0] ? i[e][0][n] : i[e][n] : e === "contentBoxSize" ? i.contentRect[n === "inlineSize" ? "width" : "height"] : void 0;
}
function f2(i) {
  i === void 0 && (i = {});
  var e = i.onResize, n = yt.useRef(void 0);
  n.current = e;
  var r = i.round || Math.round, o = yt.useRef(), s = yt.useState({
    width: void 0,
    height: void 0
  }), a = s[0], l = s[1], u = yt.useRef(!1);
  yt.useEffect(function() {
    return u.current = !1, function() {
      u.current = !0;
    };
  }, []);
  var c = yt.useRef({
    width: void 0,
    height: void 0
  }), d = function(h, p) {
    var m = yt.useRef(null), v = yt.useRef(null);
    v.current = p;
    var y = yt.useRef(null);
    yt.useEffect(function() {
      w();
    });
    var w = yt.useCallback(function() {
      var g = y.current, k = v.current, _ = g || (k ? k instanceof Element ? k : k.current : null);
      m.current && m.current.element === _ && m.current.subscriber === h || (m.current && m.current.cleanup && m.current.cleanup(), m.current = {
        element: _,
        subscriber: h,
        cleanup: _ ? h(_) : void 0
      });
    }, [h]);
    return yt.useEffect(function() {
      return function() {
        m.current && m.current.cleanup && (m.current.cleanup(), m.current = null);
      };
    }, []), yt.useCallback(function(g) {
      y.current = g, w();
    }, [w]);
  }(yt.useCallback(function(h) {
    return o.current && o.current.box === i.box && o.current.round === r || (o.current = {
      box: i.box,
      round: r,
      instance: new ResizeObserver(function(p) {
        var m = p[0], v = i.box === "border-box" ? "borderBoxSize" : i.box === "device-pixel-content-box" ? "devicePixelContentBoxSize" : "contentBoxSize", y = mg(m, v, "inlineSize"), w = mg(m, v, "blockSize"), g = y ? r(y) : void 0, k = w ? r(w) : void 0;
        if (c.current.width !== g || c.current.height !== k) {
          var _ = {
            width: g,
            height: k
          };
          c.current.width = g, c.current.height = k, n.current ? n.current(_) : u.current || l(_);
        }
      })
    }), o.current.instance.observe(h, {
      box: i.box
    }), function() {
      o.current && o.current.instance.unobserve(h);
    };
  }, [i.box, r]), i.ref);
  return yt.useMemo(function() {
    return {
      ref: d,
      width: a.width,
      height: a.height
    };
  }, [d, a.width, a.height]);
}
var p2 = "allotment-module_splitView__L-yRc", m2 = "allotment-module_sashContainer__fzwJF", g2 = "allotment-module_splitViewContainer__rQnVa", db = "allotment-module_splitViewView__MGZ6O", v2 = "allotment-module_vertical__WSwwa", y2 = "allotment-module_horizontal__7doS8", b2 = "allotment-module_separatorBorder__x-rDS";
let Fa, hb = !1, fb = !1;
typeof navigator == "object" && (Fa = navigator.userAgent, fb = Fa.indexOf("Macintosh") >= 0, hb = (Fa.indexOf("Macintosh") >= 0 || Fa.indexOf("iPad") >= 0 || Fa.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
const pb = hb, w2 = fb, gg = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? yt.useLayoutEffect : yt.useEffect;
let _2 = class {
  constructor() {
    this._size = void 0;
  }
  getSize() {
    return this._size;
  }
  setSize(e) {
    this._size = e;
  }
};
function Tu(i, e) {
  const n = i.length, r = n - e.length;
  return r >= 0 && i.slice(r, n) === e;
}
var vg, yg = {
  exports: {}
}, bg, wg, x2 = (vg || (vg = 1, function(i) {
  var e = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  function o(u, c, d) {
    this.fn = u, this.context = c, this.once = d || !1;
  }
  function s(u, c, d, h, p) {
    if (typeof d != "function") throw new TypeError("The listener must be a function");
    var m = new o(d, h || u, p), v = n ? n + c : c;
    return u._events[v] ? u._events[v].fn ? u._events[v] = [u._events[v], m] : u._events[v].push(m) : (u._events[v] = m, u._eventsCount++), u;
  }
  function a(u, c) {
    --u._eventsCount == 0 ? u._events = new r() : delete u._events[c];
  }
  function l() {
    this._events = new r(), this._eventsCount = 0;
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1)), l.prototype.eventNames = function() {
    var u, c, d = [];
    if (this._eventsCount === 0) return d;
    for (c in u = this._events) e.call(u, c) && d.push(n ? c.slice(1) : c);
    return Object.getOwnPropertySymbols ? d.concat(Object.getOwnPropertySymbols(u)) : d;
  }, l.prototype.listeners = function(u) {
    var c = n ? n + u : u, d = this._events[c];
    if (!d) return [];
    if (d.fn) return [d.fn];
    for (var h = 0, p = d.length, m = new Array(p); h < p; h++) m[h] = d[h].fn;
    return m;
  }, l.prototype.listenerCount = function(u) {
    var c = n ? n + u : u, d = this._events[c];
    return d ? d.fn ? 1 : d.length : 0;
  }, l.prototype.emit = function(u, c, d, h, p, m) {
    var v = n ? n + u : u;
    if (!this._events[v]) return !1;
    var y, w, g = this._events[v], k = arguments.length;
    if (g.fn) {
      switch (g.once && this.removeListener(u, g.fn, void 0, !0), k) {
        case 1:
          return g.fn.call(g.context), !0;
        case 2:
          return g.fn.call(g.context, c), !0;
        case 3:
          return g.fn.call(g.context, c, d), !0;
        case 4:
          return g.fn.call(g.context, c, d, h), !0;
        case 5:
          return g.fn.call(g.context, c, d, h, p), !0;
        case 6:
          return g.fn.call(g.context, c, d, h, p, m), !0;
      }
      for (w = 1, y = new Array(k - 1); w < k; w++) y[w - 1] = arguments[w];
      g.fn.apply(g.context, y);
    } else {
      var _, S = g.length;
      for (w = 0; w < S; w++) switch (g[w].once && this.removeListener(u, g[w].fn, void 0, !0), k) {
        case 1:
          g[w].fn.call(g[w].context);
          break;
        case 2:
          g[w].fn.call(g[w].context, c);
          break;
        case 3:
          g[w].fn.call(g[w].context, c, d);
          break;
        case 4:
          g[w].fn.call(g[w].context, c, d, h);
          break;
        default:
          if (!y) for (_ = 1, y = new Array(k - 1); _ < k; _++) y[_ - 1] = arguments[_];
          g[w].fn.apply(g[w].context, y);
      }
    }
    return !0;
  }, l.prototype.on = function(u, c, d) {
    return s(this, u, c, d, !1);
  }, l.prototype.once = function(u, c, d) {
    return s(this, u, c, d, !0);
  }, l.prototype.removeListener = function(u, c, d, h) {
    var p = n ? n + u : u;
    if (!this._events[p]) return this;
    if (!c) return a(this, p), this;
    var m = this._events[p];
    if (m.fn) m.fn !== c || h && !m.once || d && m.context !== d || a(this, p);
    else {
      for (var v = 0, y = [], w = m.length; v < w; v++) (m[v].fn !== c || h && !m[v].once || d && m[v].context !== d) && y.push(m[v]);
      y.length ? this._events[p] = y.length === 1 ? y[0] : y : a(this, p);
    }
    return this;
  }, l.prototype.removeAllListeners = function(u) {
    var c;
    return u ? (c = n ? n + u : u, this._events[c] && a(this, c)) : (this._events = new r(), this._eventsCount = 0), this;
  }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = n, l.EventEmitter = l, i.exports = l;
}(yg)), yg.exports), Qf = lu(x2);
function _g(i, e) {
  const n = i.indexOf(e);
  n > -1 && (i.splice(n, 1), i.unshift(e));
}
function Qd(i, e) {
  const n = i.indexOf(e);
  n > -1 && (i.splice(n, 1), i.push(e));
}
function mi(i, e, n = 1) {
  const r = Math.max(0, Math.ceil((e - i) / n)), o = new Array(r);
  let s = -1;
  for (; ++s < r; ) o[s] = i + s * n;
  return o;
}
var S2 = lu(function() {
  if (wg) return bg;
  wg = 1;
  var i = /^\s+|\s+$/g, e = /^[-+]0x[0-9a-f]+$/i, n = /^0b[01]+$/i, r = /^0o[0-7]+$/i, o = parseInt, s = typeof Ao == "object" && Ao && Ao.Object === Object && Ao, a = typeof self == "object" && self && self.Object === Object && self, l = s || a || Function("return this")(), u = Object.prototype.toString, c = Math.max, d = Math.min, h = function() {
    return l.Date.now();
  };
  function p(v) {
    var y = typeof v;
    return !!v && (y == "object" || y == "function");
  }
  function m(v) {
    if (typeof v == "number") return v;
    if (function(g) {
      return typeof g == "symbol" || /* @__PURE__ */ function(k) {
        return !!k && typeof k == "object";
      }(g) && u.call(g) == "[object Symbol]";
    }(v)) return NaN;
    if (p(v)) {
      var y = typeof v.valueOf == "function" ? v.valueOf() : v;
      v = p(y) ? y + "" : y;
    }
    if (typeof v != "string") return v === 0 ? v : +v;
    v = v.replace(i, "");
    var w = n.test(v);
    return w || r.test(v) ? o(v.slice(2), w ? 2 : 8) : e.test(v) ? NaN : +v;
  }
  return bg = function(v, y, w) {
    var g, k, _, S, b, C, x = 0, I = !1, F = !1, B = !0;
    if (typeof v != "function") throw new TypeError("Expected a function");
    function X(W) {
      var R = g, V = k;
      return g = k = void 0, x = W, S = v.apply(V, R);
    }
    function j(W) {
      var R = W - C;
      return C === void 0 || R >= y || R < 0 || F && W - x >= _;
    }
    function ee() {
      var W = h();
      if (j(W)) return ie(W);
      b = setTimeout(ee, function(R) {
        var V = y - (R - C);
        return F ? d(V, _ - (R - x)) : V;
      }(W));
    }
    function ie(W) {
      return b = void 0, B && g ? X(W) : (g = k = void 0, S);
    }
    function M() {
      var W = h(), R = j(W);
      if (g = arguments, k = this, C = W, R) {
        if (b === void 0) return function(V) {
          return x = V, b = setTimeout(ee, y), I ? X(V) : S;
        }(C);
        if (F) return b = setTimeout(ee, y), X(C);
      }
      return b === void 0 && (b = setTimeout(ee, y)), S;
    }
    return y = m(y) || 0, p(w) && (I = !!w.leading, _ = (F = "maxWait" in w) ? c(m(w.maxWait) || 0, y) : _, B = "trailing" in w ? !!w.trailing : B), M.cancel = function() {
      b !== void 0 && clearTimeout(b), x = 0, g = C = k = b = void 0;
    }, M.flush = function() {
      return b === void 0 ? S : ie(h());
    }, M;
  };
}()), C2 = "sash-module_sash__K-9lB", k2 = "sash-module_disabled__Hm-wx", O2 = "sash-module_mac__Jf6OJ", xg = "sash-module_vertical__pB-rs", E2 = "sash-module_minimum__-UKxp", T2 = "sash-module_maximum__TCWxD", Sg = "sash-module_horizontal__kFbiw", eh = "sash-module_hover__80W6I", th = "sash-module_active__bJspD";
let _i = function(i) {
  return i.Vertical = "VERTICAL", i.Horizontal = "HORIZONTAL", i;
}({}), si = function(i) {
  return i.Disabled = "DISABLED", i.Minimum = "MINIMUM", i.Maximum = "MAXIMUM", i.Enabled = "ENABLED", i;
}({}), mb = pb ? 20 : 8;
const gb = new Qf();
let Cg = class extends Qf {
  get state() {
    return this._state;
  }
  set state(e) {
    this._state !== e && (this.el.classList.toggle(k2, e === si.Disabled), this.el.classList.toggle("sash-disabled", e === si.Disabled), this.el.classList.toggle(E2, e === si.Minimum), this.el.classList.toggle("sash-minimum", e === si.Minimum), this.el.classList.toggle(T2, e === si.Maximum), this.el.classList.toggle("sash-maximum", e === si.Maximum), this._state = e, this.emit("enablementChange", e));
  }
  constructor(e, n, r) {
    var o;
    super(), this.el = void 0, this.layoutProvider = void 0, this.orientation = void 0, this.size = void 0, this.hoverDelay = 300, this.hoverDelayer = S2((s) => s.classList.add("sash-hover", eh), this.hoverDelay), this._state = si.Enabled, this.onPointerStart = (s) => {
      const a = s.pageX, l = s.pageY, u = {
        startX: a,
        currentX: a,
        startY: l,
        currentY: l
      };
      this.el.classList.add("sash-active", th), this.emit("start", u), this.el.setPointerCapture(s.pointerId);
      const c = (h) => {
        h.preventDefault();
        const p = {
          startX: a,
          currentX: h.pageX,
          startY: l,
          currentY: h.pageY
        };
        this.emit("change", p);
      }, d = (h) => {
        h.preventDefault(), this.el.classList.remove("sash-active", th), this.hoverDelayer.cancel(), this.emit("end"), this.el.releasePointerCapture(h.pointerId), window.removeEventListener("pointermove", c), window.removeEventListener("pointerup", d);
      };
      window.addEventListener("pointermove", c), window.addEventListener("pointerup", d);
    }, this.onPointerDoublePress = () => {
      this.emit("reset");
    }, this.onMouseEnter = () => {
      this.el.classList.contains(th) ? (this.hoverDelayer.cancel(), this.el.classList.add("sash-hover", eh)) : this.hoverDelayer(this.el);
    }, this.onMouseLeave = () => {
      this.hoverDelayer.cancel(), this.el.classList.remove("sash-hover", eh);
    }, this.el = document.createElement("div"), this.el.classList.add("sash", C2), this.el.dataset.testid = "sash", e.append(this.el), w2 && this.el.classList.add("sash-mac", O2), this.el.addEventListener("pointerdown", this.onPointerStart), this.el.addEventListener("dblclick", this.onPointerDoublePress), this.el.addEventListener("mouseenter", this.onMouseEnter), this.el.addEventListener("mouseleave", this.onMouseLeave), typeof r.size == "number" ? (this.size = r.size, r.orientation === _i.Vertical ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = mb, gb.on("onDidChangeGlobalSize", (s) => {
      this.size = s, this.layout();
    })), this.layoutProvider = n, this.orientation = (o = r.orientation) != null ? o : _i.Vertical, this.orientation === _i.Horizontal ? (this.el.classList.add("sash-horizontal", Sg), this.el.classList.remove("sash-vertical", xg)) : (this.el.classList.remove("sash-horizontal", Sg), this.el.classList.add("sash-vertical", xg)), this.layout();
  }
  layout() {
    if (this.orientation === _i.Vertical) {
      const e = this.layoutProvider;
      this.el.style.left = e.getVerticalSashLeft(this) - this.size / 2 + "px", e.getVerticalSashTop && (this.el.style.top = e.getVerticalSashTop(this) + "px"), e.getVerticalSashHeight && (this.el.style.height = e.getVerticalSashHeight(this) + "px");
    } else {
      const e = this.layoutProvider;
      this.el.style.top = e.getHorizontalSashTop(this) - this.size / 2 + "px", e.getHorizontalSashLeft && (this.el.style.left = e.getHorizontalSashLeft(this) + "px"), e.getHorizontalSashWidth && (this.el.style.width = e.getHorizontalSashWidth(this) + "px");
    }
  }
  dispose() {
    this.el.removeEventListener("pointerdown", this.onPointerStart), this.el.removeEventListener("dblclick", this.onPointerDoublePress), this.el.removeEventListener("mouseenter", this.onMouseEnter), this.el.removeEventListener("mouseleave", () => this.onMouseLeave), this.el.remove();
  }
}, Rc;
var nh;
(nh = Rc || (Rc = {})).Distribute = {
  type: "distribute"
}, nh.Split = function(i) {
  return {
    type: "split",
    index: i
  };
}, nh.Invisible = function(i) {
  return {
    type: "invisible",
    cachedVisibleSize: i
  };
};
let bi = function(i) {
  return i.Normal = "NORMAL", i.Low = "LOW", i.High = "HIGH", i;
}({}), vb = class {
  constructor(e, n, r) {
    this.container = void 0, this.view = void 0, this._size = void 0, this._cachedVisibleSize = void 0, this.container = e, this.view = n, this.container.classList.add("split-view-view", db), this.container.dataset.testid = "split-view-view", typeof r == "number" ? (this._size = r, this._cachedVisibleSize = void 0, e.classList.add("split-view-view-visible")) : (this._size = 0, this._cachedVisibleSize = r.cachedVisibleSize);
  }
  set size(e) {
    this._size = e;
  }
  get size() {
    return this._size;
  }
  get priority() {
    return this.view.priority;
  }
  get snap() {
    return !!this.view.snap;
  }
  get cachedVisibleSize() {
    return this._cachedVisibleSize;
  }
  get visible() {
    return this._cachedVisibleSize === void 0;
  }
  setVisible(e, n) {
    e !== this.visible && (e ? (this.size = Mi(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof n == "number" ? n : this.size, this.size = 0), this.container.classList.toggle("split-view-view-visible", e), this.view.setVisible && this.view.setVisible(e));
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  set enabled(e) {
    this.container.style.pointerEvents = e ? "" : "none";
  }
  layout(e) {
    this.layoutContainer(e), this.view.layout(this.size, e);
  }
}, D2 = class extends vb {
  layoutContainer(e) {
    this.container.style.left = `${e}px`, this.container.style.width = `${this.size}px`;
  }
}, $2 = class extends vb {
  layoutContainer(e) {
    this.container.style.top = `${e}px`, this.container.style.height = `${this.size}px`;
  }
}, M2 = class extends Qf {
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  set startSnappingEnabled(e) {
    this._startSnappingEnabled !== e && (this._startSnappingEnabled = e, this.updateSashEnablement());
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  set endSnappingEnabled(e) {
    this._endSnappingEnabled !== e && (this._endSnappingEnabled = e, this.updateSashEnablement());
  }
  constructor(e, n = {}, r, o, s) {
    var a, l;
    if (super(), this.onDidChange = void 0, this.onDidDragStart = void 0, this.onDidDragEnd = void 0, this.orientation = void 0, this.sashContainer = void 0, this.size = 0, this.contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.sashDragState = void 0, this.proportionalLayout = void 0, this.getSashOrthogonalSize = void 0, this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this.onSashEnd = (u) => {
      this.emit("sashchange", u), this.saveProportions();
      for (const c of this.viewItems) c.enabled = !0;
    }, this.orientation = (a = n.orientation) != null ? a : _i.Vertical, this.proportionalLayout = (l = n.proportionalLayout) != null ? l : !0, this.getSashOrthogonalSize = n.getSashOrthogonalSize, r && (this.onDidChange = r), o && (this.onDidDragStart = o), s && (this.onDidDragEnd = s), this.sashContainer = document.createElement("div"), this.sashContainer.classList.add("sash-container", m2), e.prepend(this.sashContainer), n.descriptor) {
      this.size = n.descriptor.size;
      for (const [u, c] of n.descriptor.views.entries()) {
        const d = c.size, h = c.container, p = c.view;
        this.addView(h, p, d, u, !0);
      }
      this.contentSize = this.viewItems.reduce((u, c) => u + c.size, 0), this.saveProportions();
    }
  }
  addView(e, n, r, o = this.viewItems.length, s) {
    let a;
    a = typeof r == "number" ? r : r.type === "split" ? this.getViewSize(r.index) / 2 : r.type === "invisible" ? {
      cachedVisibleSize: r.cachedVisibleSize
    } : n.minimumSize;
    const l = this.orientation === _i.Vertical ? new $2(e, n, a) : new D2(e, n, a);
    if (this.viewItems.splice(o, 0, l), this.viewItems.length > 1) {
      const u = this.orientation === _i.Vertical ? new Cg(this.sashContainer, {
        getHorizontalSashTop: (h) => this.getSashPosition(h),
        getHorizontalSashWidth: this.getSashOrthogonalSize
      }, {
        orientation: _i.Horizontal
      }) : new Cg(this.sashContainer, {
        getVerticalSashLeft: (h) => this.getSashPosition(h),
        getVerticalSashHeight: this.getSashOrthogonalSize
      }, {
        orientation: _i.Vertical
      }), c = this.orientation === _i.Vertical ? (h) => ({
        sash: u,
        start: h.startY,
        current: h.currentY
      }) : (h) => ({
        sash: u,
        start: h.startX,
        current: h.currentX
      });
      u.on("start", (h) => {
        var p;
        this.emit("sashDragStart"), this.onSashStart(c(h));
        const m = this.viewItems.map((v) => v.size);
        (p = this.onDidDragStart) == null || p.call(this, m);
      }), u.on("change", (h) => this.onSashChange(c(h))), u.on("end", () => {
        var h;
        this.emit("sashDragEnd"), this.onSashEnd(this.sashItems.findIndex((m) => m.sash === u));
        const p = this.viewItems.map((m) => m.size);
        (h = this.onDidDragEnd) == null || h.call(this, p);
      }), u.on("reset", () => {
        const h = this.sashItems.findIndex((w) => w.sash === u), p = mi(h, -1, -1), m = mi(h + 1, this.viewItems.length), v = this.findFirstSnapIndex(p), y = this.findFirstSnapIndex(m);
        (typeof v != "number" || this.viewItems[v].visible) && (typeof y != "number" || this.viewItems[y].visible) && this.emit("sashreset", h);
      });
      const d = {
        sash: u
      };
      this.sashItems.splice(o - 1, 0, d);
    }
    s || this.relayout(), s || typeof r == "number" || r.type !== "distribute" || this.distributeViewSizes();
  }
  removeView(e, n) {
    if (e < 0 || e >= this.viewItems.length) throw new Error("Index out of bounds");
    const r = this.viewItems.splice(e, 1)[0].view;
    if (this.viewItems.length >= 1) {
      const o = Math.max(e - 1, 0);
      this.sashItems.splice(o, 1)[0].sash.dispose();
    }
    return this.relayout(), n && n.type === "distribute" && this.distributeViewSizes(), r;
  }
  moveView(e, n, r) {
    const o = this.getViewCachedVisibleSize(n), s = o === void 0 ? this.getViewSize(n) : Rc.Invisible(o), a = this.removeView(n);
    this.addView(e, a, s, r);
  }
  getViewCachedVisibleSize(e) {
    if (e < 0 || e >= this.viewItems.length) throw new Error("Index out of bounds");
    return this.viewItems[e].cachedVisibleSize;
  }
  layout(e = this.size) {
    const n = Math.max(this.size, this.contentSize);
    if (this.size = e, this.proportions) for (let r = 0; r < this.viewItems.length; r++) {
      const o = this.viewItems[r];
      o.size = Mi(Math.round(this.proportions[r] * e), o.minimumSize, o.maximumSize);
    }
    else {
      const r = mi(0, this.viewItems.length), o = r.filter((a) => this.viewItems[a].priority === bi.Low), s = r.filter((a) => this.viewItems[a].priority === bi.High);
      this.resize(this.viewItems.length - 1, e - n, void 0, o, s);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  resizeView(e, n) {
    if (e < 0 || e >= this.viewItems.length) return;
    const r = mi(0, this.viewItems.length).filter((l) => l !== e), o = [...r.filter((l) => this.viewItems[l].priority === bi.Low), e], s = r.filter((l) => this.viewItems[l].priority === bi.High), a = this.viewItems[e];
    n = Math.round(n), n = Mi(n, a.minimumSize, Math.min(a.maximumSize, this.size)), a.size = n, this.relayout(o, s);
  }
  resizeViews(e) {
    for (let n = 0; n < e.length; n++) {
      const r = this.viewItems[n];
      let o = e[n];
      o = Math.round(o), o = Mi(o, r.minimumSize, Math.min(r.maximumSize, this.size)), r.size = o;
    }
    this.contentSize = this.viewItems.reduce((n, r) => n + r.size, 0), this.saveProportions(), this.layout(this.size);
  }
  getViewSize(e) {
    return e < 0 || e >= this.viewItems.length ? -1 : this.viewItems[e].size;
  }
  isViewVisible(e) {
    if (e < 0 || e >= this.viewItems.length) throw new Error("Index out of bounds");
    return this.viewItems[e].visible;
  }
  setViewVisible(e, n) {
    if (e < 0 || e >= this.viewItems.length) throw new Error("Index out of bounds");
    this.viewItems[e].setVisible(n), this.distributeEmptySpace(e), this.layoutViews(), this.saveProportions();
  }
  distributeViewSizes() {
    const e = [];
    let n = 0;
    for (const l of this.viewItems) l.maximumSize - l.minimumSize > 0 && (e.push(l), n += l.size);
    const r = Math.floor(n / e.length);
    for (const l of e) l.size = Mi(r, l.minimumSize, l.maximumSize);
    const o = mi(0, this.viewItems.length), s = o.filter((l) => this.viewItems[l].priority === bi.Low), a = o.filter((l) => this.viewItems[l].priority === bi.High);
    this.relayout(s, a);
  }
  dispose() {
    this.sashItems.forEach((e) => e.sash.dispose()), this.sashItems = [], this.sashContainer.remove();
  }
  relayout(e, n) {
    const r = this.viewItems.reduce((o, s) => o + s.size, 0);
    this.resize(this.viewItems.length - 1, this.size - r, void 0, e, n), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
  }
  onSashStart({
    sash: e,
    start: n
  }) {
    const r = this.sashItems.findIndex((o) => o.sash === e);
    ((o) => {
      const s = this.viewItems.map((k) => k.size);
      let a, l, u = Number.NEGATIVE_INFINITY, c = Number.POSITIVE_INFINITY;
      const d = mi(r, -1, -1), h = mi(r + 1, this.viewItems.length), p = d.reduce((k, _) => k + (this.viewItems[_].minimumSize - s[_]), 0), m = d.reduce((k, _) => k + (this.viewItems[_].viewMaximumSize - s[_]), 0), v = h.length === 0 ? Number.POSITIVE_INFINITY : h.reduce((k, _) => k + (s[_] - this.viewItems[_].minimumSize), 0), y = h.length === 0 ? Number.NEGATIVE_INFINITY : h.reduce((k, _) => k + (s[_] - this.viewItems[_].viewMaximumSize), 0);
      u = Math.max(p, y), c = Math.min(v, m);
      const w = this.findFirstSnapIndex(d), g = this.findFirstSnapIndex(h);
      if (typeof w == "number") {
        const k = this.viewItems[w], _ = Math.floor(k.viewMinimumSize / 2);
        a = {
          index: w,
          limitDelta: k.visible ? u - _ : u + _,
          size: k.size
        };
      }
      if (typeof g == "number") {
        const k = this.viewItems[g], _ = Math.floor(k.viewMinimumSize / 2);
        l = {
          index: g,
          limitDelta: k.visible ? c + _ : c - _,
          size: k.size
        };
      }
      this.sashDragState = {
        start: o,
        current: o,
        index: r,
        sizes: s,
        minDelta: u,
        maxDelta: c,
        snapBefore: a,
        snapAfter: l
      };
    })(n);
  }
  onSashChange({
    current: e
  }) {
    const {
      index: n,
      start: r,
      sizes: o,
      minDelta: s,
      maxDelta: a,
      snapBefore: l,
      snapAfter: u
    } = this.sashDragState;
    this.sashDragState.current = e;
    const c = e - r;
    this.resize(n, c, o, void 0, void 0, s, a, l, u), this.distributeEmptySpace(), this.layoutViews();
  }
  getSashPosition(e) {
    let n = 0;
    for (let r = 0; r < this.sashItems.length; r++) if (n += this.viewItems[r].size, this.sashItems[r].sash === e) return n;
    return 0;
  }
  resize(e, n, r = this.viewItems.map((d) => d.size), o, s, a = Number.NEGATIVE_INFINITY, l = Number.POSITIVE_INFINITY, u, c) {
    if (e < 0 || e >= this.viewItems.length) return 0;
    const d = mi(e, -1, -1), h = mi(e + 1, this.viewItems.length);
    if (s) for (const x of s) _g(d, x), _g(h, x);
    if (o) for (const x of o) Qd(d, x), Qd(h, x);
    const p = d.map((x) => this.viewItems[x]), m = d.map((x) => r[x]), v = h.map((x) => this.viewItems[x]), y = h.map((x) => r[x]), w = d.reduce((x, I) => x + (this.viewItems[I].minimumSize - r[I]), 0), g = d.reduce((x, I) => x + (this.viewItems[I].maximumSize - r[I]), 0), k = h.length === 0 ? Number.POSITIVE_INFINITY : h.reduce((x, I) => x + (r[I] - this.viewItems[I].minimumSize), 0), _ = h.length === 0 ? Number.NEGATIVE_INFINITY : h.reduce((x, I) => x + (r[I] - this.viewItems[I].maximumSize), 0), S = Math.max(w, _, a), b = Math.min(k, g, l);
    let C = !1;
    if (u) {
      const x = this.viewItems[u.index], I = n >= u.limitDelta;
      C = I !== x.visible, x.setVisible(I, u.size);
    }
    if (!C && c) {
      const x = this.viewItems[c.index], I = n < c.limitDelta;
      C = I !== x.visible, x.setVisible(I, c.size);
    }
    if (C) return this.resize(e, n, r, o, s, a, l);
    for (let x = 0, I = n = Mi(n, S, b); x < p.length; x++) {
      const F = p[x], B = Mi(m[x] + I, F.minimumSize, F.maximumSize);
      I -= B - m[x], F.size = B;
    }
    for (let x = 0, I = n; x < v.length; x++) {
      const F = v[x], B = Mi(y[x] - I, F.minimumSize, F.maximumSize);
      I += B - y[x], F.size = B;
    }
    return n;
  }
  distributeEmptySpace(e) {
    const n = this.viewItems.reduce((c, d) => c + d.size, 0);
    let r = this.size - n;
    const o = mi(0, this.viewItems.length), s = [], a = o.filter((c) => this.viewItems[c].priority === bi.Low), l = o.filter((c) => this.viewItems[c].priority === bi.Normal), u = o.filter((c) => this.viewItems[c].priority === bi.High);
    s.push(...u, ...l, ...a), typeof e == "number" && Qd(s, e);
    for (let c = 0; r !== 0 && c < s.length; c++) {
      const d = this.viewItems[s[c]], h = Mi(d.size + r, d.minimumSize, d.maximumSize);
      r -= h - d.size, d.size = h;
    }
  }
  layoutViews() {
    var e;
    this.contentSize = this.viewItems.reduce((r, o) => r + o.size, 0);
    let n = 0;
    for (const r of this.viewItems) r.layout(n), n += r.size;
    (e = this.onDidChange) != null && e.call(this, this.viewItems.map((r) => r.size)), this.sashItems.forEach((r) => r.sash.layout()), this.updateSashEnablement();
  }
  saveProportions() {
    this.proportionalLayout && this.contentSize > 0 && (this.proportions = this.viewItems.map((e) => e.size / this.contentSize));
  }
  updateSashEnablement() {
    let e = !1;
    const n = this.viewItems.map((u) => e = u.size - u.minimumSize > 0 || e);
    e = !1;
    const r = this.viewItems.map((u) => e = u.maximumSize - u.size > 0 || e), o = [...this.viewItems].reverse();
    e = !1;
    const s = o.map((u) => e = u.size - u.minimumSize > 0 || e).reverse();
    e = !1;
    const a = o.map((u) => e = u.maximumSize - u.size > 0 || e).reverse();
    let l = 0;
    for (let u = 0; u < this.sashItems.length; u++) {
      const {
        sash: c
      } = this.sashItems[u];
      l += this.viewItems[u].size;
      const d = !(n[u] && a[u + 1]), h = !(r[u] && s[u + 1]);
      if (d && h) {
        const p = mi(u, -1, -1), m = mi(u + 1, this.viewItems.length), v = this.findFirstSnapIndex(p), y = this.findFirstSnapIndex(m), w = typeof v == "number" && !this.viewItems[v].visible, g = typeof y == "number" && !this.viewItems[y].visible;
        w && s[u] && (l > 0 || this.startSnappingEnabled) ? c.state = si.Minimum : g && n[u] && (l < this.contentSize || this.endSnappingEnabled) ? c.state = si.Maximum : c.state = si.Disabled;
      } else c.state = d && !h ? si.Minimum : !d && h ? si.Maximum : si.Enabled;
    }
  }
  findFirstSnapIndex(e) {
    for (const n of e) {
      const r = this.viewItems[n];
      if (r.visible && r.snap) return n;
    }
    for (const n of e) {
      const r = this.viewItems[n];
      if (r.visible && r.maximumSize - r.minimumSize > 0) return;
      if (!r.visible && r.snap) return n;
    }
  }
}, Ws = class {
  constructor(e) {
    this.size = void 0, this.size = e;
  }
  getPreferredSize() {
    return this.size;
  }
}, kg = class {
  constructor(e, n) {
    this.proportion = void 0, this.layoutService = void 0, this.proportion = e, this.layoutService = n;
  }
  getPreferredSize() {
    return this.proportion * this.layoutService.getSize();
  }
}, Du = class {
  getPreferredSize() {
  }
}, Og = class {
  get preferredSize() {
    return this.layoutStrategy.getPreferredSize();
  }
  set preferredSize(e) {
    if (typeof e == "number") this.layoutStrategy = new Ws(e);
    else if (typeof e == "string") {
      const n = e.trim();
      if (Tu(n, "%")) {
        const r = Number(n.slice(0, -1)) / 100;
        this.layoutStrategy = new kg(r, this.layoutService);
      } else if (Tu(n, "px")) {
        const r = Number(n.slice(0, -2)) / 100;
        this.layoutStrategy = new Ws(r);
      } else if (typeof Number.parseFloat(n) == "number") {
        const r = Number.parseFloat(n);
        this.layoutStrategy = new Ws(r);
      } else this.layoutStrategy = new Du();
    } else this.layoutStrategy = new Du();
  }
  constructor(e, n) {
    var r;
    if (this.minimumSize = 0, this.maximumSize = Number.POSITIVE_INFINITY, this.element = void 0, this.priority = void 0, this.snap = void 0, this.layoutService = void 0, this.layoutStrategy = void 0, this.layoutService = e, this.element = n.element, this.minimumSize = typeof n.minimumSize == "number" ? n.minimumSize : 30, this.maximumSize = typeof n.maximumSize == "number" ? n.maximumSize : Number.POSITIVE_INFINITY, typeof n.preferredSize == "number") this.layoutStrategy = new Ws(n.preferredSize);
    else if (typeof n.preferredSize == "string") {
      const o = n.preferredSize.trim();
      if (Tu(o, "%")) {
        const s = Number(o.slice(0, -1)) / 100;
        this.layoutStrategy = new kg(s, this.layoutService);
      } else if (Tu(o, "px")) {
        const s = Number(o.slice(0, -2));
        this.layoutStrategy = new Ws(s);
      } else if (typeof Number.parseFloat(o) == "number") {
        const s = Number.parseFloat(o);
        this.layoutStrategy = new Ws(s);
      } else this.layoutStrategy = new Du();
    } else this.layoutStrategy = new Du();
    this.priority = (r = n.priority) != null ? r : bi.Normal, this.snap = typeof n.snap == "boolean" && n.snap;
  }
  layout(e) {
  }
};
function Eg(i) {
  return i.minSize !== void 0 || i.maxSize !== void 0 || i.preferredSize !== void 0 || i.priority !== void 0 || i.visible !== void 0;
}
const ep = yt.forwardRef(({
  className: i,
  children: e
}, n) => Fr.createElement("div", {
  ref: n,
  className: Wh("split-view-view", db, i)
}, e));
ep.displayName = "Allotment.Pane";
const yb = yt.forwardRef(({
  children: i,
  className: e,
  id: n,
  maxSize: r = 1 / 0,
  minSize: o = 30,
  proportionalLayout: s = !0,
  separator: a = !0,
  sizes: l,
  defaultSizes: u = l,
  snap: c = !1,
  vertical: d = !1,
  onChange: h,
  onReset: p,
  onVisibleChange: m,
  onDragStart: v,
  onDragEnd: y
}, w) => {
  const g = yt.useRef(null), k = yt.useRef([]), _ = yt.useRef(/* @__PURE__ */ new Map()), S = yt.useRef(null), b = yt.useRef(/* @__PURE__ */ new Map()), C = yt.useRef(new _2()), x = yt.useRef([]), [I, F] = yt.useState(!1);
  process.env.NODE_ENV !== "production" && l && console.warn("Prop sizes is deprecated. Please use defaultSizes instead.");
  const B = yt.useMemo(() => Fr.Children.toArray(i).filter(Fr.isValidElement), [i]), X = yt.useCallback((j) => {
    var ee, ie;
    const M = (ee = x.current) == null ? void 0 : ee[j];
    return typeof (M == null ? void 0 : M.preferredSize) == "number" && ((ie = S.current) != null && ie.resizeView(j, Math.round(M.preferredSize)), !0);
  }, []);
  return yt.useImperativeHandle(w, () => ({
    reset: () => {
      if (p) p();
      else {
        var j;
        (j = S.current) == null || j.distributeViewSizes();
        for (let ee = 0; ee < x.current.length; ee++) X(ee);
      }
    },
    resize: (j) => {
      var ee;
      (ee = S.current) == null || ee.resizeViews(j);
    }
  })), gg(() => {
    let j = !0;
    u && b.current.size !== u.length && (j = !1, console.warn(`Expected ${u.length} children based on defaultSizes but found ${b.current.size}`)), j && u && (k.current = B.map((M) => M.key));
    const ee = dl({
      orientation: d ? _i.Vertical : _i.Horizontal,
      proportionalLayout: s
    }, j && u && {
      descriptor: {
        size: u.reduce((M, W) => M + W, 0),
        views: u.map((M, W) => {
          var R, V, ae, $e;
          const N = _.current.get(k.current[W]), me = new Og(C.current, dl({
            element: document.createElement("div"),
            minimumSize: (R = N == null ? void 0 : N.minSize) != null ? R : o,
            maximumSize: (V = N == null ? void 0 : N.maxSize) != null ? V : r,
            priority: (ae = N == null ? void 0 : N.priority) != null ? ae : bi.Normal
          }, (N == null ? void 0 : N.preferredSize) && {
            preferredSize: N == null ? void 0 : N.preferredSize
          }, {
            snap: ($e = N == null ? void 0 : N.snap) != null ? $e : c
          }));
          return x.current.push(me), {
            container: [...b.current.values()][W],
            size: M,
            view: me
          };
        })
      }
    });
    S.current = new M2(g.current, ee, h, v, y), S.current.on("sashDragStart", () => {
      var M;
      (M = g.current) == null || M.classList.add("split-view-sash-dragging");
    }), S.current.on("sashDragEnd", () => {
      var M;
      (M = g.current) == null || M.classList.remove("split-view-sash-dragging");
    }), S.current.on("sashchange", (M) => {
      if (m && S.current) {
        const W = B.map((R) => R.key);
        for (let R = 0; R < W.length; R++) {
          const V = _.current.get(W[R]);
          (V == null ? void 0 : V.visible) !== void 0 && V.visible !== S.current.isViewVisible(R) && m(R, S.current.isViewVisible(R));
        }
      }
    }), S.current.on("sashreset", (M) => {
      if (p) p();
      else {
        var W;
        if (X(M) || X(M + 1)) return;
        (W = S.current) == null || W.distributeViewSizes();
      }
    });
    const ie = S.current;
    return () => {
      ie.dispose();
    };
  }, []), gg(() => {
    if (I) {
      const we = B.map((Ce) => Ce.key), fe = [...k.current], te = we.filter((Ce) => !k.current.includes(Ce)), Me = we.filter((Ce) => k.current.includes(Ce)), Re = k.current.map((Ce) => !we.includes(Ce));
      for (let Ce = Re.length - 1; Ce >= 0; Ce--) {
        var j;
        Re[Ce] && ((j = S.current) != null && j.removeView(Ce), fe.splice(Ce, 1), x.current.splice(Ce, 1));
      }
      for (const Ce of te) {
        var ee, ie, M, W, R;
        const le = _.current.get(Ce), T = new Og(C.current, dl({
          element: document.createElement("div"),
          minimumSize: (ee = le == null ? void 0 : le.minSize) != null ? ee : o,
          maximumSize: (ie = le == null ? void 0 : le.maxSize) != null ? ie : r,
          priority: (M = le == null ? void 0 : le.priority) != null ? M : bi.Normal
        }, (le == null ? void 0 : le.preferredSize) && {
          preferredSize: le == null ? void 0 : le.preferredSize
        }, {
          snap: (W = le == null ? void 0 : le.snap) != null ? W : c
        }));
        (R = S.current) != null && R.addView(b.current.get(Ce), T, Rc.Distribute, we.findIndex((E) => E === Ce)), fe.splice(we.findIndex((E) => E === Ce), 0, Ce), x.current.splice(we.findIndex((E) => E === Ce), 0, T);
      }
      for (; !h2(we, fe); ) for (const [Ce, le] of we.entries()) {
        const T = fe.findIndex((E) => E === le);
        if (T !== Ce) {
          var V;
          (V = S.current) == null || V.moveView(b.current.get(le), T, Ce);
          const E = fe[T];
          fe.splice(T, 1), fe.splice(Ce, 0, E);
          break;
        }
      }
      for (const Ce of te) {
        var ae;
        const le = we.findIndex((E) => E === Ce), T = x.current[le].preferredSize;
        T !== void 0 && ((ae = S.current) == null || ae.resizeView(le, T));
      }
      for (const Ce of [...te, ...Me]) {
        var $e, N;
        const le = _.current.get(Ce), T = we.findIndex((E) => E === Ce);
        le && Eg(le) && le.visible !== void 0 && (($e = S.current) == null ? void 0 : $e.isViewVisible(T)) !== le.visible && ((N = S.current) == null || N.setViewVisible(T, le.visible));
      }
      for (const Ce of Me) {
        const le = _.current.get(Ce), T = we.findIndex((E) => E === Ce);
        if (le && Eg(le)) {
          var me;
          le.preferredSize !== void 0 && x.current[T].preferredSize !== le.preferredSize && (x.current[T].preferredSize = le.preferredSize);
          let E = !1;
          le.minSize !== void 0 && x.current[T].minimumSize !== le.minSize && (x.current[T].minimumSize = le.minSize, E = !0), le.maxSize !== void 0 && x.current[T].maximumSize !== le.maxSize && (x.current[T].maximumSize = le.maxSize, E = !0), E && ((me = S.current) == null || me.layout());
        }
      }
      (te.length > 0 || Re.length > 0) && (k.current = we);
    }
  }, [B, I, r, o, c]), yt.useEffect(() => {
    S.current && (S.current.onDidChange = h);
  }, [h]), yt.useEffect(() => {
    S.current && (S.current.onDidDragStart = v);
  }, [v]), yt.useEffect(() => {
    S.current && (S.current.onDidDragEnd = y);
  }, [y]), f2({
    ref: g,
    onResize: ({
      width: j,
      height: ee
    }) => {
      var ie;
      j && ee && ((ie = S.current) != null && ie.layout(d ? ee : j), C.current.setSize(d ? ee : j), F(!0));
    }
  }), yt.useEffect(() => {
    pb && P2(20);
  }, []), Fr.createElement("div", {
    ref: g,
    className: Wh("split-view", d ? "split-view-vertical" : "split-view-horizontal", {
      "split-view-separator-border": a
    }, p2, d ? v2 : y2, {
      [b2]: a
    }, e),
    id: n
  }, Fr.createElement("div", {
    className: Wh("split-view-container", g2)
  }, Fr.Children.toArray(i).map((j) => {
    if (!Fr.isValidElement(j)) return null;
    const ee = j.key;
    return j.type.displayName === "Allotment.Pane" ? (_.current.set(ee, j.props), Fr.cloneElement(j, {
      key: ee,
      ref: (ie) => {
        const M = j.ref;
        M && (M.current = ie), ie ? b.current.set(ee, ie) : b.current.delete(ee);
      }
    })) : Fr.createElement(ep, {
      key: ee,
      ref: (ie) => {
        ie ? b.current.set(ee, ie) : b.current.delete(ee);
      }
    }, j);
  })));
});
function P2(i) {
  const e = Mi(i, 4, 20), n = Mi(i, 1, 8);
  document.documentElement.style.setProperty("--sash-size", e + "px"), document.documentElement.style.setProperty("--sash-hover-size", n + "px"), function(r) {
    mb = r, gb.emit("onDidChangeGlobalSize", r);
  }(e);
}
yb.displayName = "Allotment";
var sr = Object.assign(yb, {
  Pane: ep
});
const Xr = 2048, I2 = {
  sub: [20, 60],
  bass: [60, 250],
  lowMid: [250, 500],
  mid: [500, 2e3],
  highMid: [2e3, 4e3],
  high: [4e3, 2e4]
};
async function L2(i) {
  const e = await i.arrayBuffer(), n = new AudioContext();
  try {
    const r = await n.decodeAudioData(e);
    return await n.close(), r;
  } catch (r) {
    throw await n.close(), new Error(`Failed to decode audio file: ${r}`);
  }
}
async function A2(i, e) {
  const n = i.duration, r = Math.ceil(n * e), o = i.sampleRate, s = V2(i, e), a = F2(i, e), l = await j2(i, e), u = await R2(i, e), c = N2(i, e), d = B2(i);
  return {
    sampleRate: o,
    duration: n,
    frameCount: r,
    amplitudeEnvelope: s,
    rmsEnergy: a,
    spectralCentroid: u,
    frequencyBands: l,
    onsets: c,
    bpm: d
  };
}
function V2(i, e) {
  const n = i.getChannelData(0), r = Math.floor(i.sampleRate / e), o = Math.ceil(i.duration * e), s = [];
  for (let l = 0; l < o; l++) {
    const u = l * r, c = Math.min(u + r, n.length);
    let d = 0;
    for (let h = u; h < c; h++) {
      const p = Math.abs(n[h]);
      p > d && (d = p);
    }
    s.push(d);
  }
  const a = Math.max(...s, 1e-4);
  return s.map((l) => l / a);
}
function F2(i, e) {
  const n = i.getChannelData(0), r = Math.floor(i.sampleRate / e), o = Math.ceil(i.duration * e), s = [];
  for (let l = 0; l < o; l++) {
    const u = l * r, c = Math.min(u + r, n.length);
    let d = 0, h = 0;
    for (let m = u; m < c; m++)
      d += n[m] * n[m], h++;
    const p = h > 0 ? Math.sqrt(d / h) : 0;
    s.push(p);
  }
  const a = Math.max(...s, 1e-4);
  return s.map((l) => l / a);
}
async function j2(i, e) {
  const n = i.duration, r = Math.ceil(n * e), o = i.sampleRate, s = new OfflineAudioContext(
    1,
    i.length,
    o
  ), a = s.createBufferSource();
  a.buffer = i;
  const l = s.createAnalyser();
  l.fftSize = Xr, l.smoothingTimeConstant = 0, a.connect(l), l.connect(s.destination);
  const u = {
    sub: [],
    bass: [],
    lowMid: [],
    mid: [],
    highMid: [],
    high: []
  }, c = o / Xr, d = Object.entries(I2).reduce((m, [v, [y, w]]) => (m[v] = {
    start: Math.floor(y / c),
    end: Math.ceil(w / c)
  }, m), {}), h = Math.floor(o / e), p = i.getChannelData(0);
  for (let m = 0; m < r; m++) {
    const v = m * h;
    if (Math.min(v + Xr, p.length) - v < 64) {
      Object.keys(u).forEach((k) => {
        const _ = u[k];
        _.push(_.length > 0 ? _[_.length - 1] : 0);
      });
      continue;
    }
    const g = tp(p.slice(v, v + Xr));
    for (const [k, { start: _, end: S }] of Object.entries(d)) {
      let b = 0, C = 0;
      for (let x = _; x < Math.min(S, g.length); x++)
        b += g[x], C++;
      u[k].push(C > 0 ? b / C : 0);
    }
  }
  for (const m of Object.keys(u)) {
    const v = Math.max(...u[m], 1e-4);
    u[m] = u[m].map((y) => y / v);
  }
  return u;
}
function tp(i) {
  const e = i.length, n = [], r = new Float32Array(e);
  for (let s = 0; s < e; s++) {
    const a = 0.5 * (1 - Math.cos(2 * Math.PI * s / (e - 1)));
    r[s] = (i[s] || 0) * a;
  }
  const o = Math.floor(e / 2);
  for (let s = 0; s < o; s++) {
    let a = 0, l = 0;
    for (let u = 0; u < e; u++) {
      const c = 2 * Math.PI * s * u / e;
      a += r[u] * Math.cos(c), l -= r[u] * Math.sin(c);
    }
    n.push(Math.sqrt(a * a + l * l) / e);
  }
  return n;
}
async function R2(i, e) {
  const n = Math.ceil(i.duration * e), r = i.sampleRate, o = i.getChannelData(0), s = Math.floor(r / e), a = [], l = r / Xr;
  for (let c = 0; c < n; c++) {
    const d = c * s;
    if (d + Xr > o.length) {
      a.push(a.length > 0 ? a[a.length - 1] : 0);
      continue;
    }
    const h = tp(o.slice(d, d + Xr));
    let p = 0, m = 0;
    for (let y = 0; y < h.length; y++) {
      const w = y * l;
      p += w * h[y], m += h[y];
    }
    const v = m > 0 ? p / m : 0;
    a.push(v);
  }
  const u = Math.max(...a, 1e-4);
  return a.map((c) => c / u);
}
function N2(i, e, n = 0.5) {
  const r = i.getChannelData(0), o = i.sampleRate, s = Math.floor(o / e), a = Math.ceil(i.duration * e), l = [];
  let u = null;
  for (let h = 0; h < a; h++) {
    const p = h * s;
    if (p + Xr > r.length) {
      l.push(0);
      continue;
    }
    const m = tp(r.slice(p, p + Xr));
    if (u) {
      let v = 0;
      for (let y = 0; y < m.length; y++) {
        const w = m[y] - u[y];
        w > 0 && (v += w);
      }
      l.push(v);
    } else
      l.push(0);
    u = m;
  }
  const c = [], d = z2(l, n);
  for (let h = 1; h < l.length - 1; h++)
    l[h] > l[h - 1] && l[h] > l[h + 1] && l[h] > d[h] && c.push(h);
  return c;
}
function z2(i, e) {
  const r = [];
  for (let o = 0; o < i.length; o++) {
    const s = Math.max(0, o - 10), a = Math.min(i.length, o + 10 + 1), l = i.slice(s, a), u = l.reduce((d, h) => d + h, 0) / l.length, c = Math.sqrt(
      l.reduce((d, h) => d + (h - u) ** 2, 0) / l.length
    );
    r.push(u + (1 - e) * 2 * c);
  }
  return r;
}
function B2(i) {
  const e = i.getChannelData(0), n = i.sampleRate, r = 4, o = [];
  for (let w = 0; w < e.length; w += r)
    o.push(Math.abs(e[w]));
  const s = H2(o, 0.1), a = 60, l = 200, u = n / r, c = Math.floor(60 / l * u), d = Math.floor(60 / a * u);
  let h = 0, p = c;
  const m = Math.min(s.length, u * 10), v = s.slice(0, m);
  for (let w = c; w <= d; w++) {
    let g = 0, k = 0;
    for (let _ = 0; _ < v.length - w; _++)
      g += v[_] * v[_ + w], k++;
    k > 0 && (g /= k, g > h && (h = g, p = w));
  }
  const y = 60 * u / p;
  return Math.round(Math.max(a, Math.min(l, y)));
}
function H2(i, e) {
  const n = [];
  let r = 0;
  for (const o of i)
    o > r ? r = o : r = r * (1 - e) + o * e, n.push(r);
  return n;
}
function Gh(i, e, n) {
  const r = Math.max(0, Math.min(n, i.frameCount - 1));
  switch (e) {
    case "amplitude":
      return i.amplitudeEnvelope[r] ?? 0;
    case "rms":
      return i.rmsEnergy[r] ?? 0;
    case "spectralCentroid":
      return i.spectralCentroid[r] ?? 0;
    case "sub":
      return i.frequencyBands.sub[r] ?? 0;
    case "bass":
      return i.frequencyBands.bass[r] ?? 0;
    case "lowMid":
      return i.frequencyBands.lowMid[r] ?? 0;
    case "mid":
      return i.frequencyBands.mid[r] ?? 0;
    case "highMid":
      return i.frequencyBands.highMid[r] ?? 0;
    case "high":
      return i.frequencyBands.high[r] ?? 0;
    case "onsets":
      return i.onsets.includes(r) ? 1 : 0;
    default:
      return 0;
  }
}
function U2(i, e) {
  const { threshold: n, minPeaksDistance: r, multiply: o } = e, s = i.map((d) => Math.min(1, d * o)), a = [];
  for (let d = 1; d < s.length - 1; d++) {
    const h = s[d - 1], p = s[d], m = s[d + 1];
    p > h && p > m && p >= n && a.push({ index: d, value: p });
  }
  const l = [];
  for (const d of a) {
    const h = l.findIndex(
      (p) => Math.abs(p.index - d.index) < r
    );
    h === -1 ? l.push(d) : d.value > l[h].value && (l[h] = d);
  }
  l.sort((d, h) => d.index - h.index);
  const u = new Array(i.length).fill(0);
  let c = 0;
  for (let d = 0; d < i.length; d++)
    l.some((p) => p.index === d) && (c = 1 - c), u[d] = c;
  return {
    indices: l.map((d) => d.index),
    values: l.map((d) => d.value),
    count: l.length,
    alternating: u
  };
}
function Tg(i, e) {
  return i.onsets.includes(e);
}
function W2(i, e) {
  return i.indices.includes(e);
}
function wi(i, e, n = "number") {
  return {
    id: `prop_${i}_${Date.now()}`,
    name: i,
    type: n,
    value: e,
    animated: !1,
    keyframes: []
  };
}
function G2() {
  return {
    position: wi("position", { x: 0, y: 0 }, "position"),
    anchor: { x: 0, y: 0 },
    scale: wi("scale", { x: 1, y: 1 }, "position"),
    rotation: wi("rotation", 0, "number")
  };
}
function X2(i, e) {
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    composition: {
      width: i,
      height: e,
      frameCount: 81,
      fps: 16,
      duration: 81 / 16,
      backgroundColor: "#000000"
    },
    assets: {},
    layers: [],
    currentFrame: 0
  };
}
function Qs(i, e) {
  if (!i.animated || i.keyframes.length === 0)
    return i.value;
  const n = i.keyframes;
  if (e <= n[0].frame)
    return n[0].value;
  if (e >= n[n.length - 1].frame)
    return n[n.length - 1].value;
  let r = n[0], o = n[1];
  for (let u = 0; u < n.length - 1; u++)
    if (e >= n[u].frame && e <= n[u + 1].frame) {
      r = n[u], o = n[u + 1];
      break;
    }
  const s = o.frame - r.frame, a = e - r.frame;
  let l = s > 0 ? a / s : 0;
  switch (r.interpolation) {
    case "hold":
      return r.value;
    case "bezier":
      l = Y2(l, r.outHandle, o.inHandle);
      break;
  }
  return q2(r.value, o.value, l);
}
function Y2(i, e, n) {
  const r = e.x, o = e.y, s = 1 - n.x, a = 1 - n.y;
  let l = i;
  for (let u = 0; u < 8; u++) {
    const c = Nc(l, 0, r, s, 1), d = K2(l, 0, r, s, 1);
    if (Math.abs(d) < 1e-6) break;
    const h = c - i;
    l -= h / d, l = Math.max(0, Math.min(1, l));
  }
  return Nc(l, 0, o, a, 1);
}
function Nc(i, e, n, r, o) {
  const s = 1 - i;
  return s * s * s * e + 3 * s * s * i * n + 3 * s * i * i * r + i * i * i * o;
}
function K2(i, e, n, r, o) {
  const s = 1 - i;
  return 3 * s * s * (n - e) + 6 * s * i * (r - n) + 3 * i * i * (o - r);
}
function q2(i, e, n) {
  return typeof i == "number" && typeof e == "number" ? i + (e - i) * n : typeof i == "object" && i !== null && "x" in i && "y" in i && typeof e == "object" && e !== null && "x" in e && "y" in e ? {
    x: i.x + (e.x - i.x) * n,
    y: i.y + (e.y - i.y) * n
  } : typeof i == "string" && typeof e == "string" && i.startsWith("#") && e.startsWith("#") ? Z2(i, e, n) : n < 0.5 ? i : e;
}
function Z2(i, e, n) {
  const r = parseInt(i.slice(1, 3), 16), o = parseInt(i.slice(3, 5), 16), s = parseInt(i.slice(5, 7), 16), a = parseInt(e.slice(1, 3), 16), l = parseInt(e.slice(3, 5), 16), u = parseInt(e.slice(5, 7), 16), c = Math.round(r + (a - r) * n), d = Math.round(o + (l - o) * n), h = Math.round(s + (u - s) * n);
  return `#${c.toString(16).padStart(2, "0")}${d.toString(16).padStart(2, "0")}${h.toString(16).padStart(2, "0")}`;
}
const zc = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
};
function J2(i, e, n) {
  const r = e.x, o = e.y, s = 1 - n.x, a = 1 - n.y;
  return {
    x: Nc(i, 0, r, s, 1),
    y: Nc(i, 0, o, a, 1)
  };
}
function Q2(i, e) {
  const n = Math.max(0, Math.min(1, i));
  return J2(n, e.outHandle, e.inHandle).y;
}
class ek {
  constructor(e) {
    Xe(this, "analysis");
    Xe(this, "mappings", /* @__PURE__ */ new Map());
    Xe(this, "smoothedValues", /* @__PURE__ */ new Map());
    Xe(this, "peakData", null);
    this.analysis = e;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(e) {
    this.peakData = e;
  }
  /**
   * Add a new mapping
   */
  addMapping(e) {
    this.mappings.set(e.id, e), this.smoothedValues.set(e.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(e) {
    this.mappings.delete(e), this.smoothedValues.delete(e);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(e, n) {
    const r = this.mappings.get(e);
    r && Object.assign(r, n);
  }
  /**
   * Get a specific mapping
   */
  getMapping(e) {
    return this.mappings.get(e);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(e) {
    return Array.from(this.mappings.values()).filter(
      (n) => n.targetLayerId === e || n.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(e) {
    return Array.from(this.mappings.values()).filter((n) => n.target === e);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(e, n) {
    return e === "peaks" ? this.peakData && W2(this.peakData, n) ? 1 : 0 : Gh(this.analysis, e, n);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(e, n) {
    const r = this.mappings.get(e);
    if (!r || !r.enabled) return 0;
    let o = this.getFeatureAtFrame(r.feature, n);
    o < r.threshold && (o = 0), r.invert && (o = 1 - o), o *= r.sensitivity, o += r.offset, o = Math.max(r.min, Math.min(r.max, o));
    const a = (this.smoothedValues.get(e) || 0) * r.smoothing + o * (1 - r.smoothing);
    return this.smoothedValues.set(e, a), a;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(e) {
    const n = /* @__PURE__ */ new Map();
    for (const r of this.mappings.values()) {
      if (!r.enabled) continue;
      const o = this.getValueAtFrame(r.id, e), s = n.get(r.target);
      s !== void 0 ? n.set(r.target, s + o) : n.set(r.target, o);
    }
    return n;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(e, n) {
    const r = /* @__PURE__ */ new Map();
    for (const o of this.mappings.values()) {
      if (!o.enabled || o.targetLayerId && o.targetLayerId !== e) continue;
      const s = this.getValueAtFrame(o.id, n), a = r.get(o.target);
      a !== void 0 ? r.set(o.target, a + s) : r.set(o.target, s);
    }
    return r;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
    for (const e of this.mappings.values())
      this.smoothedValues.set(e.id, 0);
  }
  /**
   * Update analysis data
   */
  setAnalysis(e) {
    this.analysis = e, this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear(), this.smoothedValues.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addMapping(n);
  }
}
const tk = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: !0,
  beatThreshold: 0.05,
  motionBlur: !1,
  motionBlurStrength: 0.5
};
class nk {
  // For amplitude mode release tracking
  constructor(e = {}) {
    Xe(this, "config");
    Xe(this, "state");
    Xe(this, "pathSegments", []);
    Xe(this, "totalLength", 0);
    Xe(this, "releaseState", 0);
    this.config = { ...tk, ...e }, this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(e) {
    this.pathSegments = this.parsePath(e), this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(e) {
    const n = [], r = e.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let o = 0, s = 0;
    for (const a of r) {
      const l = a[0].toUpperCase(), u = a.slice(1).trim().split(/[\s,]+/).map(Number).filter((c) => !isNaN(c));
      switch (l) {
        case "M":
          o = u[0] || 0, s = u[1] || 0, n.push({
            type: "M",
            points: [o, s],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          n.push({
            type: "L",
            points: [o, s, u[0], u[1]],
            length: 0,
            startT: 0,
            endT: 0
          }), o = u[0], s = u[1];
          break;
        case "C":
          n.push({
            type: "C",
            points: [o, s, u[0], u[1], u[2], u[3], u[4], u[5]],
            length: 0,
            startT: 0,
            endT: 0
          }), o = u[4], s = u[5];
          break;
        case "Q":
          n.push({
            type: "Q",
            points: [o, s, u[0], u[1], u[2], u[3]],
            length: 0,
            startT: 0,
            endT: 0
          }), o = u[2], s = u[3];
          break;
        case "Z":
          const c = n.find((d) => d.type === "M");
          c && n.push({
            type: "L",
            points: [o, s, c.points[0], c.points[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
      }
    }
    return n;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let e = 0;
    for (const n of this.pathSegments) {
      switch (n.type) {
        case "M":
          n.length = 0;
          break;
        case "L":
          n.length = this.lineLength(n.points);
          break;
        case "C":
          n.length = this.bezierLength(n.points, 3);
          break;
        case "Q":
          n.length = this.bezierLength(n.points, 2);
          break;
      }
      n.startT = e, e += n.length, n.endT = e;
    }
    if (this.totalLength = e, this.totalLength > 0)
      for (const n of this.pathSegments)
        n.startT /= this.totalLength, n.endT /= this.totalLength;
  }
  lineLength(e) {
    const n = e[2] - e[0], r = e[3] - e[1];
    return Math.sqrt(n * n + r * r);
  }
  bezierLength(e, n) {
    let o = 0, s = e[0], a = e[1];
    for (let l = 1; l <= 20; l++) {
      const u = l / 20, { x: c, y: d } = this.getBezierPoint(e, u, n), h = c - s, p = d - a;
      o += Math.sqrt(h * h + p * p), s = c, a = d;
    }
    return o;
  }
  getBezierPoint(e, n, r) {
    if (r === 2) {
      const o = 1 - n;
      return {
        x: o * o * e[0] + 2 * o * n * e[2] + n * n * e[4],
        y: o * o * e[1] + 2 * o * n * e[3] + n * n * e[5]
      };
    } else {
      const o = 1 - n, s = o * o, a = n * n;
      return {
        x: s * o * e[0] + 3 * s * n * e[2] + 3 * o * a * e[4] + a * n * e[6],
        y: s * o * e[1] + 3 * s * n * e[3] + 3 * o * a * e[5] + a * n * e[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(e, n) {
    this.state.previousPosition = this.state.position;
    const r = this.state.smoothedValue * this.config.smoothing + e * (1 - this.config.smoothing);
    this.state.smoothedValue = r, this.config.movementMode === "amplitude" ? this.updateAmplitudeMode(r) : this.updateAccumulateMode(r, n);
    const o = this.getPositionOnPath(this.state.position);
    return this.state.x = o.x, this.state.y = o.y, this.state.angle = o.angle, { ...this.state };
  }
  updateAmplitudeMode(e) {
    let n = Math.pow(e, this.config.amplitudeCurve);
    if (n > this.releaseState)
      this.releaseState = n;
    else {
      const o = 1 - this.config.release * 0.95;
      this.releaseState *= o;
    }
    const r = Math.max(n, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, r * this.config.sensitivity));
  }
  updateAccumulateMode(e, n) {
    this.config.flipOnBeat && n && e > this.config.beatThreshold && (this.state.direction *= -1);
    const r = e * this.config.sensitivity * 0.02 * this.state.direction;
    let o = this.state.position + r;
    o > 1 ? (o = 2 - o, this.state.direction = -1) : o < 0 && (o = -o, this.state.direction = 1), this.state.position = Math.max(0, Math.min(1, o));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(e) {
    if (e = Math.max(0, Math.min(1, e)), this.pathSegments.length === 0)
      return { x: 0, y: 0, angle: 0 };
    let n = this.pathSegments[0];
    for (const c of this.pathSegments)
      if (c.type !== "M" && e >= c.startT && e <= c.endT) {
        n = c;
        break;
      }
    if (n.type === "M")
      return { x: n.points[0], y: n.points[1], angle: 0 };
    const r = n.endT > n.startT ? (e - n.startT) / (n.endT - n.startT) : 0;
    let o, s, a, l;
    switch (n.type) {
      case "L":
        o = n.points[0] + (n.points[2] - n.points[0]) * r, s = n.points[1] + (n.points[3] - n.points[1]) * r, a = n.points[2] - n.points[0], l = n.points[3] - n.points[1];
        break;
      case "Q": {
        const c = this.getBezierPoint(n.points, r, 2);
        o = c.x, s = c.y;
        const d = 1 - r;
        a = 2 * d * (n.points[2] - n.points[0]) + 2 * r * (n.points[4] - n.points[2]), l = 2 * d * (n.points[3] - n.points[1]) + 2 * r * (n.points[5] - n.points[3]);
        break;
      }
      case "C": {
        const c = this.getBezierPoint(n.points, r, 3);
        o = c.x, s = c.y;
        const d = 1 - r, h = d * d, p = r * r;
        a = 3 * h * (n.points[2] - n.points[0]) + 6 * d * r * (n.points[4] - n.points[2]) + 3 * p * (n.points[6] - n.points[4]), l = 3 * h * (n.points[3] - n.points[1]) + 6 * d * r * (n.points[5] - n.points[3]) + 3 * p * (n.points[7] - n.points[5]);
        break;
      }
      default:
        o = 0, s = 0, a = 1, l = 0;
    }
    const u = Math.atan2(l, a);
    return { x: o, y: s, angle: u };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(e = 5) {
    if (!this.config.motionBlur) return [];
    const n = [], r = this.state.previousPosition, o = this.state.position;
    for (let s = 0; s <= e; s++) {
      const a = r + (o - r) * (s / e), l = this.getPositionOnPath(a), u = s / e * this.config.motionBlurStrength;
      n.push({ x: l.x, y: l.y, opacity: u });
    }
    return n;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    }, this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(e) {
    Object.assign(this.config, e);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}
const Gn = /* @__PURE__ */ iC("compositor", {
  state: () => ({
    project: X2(1024, 1024),
    comfyuiNodeId: null,
    sourceImage: null,
    depthMap: null,
    isPlaying: !1,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    selectedLayerIds: [],
    selectedKeyframeIds: [],
    currentTool: "select",
    graphEditorVisible: !1,
    historyStack: [],
    historyIndex: -1,
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    audioMappings: /* @__PURE__ */ new Map(),
    peakData: null,
    audioReactiveMappings: [],
    audioReactiveMapper: null,
    pathAnimators: /* @__PURE__ */ new Map()
  }),
  getters: {
    // Project info
    hasProject: (i) => i.sourceImage !== null,
    width: (i) => i.project.composition.width,
    height: (i) => i.project.composition.height,
    frameCount: (i) => i.project.composition.frameCount,
    fps: (i) => i.project.composition.fps,
    duration: (i) => i.project.composition.duration,
    // Current frame
    currentFrame: (i) => i.project.currentFrame,
    currentTime: (i) => i.project.currentFrame / i.project.composition.fps,
    // Layers
    layers: (i) => i.project.layers,
    visibleLayers: (i) => i.project.layers.filter((e) => e.visible),
    // Selection
    selectedLayers: (i) => i.project.layers.filter((e) => i.selectedLayerIds.includes(e.id)),
    selectedLayer: (i) => i.selectedLayerIds.length !== 1 ? null : i.project.layers.find((e) => e.id === i.selectedLayerIds[0]) || null,
    // Assets
    assets: (i) => i.project.assets,
    // History
    canUndo: (i) => i.historyIndex > 0,
    canRedo: (i) => i.historyIndex < i.historyStack.length - 1
  },
  actions: {
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(i) {
      this.comfyuiNodeId = i.node_id, this.sourceImage = i.source_image, this.depthMap = i.depth_map, this.project.composition.width = i.width, this.project.composition.height = i.height, this.project.composition.frameCount = i.frame_count, this.project.composition.duration = i.frame_count / this.project.composition.fps, i.source_image && (this.project.assets.source_image = {
        id: "source_image",
        type: "image",
        source: "comfyui_node",
        nodeId: i.node_id,
        width: i.width,
        height: i.height,
        data: i.source_image
      }), i.depth_map && (this.project.assets.depth_map = {
        id: "depth_map",
        type: "depth_map",
        source: "comfyui_node",
        nodeId: i.node_id,
        width: i.width,
        height: i.height,
        data: i.depth_map
      }), this.project.currentFrame = 0, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), console.log("[Weyl] Loaded inputs from ComfyUI:", {
        width: i.width,
        height: i.height,
        frameCount: i.frame_count
      }), this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(i, e) {
      const r = {
        id: `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: e || `${i.charAt(0).toUpperCase() + i.slice(1)} ${this.project.layers.length + 1}`,
        type: i,
        visible: !0,
        locked: !1,
        solo: !1,
        inPoint: 0,
        outPoint: this.project.composition.frameCount - 1,
        parentId: null,
        blendMode: "normal",
        opacity: wi("opacity", 100, "number"),
        transform: G2(),
        properties: [],
        data: null
      };
      return this.project.layers.unshift(r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), r;
    },
    /**
     * Delete a layer
     */
    deleteLayer(i) {
      const e = this.project.layers.findIndex((n) => n.id === i);
      e !== -1 && (this.project.layers.splice(e, 1), this.selectedLayerIds = this.selectedLayerIds.filter((n) => n !== i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Update layer properties
     */
    updateLayer(i, e) {
      const n = this.project.layers.find((r) => r.id === i);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Reorder layers
     */
    moveLayer(i, e) {
      const n = this.project.layers.findIndex((o) => o.id === i);
      if (n === -1) return;
      const [r] = this.project.layers.splice(n, 1);
      this.project.layers.splice(e, 0, r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Selection
     */
    selectLayer(i, e = !1) {
      e ? this.selectedLayerIds.includes(i) || this.selectedLayerIds.push(i) : this.selectedLayerIds = [i];
    },
    deselectLayer(i) {
      this.selectedLayerIds = this.selectedLayerIds.filter((e) => e !== i);
    },
    clearSelection() {
      this.selectedLayerIds = [], this.selectedKeyframeIds = [];
    },
    /**
     * Playback controls
     */
    play() {
      this.isPlaying || (this.isPlaying = !0, this.playbackStartTime = performance.now(), this.playbackStartFrame = this.project.currentFrame, this.playbackLoop());
    },
    pause() {
      this.isPlaying = !1, this.playbackRequestId !== null && (cancelAnimationFrame(this.playbackRequestId), this.playbackRequestId = null);
    },
    togglePlayback() {
      this.isPlaying ? this.pause() : this.play();
    },
    /**
     * Animation loop for playback
     */
    playbackLoop() {
      if (!this.isPlaying) return;
      const i = performance.now() - (this.playbackStartTime || 0), e = this.project.composition.fps, n = this.project.composition.frameCount, r = Math.floor(i / 1e3 * e);
      let o = this.playbackStartFrame + r;
      o >= n && (o = 0, this.playbackStartFrame = 0, this.playbackStartTime = performance.now()), this.project.currentFrame = o, this.playbackRequestId = requestAnimationFrame(() => this.playbackLoop());
    },
    setFrame(i) {
      this.project.currentFrame = Math.max(0, Math.min(i, this.project.composition.frameCount - 1));
    },
    nextFrame() {
      this.project.currentFrame < this.project.composition.frameCount - 1 && this.project.currentFrame++;
    },
    prevFrame() {
      this.project.currentFrame > 0 && this.project.currentFrame--;
    },
    goToStart() {
      this.project.currentFrame = 0;
    },
    goToEnd() {
      this.project.currentFrame = this.project.composition.frameCount - 1;
    },
    /**
     * Tool selection
     */
    setTool(i) {
      this.currentTool = i;
    },
    /**
     * History management
     */
    pushHistory() {
      this.historyIndex < this.historyStack.length - 1 && (this.historyStack = this.historyStack.slice(0, this.historyIndex + 1));
      const i = JSON.parse(JSON.stringify(this.project));
      this.historyStack.push(i), this.historyIndex = this.historyStack.length - 1;
      const e = 50;
      this.historyStack.length > e && (this.historyStack = this.historyStack.slice(-e), this.historyIndex = this.historyStack.length - 1);
    },
    undo() {
      this.historyIndex <= 0 || (this.historyIndex--, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    redo() {
      this.historyIndex >= this.historyStack.length - 1 || (this.historyIndex++, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    /**
     * Project serialization
     */
    exportProject() {
      return JSON.stringify(this.project, null, 2);
    },
    importProject(i) {
      try {
        const e = JSON.parse(i);
        this.project = e, this.pushHistory();
      } catch (e) {
        console.error("[Weyl] Failed to import project:", e);
      }
    },
    /**
     * Toggle graph editor visibility
     */
    toggleGraphEditor() {
      this.graphEditorVisible = !this.graphEditorVisible;
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(i) {
      return Qs(i, this.project.currentFrame);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(i, e, n) {
      const r = this.project.layers.find((l) => l.id === i);
      if (!r) return null;
      let o;
      if (e === "position" ? o = r.transform.position : e === "scale" ? o = r.transform.scale : e === "rotation" ? o = r.transform.rotation : e === "opacity" ? o = r.opacity : o = r.properties.find((l) => l.name === e), !o) return null;
      o.animated = !0;
      const s = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: this.project.currentFrame,
        value: n,
        interpolation: "bezier",
        inHandle: { x: 0.33, y: 0.33 },
        outHandle: { x: 0.33, y: 0.33 },
        handlesBroken: !1
      }, a = o.keyframes.findIndex((l) => l.frame === this.project.currentFrame);
      return a >= 0 ? o.keyframes[a] = s : (o.keyframes.push(s), o.keyframes.sort((l, u) => l.frame - u.frame)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), s;
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(i, e, n) {
      const r = this.project.layers.find((a) => a.id === i);
      if (!r) return;
      let o;
      if (e === "position" ? o = r.transform.position : e === "scale" ? o = r.transform.scale : e === "rotation" ? o = r.transform.rotation : e === "opacity" ? o = r.opacity : o = r.properties.find((a) => a.name === e), !o) return;
      const s = o.keyframes.findIndex((a) => a.id === n);
      s >= 0 && (o.keyframes.splice(s, 1), o.keyframes.length === 0 && (o.animated = !1)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(i = "Text") {
      const e = this.createLayer("text", i.substring(0, 20)), n = {
        text: i,
        fontFamily: "Arial",
        fontSize: 48,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        pathLayerId: null,
        pathOffset: 0,
        pathAlign: "left"
      };
      return e.data = n, e.properties.push(wi("fontSize", 48, "number")), e.properties.push(wi("pathOffset", 0, "number")), e.properties.push(wi("letterSpacing", 0, "number")), e;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const i = this.createLayer("spline"), e = {
        pathData: "",
        controlPoints: [],
        closed: !1,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      return i.data = e, i;
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const i = this.createLayer("particles", "Particle System"), e = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: !1,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          x: 0.5,
          y: 0.5,
          direction: 270,
          spread: 30,
          speed: 330,
          speedVariance: 50,
          size: 17,
          sizeVariance: 5,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 10,
          enabled: !0,
          burstOnBeat: !1,
          burstCount: 20
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: !1,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: !1,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: !1,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: !1,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: !0
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      return i.data = e, i;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(i, e) {
      const n = this.project.layers.find((o) => o.id === i);
      if (!n || n.type !== "particles") return;
      const r = n.data;
      Object.assign(r, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(i, e) {
      const n = this.project.layers.find((o) => o.id === i);
      if (!n || n.type !== "particles") return;
      n.data.emitters.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(i, e, n) {
      const r = this.project.layers.find((a) => a.id === i);
      if (!r || r.type !== "particles") return;
      const s = r.data.emitters.find((a) => a.id === e);
      s && (Object.assign(s, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(i, e) {
      const n = this.project.layers.find((o) => o.id === i);
      if (!n || n.type !== "particles") return;
      const r = n.data;
      r.emitters = r.emitters.filter((o) => o.id !== e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(i = "", e = "") {
      const n = this.createLayer("depthflow", "Depthflow"), r = {
        sourceLayerId: i,
        depthLayerId: e,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: !0
        },
        animatedZoom: wi("zoom", 1, "number"),
        animatedOffsetX: wi("offsetX", 0, "number"),
        animatedOffsetY: wi("offsetY", 0, "number"),
        animatedRotation: wi("rotation", 0, "number"),
        animatedDepthScale: wi("depthScale", 1, "number")
      };
      return n.data = r, n;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(i, e) {
      const n = this.project.layers.find((o) => o.id === i);
      if (!n || n.type !== "depthflow") return;
      const r = n.data;
      Object.assign(r.config, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // AUDIO ACTIONS
    // ============================================================
    /**
     * Load audio file for analysis
     */
    async loadAudio(i) {
      try {
        this.audioFile = i, this.audioBuffer = await L2(i), this.audioAnalysis = await A2(this.audioBuffer, this.project.composition.fps), this.initializeAudioReactiveMapper(), console.log("[Weyl] Audio loaded:", {
          duration: this.audioBuffer.duration,
          bpm: this.audioAnalysis.bpm,
          frameCount: this.audioAnalysis.frameCount
        });
      } catch (e) {
        console.error("[Weyl] Failed to load audio:", e), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioReactiveMapper = null;
      }
    },
    /**
     * Clear loaded audio
     */
    clearAudio() {
      this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioMappings.clear();
    },
    /**
     * Get audio feature value at current frame
     */
    getAudioFeatureAtFrame(i, e) {
      return this.audioAnalysis ? Gh(this.audioAnalysis, i, e ?? this.project.currentFrame) : 0;
    },
    /**
     * Apply audio reactivity mapping to particle layer
     */
    applyAudioToParticles(i, e) {
      const n = this.audioMappings.get(i) || [];
      n.push(e), this.audioMappings.set(i, n);
    },
    /**
     * Remove audio mapping (legacy)
     */
    removeLegacyAudioMapping(i, e) {
      const n = this.audioMappings.get(i);
      n && (n.splice(e, 1), n.length === 0 && this.audioMappings.delete(i));
    },
    /**
     * Get audio mappings for a layer (legacy)
     */
    getAudioMappingsForLayer(i) {
      return this.audioMappings.get(i) || [];
    },
    // ============================================================
    // NEW AUDIO REACTIVE SYSTEM
    // ============================================================
    /**
     * Set peak data
     */
    setPeakData(i) {
      this.peakData = i, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(i);
    },
    /**
     * Detect peaks with config
     */
    detectAudioPeaks(i) {
      if (!this.audioAnalysis) return null;
      const e = this.audioAnalysis.amplitudeEnvelope, n = U2(e, i);
      return this.peakData = n, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(n), n;
    },
    /**
     * Add new audio mapping
     */
    addAudioMapping(i) {
      this.audioReactiveMappings.push(i), this.audioReactiveMapper && this.audioReactiveMapper.addMapping(i);
    },
    /**
     * Remove audio mapping by ID
     */
    removeAudioMapping(i) {
      const e = this.audioReactiveMappings.findIndex((n) => n.id === i);
      e >= 0 && this.audioReactiveMappings.splice(e, 1), this.audioReactiveMapper && this.audioReactiveMapper.removeMapping(i);
    },
    /**
     * Update audio mapping
     */
    updateAudioMapping(i, e) {
      const n = this.audioReactiveMappings.find((r) => r.id === i);
      n && Object.assign(n, e), this.audioReactiveMapper && this.audioReactiveMapper.updateMapping(i, e);
    },
    /**
     * Get all audio mappings
     */
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    /**
     * Get mapped value at frame
     */
    getMappedValueAtFrame(i, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValueAtFrame(i, e) : 0;
    },
    /**
     * Get all mapped values at current frame
     */
    getAllMappedValuesAtFrame(i) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getAllValuesAtFrame(i ?? this.project.currentFrame) : /* @__PURE__ */ new Map();
    },
    /**
     * Get active mappings for a specific layer
     */
    getActiveMappingsForLayer(i) {
      return this.audioReactiveMappings.filter(
        (e) => e.enabled && (e.targetLayerId === i || e.targetLayerId === void 0)
      );
    },
    /**
     * Check if current frame is a beat
     */
    isBeatAtCurrentFrame() {
      return this.audioAnalysis ? Tg(this.audioAnalysis, this.project.currentFrame) : !1;
    },
    // ============================================================
    // PATH ANIMATOR ACTIONS
    // ============================================================
    /**
     * Create path animator for a layer
     */
    createPathAnimator(i, e = {}) {
      const n = new nk(e);
      this.pathAnimators.set(i, n);
    },
    /**
     * Set path for an animator
     */
    setPathAnimatorPath(i, e) {
      const n = this.pathAnimators.get(i);
      n && n.setPath(e);
    },
    /**
     * Update path animator config
     */
    updatePathAnimatorConfig(i, e) {
      const n = this.pathAnimators.get(i);
      n && n.setConfig(e);
    },
    /**
     * Remove path animator
     */
    removePathAnimator(i) {
      this.pathAnimators.delete(i);
    },
    /**
     * Get path animator for layer
     */
    getPathAnimator(i) {
      return this.pathAnimators.get(i);
    },
    /**
     * Update all path animators for current frame
     */
    updatePathAnimators() {
      if (!this.audioAnalysis) return;
      const i = this.project.currentFrame, e = Gh(this.audioAnalysis, "amplitude", i), n = Tg(this.audioAnalysis, i);
      for (const [r, o] of this.pathAnimators)
        o.update(e, n);
    },
    /**
     * Reset all path animators
     */
    resetPathAnimators() {
      for (const i of this.pathAnimators.values())
        i.reset();
    },
    /**
     * Initialize audio reactive mapper when audio is loaded
     */
    initializeAudioReactiveMapper() {
      if (this.audioAnalysis) {
        this.audioReactiveMapper = new ek(this.audioAnalysis);
        for (const i of this.audioReactiveMappings)
          this.audioReactiveMapper.addMapping(i);
        this.peakData && this.audioReactiveMapper.setPeakData(this.peakData);
      }
    }
  }
}), ik = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useCompositorStore: Gn
}, Symbol.toStringTag, { value: "Module" }));
async function Dg(i) {
  try {
    const e = await i.requestDevice(), n = e.limits.maxBufferSize;
    return e.destroy(), Math.round(n * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function rk() {
  if ("gpu" in navigator)
    try {
      const r = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (r) {
        let o = "";
        if ("info" in r) {
          const s = r.info;
          o = (s == null ? void 0 : s.device) || (s == null ? void 0 : s.description) || "";
        }
        return o.includes("RTX 50") || o.toLowerCase().includes("blackwell") || o.includes("B100") || o.includes("B200") ? {
          tier: "blackwell",
          vram: await Dg(r),
          features: ["fp4_tensor", "webgpu", "cuda_12"]
        } : {
          tier: "webgpu",
          vram: await Dg(r),
          features: ["webgpu"]
        };
      }
    } catch (n) {
      console.warn("[Weyl] WebGPU detection failed:", n);
    }
  const e = document.createElement("canvas").getContext("webgl2");
  if (e) {
    const n = e.getExtension("WEBGL_debug_renderer_info"), r = n ? e.getParameter(n.UNMASKED_RENDERER_WEBGL) : "Unknown";
    return console.log("[Weyl] WebGL renderer:", r), {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}
const ok = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function sk(i, e, n) {
  const r = e / 2, o = n / 2;
  return {
    id: i,
    name: "Camera 1",
    type: "two-node",
    position: { x: r, y: o, z: -1500 },
    pointOfInterest: { x: r, y: o, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: !1,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: !1
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function ak() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
const lk = { class: "project-panel" }, uk = { class: "panel-header" }, ck = { class: "header-actions" }, dk = {
  key: 0,
  class: "search-bar"
}, hk = { class: "panel-content" }, fk = { class: "folder-tree" }, pk = ["onClick", "onDblclick"], mk = ["onClick"], gk = { class: "folder-name" }, vk = { class: "item-count" }, yk = {
  key: 0,
  class: "folder-contents"
}, bk = ["onClick", "onDblclick", "onDragstart"], wk = { class: "item-icon" }, _k = { class: "item-name" }, xk = { class: "item-info" }, Sk = ["onClick", "onDblclick", "onDragstart"], Ck = { class: "item-icon" }, kk = { class: "item-name" }, Ok = { class: "item-info" }, Ek = {
  key: 0,
  class: "empty-state"
}, Tk = {
  key: 1,
  class: "panel-footer"
}, Dk = { class: "item-details" }, $k = { class: "detail-label" }, Mk = { class: "detail-info" }, Pk = /* @__PURE__ */ tn({
  __name: "ProjectPanel",
  setup(i) {
    Gn();
    const e = re(!1), n = re(""), r = re(null), o = re(["compositions", "footage"]), s = re([
      {
        id: "compositions",
        name: "Compositions",
        items: [
          { id: "comp-1", name: "Main Comp", type: "composition", width: 1920, height: 1080, fps: 30, duration: 300 }
        ]
      },
      {
        id: "footage",
        name: "Footage",
        items: []
      },
      {
        id: "solids",
        name: "Solids",
        items: []
      }
    ]), a = re([]), l = Ee(() => {
      if (!n.value) return s.value;
      const g = n.value.toLowerCase();
      return s.value.map((k) => ({
        ...k,
        items: k.items.filter(
          (_) => _.name.toLowerCase().includes(g)
        )
      })).filter((k) => k.items.length > 0 || k.name.toLowerCase().includes(g));
    }), u = Ee(() => {
      if (!n.value) return a.value;
      const g = n.value.toLowerCase();
      return a.value.filter(
        (k) => k.name.toLowerCase().includes(g)
      );
    }), c = Ee(() => {
      if (!r.value) return null;
      for (const k of s.value) {
        const _ = k.items.find((S) => S.id === r.value);
        if (_)
          return {
            name: _.name,
            info: y(_)
          };
      }
      const g = a.value.find((k) => k.id === r.value);
      return g ? {
        name: g.name,
        info: y(g)
      } : null;
    });
    function d(g) {
      const k = o.value.indexOf(g);
      k >= 0 ? o.value.splice(k, 1) : o.value.push(g);
    }
    function h(g) {
      r.value = g;
    }
    function p(g) {
      g.type === "composition" && console.log("Opening composition:", g.name);
    }
    function m() {
      console.log("Create new item");
    }
    function v(g) {
      return {
        composition: "",
        footage: "",
        solid: "",
        audio: "",
        folder: ""
      }[g] || "";
    }
    function y(g) {
      if (g.type === "composition" || g.type === "footage") {
        const k = [];
        if (g.width && g.height && k.push(`${g.width}${g.height}`), g.fps && k.push(`${g.fps}fps`), g.duration) {
          const _ = g.duration / (g.fps || 30);
          k.push(`${_.toFixed(1)}s`);
        }
        return k.join("  ");
      }
      return "";
    }
    function w(g, k) {
      var _;
      (_ = k.dataTransfer) == null || _.setData("application/project-item", JSON.stringify(g));
    }
    return (g, k) => ($(), A("div", lk, [
      f("div", uk, [
        k[2] || (k[2] = f("span", { class: "panel-title" }, "Project", -1)),
        f("div", ck, [
          f("button", {
            onClick: m,
            title: "New Item"
          }, "+"),
          f("button", {
            onClick: k[0] || (k[0] = (_) => e.value = !e.value),
            title: "Search"
          }, "")
        ])
      ]),
      e.value ? ($(), A("div", dk, [
        ot(f("input", {
          type: "text",
          "onUpdate:modelValue": k[1] || (k[1] = (_) => n.value = _),
          placeholder: "Search project...",
          class: "search-input"
        }, null, 512), [
          [Qt, n.value]
        ])
      ])) : ve("", !0),
      f("div", hk, [
        f("div", fk, [
          ($(!0), A(Fe, null, Ke(l.value, (_) => ($(), A("div", {
            key: _.id,
            class: "folder-item"
          }, [
            f("div", {
              class: _e(["folder-header", { selected: r.value === _.id }]),
              onClick: (S) => h(_.id),
              onDblclick: (S) => d(_.id)
            }, [
              f("span", {
                class: "expand-icon",
                onClick: tt((S) => d(_.id), ["stop"])
              }, Q(o.value.includes(_.id) ? "" : ""), 9, mk),
              k[3] || (k[3] = f("span", { class: "folder-icon" }, "", -1)),
              f("span", gk, Q(_.name), 1),
              f("span", vk, Q(_.items.length), 1)
            ], 42, pk),
            o.value.includes(_.id) ? ($(), A("div", yk, [
              ($(!0), A(Fe, null, Ke(_.items, (S) => ($(), A("div", {
                key: S.id,
                class: _e(["project-item", { selected: r.value === S.id }]),
                onClick: (b) => h(S.id),
                onDblclick: (b) => p(S),
                draggable: "true",
                onDragstart: (b) => w(S, b)
              }, [
                f("span", wk, Q(v(S.type)), 1),
                f("span", _k, Q(S.name), 1),
                f("span", xk, Q(y(S)), 1)
              ], 42, bk))), 128))
            ])) : ve("", !0)
          ]))), 128)),
          ($(!0), A(Fe, null, Ke(u.value, (_) => ($(), A("div", {
            key: _.id,
            class: _e(["project-item", { selected: r.value === _.id }]),
            onClick: (S) => h(_.id),
            onDblclick: (S) => p(_),
            draggable: "true",
            onDragstart: (S) => w(_, S)
          }, [
            f("span", Ck, Q(v(_.type)), 1),
            f("span", kk, Q(_.name), 1),
            f("span", Ok, Q(y(_)), 1)
          ], 42, Sk))), 128))
        ]),
        a.value.length === 0 ? ($(), A("div", Ek, [...k[4] || (k[4] = [
          f("p", null, "No items in project", -1),
          f("p", { class: "hint" }, "Import footage or create compositions", -1)
        ])])) : ve("", !0)
      ]),
      c.value ? ($(), A("div", Tk, [
        f("div", Dk, [
          f("span", $k, Q(c.value.name), 1),
          f("span", Mk, Q(c.value.info), 1)
        ])
      ])) : ve("", !0)
    ]));
  }
}), cn = (i, e) => {
  const n = i.__vccOpts || i;
  for (const [r, o] of e)
    n[r] = o;
  return n;
}, Ik = /* @__PURE__ */ cn(Pk, [["__scopeId", "data-v-44ad51d4"]]), bb = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: !0 },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: !1 },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: !0 }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: !0 },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: !1 },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: !1 }
    ]
  },
  sharpen: {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: !0 }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: !0 },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: !0 },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: !0 },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Use Legacy", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: !1 },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: !0, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  curves: {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: !1 }
      // Note: Actual curve control would be a custom component
    ]
  },
  levels: {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: !1 },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: !0 },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  tint: {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Distort
  transform: {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: !0 },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  warp: {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: !1 },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: !1 },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 }
    ]
  },
  // Generate
  fill: {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: !0 },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: !0 },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: !1 },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Stylize
  glow: {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: !0 },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: !0 },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: !0 },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: !1 },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: !0 }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: !0 },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: !0 },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: !0 },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: !0 },
      { name: "Shadow Only", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: !1 },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: !1 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: !0 },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: !0 },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: !0 },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: !0 },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: !0 }
    ]
  }
}, $g = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  distort: { label: "Distort", icon: "D", description: "Distortion effects" },
  generate: { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  keying: { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  matte: { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  perspective: { label: "Perspective", icon: "P", description: "3D perspective effects" },
  stylize: { label: "Stylize", icon: "S", description: "Stylization effects" },
  time: { label: "Time", icon: "T", description: "Time-based effects" },
  transition: { label: "Transition", icon: "Tr", description: "Transition effects" },
  utility: { label: "Utility", icon: "U", description: "Utility effects" }
};
function Lk(i) {
  const e = bb[i];
  return e ? {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    name: e.name,
    category: e.category,
    enabled: !0,
    expanded: !0,
    parameters: e.parameters.map((n, r) => ({
      ...n,
      id: `param-${r}`,
      value: n.defaultValue
    })),
    fragmentShader: e.fragmentShader
  } : null;
}
const Ak = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
], Vk = { class: "effects-panel" }, Fk = { class: "panel-header" }, jk = { class: "header-actions" }, Rk = { class: "panel-content" }, Nk = { class: "tabs" }, zk = {
  key: 0,
  class: "effects-list"
}, Bk = ["onClick"], Hk = { class: "expand-icon" }, Uk = { class: "category-icon" }, Wk = { class: "category-name" }, Gk = { class: "effect-count" }, Xk = {
  key: 0,
  class: "category-effects"
}, Yk = ["onDblclick", "onDragstart"], Kk = { class: "effect-name" }, qk = ["onClick", "title"], Zk = {
  key: 1,
  class: "presets-list"
}, Jk = ["onClick"], Qk = { class: "expand-icon" }, eO = { class: "category-name" }, tO = { class: "preset-count" }, nO = {
  key: 0,
  class: "category-presets"
}, iO = ["onDblclick", "onDragstart"], rO = { class: "preset-info" }, oO = { class: "preset-name" }, sO = { class: "preset-description" }, aO = {
  key: 2,
  class: "favorites-list"
}, lO = {
  key: 0,
  class: "empty-favorites"
}, uO = ["onDblclick", "onDragstart"], cO = { class: "category-badge" }, dO = { class: "effect-name" }, hO = ["onClick"], fO = /* @__PURE__ */ tn({
  __name: "EffectsPanel",
  setup(i) {
    const e = Gn(), n = re("effects"), r = re(""), o = re(["blur-sharpen", "color-correction"]), s = re(["Fade", "Scale"]), a = re([]);
    Wn(() => {
      const S = localStorage.getItem("effect-favorites");
      if (S)
        try {
          a.value = JSON.parse(S);
        } catch {
          a.value = [];
        }
    });
    function l() {
      localStorage.setItem("effect-favorites", JSON.stringify(a.value));
    }
    const u = Ee(() => Object.entries(bb).map(([S, b]) => ({
      key: S,
      name: b.name,
      category: b.category,
      description: b.description
    }))), c = Ee(() => {
      const S = r.value.toLowerCase();
      return Object.entries($g).map(([b, C]) => {
        const x = u.value.filter((I) => !(I.category !== b || S && !I.name.toLowerCase().includes(S)));
        return {
          key: b,
          label: C.label,
          icon: C.icon,
          effects: x
        };
      }).filter((b) => b.effects.length > 0);
    }), d = Ee(() => {
      const S = r.value.toLowerCase(), b = {};
      for (const C of Ak)
        S && !C.name.toLowerCase().includes(S) || (b[C.category] || (b[C.category] = []), b[C.category].push(C));
      return Object.entries(b).map(([C, x]) => ({
        category: C,
        presets: x
      }));
    }), h = Ee(() => u.value.filter((S) => a.value.includes(S.key)));
    function p(S) {
      const b = o.value.indexOf(S);
      b >= 0 ? o.value.splice(b, 1) : o.value.push(S);
    }
    function m(S) {
      const b = s.value.indexOf(S);
      b >= 0 ? s.value.splice(b, 1) : s.value.push(S);
    }
    function v(S) {
      const b = a.value.indexOf(S);
      b >= 0 ? a.value.splice(b, 1) : a.value.push(S), l();
    }
    function y(S) {
      var b;
      return ((b = $g[S]) == null ? void 0 : b.icon) || "?";
    }
    function w(S) {
      const b = Lk(S);
      if (!b) return;
      const C = e.selectedLayer;
      if (!C) {
        console.warn("No layer selected to apply effect");
        return;
      }
      C.effects || (C.effects = []), C.effects.push(b);
    }
    function g(S) {
      if (!e.selectedLayer) {
        console.warn("No layer selected to apply preset");
        return;
      }
      console.log("Applying preset:", S.name);
    }
    function k(S, b) {
      var C;
      (C = b.dataTransfer) == null || C.setData("application/effect", S);
    }
    function _(S, b) {
      var C;
      (C = b.dataTransfer) == null || C.setData("application/preset", JSON.stringify(S));
    }
    return (S, b) => ($(), A("div", Vk, [
      f("div", Fk, [
        b[4] || (b[4] = f("span", { class: "panel-title" }, "Effects & Presets", -1)),
        f("div", jk, [
          ot(f("input", {
            type: "text",
            "onUpdate:modelValue": b[0] || (b[0] = (C) => r.value = C),
            placeholder: "Search...",
            class: "search-input"
          }, null, 512), [
            [Qt, r.value]
          ])
        ])
      ]),
      f("div", Rk, [
        f("div", Nk, [
          f("button", {
            class: _e({ active: n.value === "effects" }),
            onClick: b[1] || (b[1] = (C) => n.value = "effects")
          }, " Effects ", 2),
          f("button", {
            class: _e({ active: n.value === "presets" }),
            onClick: b[2] || (b[2] = (C) => n.value = "presets")
          }, " Presets ", 2),
          f("button", {
            class: _e({ active: n.value === "favorites" }),
            onClick: b[3] || (b[3] = (C) => n.value = "favorites")
          }, " Favorites ", 2)
        ]),
        n.value === "effects" ? ($(), A("div", zk, [
          ($(!0), A(Fe, null, Ke(c.value, (C) => ($(), A("div", {
            key: C.key,
            class: "effect-category"
          }, [
            f("div", {
              class: "category-header",
              onClick: (x) => p(C.key)
            }, [
              f("span", Hk, Q(o.value.includes(C.key) ? "" : ""), 1),
              f("span", Uk, Q(C.icon), 1),
              f("span", Wk, Q(C.label), 1),
              f("span", Gk, Q(C.effects.length), 1)
            ], 8, Bk),
            o.value.includes(C.key) ? ($(), A("div", Xk, [
              ($(!0), A(Fe, null, Ke(C.effects, (x) => ($(), A("div", {
                key: x.key,
                class: _e(["effect-item", { favorite: a.value.includes(x.key) }]),
                onDblclick: (I) => w(x.key),
                onDragstart: (I) => k(x.key, I),
                draggable: "true"
              }, [
                f("span", Kk, Q(x.name), 1),
                f("button", {
                  class: "favorite-btn",
                  onClick: tt((I) => v(x.key), ["stop"]),
                  title: a.value.includes(x.key) ? "Remove from favorites" : "Add to favorites"
                }, Q(a.value.includes(x.key) ? "" : ""), 9, qk)
              ], 42, Yk))), 128))
            ])) : ve("", !0)
          ]))), 128))
        ])) : n.value === "presets" ? ($(), A("div", Zk, [
          ($(!0), A(Fe, null, Ke(d.value, (C) => ($(), A("div", {
            key: C.category,
            class: "preset-category"
          }, [
            f("div", {
              class: "category-header",
              onClick: (x) => m(C.category)
            }, [
              f("span", Qk, Q(s.value.includes(C.category) ? "" : ""), 1),
              f("span", eO, Q(C.category), 1),
              f("span", tO, Q(C.presets.length), 1)
            ], 8, Jk),
            s.value.includes(C.category) ? ($(), A("div", nO, [
              ($(!0), A(Fe, null, Ke(C.presets, (x) => ($(), A("div", {
                key: x.id,
                class: "preset-item",
                onDblclick: (I) => g(x),
                onDragstart: (I) => _(x, I),
                draggable: "true"
              }, [
                b[5] || (b[5] = f("div", { class: "preset-preview" }, [
                  f("span", { class: "preview-icon" }, "")
                ], -1)),
                f("div", rO, [
                  f("span", oO, Q(x.name), 1),
                  f("span", sO, Q(x.description), 1)
                ])
              ], 40, iO))), 128))
            ])) : ve("", !0)
          ]))), 128))
        ])) : n.value === "favorites" ? ($(), A("div", aO, [
          h.value.length === 0 ? ($(), A("div", lO, [...b[6] || (b[6] = [
            f("p", null, "No favorites yet", -1),
            f("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
          ])])) : ve("", !0),
          ($(!0), A(Fe, null, Ke(h.value, (C) => ($(), A("div", {
            key: C.key,
            class: "effect-item",
            onDblclick: (x) => w(C.key),
            onDragstart: (x) => k(C.key, x),
            draggable: "true"
          }, [
            f("span", cO, Q(y(C.category)), 1),
            f("span", dO, Q(C.name), 1),
            f("button", {
              class: "favorite-btn active",
              onClick: tt((x) => v(C.key), ["stop"])
            }, "  ", 8, hO)
          ], 40, uO))), 128))
        ])) : ve("", !0)
      ]),
      b[7] || (b[7] = f("div", { class: "panel-footer" }, [
        f("span", { class: "info-text" }, "Double-click or drag to apply")
      ], -1))
    ]));
  }
}), pO = /* @__PURE__ */ cn(fO, [["__scopeId", "data-v-b66ebaa1"]]), mO = ["value", "min", "max", "step", "disabled"], gO = {
  key: 1,
  class: "scrub-unit"
}, vO = /* @__PURE__ */ tn({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -1 / 0 },
    max: { default: 1 / 0 },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(i, { emit: e }) {
    const n = i, r = e, o = re(!1), s = re(0), a = re(0), l = Ee(() => n.default ?? n.modelValue), u = Ee(() => n.default !== void 0), c = Ee(() => Number.isInteger(n.modelValue) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function d(_) {
      return Math.max(n.min, Math.min(n.max, _));
    }
    function h(_) {
      const S = Math.pow(10, n.precision);
      return Math.round(_ * S) / S;
    }
    function p(_) {
      n.disabled || (o.value = !0, s.value = _.clientX, a.value = n.modelValue, document.addEventListener("mousemove", m), document.addEventListener("mouseup", v), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function m(_) {
      const S = _.clientX - s.value;
      let b = n.sensitivity;
      _.shiftKey && (b *= 10), (_.ctrlKey || _.metaKey) && (b *= 0.1);
      const C = S * n.step * b * 0.5, x = h(d(a.value + C));
      x !== n.modelValue && r("update:modelValue", x);
    }
    function v() {
      o.value = !1, document.removeEventListener("mousemove", m), document.removeEventListener("mouseup", v), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function y(_) {
      const S = _.target, b = parseFloat(S.value);
      isNaN(b) || r("update:modelValue", h(d(b)));
    }
    function w(_) {
      if (n.disabled) return;
      let S = 0;
      _.key === "ArrowUp" ? S = n.step : _.key === "ArrowDown" && (S = -n.step), S !== 0 && (_.preventDefault(), _.shiftKey && (S *= 10), (_.ctrlKey || _.metaKey) && (S *= 0.1), r("update:modelValue", h(d(n.modelValue + S))));
    }
    function g(_) {
      const S = _.target, b = parseFloat(S.value);
      isNaN(b) && (S.value = c.value.toString());
    }
    function k() {
      n.default !== void 0 && r("update:modelValue", n.default);
    }
    return (_, S) => ($(), A("div", {
      class: _e(["scrubable-number", { disabled: i.disabled }])
    }, [
      i.label ? ($(), A("label", {
        key: 0,
        class: _e(["scrub-label", { scrubbing: o.value }]),
        onMousedown: p
      }, Q(i.label), 35)) : ve("", !0),
      f("input", {
        type: "number",
        class: "scrub-input",
        value: c.value,
        min: i.min,
        max: i.max,
        step: i.step,
        disabled: i.disabled,
        onInput: y,
        onKeydown: w,
        onBlur: g
      }, null, 40, mO),
      i.unit ? ($(), A("span", gO, Q(i.unit), 1)) : ve("", !0),
      u.value && i.modelValue !== l.value ? ($(), A("button", {
        key: 2,
        class: "reset-btn",
        onClick: k,
        title: "Reset to default"
      }, [...S[0] || (S[0] = [
        f("i", { class: "pi pi-refresh" }, null, -1)
      ])])) : ve("", !0)
    ], 2));
  }
}), Rt = /* @__PURE__ */ cn(vO, [["__scopeId", "data-v-2a930cf0"]]), yO = ["value", "min", "max", "step", "disabled"], bO = {
  key: 2,
  class: "slider-unit"
}, wO = /* @__PURE__ */ tn({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: !0 },
    gradient: {},
    disabled: { type: Boolean, default: !1 },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(i, { emit: e }) {
    const n = i, r = e, o = re(null), s = re(!1), a = re(!1), l = re(0), u = re(0), c = Ee(() => {
      const C = n.max - n.min;
      return C === 0 ? 0 : (n.modelValue - n.min) / C * 100;
    }), d = Ee(() => Number.isInteger(n.step) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function h(C) {
      return Math.max(n.min, Math.min(n.max, C));
    }
    function p(C) {
      const x = Math.pow(10, n.precision);
      return Math.round(C * x) / x;
    }
    function m(C) {
      n.disabled || (s.value = !0, l.value = C.clientX, u.value = n.modelValue, document.addEventListener("mousemove", v), document.addEventListener("mouseup", y), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function v(C) {
      const x = C.clientX - l.value, I = n.max - n.min;
      let F = 1;
      C.shiftKey && (F *= 10), (C.ctrlKey || C.metaKey) && (F *= 0.1);
      const B = x / 200 * I * F, X = p(h(u.value + B));
      X !== n.modelValue && r("update:modelValue", X);
    }
    function y() {
      s.value = !1, document.removeEventListener("mousemove", v), document.removeEventListener("mouseup", y), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function w(C) {
      if (n.disabled || !o.value) return;
      const x = o.value.getBoundingClientRect(), I = (C.clientX - x.left) / x.width, F = n.min + I * (n.max - n.min);
      r("update:modelValue", p(h(F)));
    }
    function g(C) {
      n.disabled || (a.value = !0, document.addEventListener("mousemove", k), document.addEventListener("mouseup", _), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function k(C) {
      if (!o.value) return;
      const x = o.value.getBoundingClientRect(), I = (C.clientX - x.left) / x.width, F = n.min + Math.max(0, Math.min(1, I)) * (n.max - n.min);
      r("update:modelValue", p(h(F)));
    }
    function _() {
      a.value = !1, document.removeEventListener("mousemove", k), document.removeEventListener("mouseup", _), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function S(C) {
      const x = C.target, I = parseFloat(x.value);
      isNaN(I) || r("update:modelValue", p(h(I)));
    }
    function b(C) {
      const x = C.target, I = parseFloat(x.value);
      isNaN(I) && (x.value = d.value.toString());
    }
    return (C, x) => ($(), A("div", {
      class: _e(["slider-input", { disabled: i.disabled }])
    }, [
      i.label ? ($(), A("label", {
        key: 0,
        class: _e(["slider-label", { scrubbing: s.value }]),
        onMousedown: m
      }, Q(i.label), 35)) : ve("", !0),
      f("div", {
        class: "slider-track",
        ref_key: "trackRef",
        ref: o,
        onMousedown: w
      }, [
        f("div", {
          class: "slider-fill",
          style: Pt({ width: c.value + "%", background: i.gradient || void 0 })
        }, null, 4),
        f("div", {
          class: "slider-thumb",
          style: Pt({ left: c.value + "%" }),
          onMousedown: tt(g, ["stop"])
        }, null, 36)
      ], 544),
      i.showValue ? ($(), A("input", {
        key: 1,
        type: "number",
        class: "slider-value",
        value: d.value,
        min: i.min,
        max: i.max,
        step: i.step,
        disabled: i.disabled,
        onInput: S,
        onBlur: b
      }, null, 40, yO)) : ve("", !0),
      i.unit ? ($(), A("span", bO, Q(i.unit), 1)) : ve("", !0)
    ], 2));
  }
}), Kn = /* @__PURE__ */ cn(wO, [["__scopeId", "data-v-9dd40416"]]), _O = { class: "dial-marks" }, xO = {
  key: 0,
  class: "angle-value"
}, SO = ["value", "disabled"], CO = /* @__PURE__ */ tn({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(i, { emit: e }) {
    const n = i, r = e, o = re(null), s = re(!1), a = Ee(() => Math.round(n.modelValue * 10) / 10);
    function l(v) {
      return (v % 360 + 360) % 360;
    }
    function u(v) {
      n.disabled || (s.value = !0, d(v), document.addEventListener("mousemove", c), document.addEventListener("mouseup", h), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function c(v) {
      s.value && d(v);
    }
    function d(v) {
      if (!o.value) return;
      const y = o.value.getBoundingClientRect(), w = y.left + y.width / 2, g = y.top + y.height / 2, k = v.clientX - w, _ = v.clientY - g;
      let S = Math.atan2(k, -_) * (180 / Math.PI);
      S = l(S), v.shiftKey && (S = Math.round(S / 45) * 45), r("update:modelValue", S);
    }
    function h() {
      s.value = !1, document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", h), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function p(v) {
      const y = v.target, w = parseFloat(y.value);
      isNaN(w) || r("update:modelValue", l(w));
    }
    function m(v) {
      const y = v.target, w = parseFloat(y.value);
      isNaN(w) && (y.value = a.value.toString());
    }
    return (v, y) => ($(), A("div", {
      class: _e(["angle-dial", { disabled: i.disabled }])
    }, [
      f("div", {
        class: "dial",
        ref_key: "dialRef",
        ref: o,
        style: Pt({ width: i.size + "px", height: i.size + "px" }),
        onMousedown: u
      }, [
        y[0] || (y[0] = f("div", { class: "dial-ring" }, null, -1)),
        y[1] || (y[1] = f("div", { class: "dial-center" }, null, -1)),
        f("div", {
          class: "dial-indicator",
          style: Pt({ transform: `rotate(${i.modelValue}deg)` })
        }, null, 4),
        f("div", _O, [
          ($(), A(Fe, null, Ke(8, (w) => f("div", {
            class: "dial-mark",
            key: w,
            style: Pt({ transform: `rotate(${w * 45}deg)` })
          }, null, 4)), 64))
        ])
      ], 36),
      i.showValue ? ($(), A("div", xO, [
        f("input", {
          type: "number",
          class: "angle-input",
          value: a.value,
          disabled: i.disabled,
          onInput: p,
          onBlur: m
        }, null, 40, SO),
        y[2] || (y[2] = f("span", { class: "angle-unit" }, "", -1))
      ])) : ve("", !0)
    ], 2));
  }
}), kO = /* @__PURE__ */ cn(CO, [["__scopeId", "data-v-04a5caf6"]]), $u = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
], Mu = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class OO {
  constructor() {
    Xe(this, "systemFonts", []);
    Xe(this, "loadedGoogleFonts", /* @__PURE__ */ new Set());
    Xe(this, "initialized", !1);
  }
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    this.initialized || ("queryLocalFonts" in window && await this.loadSystemFonts(), this.initialized = !0);
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const e = await window.queryLocalFonts(), n = /* @__PURE__ */ new Map();
      for (const r of e)
        (!n.has(r.family) || r.style === "Regular") && n.set(r.family, {
          family: r.family,
          fullName: r.fullName,
          style: r.style,
          source: "system"
        });
      this.systemFonts = Array.from(n.values()).sort((r, o) => r.family.localeCompare(o.family)), console.log(`[FontService] Loaded ${this.systemFonts.length} system fonts`);
    } catch (e) {
      e.name === "NotAllowedError" ? console.log("[FontService] User denied font access permission") : console.error("[FontService] Error loading system fonts:", e);
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const e = [];
    return this.systemFonts.length > 0 && e.push({
      name: "System Fonts",
      fonts: this.systemFonts
    }), e.push({
      name: "Web Safe",
      fonts: $u
    }), e.push({
      name: "Google Fonts",
      fonts: Mu.map((n) => ({
        family: n,
        fullName: n,
        style: "normal",
        source: "google"
      }))
    }), e;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const e = /* @__PURE__ */ new Set();
    return $u.forEach((n) => e.add(n.family)), Mu.forEach((n) => e.add(n)), this.systemFonts.forEach((n) => e.add(n.family)), Array.from(e).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(e, n = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(e)) return;
    const r = n.join(";"), o = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(e)}:wght@${r}&display=swap`, s = document.createElement("link");
    s.rel = "stylesheet", s.href = o, document.head.appendChild(s);
    try {
      await document.fonts.load(`400 16px "${e}"`), this.loadedGoogleFonts.add(e), console.log(`[FontService] Loaded Google Font: ${e}`);
    } catch (a) {
      console.error(`[FontService] Failed to load Google Font: ${e}`, a);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(e) {
    return $u.some((n) => n.family === e) ? !0 : Mu.includes(e) ? (await this.loadGoogleFont(e), !0) : this.systemFonts.some((n) => n.family === e) ? !0 : this.isFontAvailable(e);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(e) {
    const n = "mmmmmmmmmmlli", o = document.createElement("canvas").getContext("2d");
    o.font = "72px monospace";
    const s = o.measureText(n).width;
    o.font = `72px "${e}", monospace`;
    const a = o.measureText(n).width;
    return s !== a;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return $u;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return Mu;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    return "queryLocalFonts" in window ? (await this.loadSystemFonts(), this.systemFonts.length > 0) : (console.log("[FontService] Local Font Access API not available"), !1);
  }
}
const Pi = new OO(), EO = ["title"], TO = /* @__PURE__ */ tn({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(i, { emit: e }) {
    const n = i, r = e, o = Gn(), s = Ee(() => n.property.animated ? n.property.keyframes.some((p) => p.frame === o.currentFrame) : !1), a = Ee(() => n.property.animated && n.property.keyframes.find((p) => p.frame === o.currentFrame) || null), l = Ee(() => s.value ? "pi-circle-fill" : n.property.animated ? "pi-circle" : "pi-stopwatch"), u = Ee(() => s.value ? "Remove keyframe at current frame" : n.property.animated ? "Add keyframe at current frame" : "Enable animation (add keyframe)");
    function c() {
      s.value ? h() : d();
    }
    function d() {
      const p = { x: 0.33, y: 0.33 }, m = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: o.currentFrame,
        value: n.property.value,
        interpolation: "bezier",
        inHandle: { ...p },
        outHandle: { ...p },
        handlesBroken: !1
      };
      n.property.animated || (n.property.animated = !0, r("animationToggled", !0)), n.property.keyframes.push(m), n.property.keyframes.sort((v, y) => v.frame - y.frame), r("keyframeAdded", m);
    }
    function h() {
      const p = a.value;
      if (!p) return;
      const m = n.property.keyframes.findIndex((v) => v.id === p.id);
      m >= 0 && (n.property.keyframes.splice(m, 1), r("keyframeRemoved", p.id)), n.property.keyframes.length === 0 && (n.property.animated = !1, r("animationToggled", !1));
    }
    return (p, m) => ($(), A("button", {
      class: _e(["keyframe-toggle", {
        animated: i.property.animated,
        "has-keyframe": s.value
      }]),
      onClick: c,
      title: u.value
    }, [
      f("i", {
        class: _e(["pi", l.value])
      }, null, 2)
    ], 10, EO));
  }
}), us = /* @__PURE__ */ cn(TO, [["__scopeId", "data-v-cb2aab3f"]]), DO = { class: "font-picker" }, $O = { class: "picker-header" }, MO = { class: "search-row" }, PO = { class: "font-categories" }, IO = ["onClick"], LO = { class: "font-count" }, AO = {
  key: 0,
  class: "category-fonts"
}, VO = ["onClick"], FO = { class: "font-source" }, jO = { class: "preview-section" }, RO = { class: "picker-actions" }, NO = ["disabled"], zO = /* @__PURE__ */ tn({
  __name: "FontPicker",
  props: {
    currentFont: {}
  },
  emits: ["select", "close"],
  setup(i, { emit: e }) {
    const n = i, r = e, o = re(null), s = re(""), a = re(n.currentFont), l = re("The quick brown fox jumps over the lazy dog"), u = re(/* @__PURE__ */ new Set(["Web Safe"])), c = re([]), d = re(null), h = Ee(() => {
      if (!s.value.trim())
        return c.value;
      const w = s.value.toLowerCase();
      return c.value.map((g) => ({
        ...g,
        fonts: g.fonts.filter(
          (k) => k.family.toLowerCase().includes(w)
        )
      })).filter((g) => g.fonts.length > 0);
    });
    Wn(async () => {
      var w;
      await Pi.initialize(), c.value = Pi.getFontCategories(), d.value = Pi.hasSystemFonts(), await Es(), (w = o.value) == null || w.focus(), n.currentFont && await Pi.ensureFont(n.currentFont);
    });
    function p(w) {
      u.value.has(w) ? u.value.delete(w) : u.value.add(w);
    }
    async function m(w) {
      a.value = w, await Pi.ensureFont(w);
    }
    function v() {
      a.value && r("select", a.value);
    }
    async function y() {
      await Pi.requestSystemFontAccess() && (c.value = Pi.getFontCategories(), d.value = !0, u.value.add("System Fonts"));
    }
    return (w, g) => ($(), A("div", {
      class: "font-picker-overlay",
      onClick: g[4] || (g[4] = tt((k) => r("close"), ["self"]))
    }, [
      f("div", DO, [
        f("div", $O, [
          g[6] || (g[6] = f("h3", null, "Select Font", -1)),
          f("button", {
            class: "close-btn",
            onClick: g[0] || (g[0] = (k) => r("close"))
          }, [...g[5] || (g[5] = [
            f("i", { class: "pi pi-times" }, null, -1)
          ])])
        ]),
        f("div", MO, [
          g[7] || (g[7] = f("i", { class: "pi pi-search search-icon" }, null, -1)),
          ot(f("input", {
            "onUpdate:modelValue": g[1] || (g[1] = (k) => s.value = k),
            type: "text",
            placeholder: "Search fonts...",
            class: "search-input",
            ref_key: "searchInputRef",
            ref: o
          }, null, 512), [
            [Qt, s.value]
          ])
        ]),
        f("div", PO, [
          ($(!0), A(Fe, null, Ke(h.value, (k) => ($(), A("div", {
            key: k.name,
            class: "font-category"
          }, [
            f("div", {
              class: "category-header",
              onClick: (_) => p(k.name)
            }, [
              f("i", {
                class: _e(["pi", u.value.has(k.name) ? "pi-chevron-down" : "pi-chevron-right"])
              }, null, 2),
              f("span", null, Q(k.name), 1),
              f("span", LO, Q(k.fonts.length), 1)
            ], 8, IO),
            u.value.has(k.name) ? ($(), A("div", AO, [
              ($(!0), A(Fe, null, Ke(k.fonts, (_) => ($(), A("div", {
                key: _.family,
                class: _e(["font-item", { selected: _.family === i.currentFont }]),
                onClick: (S) => m(_.family)
              }, [
                f("span", {
                  class: "font-preview",
                  style: Pt({ fontFamily: `'${_.family}', sans-serif` })
                }, Q(_.family), 5),
                f("span", FO, Q(_.source), 1)
              ], 10, VO))), 128))
            ])) : ve("", !0)
          ]))), 128))
        ]),
        f("div", jO, [
          g[8] || (g[8] = f("label", null, "Preview:", -1)),
          f("div", {
            class: "preview-text",
            style: Pt({ fontFamily: `'${a.value}', sans-serif` })
          }, Q(l.value), 5),
          ot(f("input", {
            "onUpdate:modelValue": g[2] || (g[2] = (k) => l.value = k),
            type: "text",
            class: "preview-input",
            placeholder: "Type preview text..."
          }, null, 512), [
            [Qt, l.value]
          ])
        ]),
        f("div", RO, [
          d.value === !1 ? ($(), A("button", {
            key: 0,
            class: "system-fonts-btn",
            onClick: y
          }, [...g[9] || (g[9] = [
            f("i", { class: "pi pi-desktop" }, null, -1),
            vt(" Load System Fonts ", -1)
          ])])) : ve("", !0),
          f("button", {
            class: "cancel-btn",
            onClick: g[3] || (g[3] = (k) => r("close"))
          }, "Cancel"),
          f("button", {
            class: "select-btn",
            onClick: v,
            disabled: !a.value
          }, " Select ", 8, NO)
        ])
      ])
    ]));
  }
}), BO = /* @__PURE__ */ cn(zO, [["__scopeId", "data-v-b3c36b6f"]]), HO = { class: "text-properties" }, UO = { class: "property-group" }, WO = { class: "property-group" }, GO = { class: "font-select-row" }, XO = { label: "Web Safe" }, YO = ["value"], KO = { label: "Google Fonts" }, qO = ["value"], ZO = { class: "property-group" }, JO = { class: "property-header" }, QO = { class: "slider-row" }, eE = { class: "property-group" }, tE = { class: "color-row" }, nE = { class: "property-group" }, iE = ["value"], rE = {
  key: 0,
  class: "property-group"
}, oE = { class: "property-header" }, sE = { class: "slider-row" }, aE = { class: "value-display" }, lE = { class: "property-group" }, uE = { class: "slider-row" }, cE = /* @__PURE__ */ tn({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(i, { emit: e }) {
    const n = i, r = e, o = Gn(), s = re(!1), a = re([]), l = re([]), u = Ee(() => n.layer.data || {
      text: "Text",
      fontFamily: "Arial",
      fontSize: 48,
      fontWeight: "400",
      fontStyle: "normal",
      fill: "#ffffff",
      stroke: "",
      strokeWidth: 0,
      letterSpacing: 0,
      lineHeight: 1.2,
      textAlign: "left",
      pathLayerId: null,
      pathOffset: 0,
      pathAlign: "left"
    }), c = Ee(() => o.layers.filter((b) => b.type === "spline" && b.id !== n.layer.id)), d = Ee(() => n.layer.properties.find((b) => b.name === "fontSize")), h = Ee(() => n.layer.properties.find((b) => b.name === "pathOffset")), p = Ee({
      get: () => (u.value.pathOffset || 0) * 100,
      set: (b) => {
        u.value.pathOffset = b / 100;
      }
    });
    Wn(async () => {
      await Pi.initialize(), a.value = Pi.getWebSafeFonts().map((b) => b.family), l.value = Pi.getGoogleFonts();
    });
    function m() {
      r("update");
    }
    function v() {
      Pi.ensureFont(u.value.fontFamily), r("update");
    }
    function y() {
      d.value && (d.value.value = u.value.fontSize), r("update");
    }
    function w() {
      r("update");
    }
    function g() {
      u.value.pathLayerId || (u.value.pathOffset = 0), r("update");
    }
    function k() {
      h.value && (h.value.value = u.value.pathOffset), r("update");
    }
    function _() {
      r("update");
    }
    function S(b) {
      u.value.fontFamily = b, s.value = !1, v();
    }
    return Lt(() => n.layer, (b) => {
      b.type === "text" && (b.properties.find((C) => C.name === "fontSize") || b.properties.push({
        id: `prop_fontSize_${Date.now()}`,
        name: "fontSize",
        type: "number",
        value: u.value.fontSize,
        animated: !1,
        keyframes: []
      }), b.properties.find((C) => C.name === "pathOffset") || b.properties.push({
        id: `prop_pathOffset_${Date.now()}`,
        name: "pathOffset",
        type: "number",
        value: 0,
        animated: !1,
        keyframes: []
      }));
    }, { immediate: !0 }), (b, C) => ($(), A("div", HO, [
      C[21] || (C[21] = f("h4", null, "Text Properties", -1)),
      f("div", UO, [
        C[12] || (C[12] = f("label", null, "Text", -1)),
        ot(f("textarea", {
          "onUpdate:modelValue": C[0] || (C[0] = (x) => u.value.text = x),
          class: "text-input",
          rows: "2",
          onInput: m
        }, null, 544), [
          [Qt, u.value.text]
        ])
      ]),
      f("div", WO, [
        C[14] || (C[14] = f("label", null, "Font Family", -1)),
        f("div", GO, [
          ot(f("select", {
            "onUpdate:modelValue": C[1] || (C[1] = (x) => u.value.fontFamily = x),
            class: "font-select",
            onChange: v
          }, [
            f("optgroup", XO, [
              ($(!0), A(Fe, null, Ke(a.value, (x) => ($(), A("option", {
                key: x,
                value: x
              }, Q(x), 9, YO))), 128))
            ]),
            f("optgroup", KO, [
              ($(!0), A(Fe, null, Ke(l.value, (x) => ($(), A("option", {
                key: x,
                value: x
              }, Q(x), 9, qO))), 128))
            ])
          ], 544), [
            [Zr, u.value.fontFamily]
          ]),
          f("button", {
            class: "picker-btn",
            onClick: C[2] || (C[2] = (x) => s.value = !0),
            title: "Browse fonts"
          }, [...C[13] || (C[13] = [
            f("i", { class: "pi pi-search" }, null, -1)
          ])])
        ])
      ]),
      f("div", ZO, [
        f("div", JO, [
          C[15] || (C[15] = f("label", null, "Font Size", -1)),
          d.value ? ($(), st(us, {
            key: 0,
            property: d.value,
            layerId: i.layer.id
          }, null, 8, ["property", "layerId"])) : ve("", !0)
        ]),
        f("div", QO, [
          ot(f("input", {
            type: "range",
            "onUpdate:modelValue": C[3] || (C[3] = (x) => u.value.fontSize = x),
            min: 8,
            max: 200,
            class: "slider",
            onInput: y
          }, null, 544), [
            [
              Qt,
              u.value.fontSize,
              void 0,
              { number: !0 }
            ]
          ]),
          ot(f("input", {
            type: "number",
            "onUpdate:modelValue": C[4] || (C[4] = (x) => u.value.fontSize = x),
            min: 8,
            max: 200,
            class: "number-input",
            onChange: y
          }, null, 544), [
            [
              Qt,
              u.value.fontSize,
              void 0,
              { number: !0 }
            ]
          ])
        ])
      ]),
      f("div", eE, [
        C[16] || (C[16] = f("label", null, "Fill Color", -1)),
        f("div", tE, [
          ot(f("input", {
            type: "color",
            "onUpdate:modelValue": C[5] || (C[5] = (x) => u.value.fill = x),
            class: "color-input",
            onInput: w
          }, null, 544), [
            [Qt, u.value.fill]
          ]),
          ot(f("input", {
            type: "text",
            "onUpdate:modelValue": C[6] || (C[6] = (x) => u.value.fill = x),
            class: "color-text",
            onChange: w
          }, null, 544), [
            [Qt, u.value.fill]
          ])
        ])
      ]),
      f("div", nE, [
        C[18] || (C[18] = f("label", null, "Attach to Path", -1)),
        ot(f("select", {
          "onUpdate:modelValue": C[7] || (C[7] = (x) => u.value.pathLayerId = x),
          class: "path-select",
          onChange: g
        }, [
          C[17] || (C[17] = f("option", { value: null }, "None", -1)),
          ($(!0), A(Fe, null, Ke(c.value, (x) => ($(), A("option", {
            key: x.id,
            value: x.id
          }, Q(x.name), 9, iE))), 128))
        ], 544), [
          [Zr, u.value.pathLayerId]
        ])
      ]),
      u.value.pathLayerId ? ($(), A("div", rE, [
        f("div", oE, [
          C[19] || (C[19] = f("label", null, "Path Offset", -1)),
          h.value ? ($(), st(us, {
            key: 0,
            property: h.value,
            layerId: i.layer.id
          }, null, 8, ["property", "layerId"])) : ve("", !0)
        ]),
        f("div", sE, [
          ot(f("input", {
            type: "range",
            "onUpdate:modelValue": C[8] || (C[8] = (x) => p.value = x),
            min: 0,
            max: 100,
            class: "slider",
            onInput: k
          }, null, 544), [
            [
              Qt,
              p.value,
              void 0,
              { number: !0 }
            ]
          ]),
          f("span", aE, Q(Math.round(p.value)) + "%", 1)
        ])
      ])) : ve("", !0),
      f("div", lE, [
        C[20] || (C[20] = f("label", null, "Letter Spacing", -1)),
        f("div", uE, [
          ot(f("input", {
            type: "range",
            "onUpdate:modelValue": C[9] || (C[9] = (x) => u.value.letterSpacing = x),
            min: -20,
            max: 50,
            class: "slider",
            onInput: _
          }, null, 544), [
            [
              Qt,
              u.value.letterSpacing,
              void 0,
              { number: !0 }
            ]
          ]),
          ot(f("input", {
            type: "number",
            "onUpdate:modelValue": C[10] || (C[10] = (x) => u.value.letterSpacing = x),
            class: "number-input",
            onChange: _
          }, null, 544), [
            [
              Qt,
              u.value.letterSpacing,
              void 0,
              { number: !0 }
            ]
          ])
        ])
      ]),
      s.value ? ($(), st(BO, {
        key: 1,
        "current-font": u.value.fontFamily,
        onSelect: S,
        onClose: C[11] || (C[11] = (x) => s.value = !1)
      }, null, 8, ["current-font"])) : ve("", !0)
    ]));
  }
}), dE = /* @__PURE__ */ cn(cE, [["__scopeId", "data-v-39d880c9"]]), hE = { class: "particle-properties" }, fE = { class: "property-section" }, pE = {
  key: 0,
  class: "section-content"
}, mE = { class: "property-row" }, gE = ["value"], vE = { class: "value-display" }, yE = { class: "property-row" }, bE = ["value"], wE = { class: "value-display" }, _E = { class: "property-row" }, xE = ["value"], SE = { class: "value-display" }, CE = { class: "property-row" }, kE = ["value"], OE = { class: "value-display" }, EE = { class: "property-row" }, TE = ["value"], DE = { class: "value-display" }, $E = { class: "property-row" }, ME = ["value"], PE = { class: "property-section" }, IE = {
  key: 0,
  class: "section-content"
}, LE = ["onClick"], AE = ["value", "onInput"], VE = { class: "enabled-toggle" }, FE = ["checked", "onChange"], jE = ["onClick"], RE = {
  key: 0,
  class: "emitter-content"
}, NE = { class: "property-row" }, zE = ["value", "onInput"], BE = { class: "value-display" }, HE = { class: "property-row" }, UE = ["value", "onInput"], WE = { class: "value-display" }, GE = { class: "property-row" }, XE = ["value", "onInput"], YE = { class: "value-display" }, KE = { class: "property-row" }, qE = ["value", "onInput"], ZE = { class: "value-display" }, JE = { class: "property-row" }, QE = ["value", "onInput"], eT = { class: "value-display" }, tT = { class: "property-row" }, nT = ["value", "onInput"], iT = { class: "value-display" }, rT = { class: "property-row" }, oT = ["value", "onInput"], sT = { class: "value-display" }, aT = { class: "property-row" }, lT = ["value", "onInput"], uT = { class: "value-display" }, cT = { class: "property-row" }, dT = ["value", "onInput"], hT = { class: "property-row" }, fT = ["value", "onInput"], pT = { class: "value-display" }, mT = { class: "property-row" }, gT = ["value", "onInput"], vT = { class: "value-display" }, yT = { class: "property-row" }, bT = ["value", "onInput"], wT = { class: "value-display" }, _T = { class: "property-row checkbox-row" }, xT = ["checked", "onChange"], ST = {
  key: 0,
  class: "property-row"
}, CT = ["value", "onInput"], kT = { class: "value-display" }, OT = {
  key: 0,
  class: "empty-message"
}, ET = { class: "property-section" }, TT = {
  key: 0,
  class: "section-content"
}, DT = { class: "force-tabs" }, $T = {
  key: 0,
  class: "force-list"
}, MT = { class: "force-header" }, PT = ["value", "onInput"], IT = { class: "enabled-toggle" }, LT = ["checked", "onChange"], AT = ["onClick"], VT = { class: "property-row" }, FT = ["value", "onInput"], jT = { class: "value-display" }, RT = { class: "property-row" }, NT = ["value", "onInput"], zT = { class: "value-display" }, BT = { class: "property-row" }, HT = ["value", "onInput"], UT = { class: "value-display" }, WT = { class: "property-row" }, GT = ["value", "onInput"], XT = { class: "value-display" }, YT = { class: "property-row" }, KT = ["value", "onChange"], qT = {
  key: 1,
  class: "force-list"
}, ZT = { class: "force-header" }, JT = ["value", "onInput"], QT = { class: "enabled-toggle" }, eD = ["checked", "onChange"], tD = ["onClick"], nD = { class: "property-row" }, iD = ["value", "onInput"], rD = { class: "value-display" }, oD = { class: "property-row" }, sD = ["value", "onInput"], aD = { class: "value-display" }, lD = { class: "property-row" }, uD = ["value", "onInput"], cD = { class: "value-display" }, dD = { class: "property-row" }, hD = ["value", "onInput"], fD = { class: "value-display" }, pD = { class: "property-row" }, mD = ["value", "onInput"], gD = { class: "value-display" }, vD = { class: "property-row" }, yD = ["value", "onInput"], bD = { class: "value-display" }, wD = { class: "property-section" }, _D = {
  key: 0,
  class: "section-content"
}, xD = { class: "force-header" }, SD = { class: "enabled-toggle" }, CD = ["checked", "onChange"], kD = ["onClick"], OD = { class: "property-row" }, ED = ["value", "onInput"], TD = { class: "value-display" }, DD = { class: "property-row" }, $D = ["value", "onInput"], MD = { class: "value-display" }, PD = { class: "property-row" }, ID = ["value", "onInput"], LD = { class: "value-display" }, AD = {
  key: 0,
  class: "empty-message"
}, VD = { class: "property-section" }, FD = {
  key: 0,
  class: "section-content"
}, jD = { class: "force-header" }, RD = ["value", "onChange"], ND = ["value"], zD = { class: "enabled-toggle" }, BD = ["checked", "onChange"], HD = ["onClick"], UD = { class: "property-row" }, WD = ["value", "onChange"], GD = { class: "property-row" }, XD = ["value", "onInput"], YD = { class: "value-display" }, KD = { class: "property-row" }, qD = ["value", "onInput"], ZD = { class: "value-display" }, JD = { class: "property-row" }, QD = ["value", "onInput"], e$ = { class: "value-display" }, t$ = { class: "property-row" }, n$ = ["value", "onInput"], i$ = { class: "value-display" }, r$ = { class: "property-row" }, o$ = ["value", "onInput"], s$ = { class: "value-display" }, a$ = { class: "property-row" }, l$ = ["value", "onInput"], u$ = { class: "value-display" }, c$ = { class: "property-row" }, d$ = ["value", "onInput"], h$ = {
  key: 0,
  class: "empty-message"
}, f$ = { class: "property-section" }, p$ = {
  key: 0,
  class: "section-content"
}, m$ = { class: "modulation-header" }, g$ = ["value", "onChange"], v$ = ["value"], y$ = ["onClick"], b$ = { class: "property-row" }, w$ = ["value", "onChange"], _$ = { class: "property-row" }, x$ = ["value", "onInput"], S$ = { class: "property-row" }, C$ = ["value", "onInput"], k$ = { class: "property-row" }, O$ = ["value", "onChange"], E$ = {
  key: 0,
  class: "empty-message"
}, T$ = { class: "property-section" }, D$ = {
  key: 0,
  class: "section-content"
}, $$ = { class: "property-row" }, M$ = ["value"], P$ = { class: "property-row" }, I$ = ["value"], L$ = { class: "property-row checkbox-row" }, A$ = ["checked"], V$ = {
  key: 0,
  class: "property-row"
}, F$ = ["value"], j$ = { class: "value-display" }, R$ = { class: "property-row checkbox-row" }, N$ = ["checked"], z$ = {
  key: 1,
  class: "property-row"
}, B$ = ["value"], H$ = { class: "value-display" }, U$ = {
  key: 2,
  class: "property-row"
}, W$ = ["value"], G$ = { class: "value-display" }, X$ = { class: "property-row checkbox-row" }, Y$ = ["checked"], K$ = {
  key: 3,
  class: "property-row"
}, q$ = ["value"], Z$ = { class: "value-display" }, J$ = {
  key: 4,
  class: "property-row"
}, Q$ = ["value"], eM = { class: "value-display" }, tM = {
  key: 5,
  class: "property-row"
}, nM = ["value"], iM = { class: "value-display" }, rM = {
  key: 6,
  class: "property-row"
}, oM = ["value"], sM = { class: "value-display" }, aM = {
  key: 7,
  class: "property-row checkbox-row"
}, lM = ["checked"], uM = { class: "particle-count" }, cM = /* @__PURE__ */ tn({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(i, { emit: e }) {
    const n = i, r = e, o = re(/* @__PURE__ */ new Set(["system", "emitters"])), s = re(/* @__PURE__ */ new Set()), a = re("wells"), l = Ee(() => n.layer.data || {
      systemConfig: {
        maxParticles: 1e4,
        gravity: 0,
        windStrength: 0,
        windDirection: 0,
        warmupPeriod: 0,
        respectMaskBoundary: !1,
        boundaryBehavior: "kill",
        friction: 0.01
      },
      emitters: [],
      gravityWells: [],
      vortices: [],
      modulations: [],
      renderOptions: {
        blendMode: "additive",
        renderTrails: !1,
        trailLength: 5,
        trailOpacityFalloff: 0.7,
        particleShape: "circle",
        glowEnabled: !1,
        glowRadius: 10,
        glowIntensity: 0.5,
        motionBlur: !1,
        motionBlurStrength: 0.5,
        motionBlurSamples: 8,
        connections: {
          enabled: !1,
          maxDistance: 100,
          maxConnections: 3,
          lineWidth: 1,
          lineOpacity: 0.5,
          fadeByDistance: !0
        }
      },
      turbulenceFields: [],
      subEmitters: []
    }), u = Ee(() => l.value.systemConfig), c = Ee(() => l.value.emitters), d = Ee(() => l.value.gravityWells), h = Ee(() => l.value.vortices), p = Ee(() => l.value.modulations), m = Ee(() => l.value.renderOptions), v = Ee(() => l.value.turbulenceFields || []), y = Ee(() => l.value.subEmitters || []), w = Ee(() => m.value.connections || {
      enabled: !1,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: !0
    }), g = Ee(() => n.particleCount);
    function k(le) {
      o.value.has(le) ? o.value.delete(le) : o.value.add(le);
    }
    function _(le) {
      s.value.has(le) ? s.value.delete(le) : s.value.add(le);
    }
    function S(le, T) {
      r("update", {
        systemConfig: { ...u.value, [le]: T }
      });
    }
    function b(le, T, E) {
      const L = c.value.map(
        (D) => D.id === le ? { ...D, [T]: E } : D
      );
      r("update", { emitters: L });
    }
    function C(le, T) {
      const E = Ce(T);
      b(le, "color", E);
    }
    function x() {
      const le = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${c.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: !0,
        burstOnBeat: !1,
        burstCount: 20
      };
      r("update", { emitters: [...c.value, le] }), s.value.add(le.id);
    }
    function I(le) {
      r("update", { emitters: c.value.filter((T) => T.id !== le) });
    }
    function F(le, T, E) {
      const L = d.value.map(
        (D) => D.id === le ? { ...D, [T]: E } : D
      );
      r("update", { gravityWells: L });
    }
    function B() {
      const le = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${d.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: !0
      };
      r("update", { gravityWells: [...d.value, le] });
    }
    function X(le) {
      r("update", { gravityWells: d.value.filter((T) => T.id !== le) });
    }
    function j(le, T, E) {
      const L = h.value.map(
        (D) => D.id === le ? { ...D, [T]: E } : D
      );
      r("update", { vortices: L });
    }
    function ee() {
      const le = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${h.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: !0
      };
      r("update", { vortices: [...h.value, le] });
    }
    function ie(le) {
      r("update", { vortices: h.value.filter((T) => T.id !== le) });
    }
    function M(le, T, E) {
      const L = p.value.map(
        (D) => D.id === le ? { ...D, [T]: E } : D
      );
      r("update", { modulations: L });
    }
    function W() {
      const le = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      r("update", { modulations: [...p.value, le] });
    }
    function R(le) {
      r("update", { modulations: p.value.filter((T) => T.id !== le) });
    }
    function V(le, T) {
      r("update", {
        renderOptions: { ...m.value, [le]: T }
      });
    }
    function ae(le, T) {
      r("update", {
        renderOptions: {
          ...m.value,
          connections: { ...w.value, [le]: T }
        }
      });
    }
    function $e(le, T, E) {
      const L = v.value.map(
        (D) => D.id === le ? { ...D, [T]: E } : D
      );
      r("update", { turbulenceFields: L });
    }
    function N() {
      const le = {
        id: `turb_${Date.now()}`,
        enabled: !0,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      r("update", { turbulenceFields: [...v.value, le] });
    }
    function me(le) {
      r("update", { turbulenceFields: v.value.filter((T) => T.id !== le) });
    }
    function we(le, T, E) {
      const L = y.value.map(
        (D) => D.id === le ? { ...D, [T]: E } : D
      );
      r("update", { subEmitters: L });
    }
    function fe(le, T) {
      const E = Ce(T);
      we(le, "color", E);
    }
    function te() {
      const le = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: !0
      };
      r("update", { subEmitters: [...y.value, le] });
    }
    function Me(le) {
      r("update", { subEmitters: y.value.filter((T) => T.id !== le) });
    }
    function Re(le) {
      return "#" + le.map((T) => T.toString(16).padStart(2, "0")).join("");
    }
    function Ce(le) {
      const T = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(le);
      return T ? [parseInt(T[1], 16), parseInt(T[2], 16), parseInt(T[3], 16)] : [255, 255, 255];
    }
    return (le, T) => ($(), A("div", hE, [
      f("div", fE, [
        f("div", {
          class: "section-header",
          onClick: T[0] || (T[0] = (E) => k("system"))
        }, [
          f("i", {
            class: _e(["pi", o.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[30] || (T[30] = f("span", null, "System Settings", -1))
        ]),
        o.value.has("system") ? ($(), A("div", pE, [
          f("div", mE, [
            T[31] || (T[31] = f("label", null, "Max Particles", -1)),
            f("input", {
              type: "range",
              value: u.value.maxParticles,
              min: "100",
              max: "50000",
              step: "100",
              onInput: T[1] || (T[1] = (E) => S("maxParticles", Number(E.target.value)))
            }, null, 40, gE),
            f("span", vE, Q(u.value.maxParticles), 1)
          ]),
          f("div", yE, [
            T[32] || (T[32] = f("label", null, "Gravity", -1)),
            f("input", {
              type: "range",
              value: u.value.gravity,
              min: "-1000",
              max: "1000",
              step: "10",
              onInput: T[2] || (T[2] = (E) => S("gravity", Number(E.target.value)))
            }, null, 40, bE),
            f("span", wE, Q(u.value.gravity), 1)
          ]),
          f("div", _E, [
            T[33] || (T[33] = f("label", null, "Wind Strength", -1)),
            f("input", {
              type: "range",
              value: u.value.windStrength,
              min: "0",
              max: "1000",
              step: "10",
              onInput: T[3] || (T[3] = (E) => S("windStrength", Number(E.target.value)))
            }, null, 40, xE),
            f("span", SE, Q(u.value.windStrength), 1)
          ]),
          f("div", CE, [
            T[34] || (T[34] = f("label", null, "Wind Direction", -1)),
            f("input", {
              type: "range",
              value: u.value.windDirection,
              min: "0",
              max: "360",
              step: "5",
              onInput: T[4] || (T[4] = (E) => S("windDirection", Number(E.target.value)))
            }, null, 40, kE),
            f("span", OE, Q(u.value.windDirection) + "", 1)
          ]),
          f("div", EE, [
            T[35] || (T[35] = f("label", null, "Friction", -1)),
            f("input", {
              type: "range",
              value: u.value.friction,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: T[5] || (T[5] = (E) => S("friction", Number(E.target.value)))
            }, null, 40, TE),
            f("span", DE, Q(u.value.friction.toFixed(2)), 1)
          ]),
          f("div", $E, [
            T[37] || (T[37] = f("label", null, "Boundary", -1)),
            f("select", {
              value: u.value.boundaryBehavior,
              onChange: T[6] || (T[6] = (E) => S("boundaryBehavior", E.target.value))
            }, [...T[36] || (T[36] = [
              f("option", { value: "kill" }, "Kill", -1),
              f("option", { value: "bounce" }, "Bounce", -1),
              f("option", { value: "wrap" }, "Wrap", -1)
            ])], 40, ME)
          ])
        ])) : ve("", !0)
      ]),
      f("div", PE, [
        f("div", {
          class: "section-header",
          onClick: T[7] || (T[7] = (E) => k("emitters"))
        }, [
          f("i", {
            class: _e(["pi", o.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[39] || (T[39] = f("span", null, "Emitters", -1)),
          f("button", {
            class: "add-btn",
            onClick: tt(x, ["stop"]),
            title: "Add Emitter"
          }, [...T[38] || (T[38] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        o.value.has("emitters") ? ($(), A("div", IE, [
          ($(!0), A(Fe, null, Ke(c.value, (E) => ($(), A("div", {
            key: E.id,
            class: "emitter-item"
          }, [
            f("div", {
              class: "emitter-header",
              onClick: (L) => _(E.id)
            }, [
              f("i", {
                class: _e(["pi", s.value.has(E.id) ? "pi-chevron-down" : "pi-chevron-right"])
              }, null, 2),
              f("input", {
                type: "text",
                value: E.name,
                onInput: (L) => b(E.id, "name", L.target.value),
                onClick: T[8] || (T[8] = tt(() => {
                }, ["stop"])),
                class: "emitter-name"
              }, null, 40, AE),
              f("label", VE, [
                f("input", {
                  type: "checkbox",
                  checked: E.enabled,
                  onChange: (L) => b(E.id, "enabled", L.target.checked),
                  onClick: T[9] || (T[9] = tt(() => {
                  }, ["stop"]))
                }, null, 40, FE)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: tt((L) => I(E.id), ["stop"]),
                title: "Remove"
              }, [...T[40] || (T[40] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, jE)
            ], 8, LE),
            s.value.has(E.id) ? ($(), A("div", RE, [
              f("div", NE, [
                T[41] || (T[41] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: E.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => b(E.id, "x", Number(L.target.value))
                }, null, 40, zE),
                f("span", BE, Q(E.x.toFixed(2)), 1)
              ]),
              f("div", HE, [
                T[42] || (T[42] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: E.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => b(E.id, "y", Number(L.target.value))
                }, null, 40, UE),
                f("span", WE, Q(E.y.toFixed(2)), 1)
              ]),
              f("div", GE, [
                T[43] || (T[43] = f("label", null, "Direction", -1)),
                f("input", {
                  type: "range",
                  value: E.direction,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (L) => b(E.id, "direction", Number(L.target.value))
                }, null, 40, XE),
                f("span", YE, Q(E.direction) + "", 1)
              ]),
              f("div", KE, [
                T[44] || (T[44] = f("label", null, "Spread", -1)),
                f("input", {
                  type: "range",
                  value: E.spread,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (L) => b(E.id, "spread", Number(L.target.value))
                }, null, 40, qE),
                f("span", ZE, Q(E.spread) + "", 1)
              ]),
              f("div", JE, [
                T[45] || (T[45] = f("label", null, "Speed", -1)),
                f("input", {
                  type: "range",
                  value: E.speed,
                  min: "1",
                  max: "1000",
                  step: "10",
                  onInput: (L) => b(E.id, "speed", Number(L.target.value))
                }, null, 40, QE),
                f("span", eT, Q(E.speed), 1)
              ]),
              f("div", tT, [
                T[46] || (T[46] = f("label", null, "Speed Variance", -1)),
                f("input", {
                  type: "range",
                  value: E.speedVariance,
                  min: "0",
                  max: "500",
                  step: "10",
                  onInput: (L) => b(E.id, "speedVariance", Number(L.target.value))
                }, null, 40, nT),
                f("span", iT, Q(E.speedVariance), 1)
              ]),
              f("div", rT, [
                T[47] || (T[47] = f("label", null, "Size", -1)),
                f("input", {
                  type: "range",
                  value: E.size,
                  min: "1",
                  max: "400",
                  step: "1",
                  onInput: (L) => b(E.id, "size", Number(L.target.value))
                }, null, 40, oT),
                f("span", sT, Q(E.size) + "px", 1)
              ]),
              f("div", aT, [
                T[48] || (T[48] = f("label", null, "Size Variance", -1)),
                f("input", {
                  type: "range",
                  value: E.sizeVariance,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (L) => b(E.id, "sizeVariance", Number(L.target.value))
                }, null, 40, lT),
                f("span", uT, Q(E.sizeVariance), 1)
              ]),
              f("div", cT, [
                T[49] || (T[49] = f("label", null, "Color", -1)),
                f("input", {
                  type: "color",
                  value: Re(E.color),
                  onInput: (L) => C(E.id, L.target.value)
                }, null, 40, dT)
              ]),
              f("div", hT, [
                T[50] || (T[50] = f("label", null, "Emission Rate", -1)),
                f("input", {
                  type: "range",
                  value: E.emissionRate,
                  min: "0.1",
                  max: "100",
                  step: "0.1",
                  onInput: (L) => b(E.id, "emissionRate", Number(L.target.value))
                }, null, 40, fT),
                f("span", pT, Q(E.emissionRate.toFixed(1)) + "/s", 1)
              ]),
              f("div", mT, [
                T[51] || (T[51] = f("label", null, "Lifetime", -1)),
                f("input", {
                  type: "range",
                  value: E.particleLifetime,
                  min: "1",
                  max: "300",
                  step: "1",
                  onInput: (L) => b(E.id, "particleLifetime", Number(L.target.value))
                }, null, 40, gT),
                f("span", vT, Q(E.particleLifetime) + "f", 1)
              ]),
              f("div", yT, [
                T[52] || (T[52] = f("label", null, "Initial Burst", -1)),
                f("input", {
                  type: "range",
                  value: E.initialBurst,
                  min: "0",
                  max: "1",
                  step: "0.1",
                  onInput: (L) => b(E.id, "initialBurst", Number(L.target.value))
                }, null, 40, bT),
                f("span", wT, Q((E.initialBurst * 100).toFixed(0)) + "%", 1)
              ]),
              f("div", _T, [
                f("label", null, [
                  f("input", {
                    type: "checkbox",
                    checked: E.burstOnBeat,
                    onChange: (L) => b(E.id, "burstOnBeat", L.target.checked)
                  }, null, 40, xT),
                  T[53] || (T[53] = vt(" Burst on Beat ", -1))
                ])
              ]),
              E.burstOnBeat ? ($(), A("div", ST, [
                T[54] || (T[54] = f("label", null, "Burst Count", -1)),
                f("input", {
                  type: "range",
                  value: E.burstCount,
                  min: "1",
                  max: "100",
                  step: "1",
                  onInput: (L) => b(E.id, "burstCount", Number(L.target.value))
                }, null, 40, CT),
                f("span", kT, Q(E.burstCount), 1)
              ])) : ve("", !0)
            ])) : ve("", !0)
          ]))), 128)),
          c.value.length === 0 ? ($(), A("div", OT, " No emitters. Click + to add one. ")) : ve("", !0)
        ])) : ve("", !0)
      ]),
      f("div", ET, [
        f("div", {
          class: "section-header",
          onClick: T[10] || (T[10] = (E) => k("forces"))
        }, [
          f("i", {
            class: _e(["pi", o.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[55] || (T[55] = f("span", null, "Force Fields", -1))
        ]),
        o.value.has("forces") ? ($(), A("div", TT, [
          f("div", DT, [
            f("button", {
              class: _e({ active: a.value === "wells" }),
              onClick: T[11] || (T[11] = (E) => a.value = "wells")
            }, " Gravity Wells ", 2),
            f("button", {
              class: _e({ active: a.value === "vortices" }),
              onClick: T[12] || (T[12] = (E) => a.value = "vortices")
            }, " Vortices ", 2)
          ]),
          a.value === "wells" ? ($(), A("div", $T, [
            f("button", {
              class: "add-btn full-width",
              onClick: B
            }, [...T[56] || (T[56] = [
              f("i", { class: "pi pi-plus" }, null, -1),
              vt(" Add Gravity Well ", -1)
            ])]),
            ($(!0), A(Fe, null, Ke(d.value, (E) => ($(), A("div", {
              key: E.id,
              class: "force-item"
            }, [
              f("div", MT, [
                f("input", {
                  type: "text",
                  value: E.name,
                  onInput: (L) => F(E.id, "name", L.target.value),
                  class: "force-name"
                }, null, 40, PT),
                f("label", IT, [
                  f("input", {
                    type: "checkbox",
                    checked: E.enabled,
                    onChange: (L) => F(E.id, "enabled", L.target.checked)
                  }, null, 40, LT)
                ]),
                f("button", {
                  class: "remove-btn",
                  onClick: (L) => X(E.id)
                }, [...T[57] || (T[57] = [
                  f("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, AT)
              ]),
              f("div", VT, [
                T[58] || (T[58] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: E.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => F(E.id, "x", Number(L.target.value))
                }, null, 40, FT),
                f("span", jT, Q(E.x.toFixed(2)), 1)
              ]),
              f("div", RT, [
                T[59] || (T[59] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: E.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => F(E.id, "y", Number(L.target.value))
                }, null, 40, NT),
                f("span", zT, Q(E.y.toFixed(2)), 1)
              ]),
              f("div", BT, [
                T[60] || (T[60] = f("label", null, "Strength", -1)),
                f("input", {
                  type: "range",
                  value: E.strength,
                  min: "-1000",
                  max: "1000",
                  step: "10",
                  onInput: (L) => F(E.id, "strength", Number(L.target.value))
                }, null, 40, HT),
                f("span", UT, Q(E.strength), 1)
              ]),
              f("div", WT, [
                T[61] || (T[61] = f("label", null, "Radius", -1)),
                f("input", {
                  type: "range",
                  value: E.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => F(E.id, "radius", Number(L.target.value))
                }, null, 40, GT),
                f("span", XT, Q(E.radius.toFixed(2)), 1)
              ]),
              f("div", YT, [
                T[63] || (T[63] = f("label", null, "Falloff", -1)),
                f("select", {
                  value: E.falloff,
                  onChange: (L) => F(E.id, "falloff", L.target.value)
                }, [...T[62] || (T[62] = [
                  f("option", { value: "linear" }, "Linear", -1),
                  f("option", { value: "quadratic" }, "Quadratic", -1),
                  f("option", { value: "constant" }, "Constant", -1)
                ])], 40, KT)
              ])
            ]))), 128))
          ])) : ve("", !0),
          a.value === "vortices" ? ($(), A("div", qT, [
            f("button", {
              class: "add-btn full-width",
              onClick: ee
            }, [...T[64] || (T[64] = [
              f("i", { class: "pi pi-plus" }, null, -1),
              vt(" Add Vortex ", -1)
            ])]),
            ($(!0), A(Fe, null, Ke(h.value, (E) => ($(), A("div", {
              key: E.id,
              class: "force-item"
            }, [
              f("div", ZT, [
                f("input", {
                  type: "text",
                  value: E.name,
                  onInput: (L) => j(E.id, "name", L.target.value),
                  class: "force-name"
                }, null, 40, JT),
                f("label", QT, [
                  f("input", {
                    type: "checkbox",
                    checked: E.enabled,
                    onChange: (L) => j(E.id, "enabled", L.target.checked)
                  }, null, 40, eD)
                ]),
                f("button", {
                  class: "remove-btn",
                  onClick: (L) => ie(E.id)
                }, [...T[65] || (T[65] = [
                  f("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, tD)
              ]),
              f("div", nD, [
                T[66] || (T[66] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: E.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => j(E.id, "x", Number(L.target.value))
                }, null, 40, iD),
                f("span", rD, Q(E.x.toFixed(2)), 1)
              ]),
              f("div", oD, [
                T[67] || (T[67] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: E.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => j(E.id, "y", Number(L.target.value))
                }, null, 40, sD),
                f("span", aD, Q(E.y.toFixed(2)), 1)
              ]),
              f("div", lD, [
                T[68] || (T[68] = f("label", null, "Strength", -1)),
                f("input", {
                  type: "range",
                  value: E.strength,
                  min: "0",
                  max: "1000",
                  step: "10",
                  onInput: (L) => j(E.id, "strength", Number(L.target.value))
                }, null, 40, uD),
                f("span", cD, Q(E.strength), 1)
              ]),
              f("div", dD, [
                T[69] || (T[69] = f("label", null, "Radius", -1)),
                f("input", {
                  type: "range",
                  value: E.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => j(E.id, "radius", Number(L.target.value))
                }, null, 40, hD),
                f("span", fD, Q(E.radius.toFixed(2)), 1)
              ]),
              f("div", pD, [
                T[70] || (T[70] = f("label", null, "Rotation Speed", -1)),
                f("input", {
                  type: "range",
                  value: E.rotationSpeed,
                  min: "0",
                  max: "50",
                  step: "1",
                  onInput: (L) => j(E.id, "rotationSpeed", Number(L.target.value))
                }, null, 40, mD),
                f("span", gD, Q(E.rotationSpeed) + "/f", 1)
              ]),
              f("div", vD, [
                T[71] || (T[71] = f("label", null, "Inward Pull", -1)),
                f("input", {
                  type: "range",
                  value: E.inwardPull,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (L) => j(E.id, "inwardPull", Number(L.target.value))
                }, null, 40, yD),
                f("span", bD, Q(E.inwardPull), 1)
              ])
            ]))), 128))
          ])) : ve("", !0)
        ])) : ve("", !0)
      ]),
      f("div", wD, [
        f("div", {
          class: "section-header",
          onClick: T[13] || (T[13] = (E) => k("turbulence"))
        }, [
          f("i", {
            class: _e(["pi", o.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[73] || (T[73] = f("span", null, "Turbulence", -1)),
          f("button", {
            class: "add-btn",
            onClick: tt(N, ["stop"]),
            title: "Add Turbulence Field"
          }, [...T[72] || (T[72] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        o.value.has("turbulence") ? ($(), A("div", _D, [
          ($(!0), A(Fe, null, Ke(v.value, (E) => ($(), A("div", {
            key: E.id,
            class: "force-item"
          }, [
            f("div", xD, [
              T[75] || (T[75] = f("span", { class: "force-label" }, "Turbulence Field", -1)),
              f("label", SD, [
                f("input", {
                  type: "checkbox",
                  checked: E.enabled,
                  onChange: (L) => $e(E.id, "enabled", L.target.checked)
                }, null, 40, CD)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: (L) => me(E.id)
              }, [...T[74] || (T[74] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, kD)
            ]),
            f("div", OD, [
              T[76] || (T[76] = f("label", null, "Scale", -1)),
              f("input", {
                type: "range",
                value: E.scale,
                min: "0.001",
                max: "0.02",
                step: "0.001",
                onInput: (L) => $e(E.id, "scale", Number(L.target.value))
              }, null, 40, ED),
              f("span", TD, Q(E.scale.toFixed(3)), 1)
            ]),
            f("div", DD, [
              T[77] || (T[77] = f("label", null, "Strength", -1)),
              f("input", {
                type: "range",
                value: E.strength,
                min: "0",
                max: "500",
                step: "10",
                onInput: (L) => $e(E.id, "strength", Number(L.target.value))
              }, null, 40, $D),
              f("span", MD, Q(E.strength), 1)
            ]),
            f("div", PD, [
              T[78] || (T[78] = f("label", null, "Evolution", -1)),
              f("input", {
                type: "range",
                value: E.evolutionSpeed,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: (L) => $e(E.id, "evolutionSpeed", Number(L.target.value))
              }, null, 40, ID),
              f("span", LD, Q(E.evolutionSpeed.toFixed(2)), 1)
            ])
          ]))), 128)),
          v.value.length === 0 ? ($(), A("div", AD, " No turbulence fields. Add one for organic particle motion. ")) : ve("", !0)
        ])) : ve("", !0)
      ]),
      f("div", VD, [
        f("div", {
          class: "section-header",
          onClick: T[14] || (T[14] = (E) => k("subEmitters"))
        }, [
          f("i", {
            class: _e(["pi", o.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[80] || (T[80] = f("span", null, "Sub-Emitters", -1)),
          f("button", {
            class: "add-btn",
            onClick: tt(te, ["stop"]),
            title: "Add Sub-Emitter"
          }, [...T[79] || (T[79] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        o.value.has("subEmitters") ? ($(), A("div", FD, [
          ($(!0), A(Fe, null, Ke(y.value, (E) => ($(), A("div", {
            key: E.id,
            class: "force-item"
          }, [
            f("div", jD, [
              f("select", {
                value: E.parentEmitterId,
                onChange: (L) => we(E.id, "parentEmitterId", L.target.value),
                class: "sub-emitter-parent"
              }, [
                T[81] || (T[81] = f("option", { value: "*" }, "All Emitters", -1)),
                ($(!0), A(Fe, null, Ke(c.value, (L) => ($(), A("option", {
                  key: L.id,
                  value: L.id
                }, Q(L.name), 9, ND))), 128))
              ], 40, RD),
              f("label", zD, [
                f("input", {
                  type: "checkbox",
                  checked: E.enabled,
                  onChange: (L) => we(E.id, "enabled", L.target.checked)
                }, null, 40, BD)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: (L) => Me(E.id)
              }, [...T[82] || (T[82] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, HD)
            ]),
            f("div", UD, [
              T[84] || (T[84] = f("label", null, "Trigger", -1)),
              f("select", {
                value: E.trigger,
                onChange: (L) => we(E.id, "trigger", L.target.value)
              }, [...T[83] || (T[83] = [
                f("option", { value: "death" }, "On Death", -1)
              ])], 40, WD)
            ]),
            f("div", GD, [
              T[85] || (T[85] = f("label", null, "Spawn Count", -1)),
              f("input", {
                type: "range",
                value: E.spawnCount,
                min: "1",
                max: "10",
                step: "1",
                onInput: (L) => we(E.id, "spawnCount", Number(L.target.value))
              }, null, 40, XD),
              f("span", YD, Q(E.spawnCount), 1)
            ]),
            f("div", KD, [
              T[86] || (T[86] = f("label", null, "Inherit Velocity", -1)),
              f("input", {
                type: "range",
                value: E.inheritVelocity,
                min: "0",
                max: "1",
                step: "0.1",
                onInput: (L) => we(E.id, "inheritVelocity", Number(L.target.value))
              }, null, 40, qD),
              f("span", ZD, Q((E.inheritVelocity * 100).toFixed(0)) + "%", 1)
            ]),
            f("div", JD, [
              T[87] || (T[87] = f("label", null, "Size", -1)),
              f("input", {
                type: "range",
                value: E.size,
                min: "1",
                max: "100",
                step: "1",
                onInput: (L) => we(E.id, "size", Number(L.target.value))
              }, null, 40, QD),
              f("span", e$, Q(E.size) + "px", 1)
            ]),
            f("div", t$, [
              T[88] || (T[88] = f("label", null, "Lifetime", -1)),
              f("input", {
                type: "range",
                value: E.lifetime,
                min: "1",
                max: "120",
                step: "1",
                onInput: (L) => we(E.id, "lifetime", Number(L.target.value))
              }, null, 40, n$),
              f("span", i$, Q(E.lifetime) + "f", 1)
            ]),
            f("div", r$, [
              T[89] || (T[89] = f("label", null, "Speed", -1)),
              f("input", {
                type: "range",
                value: E.speed,
                min: "1",
                max: "500",
                step: "10",
                onInput: (L) => we(E.id, "speed", Number(L.target.value))
              }, null, 40, o$),
              f("span", s$, Q(E.speed), 1)
            ]),
            f("div", a$, [
              T[90] || (T[90] = f("label", null, "Spread", -1)),
              f("input", {
                type: "range",
                value: E.spread,
                min: "0",
                max: "360",
                step: "5",
                onInput: (L) => we(E.id, "spread", Number(L.target.value))
              }, null, 40, l$),
              f("span", u$, Q(E.spread) + "", 1)
            ]),
            f("div", c$, [
              T[91] || (T[91] = f("label", null, "Color", -1)),
              f("input", {
                type: "color",
                value: Re(E.color),
                onInput: (L) => fe(E.id, L.target.value)
              }, null, 40, d$)
            ])
          ]))), 128)),
          y.value.length === 0 ? ($(), A("div", h$, " No sub-emitters. Add one for particle death effects. ")) : ve("", !0)
        ])) : ve("", !0)
      ]),
      f("div", f$, [
        f("div", {
          class: "section-header",
          onClick: T[15] || (T[15] = (E) => k("modulations"))
        }, [
          f("i", {
            class: _e(["pi", o.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[93] || (T[93] = f("span", null, "Modulations", -1)),
          f("button", {
            class: "add-btn",
            onClick: tt(W, ["stop"]),
            title: "Add Modulation"
          }, [...T[92] || (T[92] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        o.value.has("modulations") ? ($(), A("div", p$, [
          ($(!0), A(Fe, null, Ke(p.value, (E) => ($(), A("div", {
            key: E.id,
            class: "modulation-item"
          }, [
            f("div", m$, [
              f("select", {
                value: E.emitterId,
                onChange: (L) => M(E.id, "emitterId", L.target.value)
              }, [
                T[94] || (T[94] = f("option", { value: "*" }, "All Emitters", -1)),
                ($(!0), A(Fe, null, Ke(c.value, (L) => ($(), A("option", {
                  key: L.id,
                  value: L.id
                }, Q(L.name), 9, v$))), 128))
              ], 40, g$),
              f("button", {
                class: "remove-btn",
                onClick: (L) => R(E.id)
              }, [...T[95] || (T[95] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, y$)
            ]),
            f("div", b$, [
              T[97] || (T[97] = f("label", null, "Property", -1)),
              f("select", {
                value: E.property,
                onChange: (L) => M(E.id, "property", L.target.value)
              }, [...T[96] || (T[96] = [
                va('<option value="size" data-v-60b9bdc8>Size</option><option value="speed" data-v-60b9bdc8>Speed</option><option value="opacity" data-v-60b9bdc8>Opacity</option><option value="colorR" data-v-60b9bdc8>Color R</option><option value="colorG" data-v-60b9bdc8>Color G</option><option value="colorB" data-v-60b9bdc8>Color B</option>', 6)
              ])], 40, w$)
            ]),
            f("div", _$, [
              T[98] || (T[98] = f("label", null, "Start Value", -1)),
              f("input", {
                type: "number",
                value: E.startValue,
                step: "0.1",
                onInput: (L) => M(E.id, "startValue", Number(L.target.value))
              }, null, 40, x$)
            ]),
            f("div", S$, [
              T[99] || (T[99] = f("label", null, "End Value", -1)),
              f("input", {
                type: "number",
                value: E.endValue,
                step: "0.1",
                onInput: (L) => M(E.id, "endValue", Number(L.target.value))
              }, null, 40, C$)
            ]),
            f("div", k$, [
              T[101] || (T[101] = f("label", null, "Easing", -1)),
              f("select", {
                value: E.easing,
                onChange: (L) => M(E.id, "easing", L.target.value)
              }, [...T[100] || (T[100] = [
                va('<option value="linear" data-v-60b9bdc8>Linear</option><option value="easeIn" data-v-60b9bdc8>Ease In</option><option value="easeOut" data-v-60b9bdc8>Ease Out</option><option value="easeInOut" data-v-60b9bdc8>Ease In Out</option><option value="bounce" data-v-60b9bdc8>Bounce</option><option value="elastic" data-v-60b9bdc8>Elastic</option>', 6)
              ])], 40, O$)
            ])
          ]))), 128)),
          p.value.length === 0 ? ($(), A("div", E$, " No modulations. Add one to animate particle properties over lifetime. ")) : ve("", !0)
        ])) : ve("", !0)
      ]),
      f("div", T$, [
        f("div", {
          class: "section-header",
          onClick: T[16] || (T[16] = (E) => k("render"))
        }, [
          f("i", {
            class: _e(["pi", o.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          T[102] || (T[102] = f("span", null, "Render Options", -1))
        ]),
        o.value.has("render") ? ($(), A("div", D$, [
          f("div", $$, [
            T[104] || (T[104] = f("label", null, "Blend Mode", -1)),
            f("select", {
              value: m.value.blendMode,
              onChange: T[17] || (T[17] = (E) => V("blendMode", E.target.value))
            }, [...T[103] || (T[103] = [
              f("option", { value: "normal" }, "Normal", -1),
              f("option", { value: "additive" }, "Additive", -1),
              f("option", { value: "multiply" }, "Multiply", -1),
              f("option", { value: "screen" }, "Screen", -1)
            ])], 40, M$)
          ]),
          f("div", P$, [
            T[106] || (T[106] = f("label", null, "Shape", -1)),
            f("select", {
              value: m.value.particleShape,
              onChange: T[18] || (T[18] = (E) => V("particleShape", E.target.value))
            }, [...T[105] || (T[105] = [
              f("option", { value: "circle" }, "Circle", -1),
              f("option", { value: "square" }, "Square", -1),
              f("option", { value: "triangle" }, "Triangle", -1),
              f("option", { value: "star" }, "Star", -1)
            ])], 40, I$)
          ]),
          f("div", L$, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: m.value.renderTrails,
                onChange: T[19] || (T[19] = (E) => V("renderTrails", E.target.checked))
              }, null, 40, A$),
              T[107] || (T[107] = vt(" Render Trails ", -1))
            ])
          ]),
          m.value.renderTrails ? ($(), A("div", V$, [
            T[108] || (T[108] = f("label", null, "Trail Length", -1)),
            f("input", {
              type: "range",
              value: m.value.trailLength,
              min: "1",
              max: "20",
              step: "1",
              onInput: T[20] || (T[20] = (E) => V("trailLength", Number(E.target.value)))
            }, null, 40, F$),
            f("span", j$, Q(m.value.trailLength), 1)
          ])) : ve("", !0),
          f("div", R$, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: m.value.glowEnabled,
                onChange: T[21] || (T[21] = (E) => V("glowEnabled", E.target.checked))
              }, null, 40, N$),
              T[109] || (T[109] = vt(" Enable Glow ", -1))
            ])
          ]),
          m.value.glowEnabled ? ($(), A("div", z$, [
            T[110] || (T[110] = f("label", null, "Glow Radius", -1)),
            f("input", {
              type: "range",
              value: m.value.glowRadius,
              min: "1",
              max: "50",
              step: "1",
              onInput: T[22] || (T[22] = (E) => V("glowRadius", Number(E.target.value)))
            }, null, 40, B$),
            f("span", H$, Q(m.value.glowRadius) + "px", 1)
          ])) : ve("", !0),
          m.value.glowEnabled ? ($(), A("div", U$, [
            T[111] || (T[111] = f("label", null, "Glow Intensity", -1)),
            f("input", {
              type: "range",
              value: m.value.glowIntensity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: T[23] || (T[23] = (E) => V("glowIntensity", Number(E.target.value)))
            }, null, 40, W$),
            f("span", G$, Q(m.value.glowIntensity.toFixed(2)), 1)
          ])) : ve("", !0),
          T[118] || (T[118] = f("div", { class: "subsection-divider" }, "Particle Connections", -1)),
          f("div", X$, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: w.value.enabled,
                onChange: T[24] || (T[24] = (E) => ae("enabled", E.target.checked))
              }, null, 40, Y$),
              T[112] || (T[112] = vt(" Enable Connections ", -1))
            ])
          ]),
          w.value.enabled ? ($(), A("div", K$, [
            T[113] || (T[113] = f("label", null, "Max Distance", -1)),
            f("input", {
              type: "range",
              value: w.value.maxDistance,
              min: "10",
              max: "300",
              step: "10",
              onInput: T[25] || (T[25] = (E) => ae("maxDistance", Number(E.target.value)))
            }, null, 40, q$),
            f("span", Z$, Q(w.value.maxDistance) + "px", 1)
          ])) : ve("", !0),
          w.value.enabled ? ($(), A("div", J$, [
            T[114] || (T[114] = f("label", null, "Max Connections", -1)),
            f("input", {
              type: "range",
              value: w.value.maxConnections,
              min: "1",
              max: "5",
              step: "1",
              onInput: T[26] || (T[26] = (E) => ae("maxConnections", Number(E.target.value)))
            }, null, 40, Q$),
            f("span", eM, Q(w.value.maxConnections), 1)
          ])) : ve("", !0),
          w.value.enabled ? ($(), A("div", tM, [
            T[115] || (T[115] = f("label", null, "Line Width", -1)),
            f("input", {
              type: "range",
              value: w.value.lineWidth,
              min: "0.5",
              max: "3",
              step: "0.1",
              onInput: T[27] || (T[27] = (E) => ae("lineWidth", Number(E.target.value)))
            }, null, 40, nM),
            f("span", iM, Q(w.value.lineWidth.toFixed(1)), 1)
          ])) : ve("", !0),
          w.value.enabled ? ($(), A("div", rM, [
            T[116] || (T[116] = f("label", null, "Line Opacity", -1)),
            f("input", {
              type: "range",
              value: w.value.lineOpacity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: T[28] || (T[28] = (E) => ae("lineOpacity", Number(E.target.value)))
            }, null, 40, oM),
            f("span", sM, Q(w.value.lineOpacity.toFixed(2)), 1)
          ])) : ve("", !0),
          w.value.enabled ? ($(), A("div", aM, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: w.value.fadeByDistance,
                onChange: T[29] || (T[29] = (E) => ae("fadeByDistance", E.target.checked))
              }, null, 40, lM),
              T[117] || (T[117] = vt(" Fade by Distance ", -1))
            ])
          ])) : ve("", !0)
        ])) : ve("", !0)
      ]),
      f("div", uM, [
        T[119] || (T[119] = f("i", { class: "pi pi-circle-fill" }, null, -1)),
        f("span", null, Q(g.value) + " particles", 1)
      ])
    ]));
  }
}), dM = /* @__PURE__ */ cn(cM, [["__scopeId", "data-v-60b9bdc8"]]), hM = { class: "depthflow-properties" }, fM = { class: "property-section" }, pM = {
  key: 0,
  class: "section-content"
}, mM = { class: "property-row" }, gM = ["value"], vM = ["value"], yM = { class: "property-row" }, bM = ["value"], wM = ["value"], _M = { class: "property-section" }, xM = {
  key: 0,
  class: "section-content"
}, SM = { class: "preset-grid" }, CM = ["onClick"], kM = {
  key: 0,
  class: "property-row"
}, OM = ["value"], EM = { class: "value-display" }, TM = { class: "property-section" }, DM = {
  key: 0,
  class: "section-content"
}, $M = { class: "property-row" }, MM = ["value"], PM = { class: "value-display" }, IM = { class: "property-row" }, LM = ["value"], AM = { class: "value-display" }, VM = { class: "property-row" }, FM = ["value"], jM = { class: "value-display" }, RM = { class: "property-row" }, NM = ["value"], zM = { class: "value-display" }, BM = { class: "property-section" }, HM = {
  key: 0,
  class: "section-content"
}, UM = { class: "property-row" }, WM = ["value"], GM = { class: "value-display" }, XM = { class: "property-row" }, YM = ["value"], KM = { class: "value-display" }, qM = {
  key: 0,
  class: "property-section"
}, ZM = {
  key: 0,
  class: "section-content"
}, JM = { class: "property-row" }, QM = ["value"], eP = { class: "value-display" }, tP = { class: "property-row" }, nP = ["value"], iP = { class: "value-display" }, rP = { class: "property-row" }, oP = ["value"], sP = { class: "value-display" }, aP = { class: "property-row" }, lP = ["value"], uP = { class: "value-display" }, cP = {
  key: 2,
  class: "property-row"
}, dP = ["value"], hP = { class: "value-display" }, fP = { class: "property-section" }, pP = {
  key: 0,
  class: "section-content"
}, mP = { class: "property-row" }, gP = ["value"], vP = { class: "value-display" }, yP = { class: "property-row checkbox-row" }, bP = ["checked"], wP = { class: "property-section" }, _P = {
  key: 0,
  class: "section-content"
}, xP = { class: "preview-container" }, SP = { class: "preview-controls" }, CP = { class: "frame-indicator" }, ar = 200, kP = /* @__PURE__ */ tn({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(i, { emit: e }) {
    const n = i, r = e, o = Gn(), s = re(null), a = re(!1), l = re(0), u = re(null), c = re(/* @__PURE__ */ new Set(["source", "preset", "camera"])), d = re(1), h = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ], p = Ee(() => n.layer.data || {
      sourceLayerId: "",
      depthLayerId: "",
      config: {
        preset: "static",
        zoom: 1,
        offsetX: 0,
        offsetY: 0,
        rotation: 0,
        depthScale: 1,
        focusDepth: 0.5,
        dollyZoom: 0,
        orbitRadius: 0.1,
        orbitSpeed: 360,
        swingAmplitude: 0.1,
        swingFrequency: 1,
        edgeDilation: 5,
        inpaintEdges: !0
      }
    }), m = Ee(() => p.value.config), v = Ee(() => o.frameCount), y = Ee(
      () => o.layers.filter((ie) => ie.type === "image" || ie.type === "generated")
    ), w = Ee(
      () => o.layers.filter((ie) => ie.type === "depth" || ie.type === "generated")
    ), g = Ee(
      () => ["circle_cw", "circle_ccw"].includes(m.value.preset)
    ), k = Ee(
      () => ["horizontal_swing", "vertical_swing"].includes(m.value.preset)
    ), _ = Ee(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(m.value.preset)
    ), S = Ee(
      () => g.value || k.value || _.value
    ), b = Ee(() => g.value ? "Orbit Settings" : k.value ? "Swing Settings" : _.value ? "Dolly Zoom Settings" : "Preset Settings");
    function C(ie) {
      c.value.has(ie) ? c.value.delete(ie) : c.value.add(ie);
    }
    function x(ie, M) {
      r("update", { [ie]: M });
    }
    function I(ie, M) {
      r("update", {
        config: { ...m.value, [ie]: M }
      });
    }
    function F(ie) {
      I("preset", ie);
    }
    function B(ie) {
      d.value = ie, g.value ? I("orbitRadius", 0.1 * ie) : k.value ? I("swingAmplitude", 0.1 * ie) : I("depthScale", 1 * ie);
    }
    function X() {
      a.value = !a.value, a.value ? j() : u.value !== null && (cancelAnimationFrame(u.value), u.value = null);
    }
    function j() {
      a.value && (l.value = (l.value + 1) % v.value, ee(), u.value = requestAnimationFrame(() => {
        setTimeout(j, 1e3 / o.fps);
      }));
    }
    function ee() {
      const ie = s.value;
      if (!ie) return;
      const M = ie.getContext("2d");
      M && (M.fillStyle = "#1e1e1e", M.fillRect(0, 0, ar, ar), M.fillStyle = "#333", M.fillRect(10, 10, ar - 20, ar - 20), M.fillStyle = "#666", M.font = "12px sans-serif", M.textAlign = "center", M.fillText("Depthflow Preview", ar / 2, ar / 2), M.fillText(`Frame ${l.value}`, ar / 2, ar / 2 + 16));
    }
    return Wn(() => {
      ee();
    }), Qi(() => {
      u.value !== null && cancelAnimationFrame(u.value);
    }), (ie, M) => ($(), A("div", hM, [
      f("div", fM, [
        f("div", {
          class: "section-header",
          onClick: M[0] || (M[0] = (W) => C("source"))
        }, [
          f("i", {
            class: _e(["pi", c.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          M[23] || (M[23] = f("span", null, "Source Selection", -1))
        ]),
        c.value.has("source") ? ($(), A("div", pM, [
          f("div", mM, [
            M[25] || (M[25] = f("label", null, "Source Layer", -1)),
            f("select", {
              value: p.value.sourceLayerId,
              onChange: M[1] || (M[1] = (W) => x("sourceLayerId", W.target.value))
            }, [
              M[24] || (M[24] = f("option", { value: "" }, "Select source...", -1)),
              ($(!0), A(Fe, null, Ke(y.value, (W) => ($(), A("option", {
                key: W.id,
                value: W.id
              }, Q(W.name), 9, vM))), 128))
            ], 40, gM)
          ]),
          f("div", yM, [
            M[27] || (M[27] = f("label", null, "Depth Layer", -1)),
            f("select", {
              value: p.value.depthLayerId,
              onChange: M[2] || (M[2] = (W) => x("depthLayerId", W.target.value))
            }, [
              M[26] || (M[26] = f("option", { value: "" }, "Select depth map...", -1)),
              ($(!0), A(Fe, null, Ke(w.value, (W) => ($(), A("option", {
                key: W.id,
                value: W.id
              }, Q(W.name), 9, wM))), 128))
            ], 40, bM)
          ])
        ])) : ve("", !0)
      ]),
      f("div", _M, [
        f("div", {
          class: "section-header",
          onClick: M[3] || (M[3] = (W) => C("preset"))
        }, [
          f("i", {
            class: _e(["pi", c.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          M[28] || (M[28] = f("span", null, "Motion Preset", -1))
        ]),
        c.value.has("preset") ? ($(), A("div", xM, [
          f("div", SM, [
            ($(), A(Fe, null, Ke(h, (W) => f("button", {
              key: W.value,
              class: _e(["preset-btn", { active: m.value.preset === W.value }]),
              onClick: (R) => F(W.value)
            }, [
              f("i", {
                class: _e(W.icon)
              }, null, 2),
              f("span", null, Q(W.label), 1)
            ], 10, CM)), 64))
          ]),
          m.value.preset !== "static" ? ($(), A("div", kM, [
            M[29] || (M[29] = f("label", null, "Intensity", -1)),
            f("input", {
              type: "range",
              value: d.value,
              min: "0.1",
              max: "2",
              step: "0.1",
              onInput: M[4] || (M[4] = (W) => B(Number(W.target.value)))
            }, null, 40, OM),
            f("span", EM, Q(d.value.toFixed(1)) + "x", 1)
          ])) : ve("", !0)
        ])) : ve("", !0)
      ]),
      f("div", TM, [
        f("div", {
          class: "section-header",
          onClick: M[5] || (M[5] = (W) => C("camera"))
        }, [
          f("i", {
            class: _e(["pi", c.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          M[30] || (M[30] = f("span", null, "Camera Controls", -1))
        ]),
        c.value.has("camera") ? ($(), A("div", DM, [
          f("div", $M, [
            M[31] || (M[31] = f("label", null, "Zoom", -1)),
            p.value.animatedZoom ? ($(), st(us, {
              key: 0,
              property: p.value.animatedZoom,
              "layer-id": i.layer.id
            }, null, 8, ["property", "layer-id"])) : ve("", !0),
            f("input", {
              type: "range",
              value: m.value.zoom,
              min: "0.5",
              max: "2",
              step: "0.01",
              onInput: M[6] || (M[6] = (W) => I("zoom", Number(W.target.value)))
            }, null, 40, MM),
            f("span", PM, Q(m.value.zoom.toFixed(2)), 1)
          ]),
          f("div", IM, [
            M[32] || (M[32] = f("label", null, "Offset X", -1)),
            p.value.animatedOffsetX ? ($(), st(us, {
              key: 0,
              property: p.value.animatedOffsetX,
              "layer-id": i.layer.id
            }, null, 8, ["property", "layer-id"])) : ve("", !0),
            f("input", {
              type: "range",
              value: m.value.offsetX,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: M[7] || (M[7] = (W) => I("offsetX", Number(W.target.value)))
            }, null, 40, LM),
            f("span", AM, Q(m.value.offsetX.toFixed(2)), 1)
          ]),
          f("div", VM, [
            M[33] || (M[33] = f("label", null, "Offset Y", -1)),
            p.value.animatedOffsetY ? ($(), st(us, {
              key: 0,
              property: p.value.animatedOffsetY,
              "layer-id": i.layer.id
            }, null, 8, ["property", "layer-id"])) : ve("", !0),
            f("input", {
              type: "range",
              value: m.value.offsetY,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: M[8] || (M[8] = (W) => I("offsetY", Number(W.target.value)))
            }, null, 40, FM),
            f("span", jM, Q(m.value.offsetY.toFixed(2)), 1)
          ]),
          f("div", RM, [
            M[34] || (M[34] = f("label", null, "Rotation", -1)),
            p.value.animatedRotation ? ($(), st(us, {
              key: 0,
              property: p.value.animatedRotation,
              "layer-id": i.layer.id
            }, null, 8, ["property", "layer-id"])) : ve("", !0),
            f("input", {
              type: "range",
              value: m.value.rotation,
              min: "-180",
              max: "180",
              step: "1",
              onInput: M[9] || (M[9] = (W) => I("rotation", Number(W.target.value)))
            }, null, 40, NM),
            f("span", zM, Q(m.value.rotation) + "", 1)
          ])
        ])) : ve("", !0)
      ]),
      f("div", BM, [
        f("div", {
          class: "section-header",
          onClick: M[10] || (M[10] = (W) => C("depth"))
        }, [
          f("i", {
            class: _e(["pi", c.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          M[35] || (M[35] = f("span", null, "Depth Settings", -1))
        ]),
        c.value.has("depth") ? ($(), A("div", HM, [
          f("div", UM, [
            M[36] || (M[36] = f("label", null, "Depth Scale", -1)),
            p.value.animatedDepthScale ? ($(), st(us, {
              key: 0,
              property: p.value.animatedDepthScale,
              "layer-id": i.layer.id
            }, null, 8, ["property", "layer-id"])) : ve("", !0),
            f("input", {
              type: "range",
              value: m.value.depthScale,
              min: "0",
              max: "2",
              step: "0.05",
              onInput: M[11] || (M[11] = (W) => I("depthScale", Number(W.target.value)))
            }, null, 40, WM),
            f("span", GM, Q(m.value.depthScale.toFixed(2)), 1)
          ]),
          f("div", XM, [
            M[37] || (M[37] = f("label", null, "Focus Depth", -1)),
            f("input", {
              type: "range",
              value: m.value.focusDepth,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: M[12] || (M[12] = (W) => I("focusDepth", Number(W.target.value)))
            }, null, 40, YM),
            f("span", KM, Q(m.value.focusDepth.toFixed(2)), 1)
          ]),
          M[38] || (M[38] = f("div", { class: "depth-hint" }, [
            vt(" Objects at focus depth stay stationary."),
            f("br"),
            vt(" Closer objects move more, distant objects move less. ")
          ], -1))
        ])) : ve("", !0)
      ]),
      S.value ? ($(), A("div", qM, [
        f("div", {
          class: "section-header",
          onClick: M[13] || (M[13] = (W) => C("presetSettings"))
        }, [
          f("i", {
            class: _e(["pi", c.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          f("span", null, Q(b.value), 1)
        ]),
        c.value.has("presetSettings") ? ($(), A("div", ZM, [
          g.value ? ($(), A(Fe, { key: 0 }, [
            f("div", JM, [
              M[39] || (M[39] = f("label", null, "Orbit Radius", -1)),
              f("input", {
                type: "range",
                value: m.value.orbitRadius,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: M[14] || (M[14] = (W) => I("orbitRadius", Number(W.target.value)))
              }, null, 40, QM),
              f("span", eP, Q(m.value.orbitRadius.toFixed(2)), 1)
            ]),
            f("div", tP, [
              M[40] || (M[40] = f("label", null, "Orbit Speed", -1)),
              f("input", {
                type: "range",
                value: m.value.orbitSpeed,
                min: "1",
                max: "720",
                step: "1",
                onInput: M[15] || (M[15] = (W) => I("orbitSpeed", Number(W.target.value)))
              }, null, 40, nP),
              f("span", iP, Q(m.value.orbitSpeed) + "", 1)
            ])
          ], 64)) : ve("", !0),
          k.value ? ($(), A(Fe, { key: 1 }, [
            f("div", rP, [
              M[41] || (M[41] = f("label", null, "Amplitude", -1)),
              f("input", {
                type: "range",
                value: m.value.swingAmplitude,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: M[16] || (M[16] = (W) => I("swingAmplitude", Number(W.target.value)))
              }, null, 40, oP),
              f("span", sP, Q(m.value.swingAmplitude.toFixed(2)), 1)
            ]),
            f("div", aP, [
              M[42] || (M[42] = f("label", null, "Frequency", -1)),
              f("input", {
                type: "range",
                value: m.value.swingFrequency,
                min: "0.1",
                max: "5",
                step: "0.1",
                onInput: M[17] || (M[17] = (W) => I("swingFrequency", Number(W.target.value)))
              }, null, 40, lP),
              f("span", uP, Q(m.value.swingFrequency.toFixed(1)) + " Hz", 1)
            ])
          ], 64)) : ve("", !0),
          _.value ? ($(), A("div", cP, [
            M[43] || (M[43] = f("label", null, "Dolly Rate", -1)),
            f("input", {
              type: "range",
              value: m.value.dollyZoom,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: M[18] || (M[18] = (W) => I("dollyZoom", Number(W.target.value)))
            }, null, 40, dP),
            f("span", hP, Q(m.value.dollyZoom.toFixed(2)), 1)
          ])) : ve("", !0)
        ])) : ve("", !0)
      ])) : ve("", !0),
      f("div", fP, [
        f("div", {
          class: "section-header",
          onClick: M[19] || (M[19] = (W) => C("quality"))
        }, [
          f("i", {
            class: _e(["pi", c.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          M[44] || (M[44] = f("span", null, "Quality", -1))
        ]),
        c.value.has("quality") ? ($(), A("div", pP, [
          f("div", mP, [
            M[45] || (M[45] = f("label", null, "Edge Dilation", -1)),
            f("input", {
              type: "range",
              value: m.value.edgeDilation,
              min: "0",
              max: "50",
              step: "1",
              onInput: M[20] || (M[20] = (W) => I("edgeDilation", Number(W.target.value)))
            }, null, 40, gP),
            f("span", vP, Q(m.value.edgeDilation) + "px", 1)
          ]),
          f("div", yP, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: m.value.inpaintEdges,
                onChange: M[21] || (M[21] = (W) => I("inpaintEdges", W.target.checked))
              }, null, 40, bP),
              M[46] || (M[46] = vt(" Inpaint Edges ", -1))
            ])
          ])
        ])) : ve("", !0)
      ]),
      f("div", wP, [
        f("div", {
          class: "section-header",
          onClick: M[22] || (M[22] = (W) => C("preview"))
        }, [
          f("i", {
            class: _e(["pi", c.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          M[47] || (M[47] = f("span", null, "Preview", -1))
        ]),
        c.value.has("preview") ? ($(), A("div", _P, [
          f("div", xP, [
            f("canvas", {
              ref_key: "previewCanvas",
              ref: s,
              class: "preview-canvas",
              width: ar,
              height: ar
            }, null, 512)
          ]),
          f("div", SP, [
            f("button", {
              class: _e(["preview-btn", { active: a.value }]),
              onClick: X
            }, [
              f("i", {
                class: _e(a.value ? "pi pi-pause" : "pi pi-play")
              }, null, 2),
              vt(" " + Q(a.value ? "Pause" : "Play"), 1)
            ], 2),
            f("span", CP, " Frame " + Q(l.value) + " / " + Q(v.value - 1), 1)
          ])
        ])) : ve("", !0)
      ])
    ]));
  }
}), OP = /* @__PURE__ */ cn(kP, [["__scopeId", "data-v-ffaf4c8a"]]), EP = { class: "properties-panel" }, TP = {
  key: 0,
  class: "panel-content"
}, DP = { class: "property-section" }, $P = { class: "property-row" }, MP = { class: "property-section" }, PP = { class: "expand-icon" }, IP = {
  key: 0,
  class: "section-content"
}, LP = { class: "property-row" }, AP = { class: "multi-value" }, VP = { class: "property-row" }, FP = { class: "multi-value" }, jP = { class: "property-row" }, RP = { class: "single-value" }, NP = { class: "property-row" }, zP = { class: "multi-value" }, BP = { class: "property-row" }, HP = { class: "single-value" }, UP = { class: "property-section" }, WP = { class: "property-row" }, GP = ["value"], XP = {
  key: 0,
  class: "property-section"
}, YP = { class: "expand-icon" }, KP = { class: "effect-count" }, qP = {
  key: 0,
  class: "section-content"
}, ZP = { class: "effect-header" }, JP = ["checked", "onChange"], QP = { class: "effect-name" }, eI = ["onClick"], tI = {
  key: 1,
  class: "empty-state"
}, nI = /* @__PURE__ */ tn({
  __name: "PropertiesPanel",
  setup(i) {
    const e = Gn(), n = re(["transform"]), r = re(!0), o = re(""), s = re({
      position: { x: 0, y: 0 },
      scale: { x: 100, y: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0 },
      opacity: 100
    }), a = re("normal"), l = re([]), u = re([]), c = [
      { label: "Normal", value: "normal" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
      { label: "Add", value: "add" }
    ], d = Ee(() => e.selectedLayer), h = Ee(() => {
      if (!d.value) return null;
      switch (d.value.type) {
        case "text":
          return ji(dE);
        case "particles":
          return ji(dM);
        case "depthflow":
          return ji(OP);
        default:
          return null;
      }
    });
    Lt(d, (b) => {
      var C, x, I, F, B, X, j, ee, ie, M, W, R, V, ae;
      b && (o.value = b.name, s.value = {
        position: { x: ((x = (C = b.position) == null ? void 0 : C.value) == null ? void 0 : x[0]) || 0, y: ((F = (I = b.position) == null ? void 0 : I.value) == null ? void 0 : F[1]) || 0 },
        scale: { x: ((X = (B = b.scale) == null ? void 0 : B.value) == null ? void 0 : X[0]) || 100, y: ((ee = (j = b.scale) == null ? void 0 : j.value) == null ? void 0 : ee[1]) || 100 },
        rotation: ((ie = b.rotation) == null ? void 0 : ie.value) || 0,
        anchorPoint: { x: ((W = (M = b.anchorPoint) == null ? void 0 : M.value) == null ? void 0 : W[0]) || 0, y: ((V = (R = b.anchorPoint) == null ? void 0 : R.value) == null ? void 0 : V[1]) || 0 },
        opacity: ((ae = b.opacity) == null ? void 0 : ae.value) || 100
      }, a.value = b.blendMode || "normal", l.value = b.effects || []);
    }, { immediate: !0 }), Lt(() => s.value.scale.x, (b, C) => {
      if (r.value && b !== C) {
        const x = b / C;
        s.value.scale.y = Math.round(s.value.scale.y * x * 10) / 10;
      }
    });
    function p(b) {
      const C = n.value.indexOf(b);
      C >= 0 ? n.value.splice(C, 1) : n.value.push(b);
    }
    function m() {
      d.value && o.value && (d.value.name = o.value);
    }
    function v() {
      d.value && (d.value.position && (d.value.position.value = [s.value.position.x, s.value.position.y]), d.value.scale && (d.value.scale.value = [s.value.scale.x, s.value.scale.y]), d.value.rotation && (d.value.rotation.value = s.value.rotation), d.value.anchorPoint && (d.value.anchorPoint.value = [s.value.anchorPoint.x, s.value.anchorPoint.y]), d.value.opacity && (d.value.opacity.value = s.value.opacity));
    }
    function y() {
      d.value && (d.value.blendMode = a.value);
    }
    function w(b) {
      return u.value.includes(b);
    }
    function g(b) {
      const C = u.value.indexOf(b);
      C >= 0 ? u.value.splice(C, 1) : (u.value.push(b), console.log(`Added keyframe for ${b} at frame ${e.currentFrame}`));
    }
    function k(b) {
      l.value[b] && (l.value[b].enabled = !l.value[b].enabled);
    }
    function _(b) {
      l.value.splice(b, 1), d.value && d.value.effects && d.value.effects.splice(b, 1);
    }
    function S() {
      e.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    }
    return (b, C) => ($(), A("div", EP, [
      C[28] || (C[28] = f("div", { class: "panel-header" }, [
        f("span", { class: "panel-title" }, "Properties")
      ], -1)),
      d.value ? ($(), A("div", TP, [
        f("div", DP, [
          f("div", $P, [
            ot(f("input", {
              type: "text",
              "onUpdate:modelValue": C[0] || (C[0] = (x) => o.value = x),
              class: "layer-name-input",
              onBlur: m,
              onKeydown: C[1] || (C[1] = Ah((x) => x.target.blur(), ["enter"]))
            }, null, 544), [
              [Qt, o.value]
            ])
          ])
        ]),
        f("div", MP, [
          f("div", {
            class: "section-header",
            onClick: C[2] || (C[2] = (x) => p("transform"))
          }, [
            f("span", PP, Q(n.value.includes("transform") ? "" : ""), 1),
            C[19] || (C[19] = f("span", { class: "section-title" }, "Transform", -1))
          ]),
          n.value.includes("transform") ? ($(), A("div", IP, [
            f("div", LP, [
              C[20] || (C[20] = f("label", null, "Position", -1)),
              f("div", AP, [
                Ve(ze(Rt), {
                  modelValue: s.value.position.x,
                  "onUpdate:modelValue": [
                    C[3] || (C[3] = (x) => s.value.position.x = x),
                    v
                  ],
                  min: -1e4,
                  max: 1e4,
                  precision: 1,
                  unit: "px"
                }, null, 8, ["modelValue"]),
                Ve(ze(Rt), {
                  modelValue: s.value.position.y,
                  "onUpdate:modelValue": [
                    C[4] || (C[4] = (x) => s.value.position.y = x),
                    v
                  ],
                  min: -1e4,
                  max: 1e4,
                  precision: 1,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ]),
              f("button", {
                class: _e(["keyframe-btn", { active: w("position") }]),
                onClick: C[5] || (C[5] = (x) => g("position"))
              }, "", 2)
            ]),
            f("div", VP, [
              C[21] || (C[21] = f("label", null, "Scale", -1)),
              f("div", FP, [
                Ve(ze(Rt), {
                  modelValue: s.value.scale.x,
                  "onUpdate:modelValue": [
                    C[6] || (C[6] = (x) => s.value.scale.x = x),
                    v
                  ],
                  min: 0,
                  max: 1e3,
                  precision: 1,
                  unit: "%"
                }, null, 8, ["modelValue"]),
                f("button", {
                  class: _e(["link-btn", { active: r.value }]),
                  onClick: C[7] || (C[7] = (x) => r.value = !r.value),
                  title: "Link scale values"
                }, "  ", 2),
                Ve(ze(Rt), {
                  modelValue: s.value.scale.y,
                  "onUpdate:modelValue": [
                    C[8] || (C[8] = (x) => s.value.scale.y = x),
                    v
                  ],
                  min: 0,
                  max: 1e3,
                  precision: 1,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ]),
              f("button", {
                class: _e(["keyframe-btn", { active: w("scale") }]),
                onClick: C[9] || (C[9] = (x) => g("scale"))
              }, "", 2)
            ]),
            f("div", jP, [
              C[22] || (C[22] = f("label", null, "Rotation", -1)),
              f("div", RP, [
                Ve(ze(Rt), {
                  modelValue: s.value.rotation,
                  "onUpdate:modelValue": [
                    C[10] || (C[10] = (x) => s.value.rotation = x),
                    v
                  ],
                  min: -180,
                  max: 180,
                  precision: 1,
                  wrap: !0,
                  unit: ""
                }, null, 8, ["modelValue"])
              ]),
              f("button", {
                class: _e(["keyframe-btn", { active: w("rotation") }]),
                onClick: C[11] || (C[11] = (x) => g("rotation"))
              }, "", 2)
            ]),
            f("div", NP, [
              C[23] || (C[23] = f("label", null, "Anchor Point", -1)),
              f("div", zP, [
                Ve(ze(Rt), {
                  modelValue: s.value.anchorPoint.x,
                  "onUpdate:modelValue": [
                    C[12] || (C[12] = (x) => s.value.anchorPoint.x = x),
                    v
                  ],
                  min: -1e4,
                  max: 1e4,
                  precision: 1,
                  unit: "px"
                }, null, 8, ["modelValue"]),
                Ve(ze(Rt), {
                  modelValue: s.value.anchorPoint.y,
                  "onUpdate:modelValue": [
                    C[13] || (C[13] = (x) => s.value.anchorPoint.y = x),
                    v
                  ],
                  min: -1e4,
                  max: 1e4,
                  precision: 1,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ]),
              f("button", {
                class: _e(["keyframe-btn", { active: w("anchorPoint") }]),
                onClick: C[14] || (C[14] = (x) => g("anchorPoint"))
              }, "", 2)
            ]),
            f("div", BP, [
              C[24] || (C[24] = f("label", null, "Opacity", -1)),
              f("div", HP, [
                Ve(ze(Kn), {
                  modelValue: s.value.opacity,
                  "onUpdate:modelValue": [
                    C[15] || (C[15] = (x) => s.value.opacity = x),
                    v
                  ],
                  min: 0,
                  max: 100,
                  precision: 0,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ]),
              f("button", {
                class: _e(["keyframe-btn", { active: w("opacity") }]),
                onClick: C[16] || (C[16] = (x) => g("opacity"))
              }, "", 2)
            ])
          ])) : ve("", !0)
        ]),
        f("div", UP, [
          f("div", WP, [
            C[25] || (C[25] = f("label", null, "Blend Mode", -1)),
            ot(f("select", {
              "onUpdate:modelValue": C[17] || (C[17] = (x) => a.value = x),
              class: "blend-select",
              onChange: y
            }, [
              ($(), A(Fe, null, Ke(c, (x) => f("option", {
                key: x.value,
                value: x.value
              }, Q(x.label), 9, GP)), 64))
            ], 544), [
              [Zr, a.value]
            ])
          ])
        ]),
        l.value.length > 0 ? ($(), A("div", XP, [
          f("div", {
            class: "section-header",
            onClick: C[18] || (C[18] = (x) => p("effects"))
          }, [
            f("span", YP, Q(n.value.includes("effects") ? "" : ""), 1),
            C[26] || (C[26] = f("span", { class: "section-title" }, "Effects", -1)),
            f("span", KP, Q(l.value.length), 1)
          ]),
          n.value.includes("effects") ? ($(), A("div", qP, [
            ($(!0), A(Fe, null, Ke(l.value, (x, I) => ($(), A("div", {
              key: x.id,
              class: "effect-item"
            }, [
              f("div", ZP, [
                f("input", {
                  type: "checkbox",
                  checked: x.enabled,
                  onChange: (F) => k(I),
                  class: "effect-toggle"
                }, null, 40, JP),
                f("span", QP, Q(x.name), 1),
                f("button", {
                  class: "effect-delete",
                  onClick: (F) => _(I)
                }, "", 8, eI)
              ])
            ]))), 128))
          ])) : ve("", !0)
        ])) : ve("", !0),
        h.value ? ($(), st(vr(h.value), {
          key: 1,
          layer: d.value,
          onUpdate: S
        }, null, 40, ["layer"])) : ve("", !0)
      ])) : ($(), A("div", tI, [...C[27] || (C[27] = [
        f("p", null, "No layer selected", -1),
        f("p", { class: "hint" }, "Select a layer to edit its properties", -1)
      ])]))
    ]));
  }
}), iI = /* @__PURE__ */ cn(nI, [["__scopeId", "data-v-f71a36c8"]]);
function Je(i, e, n) {
  return { x: i, y: e, z: n };
}
function lt(i, e) {
  return { x: i.x + e.x, y: i.y + e.y, z: i.z + e.z };
}
function np(i, e) {
  return { x: i.x - e.x, y: i.y - e.y, z: i.z - e.z };
}
function mt(i, e) {
  return { x: i.x * e, y: i.y * e, z: i.z * e };
}
function rI(i) {
  return Math.sqrt(i.x * i.x + i.y * i.y + i.z * i.z);
}
function Jr(i) {
  const e = rI(i);
  return e === 0 ? { x: 0, y: 0, z: 0 } : { x: i.x / e, y: i.y / e, z: i.z / e };
}
function wa(i, e) {
  return {
    x: i.y * e.z - i.z * e.y,
    y: i.z * e.x - i.x * e.z,
    z: i.x * e.y - i.y * e.x
  };
}
function ih(i, e) {
  return i.x * e.x + i.y * e.y + i.z * e.z;
}
function oI(i, e, n, r) {
  const o = new Float32Array(16), s = 1 / Math.tan(i / 2), a = 1 / (n - r);
  return o[0] = s / e, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = s, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = (r + n) * a, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = 2 * r * n * a, o[15] = 0, { elements: o };
}
function sI(i, e, n, r, o, s) {
  const a = new Float32Array(16), l = 1 / (e - i), u = 1 / (r - n), c = 1 / (s - o);
  return a[0] = 2 * l, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * u, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = -2 * c, a[11] = 0, a[12] = -(e + i) * l, a[13] = -(r + n) * u, a[14] = -10001 * c, a[15] = 1, { elements: a };
}
function ur(i, e, n) {
  const r = new Float32Array(16);
  let o = i.x - e.x, s = i.y - e.y, a = i.z - e.z, l = Math.sqrt(o * o + s * s + a * a);
  l === 0 ? a = 1 : (l = 1 / l, o *= l, s *= l, a *= l);
  let u = n.y * a - n.z * s, c = n.z * o - n.x * a, d = n.x * s - n.y * o;
  l = Math.sqrt(u * u + c * c + d * d), l === 0 ? (u = 0, c = 0, d = 0) : (l = 1 / l, u *= l, c *= l, d *= l);
  let h = s * d - a * c, p = a * u - o * d, m = o * c - s * u;
  return l = Math.sqrt(h * h + p * p + m * m), l === 0 ? (h = 0, p = 0, m = 0) : (l = 1 / l, h *= l, p *= l, m *= l), r[0] = u, r[4] = c, r[8] = d, r[12] = -ih({ x: u, y: c, z: d }, i), r[1] = h, r[5] = p, r[9] = m, r[13] = -ih({ x: h, y: p, z: m }, i), r[2] = o, r[6] = s, r[10] = a, r[14] = -ih({ x: o, y: s, z: a }, i), r[3] = 0, r[7] = 0, r[11] = 0, r[15] = 1, { elements: r };
}
function aI(i, e) {
  const n = i.elements, r = n[3] * e.x + n[7] * e.y + n[11] * e.z + n[15];
  return {
    x: (n[0] * e.x + n[4] * e.y + n[8] * e.z + n[12]) / r,
    y: (n[1] * e.x + n[5] * e.y + n[9] * e.z + n[13]) / r,
    z: (n[2] * e.x + n[6] * e.y + n[10] * e.z + n[14]) / r
  };
}
function ip(i, e) {
  return 2 * Math.atan(e / (2 * i));
}
function lI(i, e) {
  return e / (2 * Math.tan(i / 2));
}
const uI = { class: "camera-properties" }, cI = { class: "panel-header" }, dI = { class: "camera-name" }, hI = {
  key: 0,
  class: "properties-content"
}, fI = { class: "property-section" }, pI = { class: "property-row" }, mI = ["value"], gI = { class: "property-section" }, vI = { class: "toggle-icon" }, yI = { class: "section-content" }, bI = { class: "property-group" }, wI = { class: "xyz-inputs" }, _I = {
  key: 0,
  class: "property-group"
}, xI = { class: "xyz-inputs" }, SI = { class: "property-group" }, CI = { class: "xyz-inputs" }, kI = { class: "property-group" }, OI = { class: "property-group" }, EI = { class: "property-group" }, TI = { class: "property-section" }, DI = { class: "toggle-icon" }, $I = { class: "section-content" }, MI = { class: "preset-row" }, PI = ["onClick"], II = { class: "property-group" }, LI = { class: "property-group" }, AI = { class: "property-group" }, VI = { class: "property-group" }, FI = ["value"], jI = { class: "property-section" }, RI = { class: "toggle-icon" }, NI = { class: "section-content" }, zI = { class: "property-group checkbox-group" }, BI = ["checked"], HI = { class: "property-group" }, UI = { class: "property-group" }, WI = { class: "property-group" }, GI = { class: "property-group checkbox-group" }, XI = ["checked"], YI = { class: "property-section" }, KI = { class: "toggle-icon" }, qI = { class: "section-content" }, ZI = { class: "property-group" }, JI = { class: "property-group" }, QI = { class: "property-group" }, e5 = { class: "property-group" }, t5 = { class: "property-group" }, n5 = { class: "property-section" }, i5 = { class: "toggle-icon" }, r5 = { class: "section-content" }, o5 = { class: "property-group" }, s5 = { class: "property-group" }, a5 = { class: "property-group" }, l5 = { class: "property-section" }, u5 = { class: "toggle-icon" }, c5 = { class: "section-content" }, d5 = { class: "property-group" }, h5 = ["value"], f5 = { class: "property-section" }, p5 = { class: "toggle-icon" }, m5 = { class: "section-content" }, g5 = { class: "property-group" }, v5 = { class: "property-group" }, y5 = {
  key: 1,
  class: "no-camera"
}, b5 = /* @__PURE__ */ tn({
  __name: "CameraProperties",
  props: {
    camera: {}
  },
  emits: ["update:camera", "createCamera"],
  setup(i, { emit: e }) {
    const n = i, r = e, o = zo({
      transform: !0,
      lens: !0,
      dof: !1,
      iris: !1,
      highlight: !1,
      autoOrient: !1,
      clipping: !1
    });
    function s(w) {
      o[w] = !o[w];
    }
    function a(w, g) {
      n.camera && r("update:camera", { ...n.camera, [w]: g });
    }
    function l(w, g) {
      n.camera && r("update:camera", {
        ...n.camera,
        position: { ...n.camera.position, [w]: g }
      });
    }
    function u(w, g) {
      n.camera && r("update:camera", {
        ...n.camera,
        pointOfInterest: { ...n.camera.pointOfInterest, [w]: g }
      });
    }
    function c(w, g) {
      n.camera && r("update:camera", {
        ...n.camera,
        orientation: { ...n.camera.orientation, [w]: g }
      });
    }
    function d(w) {
      if (!n.camera) return;
      const g = ip(w, n.camera.filmSize);
      r("update:camera", {
        ...n.camera,
        focalLength: w,
        angleOfView: g
      });
    }
    function h(w) {
      if (!n.camera) return;
      const g = lI(w, n.camera.filmSize);
      r("update:camera", {
        ...n.camera,
        angleOfView: w,
        focalLength: g
      });
    }
    function p(w, g) {
      n.camera && r("update:camera", {
        ...n.camera,
        depthOfField: { ...n.camera.depthOfField, [w]: g }
      });
    }
    function m(w, g) {
      n.camera && r("update:camera", {
        ...n.camera,
        iris: { ...n.camera.iris, [w]: g }
      });
    }
    function v(w, g) {
      n.camera && r("update:camera", {
        ...n.camera,
        highlight: { ...n.camera.highlight, [w]: g }
      });
    }
    function y(w) {
      n.camera && r("update:camera", {
        ...n.camera,
        focalLength: w.focalLength,
        angleOfView: w.angleOfView,
        zoom: w.zoom
      });
    }
    return (w, g) => {
      var k;
      return $(), A("div", uI, [
        f("div", cI, [
          g[39] || (g[39] = f("span", { class: "panel-title" }, "Camera", -1)),
          f("span", dI, Q(((k = i.camera) == null ? void 0 : k.name) ?? "No Camera"), 1)
        ]),
        i.camera ? ($(), A("div", hI, [
          f("div", fI, [
            g[41] || (g[41] = f("div", { class: "section-header" }, "Type", -1)),
            f("div", pI, [
              f("select", {
                value: i.camera.type,
                onChange: g[0] || (g[0] = (_) => a("type", _.target.value)),
                class: "type-select"
              }, [...g[40] || (g[40] = [
                f("option", { value: "one-node" }, "One-Node Camera", -1),
                f("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, mI)
            ])
          ]),
          f("div", gI, [
            f("div", {
              class: "section-header",
              onClick: g[1] || (g[1] = (_) => s("transform"))
            }, [
              f("span", vI, Q(o.transform ? "" : ""), 1),
              g[42] || (g[42] = vt(" Transform ", -1))
            ]),
            ot(f("div", yI, [
              f("div", bI, [
                g[43] || (g[43] = f("label", null, "Position", -1)),
                f("div", wI, [
                  Ve(ze(Rt), {
                    modelValue: i.camera.position.x,
                    "onUpdate:modelValue": g[2] || (g[2] = (_) => l("x", _)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ve(ze(Rt), {
                    modelValue: i.camera.position.y,
                    "onUpdate:modelValue": g[3] || (g[3] = (_) => l("y", _)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ve(ze(Rt), {
                    modelValue: i.camera.position.z,
                    "onUpdate:modelValue": g[4] || (g[4] = (_) => l("z", _)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              i.camera.type === "two-node" ? ($(), A("div", _I, [
                g[44] || (g[44] = f("label", null, "Point of Interest", -1)),
                f("div", xI, [
                  Ve(ze(Rt), {
                    modelValue: i.camera.pointOfInterest.x,
                    "onUpdate:modelValue": g[5] || (g[5] = (_) => u("x", _)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ve(ze(Rt), {
                    modelValue: i.camera.pointOfInterest.y,
                    "onUpdate:modelValue": g[6] || (g[6] = (_) => u("y", _)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ve(ze(Rt), {
                    modelValue: i.camera.pointOfInterest.z,
                    "onUpdate:modelValue": g[7] || (g[7] = (_) => u("z", _)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : ve("", !0),
              f("div", SI, [
                g[45] || (g[45] = f("label", null, "Orientation", -1)),
                f("div", CI, [
                  Ve(ze(Rt), {
                    modelValue: i.camera.orientation.x,
                    "onUpdate:modelValue": g[8] || (g[8] = (_) => c("x", _)),
                    label: "X",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ve(ze(Rt), {
                    modelValue: i.camera.orientation.y,
                    "onUpdate:modelValue": g[9] || (g[9] = (_) => c("y", _)),
                    label: "Y",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ve(ze(Rt), {
                    modelValue: i.camera.orientation.z,
                    "onUpdate:modelValue": g[10] || (g[10] = (_) => c("z", _)),
                    label: "Z",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              f("div", kI, [
                g[46] || (g[46] = f("label", null, "X Rotation", -1)),
                Ve(ze(Rt), {
                  modelValue: i.camera.xRotation,
                  "onUpdate:modelValue": g[11] || (g[11] = (_) => a("xRotation", _)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", OI, [
                g[47] || (g[47] = f("label", null, "Y Rotation", -1)),
                Ve(ze(Rt), {
                  modelValue: i.camera.yRotation,
                  "onUpdate:modelValue": g[12] || (g[12] = (_) => a("yRotation", _)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", EI, [
                g[48] || (g[48] = f("label", null, "Z Rotation", -1)),
                Ve(ze(Rt), {
                  modelValue: i.camera.zRotation,
                  "onUpdate:modelValue": g[13] || (g[13] = (_) => a("zRotation", _)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [ts, o.transform]
            ])
          ]),
          f("div", TI, [
            f("div", {
              class: "section-header",
              onClick: g[14] || (g[14] = (_) => s("lens"))
            }, [
              f("span", DI, Q(o.lens ? "" : ""), 1),
              g[49] || (g[49] = vt(" Lens ", -1))
            ]),
            ot(f("div", $I, [
              f("div", MI, [
                ($(!0), A(Fe, null, Ke(ze(ok), (_) => ($(), A("button", {
                  key: _.name,
                  class: _e({ active: Math.abs(i.camera.focalLength - _.focalLength) < 0.5 }),
                  onClick: (S) => y(_)
                }, Q(_.name), 11, PI))), 128))
              ]),
              f("div", II, [
                g[50] || (g[50] = f("label", null, "Focal Length", -1)),
                Ve(ze(Rt), {
                  modelValue: i.camera.focalLength,
                  "onUpdate:modelValue": d,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", LI, [
                g[51] || (g[51] = f("label", null, "Angle of View", -1)),
                Ve(ze(Rt), {
                  modelValue: i.camera.angleOfView,
                  "onUpdate:modelValue": h,
                  min: 1,
                  max: 170,
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", AI, [
                g[52] || (g[52] = f("label", null, "Film Size", -1)),
                Ve(ze(Rt), {
                  modelValue: i.camera.filmSize,
                  "onUpdate:modelValue": g[15] || (g[15] = (_) => a("filmSize", _)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", VI, [
                g[54] || (g[54] = f("label", null, "Measure Film Size", -1)),
                f("select", {
                  value: i.camera.measureFilmSize,
                  onChange: g[16] || (g[16] = (_) => a("measureFilmSize", _.target.value))
                }, [...g[53] || (g[53] = [
                  f("option", { value: "horizontal" }, "Horizontal", -1),
                  f("option", { value: "vertical" }, "Vertical", -1),
                  f("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, FI)
              ])
            ], 512), [
              [ts, o.lens]
            ])
          ]),
          f("div", jI, [
            f("div", {
              class: "section-header",
              onClick: g[17] || (g[17] = (_) => s("dof"))
            }, [
              f("span", RI, Q(o.dof ? "" : ""), 1),
              g[55] || (g[55] = vt(" Depth of Field ", -1))
            ]),
            ot(f("div", NI, [
              f("div", zI, [
                f("label", null, [
                  f("input", {
                    type: "checkbox",
                    checked: i.camera.depthOfField.enabled,
                    onChange: g[18] || (g[18] = (_) => p("enabled", _.target.checked))
                  }, null, 40, BI),
                  g[56] || (g[56] = vt(" Enable DOF ", -1))
                ])
              ]),
              i.camera.depthOfField.enabled ? ($(), A(Fe, { key: 0 }, [
                f("div", HI, [
                  g[57] || (g[57] = f("label", null, "Focus Distance", -1)),
                  Ve(ze(Rt), {
                    modelValue: i.camera.depthOfField.focusDistance,
                    "onUpdate:modelValue": g[19] || (g[19] = (_) => p("focusDistance", _)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                f("div", UI, [
                  g[58] || (g[58] = f("label", null, "f-Stop", -1)),
                  Ve(ze(Rt), {
                    modelValue: i.camera.depthOfField.fStop,
                    "onUpdate:modelValue": g[20] || (g[20] = (_) => p("fStop", _)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                f("div", WI, [
                  g[59] || (g[59] = f("label", null, "Blur Level", -1)),
                  Ve(ze(Kn), {
                    modelValue: i.camera.depthOfField.blurLevel,
                    "onUpdate:modelValue": g[21] || (g[21] = (_) => p("blurLevel", _)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                f("div", GI, [
                  f("label", null, [
                    f("input", {
                      type: "checkbox",
                      checked: i.camera.depthOfField.lockToZoom,
                      onChange: g[22] || (g[22] = (_) => p("lockToZoom", _.target.checked))
                    }, null, 40, XI),
                    g[60] || (g[60] = vt(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : ve("", !0)
            ], 512), [
              [ts, o.dof]
            ])
          ]),
          f("div", YI, [
            f("div", {
              class: "section-header",
              onClick: g[23] || (g[23] = (_) => s("iris"))
            }, [
              f("span", KI, Q(o.iris ? "" : ""), 1),
              g[61] || (g[61] = vt(" Iris ", -1))
            ]),
            ot(f("div", qI, [
              f("div", ZI, [
                f("label", null, "Shape (" + Q(Math.round(i.camera.iris.shape)) + "-gon)", 1),
                Ve(ze(Kn), {
                  modelValue: i.camera.iris.shape,
                  "onUpdate:modelValue": g[24] || (g[24] = (_) => m("shape", _)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", JI, [
                g[62] || (g[62] = f("label", null, "Rotation", -1)),
                Ve(ze(kO), {
                  modelValue: i.camera.iris.rotation,
                  "onUpdate:modelValue": g[25] || (g[25] = (_) => m("rotation", _)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              f("div", QI, [
                g[63] || (g[63] = f("label", null, "Roundness", -1)),
                Ve(ze(Kn), {
                  modelValue: i.camera.iris.roundness,
                  "onUpdate:modelValue": g[26] || (g[26] = (_) => m("roundness", _)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", e5, [
                g[64] || (g[64] = f("label", null, "Aspect Ratio", -1)),
                Ve(ze(Kn), {
                  modelValue: i.camera.iris.aspectRatio,
                  "onUpdate:modelValue": g[27] || (g[27] = (_) => m("aspectRatio", _)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", t5, [
                g[65] || (g[65] = f("label", null, "Diffraction Fringe", -1)),
                Ve(ze(Kn), {
                  modelValue: i.camera.iris.diffractionFringe,
                  "onUpdate:modelValue": g[28] || (g[28] = (_) => m("diffractionFringe", _)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [ts, o.iris]
            ])
          ]),
          f("div", n5, [
            f("div", {
              class: "section-header",
              onClick: g[29] || (g[29] = (_) => s("highlight"))
            }, [
              f("span", i5, Q(o.highlight ? "" : ""), 1),
              g[66] || (g[66] = vt(" Highlight ", -1))
            ]),
            ot(f("div", r5, [
              f("div", o5, [
                g[67] || (g[67] = f("label", null, "Gain", -1)),
                Ve(ze(Kn), {
                  modelValue: i.camera.highlight.gain,
                  "onUpdate:modelValue": g[30] || (g[30] = (_) => v("gain", _)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", s5, [
                g[68] || (g[68] = f("label", null, "Threshold", -1)),
                Ve(ze(Kn), {
                  modelValue: i.camera.highlight.threshold,
                  "onUpdate:modelValue": g[31] || (g[31] = (_) => v("threshold", _)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", a5, [
                g[69] || (g[69] = f("label", null, "Saturation", -1)),
                Ve(ze(Kn), {
                  modelValue: i.camera.highlight.saturation,
                  "onUpdate:modelValue": g[32] || (g[32] = (_) => v("saturation", _)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [ts, o.highlight]
            ])
          ]),
          f("div", l5, [
            f("div", {
              class: "section-header",
              onClick: g[33] || (g[33] = (_) => s("autoOrient"))
            }, [
              f("span", u5, Q(o.autoOrient ? "" : ""), 1),
              g[70] || (g[70] = vt(" Auto-Orient ", -1))
            ]),
            ot(f("div", c5, [
              f("div", d5, [
                f("select", {
                  value: i.camera.autoOrient,
                  onChange: g[34] || (g[34] = (_) => a("autoOrient", _.target.value))
                }, [...g[71] || (g[71] = [
                  f("option", { value: "off" }, "Off", -1),
                  f("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  f("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, h5)
              ])
            ], 512), [
              [ts, o.autoOrient]
            ])
          ]),
          f("div", f5, [
            f("div", {
              class: "section-header",
              onClick: g[35] || (g[35] = (_) => s("clipping"))
            }, [
              f("span", p5, Q(o.clipping ? "" : ""), 1),
              g[72] || (g[72] = vt(" Clipping ", -1))
            ]),
            ot(f("div", m5, [
              f("div", g5, [
                g[73] || (g[73] = f("label", null, "Near Clip", -1)),
                Ve(ze(Rt), {
                  modelValue: i.camera.nearClip,
                  "onUpdate:modelValue": g[36] || (g[36] = (_) => a("nearClip", _)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", v5, [
                g[74] || (g[74] = f("label", null, "Far Clip", -1)),
                Ve(ze(Rt), {
                  modelValue: i.camera.farClip,
                  "onUpdate:modelValue": g[37] || (g[37] = (_) => a("farClip", _)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [ts, o.clipping]
            ])
          ])
        ])) : ($(), A("div", y5, [
          g[75] || (g[75] = f("p", null, "No camera selected", -1)),
          f("button", {
            onClick: g[38] || (g[38] = (_) => w.$emit("createCamera"))
          }, "Create Camera")
        ]))
      ]);
    };
  }
}), w5 = /* @__PURE__ */ cn(b5, [["__scopeId", "data-v-746aa734"]]), _5 = { class: "audio-panel" }, x5 = {
  key: 0,
  class: "panel-content"
}, S5 = { class: "audio-info" }, C5 = { class: "file-info" }, k5 = { class: "file-details" }, O5 = { class: "file-name" }, E5 = { class: "file-meta" }, T5 = { class: "control-section" }, D5 = { class: "control-row" }, $5 = { class: "waveform-section" }, M5 = { class: "section-header" }, P5 = { class: "waveform-controls" }, I5 = { class: "waveform-display" }, L5 = { class: "control-section" }, A5 = { class: "expand-icon" }, V5 = {
  key: 0,
  class: "section-content"
}, F5 = { class: "control-row" }, j5 = { class: "control-row" }, R5 = { class: "beat-indicator" }, N5 = { class: "beat-value" }, z5 = { class: "control-section" }, B5 = { class: "expand-icon" }, H5 = {
  key: 0,
  class: "section-content"
}, U5 = { class: "frequency-bands" }, W5 = { class: "band-name" }, G5 = { class: "band-meter" }, X5 = { class: "band-value" }, Y5 = { class: "control-section" }, K5 = { class: "expand-icon" }, q5 = {
  key: 0,
  class: "section-content"
}, Z5 = { class: "control-row" }, J5 = ["value"], Q5 = {
  key: 0,
  class: "reactivity-options"
}, e3 = { class: "control-row" }, t3 = { class: "control-row" }, n3 = { class: "control-row" }, i3 = { class: "control-row" }, r3 = {
  key: 1,
  class: "empty-state"
}, o3 = /* @__PURE__ */ tn({
  __name: "AudioPanel",
  setup(i) {
    const e = Gn(), n = re(null), r = re(null), o = re(["beats", "bands"]), s = re("waveform"), a = re(80), l = re(!1), u = re(70), c = re(50), d = re(120), h = re(!1), p = re([
      { name: "Bass", level: 45 },
      { name: "Low", level: 60 },
      { name: "Mid", level: 75 },
      { name: "High", level: 55 },
      { name: "Treble", level: 40 }
    ]), m = re(""), v = re("opacity"), y = re("bass"), w = re(100), g = re(50), k = Ee(() => !!e.audioBuffer), _ = Ee(() => {
      var R;
      return ((R = e.audioFile) == null ? void 0 : R.name) || "Unknown";
    }), S = Ee(() => {
      if (!e.audioBuffer) return "0:00";
      const R = e.audioBuffer.duration, V = Math.floor(R / 60), ae = Math.floor(R % 60);
      return `${V}:${String(ae).padStart(2, "0")}`;
    }), b = Ee(() => e.audioBuffer ? `${(e.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : "0 Hz"), C = Ee(() => {
      var R, V;
      return ((V = (R = e.project) == null ? void 0 : R.composition) == null ? void 0 : V.layers) || [];
    });
    function x() {
      var R;
      (R = n.value) == null || R.click();
    }
    async function I(R) {
      var $e;
      const V = R.target;
      if (!(($e = V.files) != null && $e.length)) return;
      const ae = V.files[0];
      await e.loadAudio(ae), V.value = "";
    }
    function F() {
      e.clearAudio();
    }
    function B() {
      l.value = !l.value;
    }
    function X(R) {
      const V = o.value.indexOf(R);
      V >= 0 ? o.value.splice(V, 1) : o.value.push(R);
    }
    function j() {
      if (!r.value || !e.audioBuffer) return;
      const R = r.value, V = R.getContext("2d");
      if (!V) return;
      const ae = R.getBoundingClientRect();
      R.width = ae.width * window.devicePixelRatio, R.height = ae.height * window.devicePixelRatio, V.scale(window.devicePixelRatio, window.devicePixelRatio), ee(V, ae.width, ae.height);
    }
    function ee(R, V, ae) {
      if (!e.audioBuffer) return;
      const $e = e.audioBuffer.getChannelData(0), N = Math.ceil($e.length / V), me = ae / 2;
      R.fillStyle = "#1a1a1a", R.fillRect(0, 0, V, ae), R.beginPath(), R.strokeStyle = "#4a90d9", R.lineWidth = 1;
      for (let fe = 0; fe < V; fe++) {
        let te = 1, Me = -1;
        for (let le = 0; le < N; le++) {
          const T = $e[fe * N + le];
          T < te && (te = T), T > Me && (Me = T);
        }
        const Re = (1 + te) * me, Ce = (1 + Me) * me;
        R.moveTo(fe, Re), R.lineTo(fe, Ce);
      }
      R.stroke();
      const we = e.currentFrame / e.frameCount * V;
      R.beginPath(), R.strokeStyle = "#fff", R.lineWidth = 1, R.moveTo(we, 0), R.lineTo(we, ae), R.stroke();
    }
    let ie;
    function M() {
      const V = 6e4 / d.value;
      ie = window.setInterval(() => {
        h.value = !0, setTimeout(() => {
          h.value = !1;
        }, 100), p.value = p.value.map((ae) => ({
          ...ae,
          level: Math.min(100, Math.max(10, ae.level + (Math.random() - 0.5) * 30))
        }));
      }, V);
    }
    function W() {
      clearInterval(ie);
    }
    return Wn(() => {
      k.value && (j(), M());
    }), Qi(() => {
      W();
    }), Lt(k, (R) => {
      R ? setTimeout(() => {
        j(), M();
      }, 100) : W();
    }), Lt(() => e.currentFrame, () => {
      if (k.value && r.value) {
        const R = r.value.getContext("2d");
        if (R) {
          const V = r.value.getBoundingClientRect();
          ee(R, V.width, V.height);
        }
      }
    }), (R, V) => ($(), A("div", _5, [
      f("div", { class: "panel-header" }, [
        V[14] || (V[14] = f("span", { class: "panel-title" }, "Audio", -1)),
        f("div", { class: "header-actions" }, [
          f("button", {
            onClick: x,
            title: "Load Audio"
          }, [...V[13] || (V[13] = [
            f("span", { class: "icon" }, "", -1)
          ])])
        ])
      ]),
      k.value ? ($(), A("div", x5, [
        f("div", S5, [
          f("div", C5, [
            V[15] || (V[15] = f("span", { class: "file-icon" }, "", -1)),
            f("div", k5, [
              f("span", O5, Q(_.value), 1),
              f("span", E5, Q(S.value) + "  " + Q(b.value), 1)
            ]),
            f("button", {
              class: "remove-btn",
              onClick: F,
              title: "Remove Audio"
            }, "")
          ])
        ]),
        f("div", T5, [
          f("div", D5, [
            V[16] || (V[16] = f("label", null, "Master Volume", -1)),
            Ve(ze(Kn), {
              modelValue: a.value,
              "onUpdate:modelValue": V[0] || (V[0] = (ae) => a.value = ae),
              min: 0,
              max: 100,
              precision: 0,
              unit: "%"
            }, null, 8, ["modelValue"]),
            f("button", {
              class: _e(["mute-btn", { active: l.value }]),
              onClick: B,
              title: "Mute"
            }, Q(l.value ? "" : ""), 3)
          ])
        ]),
        f("div", $5, [
          f("div", M5, [
            V[17] || (V[17] = f("span", { class: "section-title" }, "Waveform", -1)),
            f("div", P5, [
              f("button", {
                class: _e({ active: s.value === "waveform" }),
                onClick: V[1] || (V[1] = (ae) => s.value = "waveform")
              }, " Wave ", 2),
              f("button", {
                class: _e({ active: s.value === "spectrum" }),
                onClick: V[2] || (V[2] = (ae) => s.value = "spectrum")
              }, " Spectrum ", 2)
            ])
          ]),
          f("div", I5, [
            f("canvas", {
              ref_key: "waveformCanvas",
              ref: r,
              class: "waveform-canvas"
            }, null, 512)
          ])
        ]),
        f("div", L5, [
          f("div", {
            class: "section-header",
            onClick: V[3] || (V[3] = (ae) => X("beats"))
          }, [
            f("span", A5, Q(o.value.includes("beats") ? "" : ""), 1),
            V[18] || (V[18] = f("span", { class: "section-title" }, "Beat Detection", -1))
          ]),
          o.value.includes("beats") ? ($(), A("div", V5, [
            f("div", F5, [
              V[19] || (V[19] = f("label", null, "Sensitivity", -1)),
              Ve(ze(Kn), {
                modelValue: u.value,
                "onUpdate:modelValue": V[4] || (V[4] = (ae) => u.value = ae),
                min: 0,
                max: 100,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ]),
            f("div", j5, [
              V[20] || (V[20] = f("label", null, "Threshold", -1)),
              Ve(ze(Kn), {
                modelValue: c.value,
                "onUpdate:modelValue": V[5] || (V[5] = (ae) => c.value = ae),
                min: 0,
                max: 100,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ]),
            f("div", R5, [
              V[21] || (V[21] = f("span", { class: "beat-label" }, "BPM:", -1)),
              f("span", N5, Q(d.value), 1),
              f("span", {
                class: _e(["beat-pulse", { active: h.value }])
              }, null, 2)
            ])
          ])) : ve("", !0)
        ]),
        f("div", z5, [
          f("div", {
            class: "section-header",
            onClick: V[6] || (V[6] = (ae) => X("bands"))
          }, [
            f("span", B5, Q(o.value.includes("bands") ? "" : ""), 1),
            V[22] || (V[22] = f("span", { class: "section-title" }, "Frequency Bands", -1))
          ]),
          o.value.includes("bands") ? ($(), A("div", H5, [
            f("div", U5, [
              ($(!0), A(Fe, null, Ke(p.value, (ae, $e) => ($(), A("div", {
                key: ae.name,
                class: "band-item"
              }, [
                f("span", W5, Q(ae.name), 1),
                f("div", G5, [
                  f("div", {
                    class: "band-fill",
                    style: Pt({ height: `${ae.level}%` })
                  }, null, 4)
                ]),
                f("span", X5, Q(Math.round(ae.level)), 1)
              ]))), 128))
            ])
          ])) : ve("", !0)
        ]),
        f("div", Y5, [
          f("div", {
            class: "section-header",
            onClick: V[7] || (V[7] = (ae) => X("reactivity"))
          }, [
            f("span", K5, Q(o.value.includes("reactivity") ? "" : ""), 1),
            V[23] || (V[23] = f("span", { class: "section-title" }, "Audio Reactivity", -1))
          ]),
          o.value.includes("reactivity") ? ($(), A("div", q5, [
            f("div", Z5, [
              V[25] || (V[25] = f("label", null, "Link to Layer", -1)),
              ot(f("select", {
                "onUpdate:modelValue": V[8] || (V[8] = (ae) => m.value = ae),
                class: "layer-select"
              }, [
                V[24] || (V[24] = f("option", { value: "" }, "None", -1)),
                ($(!0), A(Fe, null, Ke(C.value, (ae) => ($(), A("option", {
                  key: ae.id,
                  value: ae.id
                }, Q(ae.name), 9, J5))), 128))
              ], 512), [
                [Zr, m.value]
              ])
            ]),
            m.value ? ($(), A("div", Q5, [
              f("div", e3, [
                V[27] || (V[27] = f("label", null, "Property", -1)),
                ot(f("select", {
                  "onUpdate:modelValue": V[9] || (V[9] = (ae) => v.value = ae),
                  class: "property-select"
                }, [...V[26] || (V[26] = [
                  va('<option value="opacity" data-v-589b649c>Opacity</option><option value="scale" data-v-589b649c>Scale</option><option value="rotation" data-v-589b649c>Rotation</option><option value="position.x" data-v-589b649c>Position X</option><option value="position.y" data-v-589b649c>Position Y</option>', 5)
                ])], 512), [
                  [Zr, v.value]
                ])
              ]),
              f("div", t3, [
                V[29] || (V[29] = f("label", null, "Band", -1)),
                ot(f("select", {
                  "onUpdate:modelValue": V[10] || (V[10] = (ae) => y.value = ae),
                  class: "band-select"
                }, [...V[28] || (V[28] = [
                  va('<option value="bass" data-v-589b649c>Bass</option><option value="lowMid" data-v-589b649c>Low Mid</option><option value="mid" data-v-589b649c>Mid</option><option value="highMid" data-v-589b649c>High Mid</option><option value="treble" data-v-589b649c>Treble</option><option value="overall" data-v-589b649c>Overall</option>', 6)
                ])], 512), [
                  [Zr, y.value]
                ])
              ]),
              f("div", n3, [
                V[30] || (V[30] = f("label", null, "Intensity", -1)),
                Ve(ze(Kn), {
                  modelValue: w.value,
                  "onUpdate:modelValue": V[11] || (V[11] = (ae) => w.value = ae),
                  min: 0,
                  max: 200,
                  precision: 0,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ]),
              f("div", i3, [
                V[31] || (V[31] = f("label", null, "Smoothing", -1)),
                Ve(ze(Kn), {
                  modelValue: g.value,
                  "onUpdate:modelValue": V[12] || (V[12] = (ae) => g.value = ae),
                  min: 0,
                  max: 100,
                  precision: 0,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ])
            ])) : ve("", !0)
          ])) : ve("", !0)
        ])
      ])) : ($(), A("div", r3, [
        V[32] || (V[32] = f("div", { class: "empty-icon" }, "", -1)),
        V[33] || (V[33] = f("p", null, "No audio loaded", -1)),
        f("button", {
          class: "load-btn",
          onClick: x
        }, " Load Audio File "),
        V[34] || (V[34] = f("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
      ])),
      f("input", {
        ref_key: "audioFileInput",
        ref: n,
        type: "file",
        accept: "audio/*",
        style: { display: "none" },
        onChange: I
      }, null, 544)
    ]));
  }
}), s3 = /* @__PURE__ */ cn(o3, [["__scopeId", "data-v-589b649c"]]), Mg = 40, a3 = 30;
function l3(i) {
  const e = [], n = "#ffcc00", r = i.position;
  let o;
  if (i.type === "two-node")
    o = Jr(np(i.pointOfInterest, r));
  else {
    const m = i.orientation.x * Math.PI / 180, v = i.orientation.y * Math.PI / 180;
    o = Je(
      Math.sin(v) * Math.cos(m),
      -Math.sin(m),
      Math.cos(v) * Math.cos(m)
    );
  }
  const s = Je(0, -1, 0);
  let a = Jr(wa(o, s));
  isNaN(a.x) && (a = Je(1, 0, 0));
  const l = Jr(wa(a, o)), u = Mg / 2, c = lt(r, mt(o, -Mg)), d = [];
  for (let m = 0; m < 2; m++) {
    const v = m === 0 ? r : c;
    for (let y = -1; y <= 1; y += 2)
      for (let w = -1; w <= 1; w += 2)
        d.push(lt(
          lt(v, mt(a, y * u)),
          mt(l, w * u)
        ));
  }
  e.push({ start: d[0], end: d[1], color: n }), e.push({ start: d[1], end: d[3], color: n }), e.push({ start: d[3], end: d[2], color: n }), e.push({ start: d[2], end: d[0], color: n }), e.push({ start: d[4], end: d[5], color: n }), e.push({ start: d[5], end: d[7], color: n }), e.push({ start: d[7], end: d[6], color: n }), e.push({ start: d[6], end: d[4], color: n }), e.push({ start: d[0], end: d[4], color: n }), e.push({ start: d[1], end: d[5], color: n }), e.push({ start: d[2], end: d[6], color: n }), e.push({ start: d[3], end: d[7], color: n });
  const h = lt(r, mt(o, a3)), p = 8;
  for (let m = 0; m < p; m++) {
    const v = m / p * Math.PI * 2, y = (m + 1) / p * Math.PI * 2, w = lt(
      lt(r, mt(a, Math.cos(v) * u * 0.5)),
      mt(l, Math.sin(v) * u * 0.5)
    ), g = lt(
      lt(r, mt(a, Math.cos(y) * u * 0.5)),
      mt(l, Math.sin(y) * u * 0.5)
    );
    e.push({ start: w, end: g, color: n }), e.push({ start: w, end: h, color: n });
  }
  return e;
}
function u3(i, e, n, r = 2e3) {
  const o = [], s = "#7c9cff", a = ip(i.focalLength, i.filmSize), l = e / n, u = i.position;
  let c;
  if (i.type === "two-node")
    c = Jr(np(i.pointOfInterest, u));
  else {
    const x = i.orientation.x * Math.PI / 180, I = i.orientation.y * Math.PI / 180;
    c = Je(
      Math.sin(I) * Math.cos(x),
      -Math.sin(x),
      Math.cos(I) * Math.cos(x)
    );
  }
  const d = Je(0, -1, 0);
  let h = Jr(wa(c, d));
  isNaN(h.x) && (h = Je(1, 0, 0));
  const p = Jr(wa(h, c)), m = i.nearClip, v = Math.min(i.farClip, r), y = m * Math.tan(a * Math.PI / 360), w = y * l, g = v * Math.tan(a * Math.PI / 360), k = g * l, _ = lt(u, mt(c, m)), S = [
    lt(lt(_, mt(h, -w)), mt(p, y)),
    lt(lt(_, mt(h, w)), mt(p, y)),
    lt(lt(_, mt(h, w)), mt(p, -y)),
    lt(lt(_, mt(h, -w)), mt(p, -y))
  ], b = lt(u, mt(c, v)), C = [
    lt(lt(b, mt(h, -k)), mt(p, g)),
    lt(lt(b, mt(h, k)), mt(p, g)),
    lt(lt(b, mt(h, k)), mt(p, -g)),
    lt(lt(b, mt(h, -k)), mt(p, -g))
  ];
  for (let x = 0; x < 4; x++)
    o.push({ start: S[x], end: S[(x + 1) % 4], color: s });
  for (let x = 0; x < 4; x++)
    o.push({ start: C[x], end: C[(x + 1) % 4], color: s });
  for (let x = 0; x < 4; x++)
    o.push({ start: S[x], end: C[x], color: s });
  return o;
}
function c3(i, e) {
  const n = "#00ff88", r = [
    Je(0, 0, 0),
    Je(i, 0, 0),
    Je(i, e, 0),
    Je(0, e, 0)
  ], o = [];
  for (let s = 0; s < 4; s++)
    o.push({ start: r[s], end: r[(s + 1) % 4], color: n });
  return o.push({ start: r[0], end: r[2], color: "#005533" }), o.push({ start: r[1], end: r[3], color: "#005533" }), o;
}
function d3(i) {
  return i.type !== "two-node" ? null : {
    start: i.position,
    end: i.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function h3(i, e, n) {
  if (!i.depthOfField.enabled)
    return [];
  const r = "#ff00ff", o = [], s = i.position, a = i.depthOfField.focusDistance;
  let l;
  if (i.type === "two-node")
    l = Jr(np(i.pointOfInterest, s));
  else {
    const y = i.orientation.x * Math.PI / 180, w = i.orientation.y * Math.PI / 180;
    l = Je(
      Math.sin(w) * Math.cos(y),
      -Math.sin(y),
      Math.cos(w) * Math.cos(y)
    );
  }
  const u = Je(0, -1, 0);
  let c = Jr(wa(l, u));
  isNaN(c.x) && (c = Je(1, 0, 0));
  const d = Jr(wa(c, l)), h = lt(s, mt(l, a)), p = e / 4, m = n / 4, v = [
    lt(lt(h, mt(c, -p)), mt(d, m)),
    lt(lt(h, mt(c, p)), mt(d, m)),
    lt(lt(h, mt(c, p)), mt(d, -m)),
    lt(lt(h, mt(c, -p)), mt(d, -m))
  ];
  for (let y = 0; y < 4; y++)
    o.push({ start: v[y], end: v[(y + 1) % 4], color: r });
  return o;
}
function Pg(i, e, n, r = !0, o = !0, s = !1) {
  return {
    body: l3(i),
    frustum: r ? u3(i, e, n) : [],
    compositionBounds: o ? c3(e, n) : [],
    poiLine: d3(i),
    focalPlane: s ? h3(i, e, n) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function f3(i, e, n) {
  const r = e / n, o = ip(i.focalLength, i.filmSize);
  let s;
  if (i.type === "two-node")
    s = i.pointOfInterest;
  else {
    const c = i.orientation.x * Math.PI / 180, d = i.orientation.y * Math.PI / 180, h = Je(
      Math.sin(d) * Math.cos(c),
      -Math.sin(c),
      Math.cos(d) * Math.cos(c)
    );
    s = lt(i.position, mt(h, 1e3));
  }
  const a = ur(i.position, s, Je(0, -1, 0)), l = oI(o, r, i.nearClip, i.farClip), u = multiplyMat4(l, a);
  return { view: a, projection: l, viewProjection: u };
}
function Ig(i, e, n, r) {
  const o = e / n;
  let s, a = 1e3;
  const l = e / 2, u = n / 2;
  switch (i) {
    case "front":
      s = ur(
        Je(l, u, -2e3),
        Je(l, u, 0),
        Je(0, -1, 0)
      );
      break;
    case "back":
      s = ur(
        Je(l, u, 2e3),
        Je(l, u, 0),
        Je(0, -1, 0)
      );
      break;
    case "left":
      s = ur(
        Je(-2e3, u, 0),
        Je(l, u, 0),
        Je(0, -1, 0)
      );
      break;
    case "right":
      s = ur(
        Je(l + 2e3, u, 0),
        Je(l, u, 0),
        Je(0, -1, 0)
      );
      break;
    case "top":
      s = ur(
        Je(l, -2e3, 0),
        Je(l, u, 0),
        Je(0, 0, 1)
      );
      break;
    case "bottom":
      s = ur(
        Je(l, u + 2e3, 0),
        Je(l, u, 0),
        Je(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (r) {
        const h = r.orbitPhi * Math.PI / 180, p = r.orbitTheta * Math.PI / 180, m = r.orbitDistance, v = Je(
          r.orbitCenter.x + m * Math.sin(h) * Math.sin(p),
          r.orbitCenter.y + m * Math.cos(h),
          r.orbitCenter.z + m * Math.sin(h) * Math.cos(p)
        );
        s = ur(
          v,
          r.orbitCenter,
          Je(0, -1, 0)
        ), a = 1e3 / r.orthoZoom;
      } else
        s = ur(
          Je(l, u, -2e3),
          Je(l, u, 0),
          Je(0, -1, 0)
        );
      break;
    default:
      s = ur(
        Je(l, u, -2e3),
        Je(l, u, 0),
        Je(0, -1, 0)
      );
  }
  const c = sI(
    -a * o,
    a * o,
    -a,
    a,
    1,
    1e4
  ), d = multiplyMat4(c, s);
  return { view: s, projection: c, viewProjection: d };
}
function rh(i, e, n, r) {
  const o = aI(i, e), s = e.elements, a = i.x * s[3] + i.y * s[7] + i.z * s[11] + s[15];
  if (a <= 0)
    return { x: 0, y: 0, z: o.z, visible: !1 };
  const l = (o.x / a * 0.5 + 0.5) * n, u = (-o.y / a * 0.5 + 0.5) * r;
  return {
    x: l,
    y: u,
    z: o.z / a,
    visible: !0
  };
}
function p3(i, e = 100) {
  return [
    { start: i, end: lt(i, Je(e, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: i, end: lt(i, Je(0, e, 0)), color: "#00ff00" },
    // Y - Green
    { start: i, end: lt(i, Je(0, 0, e)), color: "#0000ff" }
    // Z - Blue
  ];
}
function m3(i, e, n = 100) {
  const r = [], o = "#333333", s = "#444444", a = i / 2, l = e / 2, u = Math.max(i, e);
  for (let c = -u; c <= u + i; c += n) {
    const d = Math.abs(c - a) < n / 2;
    r.push({
      start: Je(c, -u, 0),
      end: Je(c, u + e, 0),
      color: d ? s : o
    });
  }
  for (let c = -u; c <= u + e; c += n) {
    const d = Math.abs(c - l) < n / 2;
    r.push({
      start: Je(-u, c, 0),
      end: Je(u + i, c, 0),
      color: d ? s : o
    });
  }
  return r;
}
const g3 = ["onClick"], v3 = { class: "view-header" }, y3 = ["value", "onChange"], b3 = { class: "view-tools" }, w3 = ["onClick"], _3 = ["onMousedown", "onWheel"], x3 = { class: "view-info" }, S3 = { class: "view-name" }, C3 = {
  key: 0,
  class: "view-coords"
}, k3 = { class: "layout-controls" }, O3 = ["onClick", "title"], E3 = /* @__PURE__ */ tn({
  __name: "ViewportRenderer",
  props: {
    camera: {},
    compWidth: {},
    compHeight: {},
    viewportState: {},
    viewOptions: {},
    layers: { default: () => [] }
  },
  emits: ["update:viewportState", "selectLayer"],
  setup(i, { emit: e }) {
    const n = i, r = e, o = re([null, null, null, null]), s = re([null, null, null, null]), a = re(!1), l = re({ x: 0, y: 0 }), u = re(0), c = re(0), d = [
      { value: "1-view", label: "1 View", icon: "" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "" },
      { value: "4-view", label: "4 Views", icon: "" }
    ], h = Ee(() => n.viewportState.layout), p = Ee(() => n.viewportState.activeViewIndex), m = Ee(() => n.viewportState.customViews), v = Ee(() => {
      switch (n.viewportState.layout) {
        case "1-view":
          return [n.viewportState.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return n.viewportState.views.slice(0, 2);
        case "4-view":
          return n.viewportState.views.slice(0, 4);
        default:
          return [n.viewportState.views[0]];
      }
    });
    function y(M, W) {
      o.value[W] = M, M && (s.value[W] = M.getContext("2d"));
    }
    function w(M) {
      return M.startsWith("custom-");
    }
    function g(M) {
      return {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        front: "Front",
        back: "Back",
        left: "Left",
        right: "Right",
        top: "Top",
        bottom: "Bottom"
      }[M];
    }
    function k(M) {
      r("update:viewportState", {
        ...n.viewportState,
        activeViewIndex: M
      });
    }
    function _(M, W) {
      const R = [...n.viewportState.views];
      R[M] = W, r("update:viewportState", {
        ...n.viewportState,
        views: R
      });
    }
    function S(M) {
      let W = [...n.viewportState.views];
      for (; W.length < 4; )
        W.push("front");
      r("update:viewportState", {
        ...n.viewportState,
        layout: M,
        views: W,
        activeViewIndex: Math.min(n.viewportState.activeViewIndex, b(M) - 1)
      });
    }
    function b(M) {
      switch (M) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function C(M) {
      const W = {
        orbitCenter: { x: n.compWidth / 2, y: n.compHeight / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      r("update:viewportState", {
        ...n.viewportState,
        customViews: {
          ...n.viewportState.customViews,
          [M]: W
        }
      });
    }
    function x(M, W) {
      a.value = !0, l.value = { x: M.clientX, y: M.clientY }, u.value = W, c.value = M.button, document.addEventListener("mousemove", I), document.addEventListener("mouseup", F);
    }
    function I(M) {
      if (!a.value) return;
      const W = M.clientX - l.value.x, R = M.clientY - l.value.y;
      l.value = { x: M.clientX, y: M.clientY };
      const V = v.value[u.value];
      if (w(V)) {
        const ae = m.value[V];
        if (c.value === 0) {
          const $e = ae.orbitTheta + W * 0.5, N = Math.max(1, Math.min(179, ae.orbitPhi + R * 0.5));
          r("update:viewportState", {
            ...n.viewportState,
            customViews: {
              ...n.viewportState.customViews,
              [V]: {
                ...ae,
                orbitTheta: $e,
                orbitPhi: N
              }
            }
          });
        } else (c.value === 1 || c.value === 2) && r("update:viewportState", {
          ...n.viewportState,
          customViews: {
            ...n.viewportState.customViews,
            [V]: {
              ...ae,
              orthoOffset: {
                x: ae.orthoOffset.x + W,
                y: ae.orthoOffset.y + R
              }
            }
          }
        });
      }
    }
    function F() {
      a.value = !1, document.removeEventListener("mousemove", I), document.removeEventListener("mouseup", F);
    }
    function B(M, W) {
      M.preventDefault();
      const R = v.value[W];
      if (w(R)) {
        const V = m.value[R], ae = M.deltaY > 0 ? 1.1 : 0.9;
        r("update:viewportState", {
          ...n.viewportState,
          customViews: {
            ...n.viewportState.customViews,
            [R]: {
              ...V,
              orbitDistance: V.orbitDistance * ae
            }
          }
        });
      }
    }
    function X() {
      v.value.forEach((M, W) => {
        const R = o.value[W], V = s.value[W];
        if (!R || !V) return;
        const ae = R.getBoundingClientRect(), $e = window.devicePixelRatio || 1;
        R.width = ae.width * $e, R.height = ae.height * $e, V.scale($e, $e), V.fillStyle = "#1a1a1a", V.fillRect(0, 0, ae.width, ae.height);
        let N;
        M === "active-camera" && n.camera ? N = f3(n.camera, n.compWidth, n.compHeight) : w(M) ? N = Ig(M, n.compWidth, n.compHeight, m.value[M]) : N = Ig(M, n.compWidth, n.compHeight);
        const me = [];
        if (n.viewOptions.showGrid && me.push(...m3(n.compWidth, n.compHeight)), n.viewOptions.show3DReferenceAxes && me.push(...p3(Je(n.compWidth / 2, n.compHeight / 2, 0))), n.viewOptions.showCompositionBounds) {
          const we = Pg(
            n.camera ?? j(),
            n.compWidth,
            n.compHeight,
            !1,
            !0,
            !1
          );
          me.push(...we.compositionBounds);
        }
        if (M !== "active-camera" && n.camera && (n.viewOptions.cameraWireframes === "always" || n.viewOptions.cameraWireframes === "selected")) {
          const fe = Pg(
            n.camera,
            n.compWidth,
            n.compHeight,
            !0,
            !1,
            n.viewOptions.showFocalPlane
          );
          me.push(...fe.body), me.push(...fe.frustum), me.push(...fe.focalPlane), fe.poiLine && me.push(fe.poiLine);
        }
        for (const we of me) {
          const fe = rh(we.start, N.viewProjection, ae.width, ae.height), te = rh(we.end, N.viewProjection, ae.width, ae.height);
          !fe.visible && !te.visible || (V.beginPath(), V.strokeStyle = we.color, V.lineWidth = 1, V.moveTo(fe.x, fe.y), V.lineTo(te.x, te.y), V.stroke());
        }
        if (n.viewOptions.showLayerHandles)
          for (const we of n.layers) {
            const fe = rh(we.position, N.viewProjection, ae.width, ae.height);
            fe.visible && (V.beginPath(), V.fillStyle = we.selected ? "#ffcc00" : "#888888", V.arc(fe.x, fe.y, we.selected ? 6 : 4, 0, Math.PI * 2), V.fill(), V.fillStyle = "#ffffff", V.font = "10px sans-serif", V.fillText(we.name, fe.x + 8, fe.y + 4));
          }
      });
    }
    function j() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: n.compWidth / 2, y: n.compHeight / 2, z: -1500 },
        pointOfInterest: { x: n.compWidth / 2, y: n.compHeight / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: !1,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let ee;
    function ie() {
      X(), ee = requestAnimationFrame(ie);
    }
    return Wn(() => {
      ie();
    }), Qi(() => {
      cancelAnimationFrame(ee);
    }), Lt(() => [n.camera, n.viewportState, n.viewOptions, n.layers], () => {
    }, { deep: !0 }), (M, W) => ($(), A("div", {
      class: _e(["viewport-renderer", [`layout-${h.value}`]])
    }, [
      ($(!0), A(Fe, null, Ke(v.value, (R, V) => {
        var ae, $e;
        return $(), A("div", {
          key: V,
          class: _e(["view-panel", { active: V === p.value }]),
          onClick: (N) => k(V)
        }, [
          f("div", v3, [
            f("select", {
              value: R,
              onChange: (N) => _(V, N.target.value),
              class: "view-select"
            }, [...W[1] || (W[1] = [
              va('<option value="active-camera" data-v-570e989a>Active Camera</option><option value="custom-1" data-v-570e989a>Custom View 1</option><option value="custom-2" data-v-570e989a>Custom View 2</option><option value="custom-3" data-v-570e989a>Custom View 3</option><option value="front" data-v-570e989a>Front</option><option value="back" data-v-570e989a>Back</option><option value="left" data-v-570e989a>Left</option><option value="right" data-v-570e989a>Right</option><option value="top" data-v-570e989a>Top</option><option value="bottom" data-v-570e989a>Bottom</option>', 10)
            ])], 40, y3),
            f("div", b3, [
              w(R) ? ($(), A("button", {
                key: 0,
                onClick: tt((N) => C(R), ["stop"]),
                title: "Reset View"
              }, [...W[2] || (W[2] = [
                f("span", { class: "icon" }, "", -1)
              ])], 8, w3)) : ve("", !0)
            ])
          ]),
          f("canvas", {
            ref_for: !0,
            ref: (N) => y(N, V),
            class: "view-canvas",
            onMousedown: (N) => x(N, V),
            onWheel: (N) => B(N, V),
            onContextmenu: W[0] || (W[0] = tt(() => {
            }, ["prevent"]))
          }, null, 40, _3),
          f("div", x3, [
            f("span", S3, Q(g(R)), 1),
            w(R) ? ($(), A("span", C3, " : " + Q(Math.round(((ae = m.value[R]) == null ? void 0 : ae.orbitTheta) ?? 0)) + " : " + Q(Math.round((($e = m.value[R]) == null ? void 0 : $e.orbitPhi) ?? 0)) + " ", 1)) : ve("", !0)
          ])
        ], 10, g3);
      }), 128)),
      f("div", k3, [
        ($(), A(Fe, null, Ke(d, (R) => f("button", {
          key: R.value,
          class: _e({ active: h.value === R.value }),
          onClick: (V) => S(R.value),
          title: R.label
        }, Q(R.icon), 11, O3)), 64))
      ])
    ], 2));
  }
}), T3 = /* @__PURE__ */ cn(E3, [["__scopeId", "data-v-570e989a"]]);
function Y(i, e, n) {
  return (e = function(r) {
    var o = function(s, a) {
      if (typeof s != "object" || !s) return s;
      var l = s[Symbol.toPrimitive];
      if (l !== void 0) {
        var u = l.call(s, a);
        if (typeof u != "object") return u;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (a === "string" ? String : Number)(s);
    }(r, "string");
    return typeof o == "symbol" ? o : o + "";
  }(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function Lg(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function K(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Lg(Object(n), !0).forEach(function(r) {
      Y(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : Lg(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function zt(i, e) {
  if (i == null) return {};
  var n, r, o = function(a, l) {
    if (a == null) return {};
    var u = {};
    for (var c in a) if ({}.hasOwnProperty.call(a, c)) {
      if (l.indexOf(c) >= 0) continue;
      u[c] = a[c];
    }
    return u;
  }(i, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(i);
    for (r = 0; r < s.length; r++) n = s[r], e.indexOf(n) >= 0 || {}.propertyIsEnumerable.call(i, n) && (o[n] = i[n]);
  }
  return o;
}
function Cr(i, e) {
  return e || (e = i.slice(0)), Object.freeze(Object.defineProperties(i, { raw: { value: Object.freeze(e) } }));
}
class Ag {
  constructor() {
    Y(this, "browserShadowBlurConstant", 1), Y(this, "DPI", 96), Y(this, "devicePixelRatio", typeof window < "u" ? window.devicePixelRatio : 1), Y(this, "perfLimitSizeTotal", 2097152), Y(this, "maxCacheSideLimit", 4096), Y(this, "minCacheSideLimit", 256), Y(this, "disableStyleCopyPaste", !1), Y(this, "enableGLFiltering", !0), Y(this, "textureSize", 4096), Y(this, "forceGLPutImageData", !1), Y(this, "cachesBoundsOfCurve", !1), Y(this, "fontPaths", {}), Y(this, "NUM_FRACTION_DIGITS", 4);
  }
}
const kt = new class extends Ag {
  constructor(i) {
    super(), this.configure(i);
  }
  configure() {
    let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.assign(this, i);
  }
  addFonts() {
    let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fontPaths = K(K({}, this.fontPaths), i);
  }
  removeFonts() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((i) => {
      delete this.fontPaths[i];
    });
  }
  clearFonts() {
    this.fontPaths = {};
  }
  restoreDefaults(i) {
    const e = new Ag(), n = (i == null ? void 0 : i.reduce((r, o) => (r[o] = e[o], r), {})) || e;
    this.configure(n);
  }
}(), Ro = function(i) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
  return console[i]("fabric", ...n);
};
class yr extends Error {
  constructor(e, n) {
    super("fabric: ".concat(e), n);
  }
}
class D3 extends yr {
  constructor(e) {
    super("".concat(e, " 'options.signal' is in 'aborted' state"));
  }
}
class $3 {
}
class M3 extends $3 {
  testPrecision(e, n) {
    const r = "precision ".concat(n, ` float;
void main(){}`), o = e.createShader(e.FRAGMENT_SHADER);
    return !!o && (e.shaderSource(o, r), e.compileShader(o), !!e.getShaderParameter(o, e.COMPILE_STATUS));
  }
  queryWebGL(e) {
    const n = e.getContext("webgl");
    n && (this.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE), this.GLPrecision = ["highp", "mediump", "lowp"].find((r) => this.testPrecision(n, r)), n.getExtension("WEBGL_lose_context").loseContext(), Ro("log", "WebGL: max texture size ".concat(this.maxTextureSize)));
  }
  isSupported(e) {
    return !!this.maxTextureSize && this.maxTextureSize >= e;
  }
}
const P3 = {};
let Vg;
const Sr = () => Vg || (Vg = { document, window, isTouchSupported: "ontouchstart" in window || "ontouchstart" in document || window && window.navigator && window.navigator.maxTouchPoints > 0, WebGLProbe: new M3(), dispose() {
}, copyPasteData: P3 }), Ca = () => Sr().document, fd = () => Sr().window, wb = () => {
  var i;
  return Math.max((i = kt.devicePixelRatio) !== null && i !== void 0 ? i : fd().devicePixelRatio, 1);
}, hl = new class {
  constructor() {
    Y(this, "boundsOfCurveCache", {}), this.charWidthsCache = /* @__PURE__ */ new Map();
  }
  getFontCache(i) {
    let { fontFamily: e, fontStyle: n, fontWeight: r } = i;
    e = e.toLowerCase();
    const o = this.charWidthsCache;
    o.has(e) || o.set(e, /* @__PURE__ */ new Map());
    const s = o.get(e), a = "".concat(n.toLowerCase(), "_").concat((r + "").toLowerCase());
    return s.has(a) || s.set(a, /* @__PURE__ */ new Map()), s.get(a);
  }
  clearFontCache(i) {
    i ? this.charWidthsCache.delete((i || "").toLowerCase()) : this.charWidthsCache = /* @__PURE__ */ new Map();
  }
  limitDimsByArea(i) {
    const { perfLimitSizeTotal: e } = kt, n = Math.sqrt(e * i);
    return [Math.floor(n), Math.floor(e / n)];
  }
}(), Xh = "6.9.0";
function pc() {
}
const uu = Math.PI / 2, Bc = 2 * Math.PI, rp = Math.PI / 180, Un = Object.freeze([1, 0, 0, 1, 0, 0]), op = 16, wo = 0.4477152502, ut = "center", Tt = "left", Qn = "top", Yh = "bottom", an = "right", ei = "none", sp = /\r?\n/, _b = "moving", pd = "scaling", xb = "rotating", ap = "rotate", Sb = "skewing", $l = "resizing", I3 = "modifyPoly", L3 = "modifyPath", Hc = "changed", md = "scale", ni = "scaleX", Si = "scaleY", ka = "skewX", Oa = "skewY", yn = "fill", ti = "stroke", Uc = "modified", Gs = "json", oh = "svg", Ne = new class {
  constructor() {
    this[Gs] = /* @__PURE__ */ new Map(), this[oh] = /* @__PURE__ */ new Map();
  }
  has(i) {
    return this[Gs].has(i);
  }
  getClass(i) {
    const e = this[Gs].get(i);
    if (!e) throw new yr("No class registered for ".concat(i));
    return e;
  }
  setClass(i, e) {
    e ? this[Gs].set(e, i) : (this[Gs].set(i.type, i), this[Gs].set(i.type.toLowerCase(), i));
  }
  getSVGClass(i) {
    return this[oh].get(i);
  }
  setSVGClass(i, e) {
    this[oh].set(e ?? i.type.toLowerCase(), i);
  }
}(), Wc = new class extends Array {
  remove(i) {
    const e = this.indexOf(i);
    e > -1 && this.splice(e, 1);
  }
  cancelAll() {
    const i = this.splice(0);
    return i.forEach((e) => e.abort()), i;
  }
  cancelByCanvas(i) {
    if (!i) return [];
    const e = this.filter((n) => {
      var r;
      return n.target === i || typeof n.target == "object" && ((r = n.target) === null || r === void 0 ? void 0 : r.canvas) === i;
    });
    return e.forEach((n) => n.abort()), e;
  }
  cancelByTarget(i) {
    if (!i) return [];
    const e = this.filter((n) => n.target === i);
    return e.forEach((n) => n.abort()), e;
  }
}();
class A3 {
  constructor() {
    Y(this, "__eventListeners", {});
  }
  on(e, n) {
    if (this.__eventListeners || (this.__eventListeners = {}), typeof e == "object") return Object.entries(e).forEach((r) => {
      let [o, s] = r;
      this.on(o, s);
    }), () => this.off(e);
    if (n) {
      const r = e;
      return this.__eventListeners[r] || (this.__eventListeners[r] = []), this.__eventListeners[r].push(n), () => this.off(r, n);
    }
    return () => !1;
  }
  once(e, n) {
    if (typeof e == "object") {
      const r = [];
      return Object.entries(e).forEach((o) => {
        let [s, a] = o;
        r.push(this.once(s, a));
      }), () => r.forEach((o) => o());
    }
    if (n) {
      const r = this.on(e, function() {
        for (var o = arguments.length, s = new Array(o), a = 0; a < o; a++) s[a] = arguments[a];
        n.call(this, ...s), r();
      });
      return r;
    }
    return () => !1;
  }
  _removeEventListener(e, n) {
    if (this.__eventListeners[e]) if (n) {
      const r = this.__eventListeners[e], o = r.indexOf(n);
      o > -1 && r.splice(o, 1);
    } else this.__eventListeners[e] = [];
  }
  off(e, n) {
    if (this.__eventListeners) if (e === void 0) for (const r in this.__eventListeners) this._removeEventListener(r);
    else typeof e == "object" ? Object.entries(e).forEach((r) => {
      let [o, s] = r;
      this._removeEventListener(o, s);
    }) : this._removeEventListener(e, n);
  }
  fire(e, n) {
    var r;
    if (!this.__eventListeners) return;
    const o = (r = this.__eventListeners[e]) === null || r === void 0 ? void 0 : r.concat();
    if (o) for (let s = 0; s < o.length; s++) o[s].call(this, n || {});
  }
}
const ea = (i, e) => {
  const n = i.indexOf(e);
  return n !== -1 && i.splice(n, 1), i;
}, no = (i) => {
  if (i === 0) return 1;
  switch (Math.abs(i) / uu) {
    case 1:
    case 3:
      return 0;
    case 2:
      return -1;
  }
  return Math.cos(i);
}, io = (i) => {
  if (i === 0) return 0;
  const e = i / uu, n = Math.sign(i);
  switch (e) {
    case 1:
      return n;
    case 2:
      return 0;
    case 3:
      return -n;
  }
  return Math.sin(i);
};
class ce {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    typeof e == "object" ? (this.x = e.x, this.y = e.y) : (this.x = e, this.y = n);
  }
  add(e) {
    return new ce(this.x + e.x, this.y + e.y);
  }
  addEquals(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  scalarAdd(e) {
    return new ce(this.x + e, this.y + e);
  }
  scalarAddEquals(e) {
    return this.x += e, this.y += e, this;
  }
  subtract(e) {
    return new ce(this.x - e.x, this.y - e.y);
  }
  subtractEquals(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  scalarSubtract(e) {
    return new ce(this.x - e, this.y - e);
  }
  scalarSubtractEquals(e) {
    return this.x -= e, this.y -= e, this;
  }
  multiply(e) {
    return new ce(this.x * e.x, this.y * e.y);
  }
  scalarMultiply(e) {
    return new ce(this.x * e, this.y * e);
  }
  scalarMultiplyEquals(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return new ce(this.x / e.x, this.y / e.y);
  }
  scalarDivide(e) {
    return new ce(this.x / e, this.y / e);
  }
  scalarDivideEquals(e) {
    return this.x /= e, this.y /= e, this;
  }
  eq(e) {
    return this.x === e.x && this.y === e.y;
  }
  lt(e) {
    return this.x < e.x && this.y < e.y;
  }
  lte(e) {
    return this.x <= e.x && this.y <= e.y;
  }
  gt(e) {
    return this.x > e.x && this.y > e.y;
  }
  gte(e) {
    return this.x >= e.x && this.y >= e.y;
  }
  lerp(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;
    return n = Math.max(Math.min(1, n), 0), new ce(this.x + (e.x - this.x) * n, this.y + (e.y - this.y) * n);
  }
  distanceFrom(e) {
    const n = this.x - e.x, r = this.y - e.y;
    return Math.sqrt(n * n + r * r);
  }
  midPointFrom(e) {
    return this.lerp(e);
  }
  min(e) {
    return new ce(Math.min(this.x, e.x), Math.min(this.y, e.y));
  }
  max(e) {
    return new ce(Math.max(this.x, e.x), Math.max(this.y, e.y));
  }
  toString() {
    return "".concat(this.x, ",").concat(this.y);
  }
  setXY(e, n) {
    return this.x = e, this.y = n, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setFromPoint(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  swap(e) {
    const n = this.x, r = this.y;
    this.x = e.x, this.y = e.y, e.x = n, e.y = r;
  }
  clone() {
    return new ce(this.x, this.y);
  }
  rotate(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : lp;
    const r = io(e), o = no(e), s = this.subtract(n);
    return new ce(s.x * o - s.y * r, s.x * r + s.y * o).add(n);
  }
  transform(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    return new ce(e[0] * this.x + e[2] * this.y + (n ? 0 : e[4]), e[1] * this.x + e[3] * this.y + (n ? 0 : e[5]));
  }
}
const lp = new ce(0, 0), mc = (i) => !!i && Array.isArray(i._objects);
function Cb(i) {
  class e extends i {
    constructor() {
      super(...arguments), Y(this, "_objects", []);
    }
    _onObjectAdded(r) {
    }
    _onObjectRemoved(r) {
    }
    _onStackOrderChanged(r) {
    }
    add() {
      for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];
      const a = this._objects.push(...o);
      return o.forEach((l) => this._onObjectAdded(l)), a;
    }
    insertAt(r) {
      for (var o = arguments.length, s = new Array(o > 1 ? o - 1 : 0), a = 1; a < o; a++) s[a - 1] = arguments[a];
      return this._objects.splice(r, 0, ...s), s.forEach((l) => this._onObjectAdded(l)), this._objects.length;
    }
    remove() {
      const r = this._objects, o = [];
      for (var s = arguments.length, a = new Array(s), l = 0; l < s; l++) a[l] = arguments[l];
      return a.forEach((u) => {
        const c = r.indexOf(u);
        c !== -1 && (r.splice(c, 1), o.push(u), this._onObjectRemoved(u));
      }), o;
    }
    forEachObject(r) {
      this.getObjects().forEach((o, s, a) => r(o, s, a));
    }
    getObjects() {
      for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];
      return o.length === 0 ? [...this._objects] : this._objects.filter((a) => a.isType(...o));
    }
    item(r) {
      return this._objects[r];
    }
    isEmpty() {
      return this._objects.length === 0;
    }
    size() {
      return this._objects.length;
    }
    contains(r, o) {
      return !!this._objects.includes(r) || !!o && this._objects.some((s) => s instanceof e && s.contains(r, !0));
    }
    complexity() {
      return this._objects.reduce((r, o) => r += o.complexity ? o.complexity() : 0, 0);
    }
    sendObjectToBack(r) {
      return !(!r || r === this._objects[0]) && (ea(this._objects, r), this._objects.unshift(r), this._onStackOrderChanged(r), !0);
    }
    bringObjectToFront(r) {
      return !(!r || r === this._objects[this._objects.length - 1]) && (ea(this._objects, r), this._objects.push(r), this._onStackOrderChanged(r), !0);
    }
    sendObjectBackwards(r, o) {
      if (!r) return !1;
      const s = this._objects.indexOf(r);
      if (s !== 0) {
        const a = this.findNewLowerIndex(r, s, o);
        return ea(this._objects, r), this._objects.splice(a, 0, r), this._onStackOrderChanged(r), !0;
      }
      return !1;
    }
    bringObjectForward(r, o) {
      if (!r) return !1;
      const s = this._objects.indexOf(r);
      if (s !== this._objects.length - 1) {
        const a = this.findNewUpperIndex(r, s, o);
        return ea(this._objects, r), this._objects.splice(a, 0, r), this._onStackOrderChanged(r), !0;
      }
      return !1;
    }
    moveObjectTo(r, o) {
      return r !== this._objects[o] && (ea(this._objects, r), this._objects.splice(o, 0, r), this._onStackOrderChanged(r), !0);
    }
    findNewLowerIndex(r, o, s) {
      let a;
      if (s) {
        a = o;
        for (let l = o - 1; l >= 0; --l) if (r.isOverlapping(this._objects[l])) {
          a = l;
          break;
        }
      } else a = o - 1;
      return a;
    }
    findNewUpperIndex(r, o, s) {
      let a;
      if (s) {
        a = o;
        for (let l = o + 1; l < this._objects.length; ++l) if (r.isOverlapping(this._objects[l])) {
          a = l;
          break;
        }
      } else a = o + 1;
      return a;
    }
    collectObjects(r) {
      let { left: o, top: s, width: a, height: l } = r, { includeIntersecting: u = !0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const c = [], d = new ce(o, s), h = d.add(new ce(a, l));
      for (let p = this._objects.length - 1; p >= 0; p--) {
        const m = this._objects[p];
        m.selectable && m.visible && (u && m.intersectsWithRect(d, h) || m.isContainedWithinRect(d, h) || u && m.containsPoint(d) || u && m.containsPoint(h)) && c.push(m);
      }
      return c;
    }
  }
  return e;
}
class kb extends A3 {
  _setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    for (const n in e) this.set(n, e[n]);
  }
  _setObject(e) {
    for (const n in e) this._set(n, e[n]);
  }
  set(e, n) {
    return typeof e == "object" ? this._setObject(e) : this._set(e, n), this;
  }
  _set(e, n) {
    this[e] = n;
  }
  toggle(e) {
    const n = this.get(e);
    return typeof n == "boolean" && this.set(e, !n), this;
  }
  get(e) {
    return this[e];
  }
}
function gc(i) {
  return fd().requestAnimationFrame(i);
}
function V3(i) {
  return fd().cancelAnimationFrame(i);
}
let F3 = 0;
const No = () => F3++, ro = () => {
  const i = Ca().createElement("canvas");
  if (!i || i.getContext === void 0) throw new yr("Failed to create `canvas` element");
  return i;
}, j3 = () => Ca().createElement("img"), Ci = (i) => {
  const e = ro();
  return e.width = i.width, e.height = i.height, e;
}, Ob = (i, e, n) => i.toDataURL("image/".concat(e), n), Eb = (i, e, n) => new Promise((r, o) => {
  i.toBlob(r, "image/".concat(e), n);
}), un = (i) => i * rp, oo = (i) => i / rp, R3 = (i) => i.every((e, n) => e === Un[n]), qn = (i, e, n) => new ce(i).transform(e, n), Ni = (i) => {
  const e = 1 / (i[0] * i[3] - i[1] * i[2]), n = [e * i[3], -e * i[1], -e * i[2], e * i[0], 0, 0], { x: r, y: o } = new ce(i[4], i[5]).transform(n, !0);
  return n[4] = -r, n[5] = -o, n;
}, $n = (i, e, n) => [i[0] * e[0] + i[2] * e[1], i[1] * e[0] + i[3] * e[1], i[0] * e[2] + i[2] * e[3], i[1] * e[2] + i[3] * e[3], n ? 0 : i[0] * e[4] + i[2] * e[5] + i[4], n ? 0 : i[1] * e[4] + i[3] * e[5] + i[5]], up = (i, e) => i.reduceRight((n, r) => r && n ? $n(r, n, e) : r || n, void 0) || Un.concat(), Tb = (i) => {
  let [e, n] = i;
  return Math.atan2(n, e);
}, Gc = (i) => {
  const e = Tb(i), n = Math.pow(i[0], 2) + Math.pow(i[1], 2), r = Math.sqrt(n), o = (i[0] * i[3] - i[2] * i[1]) / r, s = Math.atan2(i[0] * i[2] + i[1] * i[3], n);
  return { angle: oo(e), scaleX: r, scaleY: o, skewX: oo(s), skewY: 0, translateX: i[4] || 0, translateY: i[5] || 0 };
}, cu = function(i) {
  return [1, 0, 0, 1, i, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0];
};
function Ea() {
  let { angle: i = 0 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { x: e = 0, y: n = 0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const r = un(i), o = no(r), s = io(r);
  return [o, s, -s, o, e ? e - (o * e - s * n) : 0, n ? n - (s * e + o * n) : 0];
}
const cp = function(i) {
  return [i, 0, 0, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : i, 0, 0];
}, Db = (i) => Math.tan(un(i)), $b = (i) => [1, 0, Db(i), 1, 0, 0], Mb = (i) => [1, Db(i), 0, 1, 0, 0], gd = (i) => {
  let { scaleX: e = 1, scaleY: n = 1, flipX: r = !1, flipY: o = !1, skewX: s = 0, skewY: a = 0 } = i, l = cp(r ? -e : e, o ? -n : n);
  return s && (l = $n(l, $b(s), !0)), a && (l = $n(l, Mb(a), !0)), l;
}, N3 = (i) => {
  const { translateX: e = 0, translateY: n = 0, angle: r = 0 } = i;
  let o = cu(e, n);
  r && (o = $n(o, Ea({ angle: r })));
  const s = gd(i);
  return R3(s) || (o = $n(o, s)), o;
}, vc = function(i) {
  let { signal: e, crossOrigin: n = null } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise(function(r, o) {
    if (e && e.aborted) return o(new D3("loadImage"));
    const s = j3();
    let a;
    e && (a = function(u) {
      s.src = "", o(u);
    }, e.addEventListener("abort", a, { once: !0 }));
    const l = function() {
      s.onload = s.onerror = null, a && (e == null || e.removeEventListener("abort", a)), r(s);
    };
    i ? (s.onload = l, s.onerror = function() {
      a && (e == null || e.removeEventListener("abort", a)), o(new yr("Error loading ".concat(s.src)));
    }, n && (s.crossOrigin = n), s.src = i) : l();
  });
}, Ml = function(i) {
  let { signal: e, reviver: n = pc } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((r, o) => {
    const s = [];
    e && e.addEventListener("abort", o, { once: !0 }), Promise.all(i.map((a) => Ne.getClass(a.type).fromObject(a, { signal: e }).then((l) => (n(a, l), s.push(l), l)))).then(r).catch((a) => {
      s.forEach((l) => {
        l.dispose && l.dispose();
      }), o(a);
    }).finally(() => {
      e && e.removeEventListener("abort", o);
    });
  });
}, vd = function(i) {
  let { signal: e } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((n, r) => {
    const o = [];
    e && e.addEventListener("abort", r, { once: !0 });
    const s = Object.values(i).map((l) => l && l.type && Ne.has(l.type) ? Ml([l], { signal: e }).then((u) => {
      let [c] = u;
      return o.push(c), c;
    }) : l), a = Object.keys(i);
    Promise.all(s).then((l) => l.reduce((u, c, d) => (u[a[d]] = c, u), {})).then(n).catch((l) => {
      o.forEach((u) => {
        u.dispose && u.dispose();
      }), r(l);
    }).finally(() => {
      e && e.removeEventListener("abort", r);
    });
  });
}, Ta = function(i) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []).reduce((e, n) => (n in i && (e[n] = i[n]), e), {});
}, dp = (i, e) => Object.keys(i).reduce((n, r) => (e(i[r], r, i) && (n[r] = i[r]), n), {}), Nt = (i, e) => parseFloat(Number(i).toFixed(e)), Pl = (i) => "matrix(" + i.map((e) => Nt(e, kt.NUM_FRACTION_DIGITS)).join(" ") + ")", xi = (i) => !!i && i.toLive !== void 0, Fg = (i) => !!i && typeof i.toObject == "function", jg = (i) => !!i && i.offsetX !== void 0 && "source" in i, cs = (i) => !!i && "multiSelectionStacking" in i;
function Pb(i) {
  const e = i && Fi(i);
  let n = 0, r = 0;
  if (!i || !e) return { left: n, top: r };
  let o = i;
  const s = e.documentElement, a = e.body || { scrollLeft: 0, scrollTop: 0 };
  for (; o && (o.parentNode || o.host) && (o = o.parentNode || o.host, o === e ? (n = a.scrollLeft || s.scrollLeft || 0, r = a.scrollTop || s.scrollTop || 0) : (n += o.scrollLeft || 0, r += o.scrollTop || 0), o.nodeType !== 1 || o.style.position !== "fixed"); ) ;
  return { left: n, top: r };
}
const Fi = (i) => i.ownerDocument || null, Ib = (i) => {
  var e;
  return ((e = i.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView) || null;
}, Lb = function(i, e, n) {
  let { width: r, height: o } = n, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  i.width = r, i.height = o, s > 1 && (i.setAttribute("width", (r * s).toString()), i.setAttribute("height", (o * s).toString()), e.scale(s, s));
}, Kh = (i, e) => {
  let { width: n, height: r } = e;
  n && (i.style.width = typeof n == "number" ? "".concat(n, "px") : n), r && (i.style.height = typeof r == "number" ? "".concat(r, "px") : r);
};
function Rg(i) {
  return i.onselectstart !== void 0 && (i.onselectstart = () => !1), i.style.userSelect = ei, i;
}
class Ab {
  constructor(e) {
    Y(this, "_originalCanvasStyle", void 0), Y(this, "lower", void 0);
    const n = this.createLowerCanvas(e);
    this.lower = { el: n, ctx: n.getContext("2d") };
  }
  createLowerCanvas(e) {
    const n = (r = e) && r.getContext !== void 0 ? e : e && Ca().getElementById(e) || ro();
    var r;
    if (n.hasAttribute("data-fabric")) throw new yr("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");
    return this._originalCanvasStyle = n.style.cssText, n.setAttribute("data-fabric", "main"), n.classList.add("lower-canvas"), n;
  }
  cleanupDOM(e) {
    let { width: n, height: r } = e;
    const { el: o } = this.lower;
    o.classList.remove("lower-canvas"), o.removeAttribute("data-fabric"), o.setAttribute("width", "".concat(n)), o.setAttribute("height", "".concat(r)), o.style.cssText = this._originalCanvasStyle || "", this._originalCanvasStyle = void 0;
  }
  setDimensions(e, n) {
    const { el: r, ctx: o } = this.lower;
    Lb(r, o, e, n);
  }
  setCSSDimensions(e) {
    Kh(this.lower.el, e);
  }
  calcOffset() {
    return function(e) {
      var n;
      const r = e && Fi(e), o = { left: 0, top: 0 };
      if (!r) return o;
      const s = ((n = Ib(e)) === null || n === void 0 ? void 0 : n.getComputedStyle(e, null)) || {};
      o.left += parseInt(s.borderLeftWidth, 10) || 0, o.top += parseInt(s.borderTopWidth, 10) || 0, o.left += parseInt(s.paddingLeft, 10) || 0, o.top += parseInt(s.paddingTop, 10) || 0;
      let a = { left: 0, top: 0 };
      const l = r.documentElement;
      e.getBoundingClientRect !== void 0 && (a = e.getBoundingClientRect());
      const u = Pb(e);
      return { left: a.left + u.left - (l.clientLeft || 0) + o.left, top: a.top + u.top - (l.clientTop || 0) + o.top };
    }(this.lower.el);
  }
  dispose() {
    Sr().dispose(this.lower.el), delete this.lower;
  }
}
const z3 = { backgroundVpt: !0, backgroundColor: "", overlayVpt: !0, overlayColor: "", includeDefaultValues: !0, svgViewportTransformation: !0, renderOnAddRemove: !0, skipOffscreen: !0, enableRetinaScaling: !0, imageSmoothingEnabled: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, viewportTransform: [...Un] }, B3 = ["objects"];
class du extends Cb(kb) {
  get lowerCanvasEl() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.el;
  }
  get contextContainer() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.ctx;
  }
  static getDefaults() {
    return du.ownDefaults;
  }
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, this.constructor.getDefaults()), this.set(n), this.initElements(e), this._setDimensionsImpl({ width: this.width || this.elements.lower.el.width || 0, height: this.height || this.elements.lower.el.height || 0 }), this.skipControlsDrawing = !1, this.viewportTransform = [...this.viewportTransform], this.calcViewportBoundaries();
  }
  initElements(e) {
    this.elements = new Ab(e);
  }
  add() {
    const e = super.add(...arguments);
    return arguments.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  insertAt(e) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) r[o - 1] = arguments[o];
    const s = super.insertAt(e, ...r);
    return r.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), s;
  }
  remove() {
    const e = super.remove(...arguments);
    return e.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  _onObjectAdded(e) {
    e.canvas && e.canvas !== this && (Ro("warn", `Canvas is trying to add an object that belongs to a different canvas.
Resulting to default behavior: removing object from previous canvas and adding to new canvas`), e.canvas.remove(e)), e._set("canvas", this), e.setCoords(), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e) {
    e._set("canvas", void 0), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onStackOrderChanged() {
    this.renderOnAddRemove && this.requestRenderAll();
  }
  getRetinaScaling() {
    return this.enableRetinaScaling ? wb() : 1;
  }
  calcOffset() {
    return this._offset = this.elements.calcOffset();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setWidth(e, n) {
    return this.setDimensions({ width: e }, n);
  }
  setHeight(e, n) {
    return this.setDimensions({ height: e }, n);
  }
  _setDimensionsImpl(e) {
    let { cssOnly: n = !1, backstoreOnly: r = !1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!n) {
      const o = K({ width: this.width, height: this.height }, e);
      this.elements.setDimensions(o, this.getRetinaScaling()), this.hasLostContext = !0, this.width = o.width, this.height = o.height;
    }
    r || this.elements.setCSSDimensions(e), this.calcOffset();
  }
  setDimensions(e, n) {
    this._setDimensionsImpl(e, n), n && n.cssOnly || this.requestRenderAll();
  }
  getZoom() {
    return this.viewportTransform[0];
  }
  setViewportTransform(e) {
    this.viewportTransform = e, this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll();
  }
  zoomToPoint(e, n) {
    const r = e, o = [...this.viewportTransform], s = qn(e, Ni(o));
    o[0] = n, o[3] = n;
    const a = qn(s, o);
    o[4] += r.x - a.x, o[5] += r.y - a.y, this.setViewportTransform(o);
  }
  setZoom(e) {
    this.zoomToPoint(new ce(0, 0), e);
  }
  absolutePan(e) {
    const n = [...this.viewportTransform];
    return n[4] = -e.x, n[5] = -e.y, this.setViewportTransform(n);
  }
  relativePan(e) {
    return this.absolutePan(new ce(-e.x - this.viewportTransform[4], -e.y - this.viewportTransform[5]));
  }
  getElement() {
    return this.elements.lower.el;
  }
  clearContext(e) {
    e.clearRect(0, 0, this.width, this.height);
  }
  getContext() {
    return this.elements.lower.ctx;
  }
  clear() {
    this.remove(...this.getObjects()), this.backgroundImage = void 0, this.overlayImage = void 0, this.backgroundColor = "", this.overlayColor = "", this.clearContext(this.getContext()), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll();
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || this.renderCanvas(this.getContext(), this._objects);
  }
  renderAndReset() {
    this.nextRenderHandle = 0, this.renderAll();
  }
  requestRenderAll() {
    this.nextRenderHandle || this.disposed || this.destroyed || (this.nextRenderHandle = gc(() => this.renderAndReset()));
  }
  calcViewportBoundaries() {
    const e = this.width, n = this.height, r = Ni(this.viewportTransform), o = qn({ x: 0, y: 0 }, r), s = qn({ x: e, y: n }, r), a = o.min(s), l = o.max(s);
    return this.vptCoords = { tl: a, tr: new ce(l.x, a.y), bl: new ce(a.x, l.y), br: l };
  }
  cancelRequestedRender() {
    this.nextRenderHandle && (V3(this.nextRenderHandle), this.nextRenderHandle = 0);
  }
  drawControls(e) {
  }
  renderCanvas(e, n) {
    if (this.destroyed) return;
    const r = this.viewportTransform, o = this.clipPath;
    this.calcViewportBoundaries(), this.clearContext(e), e.imageSmoothingEnabled = this.imageSmoothingEnabled, e.patternQuality = "best", this.fire("before:render", { ctx: e }), this._renderBackground(e), e.save(), e.transform(r[0], r[1], r[2], r[3], r[4], r[5]), this._renderObjects(e, n), e.restore(), this.controlsAboveOverlay || this.skipControlsDrawing || this.drawControls(e), o && (o._set("canvas", this), o.shouldCache(), o._transformDone = !0, o.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(e, o)), this._renderOverlay(e), this.controlsAboveOverlay && !this.skipControlsDrawing && this.drawControls(e), this.fire("after:render", { ctx: e }), this.__cleanupTask && (this.__cleanupTask(), this.__cleanupTask = void 0);
  }
  drawClipPathOnCanvas(e, n) {
    const r = this.viewportTransform;
    e.save(), e.transform(...r), e.globalCompositeOperation = "destination-in", n.transform(e), e.scale(1 / n.zoomX, 1 / n.zoomY), e.drawImage(n._cacheCanvas, -n.cacheTranslationX, -n.cacheTranslationY), e.restore();
  }
  _renderObjects(e, n) {
    for (let r = 0, o = n.length; r < o; ++r) n[r] && n[r].render(e);
  }
  _renderBackgroundOrOverlay(e, n) {
    const r = this["".concat(n, "Color")], o = this["".concat(n, "Image")], s = this.viewportTransform, a = this["".concat(n, "Vpt")];
    if (!r && !o) return;
    const l = xi(r);
    if (r) {
      if (e.save(), e.beginPath(), e.moveTo(0, 0), e.lineTo(this.width, 0), e.lineTo(this.width, this.height), e.lineTo(0, this.height), e.closePath(), e.fillStyle = l ? r.toLive(e) : r, a && e.transform(...s), l) {
        e.transform(1, 0, 0, 1, r.offsetX || 0, r.offsetY || 0);
        const u = r.gradientTransform || r.patternTransform;
        u && e.transform(...u);
      }
      e.fill(), e.restore();
    }
    if (o) {
      e.save();
      const { skipOffscreen: u } = this;
      this.skipOffscreen = a, a && e.transform(...s), o.render(e), this.skipOffscreen = u, e.restore();
    }
  }
  _renderBackground(e) {
    this._renderBackgroundOrOverlay(e, "background");
  }
  _renderOverlay(e) {
    this._renderBackgroundOrOverlay(e, "overlay");
  }
  getCenter() {
    return { top: this.height / 2, left: this.width / 2 };
  }
  getCenterPoint() {
    return new ce(this.width / 2, this.height / 2);
  }
  centerObjectH(e) {
    return this._centerObject(e, new ce(this.getCenterPoint().x, e.getCenterPoint().y));
  }
  centerObjectV(e) {
    return this._centerObject(e, new ce(e.getCenterPoint().x, this.getCenterPoint().y));
  }
  centerObject(e) {
    return this._centerObject(e, this.getCenterPoint());
  }
  viewportCenterObject(e) {
    return this._centerObject(e, this.getVpCenter());
  }
  viewportCenterObjectH(e) {
    return this._centerObject(e, new ce(this.getVpCenter().x, e.getCenterPoint().y));
  }
  viewportCenterObjectV(e) {
    return this._centerObject(e, new ce(e.getCenterPoint().x, this.getVpCenter().y));
  }
  getVpCenter() {
    return qn(this.getCenterPoint(), Ni(this.viewportTransform));
  }
  _centerObject(e, n) {
    e.setXY(n, ut, ut), e.setCoords(), this.renderOnAddRemove && this.requestRenderAll();
  }
  toDatalessJSON(e) {
    return this.toDatalessObject(e);
  }
  toObject(e) {
    return this._toObjectMethod("toObject", e);
  }
  toJSON() {
    return this.toObject();
  }
  toDatalessObject(e) {
    return this._toObjectMethod("toDatalessObject", e);
  }
  _toObjectMethod(e, n) {
    const r = this.clipPath, o = r && !r.excludeFromExport ? this._toObject(r, e, n) : null;
    return K(K(K({ version: Xh }, Ta(this, n)), {}, { objects: this._objects.filter((s) => !s.excludeFromExport).map((s) => this._toObject(s, e, n)) }, this.__serializeBgOverlay(e, n)), o ? { clipPath: o } : null);
  }
  _toObject(e, n, r) {
    let o;
    this.includeDefaultValues || (o = e.includeDefaultValues, e.includeDefaultValues = !1);
    const s = e[n](r);
    return this.includeDefaultValues || (e.includeDefaultValues = !!o), s;
  }
  __serializeBgOverlay(e, n) {
    const r = {}, o = this.backgroundImage, s = this.overlayImage, a = this.backgroundColor, l = this.overlayColor;
    return xi(a) ? a.excludeFromExport || (r.background = a.toObject(n)) : a && (r.background = a), xi(l) ? l.excludeFromExport || (r.overlay = l.toObject(n)) : l && (r.overlay = l), o && !o.excludeFromExport && (r.backgroundImage = this._toObject(o, e, n)), s && !s.excludeFromExport && (r.overlayImage = this._toObject(s, e, n)), r;
  }
  toSVG() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    e.reviver = n;
    const r = [];
    return this._setSVGPreamble(r, e), this._setSVGHeader(r, e), this.clipPath && r.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId, `)" >
`)), this._setSVGBgOverlayColor(r, "background"), this._setSVGBgOverlayImage(r, "backgroundImage", n), this._setSVGObjects(r, n), this.clipPath && r.push(`</g>
`), this._setSVGBgOverlayColor(r, "overlay"), this._setSVGBgOverlayImage(r, "overlayImage", n), r.push("</svg>"), r.join("");
  }
  _setSVGPreamble(e, n) {
    n.suppressPreamble || e.push('<?xml version="1.0" encoding="', n.encoding || "UTF-8", `" standalone="no" ?>
`, '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`);
  }
  _setSVGHeader(e, n) {
    const r = n.width || "".concat(this.width), o = n.height || "".concat(this.height), s = kt.NUM_FRACTION_DIGITS, a = n.viewBox;
    let l;
    if (a) l = 'viewBox="'.concat(a.x, " ").concat(a.y, " ").concat(a.width, " ").concat(a.height, '" ');
    else if (this.svgViewportTransformation) {
      const u = this.viewportTransform;
      l = 'viewBox="'.concat(Nt(-u[4] / u[0], s), " ").concat(Nt(-u[5] / u[3], s), " ").concat(Nt(this.width / u[0], s), " ").concat(Nt(this.height / u[3], s), '" ');
    } else l = 'viewBox="0 0 '.concat(this.width, " ").concat(this.height, '" ');
    e.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', r, '" ', 'height="', o, '" ', l, `xml:space="preserve">
`, "<desc>Created with Fabric.js ", Xh, `</desc>
`, `<defs>
`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(n), `</defs>
`);
  }
  createSVGClipPathMarkup(e) {
    const n = this.clipPath;
    return n ? (n.clipPathId = "CLIPPATH_".concat(No()), '<clipPath id="'.concat(n.clipPathId, `" >
`).concat(n.toClipPathSVG(e.reviver), `</clipPath>
`)) : "";
  }
  createSVGRefElementsMarkup() {
    return ["background", "overlay"].map((e) => {
      const n = this["".concat(e, "Color")];
      if (xi(n)) {
        const r = this["".concat(e, "Vpt")], o = this.viewportTransform, s = { isType: () => !1, width: this.width / (r ? o[0] : 1), height: this.height / (r ? o[3] : 1) };
        return n.toSVG(s, { additionalTransform: r ? Pl(o) : "" });
      }
    }).join("");
  }
  createSVGFontFacesMarkup() {
    const e = [], n = {}, r = kt.fontPaths;
    this._objects.forEach(function s(a) {
      e.push(a), mc(a) && a._objects.forEach(s);
    }), e.forEach((s) => {
      if (!(a = s) || typeof a._renderText != "function") return;
      var a;
      const { styles: l, fontFamily: u } = s;
      !n[u] && r[u] && (n[u] = !0, l && Object.values(l).forEach((c) => {
        Object.values(c).forEach((d) => {
          let { fontFamily: h = "" } = d;
          !n[h] && r[h] && (n[h] = !0);
        });
      }));
    });
    const o = Object.keys(n).map((s) => `		@font-face {
			font-family: '`.concat(s, `';
			src: url('`).concat(r[s], `');
		}
`)).join("");
    return o ? `	<style type="text/css"><![CDATA[
`.concat(o, `]]></style>
`) : "";
  }
  _setSVGObjects(e, n) {
    this.forEachObject((r) => {
      r.excludeFromExport || this._setSVGObject(e, r, n);
    });
  }
  _setSVGObject(e, n, r) {
    e.push(n.toSVG(r));
  }
  _setSVGBgOverlayImage(e, n, r) {
    const o = this[n];
    o && !o.excludeFromExport && o.toSVG && e.push(o.toSVG(r));
  }
  _setSVGBgOverlayColor(e, n) {
    const r = this["".concat(n, "Color")];
    if (r) if (xi(r)) {
      const o = r.repeat || "", s = this.width, a = this.height, l = this["".concat(n, "Vpt")] ? Pl(Ni(this.viewportTransform)) : "";
      e.push('<rect transform="'.concat(l, " translate(").concat(s / 2, ",").concat(a / 2, ')" x="').concat(r.offsetX - s / 2, '" y="').concat(r.offsetY - a / 2, '" width="').concat(o !== "repeat-y" && o !== "no-repeat" || !jg(r) ? s : r.source.width, '" height="').concat(o !== "repeat-x" && o !== "no-repeat" || !jg(r) ? a : r.source.height, '" fill="url(#SVGID_').concat(r.id, `)"></rect>
`));
    } else e.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', r, '"', `></rect>
`);
  }
  loadFromJSON(e, n) {
    let { signal: r } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return Promise.reject(new yr("`json` is undefined"));
    const o = typeof e == "string" ? JSON.parse(e) : e, { objects: s = [] } = o, a = zt(o, B3), { backgroundImage: l, background: u, overlayImage: c, overlay: d, clipPath: h } = a, p = this.renderOnAddRemove;
    return this.renderOnAddRemove = !1, Promise.all([Ml(s, { reviver: n, signal: r }), vd({ backgroundImage: l, backgroundColor: u, overlayImage: c, overlayColor: d, clipPath: h }, { signal: r })]).then((m) => {
      let [v, y] = m;
      return this.clear(), this.add(...v), this.set(a), this.set(y), this.renderOnAddRemove = p, this;
    });
  }
  clone(e) {
    const n = this.toObject(e);
    return this.cloneWithoutData().loadFromJSON(n);
  }
  cloneWithoutData() {
    const e = Ci(this);
    return new this.constructor(e);
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: n = "png", quality: r = 1, multiplier: o = 1, enableRetinaScaling: s = !1 } = e, a = o * (s ? this.getRetinaScaling() : 1);
    return Ob(this.toCanvasElement(a, e), n, r);
  }
  toBlob() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: n = "png", quality: r = 1, multiplier: o = 1, enableRetinaScaling: s = !1 } = e, a = o * (s ? this.getRetinaScaling() : 1);
    return Eb(this.toCanvasElement(a, e), n, r);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, { width: n, height: r, left: o, top: s, filter: a } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const l = (n || this.width) * e, u = (r || this.height) * e, c = this.getZoom(), d = this.width, h = this.height, p = this.skipControlsDrawing, m = c * e, v = this.viewportTransform, y = [m, 0, 0, m, (v[4] - (o || 0)) * e, (v[5] - (s || 0)) * e], w = this.enableRetinaScaling, g = Ci({ width: l, height: u }), k = a ? this._objects.filter((_) => a(_)) : this._objects;
    return this.enableRetinaScaling = !1, this.viewportTransform = y, this.width = l, this.height = u, this.skipControlsDrawing = !0, this.calcViewportBoundaries(), this.renderCanvas(g.getContext("2d"), k), this.viewportTransform = v, this.width = d, this.height = h, this.calcViewportBoundaries(), this.enableRetinaScaling = w, this.skipControlsDrawing = p, g;
  }
  dispose() {
    return !this.disposed && this.elements.cleanupDOM({ width: this.width, height: this.height }), Wc.cancelByCanvas(this), this.disposed = !0, new Promise((e, n) => {
      const r = () => {
        this.destroy(), e(!0);
      };
      r.kill = n, this.__cleanupTask && this.__cleanupTask.kill("aborted"), this.destroyed ? e(!1) : this.nextRenderHandle ? this.__cleanupTask = r : r();
    });
  }
  destroy() {
    this.destroyed = !0, this.cancelRequestedRender(), this.forEachObject((e) => e.dispose()), this._objects = [], this.backgroundImage && this.backgroundImage.dispose(), this.backgroundImage = void 0, this.overlayImage && this.overlayImage.dispose(), this.overlayImage = void 0, this.elements.dispose();
  }
  toString() {
    return "#<Canvas (".concat(this.complexity(), "): { objects: ").concat(this._objects.length, " }>");
  }
}
Y(du, "ownDefaults", z3);
const H3 = ["touchstart", "touchmove", "touchend"], U3 = (i) => {
  const e = Pb(i.target), n = function(r) {
    const o = r.changedTouches;
    return o && o[0] ? o[0] : r;
  }(i);
  return new ce(n.clientX + e.left, n.clientY + e.top);
}, qh = (i) => H3.includes(i.type) || i.pointerType === "touch", Ng = (i) => {
  i.preventDefault(), i.stopPropagation();
}, Qr = (i) => {
  let e = 0, n = 0, r = 0, o = 0;
  for (let s = 0, a = i.length; s < a; s++) {
    const { x: l, y: u } = i[s];
    (l > r || !s) && (r = l), (l < e || !s) && (e = l), (u > o || !s) && (o = u), (u < n || !s) && (n = u);
  }
  return { left: e, top: n, width: r - e, height: o - n };
}, W3 = ["translateX", "translateY", "scaleX", "scaleY"], G3 = (i, e) => Xc(i, $n(e, i.calcOwnMatrix())), Xc = (i, e) => {
  const n = Gc(e), { translateX: r, translateY: o, scaleX: s, scaleY: a } = n, l = zt(n, W3), u = new ce(r, o);
  i.flipX = !1, i.flipY = !1, Object.assign(i, l), i.set({ scaleX: s, scaleY: a }), i.setPositionByOrigin(u, ut, ut);
}, X3 = (i) => {
  i.scaleX = 1, i.scaleY = 1, i.skewX = 0, i.skewY = 0, i.flipX = !1, i.flipY = !1, i.rotate(0);
}, Vb = (i) => ({ scaleX: i.scaleX, scaleY: i.scaleY, skewX: i.skewX, skewY: i.skewY, angle: i.angle, left: i.left, flipX: i.flipX, flipY: i.flipY, top: i.top }), hp = (i, e, n) => {
  const r = i / 2, o = e / 2, s = [new ce(-r, -o), new ce(r, -o), new ce(-r, o), new ce(r, o)].map((l) => l.transform(n)), a = Qr(s);
  return new ce(a.width, a.height);
}, yd = function() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Un;
  return $n(Ni(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Un), i);
}, da = function(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Un, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Un;
  return i.transform(yd(e, n));
}, Y3 = function(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Un, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Un;
  return i.transform(yd(e, n), !0);
}, K3 = (i, e, n) => {
  const r = yd(e, n);
  return Xc(i, $n(r, i.calcOwnMatrix())), r;
}, Fb = (i, e) => {
  var n;
  const { transform: { target: r } } = e;
  (n = r.canvas) === null || n === void 0 || n.fire("object:".concat(i), K(K({}, e), {}, { target: r })), r.fire(i, e);
}, q3 = { left: -0.5, top: -0.5, center: 0, bottom: 0.5, right: 0.5 }, fn = (i) => typeof i == "string" ? q3[i] : i - 0.5, Yc = "not-allowed";
function jb(i) {
  return fn(i.originX) === fn(ut) && fn(i.originY) === fn(ut);
}
function zg(i) {
  return 0.5 - fn(i);
}
const Wi = (i, e) => i[e], Rb = (i, e, n, r) => ({ e: i, transform: e, pointer: new ce(n, r) });
function Nb(i, e) {
  const n = i.getTotalAngle() + oo(Math.atan2(e.y, e.x)) + 360;
  return Math.round(n % 360 / 45);
}
function fp(i, e, n, r, o) {
  var s;
  let { target: a, corner: l } = i;
  const u = a.controls[l], c = ((s = a.canvas) === null || s === void 0 ? void 0 : s.getZoom()) || 1, d = a.padding / c, h = function(p, m, v, y) {
    const w = p.getRelativeCenterPoint(), g = v !== void 0 && y !== void 0 ? p.translateToGivenOrigin(w, ut, ut, v, y) : new ce(p.left, p.top);
    return (p.angle ? m.rotate(-un(p.angle), w) : m).subtract(g);
  }(a, new ce(r, o), e, n);
  return h.x >= d && (h.x -= d), h.x <= -d && (h.x += d), h.y >= d && (h.y -= d), h.y <= d && (h.y += d), h.x -= u.offsetX, h.y -= u.offsetY, h;
}
const Z3 = (i, e, n, r) => {
  const { target: o, offsetX: s, offsetY: a } = e, l = n - s, u = r - a, c = !Wi(o, "lockMovementX") && o.left !== l, d = !Wi(o, "lockMovementY") && o.top !== u;
  return c && o.set(Tt, l), d && o.set(Qn, u), (c || d) && Fb(_b, Rb(i, e, n, r)), c || d;
}, Kc = (i) => i.replace(/\s+/g, " "), Bg = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#0FF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000", blanchedalmond: "#FFEBCD", blue: "#00F", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#0FF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#F0F", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#789", lightslategrey: "#789", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#0F0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#F0F", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#639", red: "#F00", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFF", whitesmoke: "#F5F5F5", yellow: "#FF0", yellowgreen: "#9ACD32" }, sh = (i, e, n) => (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? i + 6 * (e - i) * n : n < 0.5 ? e : n < 2 / 3 ? i + (e - i) * (2 / 3 - n) * 6 : i), Hg = (i, e, n, r) => {
  i /= 255, e /= 255, n /= 255;
  const o = Math.max(i, e, n), s = Math.min(i, e, n);
  let a, l;
  const u = (o + s) / 2;
  if (o === s) a = l = 0;
  else {
    const c = o - s;
    switch (l = u > 0.5 ? c / (2 - o - s) : c / (o + s), o) {
      case i:
        a = (e - n) / c + (e < n ? 6 : 0);
        break;
      case e:
        a = (n - i) / c + 2;
        break;
      case n:
        a = (i - e) / c + 4;
    }
    a /= 6;
  }
  return [Math.round(360 * a), Math.round(100 * l), Math.round(100 * u), r];
}, Ug = function() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "1";
  return parseFloat(i) / (i.endsWith("%") ? 100 : 1);
}, Pu = (i) => Math.min(Math.round(i), 255).toString(16).toUpperCase().padStart(2, "0"), Wg = (i) => {
  let [e, n, r, o = 1] = i;
  const s = Math.round(0.3 * e + 0.59 * n + 0.11 * r);
  return [s, s, s, o];
};
class $t {
  constructor(e) {
    if (Y(this, "isUnrecognised", !1), e) if (e instanceof $t) this.setSource([...e._source]);
    else if (Array.isArray(e)) {
      const [n, r, o, s = 1] = e;
      this.setSource([n, r, o, s]);
    } else this.setSource(this._tryParsingColor(e));
    else this.setSource([0, 0, 0, 1]);
  }
  _tryParsingColor(e) {
    return (e = e.toLowerCase()) in Bg && (e = Bg[e]), e === "transparent" ? [255, 255, 255, 0] : $t.sourceFromHex(e) || $t.sourceFromRgb(e) || $t.sourceFromHsl(e) || (this.isUnrecognised = !0) && [0, 0, 0, 1];
  }
  getSource() {
    return this._source;
  }
  setSource(e) {
    this._source = e;
  }
  toRgb() {
    const [e, n, r] = this.getSource();
    return "rgb(".concat(e, ",").concat(n, ",").concat(r, ")");
  }
  toRgba() {
    return "rgba(".concat(this.getSource().join(","), ")");
  }
  toHsl() {
    const [e, n, r] = Hg(...this.getSource());
    return "hsl(".concat(e, ",").concat(n, "%,").concat(r, "%)");
  }
  toHsla() {
    const [e, n, r, o] = Hg(...this.getSource());
    return "hsla(".concat(e, ",").concat(n, "%,").concat(r, "%,").concat(o, ")");
  }
  toHex() {
    return this.toHexa().slice(0, 6);
  }
  toHexa() {
    const [e, n, r, o] = this.getSource();
    return "".concat(Pu(e)).concat(Pu(n)).concat(Pu(r)).concat(Pu(Math.round(255 * o)));
  }
  getAlpha() {
    return this.getSource()[3];
  }
  setAlpha(e) {
    return this._source[3] = e, this;
  }
  toGrayscale() {
    return this.setSource(Wg(this.getSource())), this;
  }
  toBlackWhite(e) {
    const [n, , , r] = Wg(this.getSource()), o = n < (e || 127) ? 0 : 255;
    return this.setSource([o, o, o, r]), this;
  }
  overlayWith(e) {
    e instanceof $t || (e = new $t(e));
    const n = this.getSource(), r = e.getSource(), [o, s, a] = n.map((l, u) => Math.round(0.5 * l + 0.5 * r[u]));
    return this.setSource([o, s, a, n[3]]), this;
  }
  static fromRgb(e) {
    return $t.fromRgba(e);
  }
  static fromRgba(e) {
    return new $t($t.sourceFromRgb(e));
  }
  static sourceFromRgb(e) {
    const n = Kc(e).match(/^rgba?\(\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?(?:\s?[,/]\s?(\d{0,3}(?:\.\d+)?%?)\s?)?\)$/i);
    if (n) {
      const [r, o, s] = n.slice(1, 4).map((a) => {
        const l = parseFloat(a);
        return a.endsWith("%") ? Math.round(2.55 * l) : l;
      });
      return [r, o, s, Ug(n[4])];
    }
  }
  static fromHsl(e) {
    return $t.fromHsla(e);
  }
  static fromHsla(e) {
    return new $t($t.sourceFromHsl(e));
  }
  static sourceFromHsl(e) {
    const n = Kc(e).match(/^hsla?\(\s?([+-]?\d{0,3}(?:\.\d+)?(?:deg|turn|rad)?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?(?:\s?[,/]\s?(\d*(?:\.\d+)?%?)\s?)?\)$/i);
    if (!n) return;
    const r = ($t.parseAngletoDegrees(n[1]) % 360 + 360) % 360 / 360, o = parseFloat(n[2]) / 100, s = parseFloat(n[3]) / 100;
    let a, l, u;
    if (o === 0) a = l = u = s;
    else {
      const c = s <= 0.5 ? s * (o + 1) : s + o - s * o, d = 2 * s - c;
      a = sh(d, c, r + 1 / 3), l = sh(d, c, r), u = sh(d, c, r - 1 / 3);
    }
    return [Math.round(255 * a), Math.round(255 * l), Math.round(255 * u), Ug(n[4])];
  }
  static fromHex(e) {
    return new $t($t.sourceFromHex(e));
  }
  static sourceFromHex(e) {
    if (e.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)) {
      const n = e.slice(e.indexOf("#") + 1);
      let r;
      r = n.length <= 4 ? n.split("").map((u) => u + u) : n.match(/.{2}/g);
      const [o, s, a, l = 255] = r.map((u) => parseInt(u, 16));
      return [o, s, a, l / 255];
    }
  }
  static parseAngletoDegrees(e) {
    const n = e.toLowerCase(), r = parseFloat(n);
    return n.includes("rad") ? oo(r) : n.includes("turn") ? 360 * r : r;
  }
}
const ha = function(i) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : op;
  const n = /\D{0,2}$/.exec(i), r = parseFloat(i), o = kt.DPI;
  switch (n == null ? void 0 : n[0]) {
    case "mm":
      return r * o / 25.4;
    case "cm":
      return r * o / 2.54;
    case "in":
      return r * o;
    case "pt":
      return r * o / 72;
    case "pc":
      return r * o / 72 * 12;
    case "em":
      return r * e;
    default:
      return r;
  }
}, J3 = (i) => {
  const [e, n] = i.trim().split(" "), [r, o] = (s = e) && s !== ei ? [s.slice(1, 4), s.slice(5, 8)] : s === ei ? [s, s] : ["Mid", "Mid"];
  var s;
  return { meetOrSlice: n || "meet", alignX: r, alignY: o };
}, Il = function(i, e) {
  let n, r, o = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
  if (e) if (e.toLive) n = "url(#SVGID_".concat(e.id, ")");
  else {
    const s = new $t(e), a = s.getAlpha();
    n = s.toRgb(), a !== 1 && (r = a.toString());
  }
  else n = "none";
  return o ? "".concat(i, ": ").concat(n, "; ").concat(r ? "".concat(i, "-opacity: ").concat(r, "; ") : "") : "".concat(i, '="').concat(n, '" ').concat(r ? "".concat(i, '-opacity="').concat(r, '" ') : "");
};
class zb {
  getSvgStyles(e) {
    const n = this.fillRule ? this.fillRule : "nonzero", r = this.strokeWidth ? this.strokeWidth : "0", o = this.strokeDashArray ? this.strokeDashArray.join(" ") : ei, s = this.strokeDashOffset ? this.strokeDashOffset : "0", a = this.strokeLineCap ? this.strokeLineCap : "butt", l = this.strokeLineJoin ? this.strokeLineJoin : "miter", u = this.strokeMiterLimit ? this.strokeMiterLimit : "4", c = this.opacity !== void 0 ? this.opacity : "1", d = this.visible ? "" : " visibility: hidden;", h = e ? "" : this.getSvgFilter(), p = Il(yn, this.fill);
    return [Il(ti, this.stroke), "stroke-width: ", r, "; ", "stroke-dasharray: ", o, "; ", "stroke-linecap: ", a, "; ", "stroke-dashoffset: ", s, "; ", "stroke-linejoin: ", l, "; ", "stroke-miterlimit: ", u, "; ", p, "fill-rule: ", n, "; ", "opacity: ", c, ";", h, d].join("");
  }
  getSvgFilter() {
    return this.shadow ? "filter: url(#SVGID_".concat(this.shadow.id, ");") : "";
  }
  getSvgCommons() {
    return [this.id ? 'id="'.concat(this.id, '" ') : "", this.clipPath ? 'clip-path="url(#'.concat(this.clipPath.clipPathId, ')" ') : ""].join("");
  }
  getSvgTransform(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const r = e ? this.calcTransformMatrix() : this.calcOwnMatrix(), o = 'transform="'.concat(Pl(r));
    return "".concat(o).concat(n, '" ');
  }
  _toSVG(e) {
    return [""];
  }
  toSVG(e) {
    return this._createBaseSVGMarkup(this._toSVG(e), { reviver: e });
  }
  toClipPathSVG(e) {
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(e), { reviver: e });
  }
  _createBaseClipPathSVGMarkup(e) {
    let { reviver: n, additionalTransform: r = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const o = [this.getSvgTransform(!0, r), this.getSvgCommons()].join(""), s = e.indexOf("COMMON_PARTS");
    return e[s] = o, n ? n(e.join("")) : e.join("");
  }
  _createBaseSVGMarkup(e) {
    let { noStyle: n, reviver: r, withShadow: o, additionalTransform: s } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const a = n ? "" : 'style="'.concat(this.getSvgStyles(), '" '), l = o ? 'style="'.concat(this.getSvgFilter(), '" ') : "", u = this.clipPath, c = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", d = u && u.absolutePositioned, h = this.stroke, p = this.fill, m = this.shadow, v = [], y = e.indexOf("COMMON_PARTS");
    let w;
    u && (u.clipPathId = "CLIPPATH_".concat(No()), w = '<clipPath id="'.concat(u.clipPathId, `" >
`).concat(u.toClipPathSVG(r), `</clipPath>
`)), d && v.push("<g ", l, this.getSvgCommons(), ` >
`), v.push("<g ", this.getSvgTransform(!1), d ? "" : l + this.getSvgCommons(), ` >
`);
    const g = [a, c, n ? "" : this.addPaintOrder(), " ", s ? 'transform="'.concat(s, '" ') : ""].join("");
    return e[y] = g, xi(p) && v.push(p.toSVG(this)), xi(h) && v.push(h.toSVG(this)), m && v.push(m.toSVG(this)), u && v.push(w), v.push(e.join("")), v.push(`</g>
`), d && v.push(`</g>
`), r ? r(v.join("")) : v.join("");
  }
  addPaintOrder() {
    return this.paintFirst !== yn ? ' paint-order="'.concat(this.paintFirst, '" ') : "";
  }
}
function bd(i) {
  return new RegExp("^(" + i.join("|") + ")\\b", "i");
}
const Ps = "textDecorationThickness", Bb = ["fontSize", "fontWeight", "fontFamily", "fontStyle"], Hb = ["underline", "overline", "linethrough"], Ub = [...Bb, "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], Wb = [...Ub, ...Hb, "textBackgroundColor", "direction", Ps], Q3 = [...Bb, ...Hb, ti, "strokeWidth", yn, "deltaY", "textBackgroundColor", Ps], e4 = { _reNewline: sp, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: Tt, fontStyle: "normal", lineHeight: 1.16, textBackgroundColor: "", stroke: null, shadow: null, path: void 0, pathStartOffset: 0, pathSide: Tt, pathAlign: "baseline", charSpacing: 0, deltaY: 0, direction: "ltr", CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2, superscript: { size: 0.6, baseline: -0.35 }, subscript: { size: 0.6, baseline: 0.11 }, _fontSizeFraction: 0.222, offsets: { underline: 0.1, linethrough: -0.28167, overline: -0.81333 }, _fontSizeMult: 1.13, [Ps]: 66.667 }, mr = "justify", qc = "justify-left", fl = "justify-right", pl = "justify-center";
var Gg, Xg, Yg;
const zi = String.raw(Gg || (Gg = Cr(["[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?"], ["[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?"]))), ah = String.raw(Xg || (Xg = Cr(["(?:s*,?s+|s*,s*)"], ["(?:\\s*,?\\s+|\\s*,\\s*)"]))), t4 = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + zi + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + zi + "))?\\s+(.*)"), n4 = { cx: Tt, x: Tt, r: "radius", cy: Qn, y: Qn, display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing", "text-decoration-thickness": Ps }, lh = "font-size", uh = "clip-path";
bd(["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"]);
bd(["symbol", "image", "marker", "pattern", "view", "svg"]);
const Kg = bd(["symbol", "g", "a", "svg", "clipPath", "defs"]);
new RegExp(String.raw(Yg || (Yg = Cr(["^s*(", ")", "(", ")", "(", ")", "(", ")s*$"], ["^\\s*(", ")", "(", ")", "(", ")", "(", ")\\s*$"])), zi, ah, zi, ah, zi, ah, zi));
const i4 = new ce(1, 0), Gb = new ce(), Xb = (i, e) => i.rotate(e), Zh = (i, e) => new ce(e).subtract(i), Jh = (i) => i.distanceFrom(Gb), Qh = (i, e) => Math.atan2(ml(i, e), o4(i, e)), r4 = (i) => Qh(i4, i), pp = (i) => i.eq(Gb) ? i : i.scalarDivide(Jh(i)), Yb = function(i) {
  let e = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
  return pp(new ce(-i.y, i.x).scalarMultiply(e ? 1 : -1));
}, ml = (i, e) => i.x * e.y - i.y * e.x, o4 = (i, e) => i.x * e.x + i.y * e.y, qg = (i, e, n) => {
  if (i.eq(e) || i.eq(n)) return !0;
  const r = ml(e, n), o = ml(e, i), s = ml(n, i);
  return r >= 0 ? o >= 0 && s <= 0 : !(o <= 0 && s >= 0);
}, Zg = "(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?", Jg = new RegExp("(?:\\s|^)" + Zg + Zg + "(" + zi + "?(?:px)?)?(?:\\s?|$)(?:$|\\s)");
class eo {
  constructor(e) {
    const n = typeof e == "string" ? eo.parseShadow(e) : e;
    Object.assign(this, eo.ownDefaults, n), this.id = No();
  }
  static parseShadow(e) {
    const n = e.trim(), [, r = 0, o = 0, s = 0] = (Jg.exec(n) || []).map((a) => parseFloat(a) || 0);
    return { color: (n.replace(Jg, "") || "rgb(0,0,0)").trim(), offsetX: r, offsetY: o, blur: s };
  }
  toString() {
    return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
  }
  toSVG(e) {
    const n = Xb(new ce(this.offsetX, this.offsetY), un(-e.angle)), r = new $t(this.color);
    let o = 40, s = 40;
    return e.width && e.height && (o = 100 * Nt((Math.abs(n.x) + this.blur) / e.width, kt.NUM_FRACTION_DIGITS) + 20, s = 100 * Nt((Math.abs(n.y) + this.blur) / e.height, kt.NUM_FRACTION_DIGITS) + 20), e.flipX && (n.x *= -1), e.flipY && (n.y *= -1), '<filter id="SVGID_'.concat(this.id, '" y="-').concat(s, '%" height="').concat(100 + 2 * s, '%" x="-').concat(o, '%" width="').concat(100 + 2 * o, `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`).concat(Nt(this.blur ? this.blur / 2 : 0, kt.NUM_FRACTION_DIGITS), `"></feGaussianBlur>
	<feOffset dx="`).concat(Nt(n.x, kt.NUM_FRACTION_DIGITS), '" dy="').concat(Nt(n.y, kt.NUM_FRACTION_DIGITS), `" result="oBlur" ></feOffset>
	<feFlood flood-color="`).concat(r.toRgb(), '" flood-opacity="').concat(r.getAlpha(), `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`);
  }
  toObject() {
    const e = { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling, type: this.constructor.type }, n = eo.ownDefaults;
    return this.includeDefaultValues ? e : dp(e, (r, o) => r !== n[o]);
  }
  static async fromObject(e) {
    return new this(e);
  }
}
Y(eo, "ownDefaults", { color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1 }), Y(eo, "type", "shadow"), Ne.setClass(eo, "shadow");
const _a = (i, e, n) => Math.max(i, Math.min(e, n)), s4 = [Qn, Tt, ni, Si, "flipX", "flipY", "originX", "originY", "angle", "opacity", "globalCompositeOperation", "shadow", "visible", ka, Oa], lo = [yn, ti, "strokeWidth", "strokeDashArray", "width", "height", "paintFirst", "strokeUniform", "strokeLineCap", "strokeDashOffset", "strokeLineJoin", "strokeMiterLimit", "backgroundColor", "clipPath"], a4 = { top: 0, left: 0, width: 0, height: 0, angle: 0, flipX: !1, flipY: !1, scaleX: 1, scaleY: 1, minScaleLimit: 0, skewX: 0, skewY: 0, originX: Tt, originY: Qn, strokeWidth: 1, strokeUniform: !1, padding: 0, opacity: 1, paintFirst: yn, fill: "rgb(0,0,0)", fillRule: "nonzero", stroke: null, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, globalCompositeOperation: "source-over", backgroundColor: "", shadow: null, visible: !0, includeDefaultValues: !0, excludeFromExport: !1, objectCaching: !0, clipPath: void 0, inverted: !1, absolutePositioned: !1, centeredRotation: !0, centeredScaling: !1, dirty: !0 }, l4 = (i, e, n, r) => -n * Math.cos(i / r * uu) + n + e, u4 = () => !1;
class mp {
  constructor(e) {
    let { startValue: n, byValue: r, duration: o = 500, delay: s = 0, easing: a = l4, onStart: l = pc, onChange: u = pc, onComplete: c = pc, abort: d = u4, target: h } = e;
    Y(this, "_state", "pending"), Y(this, "durationProgress", 0), Y(this, "valueProgress", 0), this.tick = this.tick.bind(this), this.duration = o, this.delay = s, this.easing = a, this._onStart = l, this._onChange = u, this._onComplete = c, this._abort = d, this.target = h, this.startValue = n, this.byValue = r, this.value = this.startValue, this.endValue = Object.freeze(this.calculate(this.duration).value);
  }
  get state() {
    return this._state;
  }
  isDone() {
    return this._state === "aborted" || this._state === "completed";
  }
  start() {
    const e = (n) => {
      this._state === "pending" && (this.startTime = n || +/* @__PURE__ */ new Date(), this._state = "running", this._onStart(), this.tick(this.startTime));
    };
    this.register(), this.delay > 0 ? setTimeout(() => gc(e), this.delay) : gc(e);
  }
  tick(e) {
    const n = (e || +/* @__PURE__ */ new Date()) - this.startTime, r = Math.min(n, this.duration);
    this.durationProgress = r / this.duration;
    const { value: o, valueProgress: s } = this.calculate(r);
    this.value = Object.freeze(o), this.valueProgress = s, this._state !== "aborted" && (this._abort(this.value, this.valueProgress, this.durationProgress) ? (this._state = "aborted", this.unregister()) : n >= this.duration ? (this.durationProgress = this.valueProgress = 1, this._onChange(this.endValue, this.valueProgress, this.durationProgress), this._state = "completed", this._onComplete(this.endValue, this.valueProgress, this.durationProgress), this.unregister()) : (this._onChange(this.value, this.valueProgress, this.durationProgress), gc(this.tick)));
  }
  register() {
    Wc.push(this);
  }
  unregister() {
    Wc.remove(this);
  }
  abort() {
    this._state = "aborted", this.unregister();
  }
}
const c4 = ["startValue", "endValue"];
class d4 extends mp {
  constructor(e) {
    let { startValue: n = 0, endValue: r = 100 } = e;
    super(K(K({}, zt(e, c4)), {}, { startValue: n, byValue: r - n }));
  }
  calculate(e) {
    const n = this.easing(e, this.startValue, this.byValue, this.duration);
    return { value: n, valueProgress: Math.abs((n - this.startValue) / this.byValue) };
  }
}
const h4 = ["startValue", "endValue"];
class f4 extends mp {
  constructor(e) {
    let { startValue: n = [0], endValue: r = [100] } = e;
    super(K(K({}, zt(e, h4)), {}, { startValue: n, byValue: r.map((o, s) => o - n[s]) }));
  }
  calculate(e) {
    const n = this.startValue.map((r, o) => this.easing(e, r, this.byValue[o], this.duration, o));
    return { value: n, valueProgress: Math.abs((n[0] - this.startValue[0]) / this.byValue[0]) };
  }
}
const p4 = ["startValue", "endValue", "easing", "onChange", "onComplete", "abort"], m4 = (i, e, n, r) => e + n * (1 - Math.cos(i / r * uu)), ch = (i) => i && ((e, n, r) => i(new $t(e).toRgba(), n, r));
class g4 extends mp {
  constructor(e) {
    let { startValue: n, endValue: r, easing: o = m4, onChange: s, onComplete: a, abort: l } = e, u = zt(e, p4);
    const c = new $t(n).getSource(), d = new $t(r).getSource();
    super(K(K({}, u), {}, { startValue: c, byValue: d.map((h, p) => h - c[p]), easing: o, onChange: ch(s), onComplete: ch(a), abort: ch(l) }));
  }
  calculate(e) {
    const [n, r, o, s] = this.startValue.map((l, u) => this.easing(e, l, this.byValue[u], this.duration, u)), a = [...[n, r, o].map(Math.round), _a(0, s, 1)];
    return { value: a, valueProgress: a.map((l, u) => this.byValue[u] !== 0 ? Math.abs((l - this.startValue[u]) / this.byValue[u]) : 0).find((l) => l !== 0) || 0 };
  }
}
function Kb(i) {
  const e = ((n) => Array.isArray(n.startValue) || Array.isArray(n.endValue))(i) ? new f4(i) : new d4(i);
  return e.start(), e;
}
function v4(i) {
  const e = new g4(i);
  return e.start(), e;
}
class Kt {
  constructor(e) {
    this.status = e, this.points = [];
  }
  includes(e) {
    return this.points.some((n) => n.eq(e));
  }
  append() {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
    return this.points = this.points.concat(n.filter((o) => !this.includes(o))), this;
  }
  static isPointContained(e, n, r) {
    let o = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    if (n.eq(r)) return e.eq(n);
    if (n.x === r.x) return e.x === n.x && (o || e.y >= Math.min(n.y, r.y) && e.y <= Math.max(n.y, r.y));
    if (n.y === r.y) return e.y === n.y && (o || e.x >= Math.min(n.x, r.x) && e.x <= Math.max(n.x, r.x));
    {
      const s = Zh(n, r), a = Zh(n, e).divide(s);
      return o ? Math.abs(a.x) === Math.abs(a.y) : a.x === a.y && a.x >= 0 && a.x <= 1;
    }
  }
  static isPointInPolygon(e, n) {
    const r = new ce(e).setX(Math.min(e.x - 1, ...n.map((s) => s.x)));
    let o = 0;
    for (let s = 0; s < n.length; s++) {
      const a = this.intersectSegmentSegment(n[s], n[(s + 1) % n.length], e, r);
      if (a.includes(e)) return !0;
      o += +(a.status === "Intersection");
    }
    return o % 2 == 1;
  }
  static intersectLineLine(e, n, r, o) {
    let s = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], a = !(arguments.length > 5 && arguments[5] !== void 0) || arguments[5];
    const l = n.x - e.x, u = n.y - e.y, c = o.x - r.x, d = o.y - r.y, h = e.x - r.x, p = e.y - r.y, m = c * p - d * h, v = l * p - u * h, y = d * l - c * u;
    if (y !== 0) {
      const w = m / y, g = v / y;
      return (s || 0 <= w && w <= 1) && (a || 0 <= g && g <= 1) ? new Kt("Intersection").append(new ce(e.x + w * l, e.y + w * u)) : new Kt();
    }
    if (m === 0 || v === 0) {
      const w = s || a || Kt.isPointContained(e, r, o) || Kt.isPointContained(n, r, o) || Kt.isPointContained(r, e, n) || Kt.isPointContained(o, e, n);
      return new Kt(w ? "Coincident" : void 0);
    }
    return new Kt("Parallel");
  }
  static intersectSegmentLine(e, n, r, o) {
    return Kt.intersectLineLine(e, n, r, o, !1, !0);
  }
  static intersectSegmentSegment(e, n, r, o) {
    return Kt.intersectLineLine(e, n, r, o, !1, !1);
  }
  static intersectLinePolygon(e, n, r) {
    let o = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
    const s = new Kt(), a = r.length;
    for (let l, u, c, d = 0; d < a; d++) {
      if (l = r[d], u = r[(d + 1) % a], c = Kt.intersectLineLine(e, n, l, u, o, !1), c.status === "Coincident") return c;
      s.append(...c.points);
    }
    return s.points.length > 0 && (s.status = "Intersection"), s;
  }
  static intersectSegmentPolygon(e, n, r) {
    return Kt.intersectLinePolygon(e, n, r, !1);
  }
  static intersectPolygonPolygon(e, n) {
    const r = new Kt(), o = e.length, s = [];
    for (let a = 0; a < o; a++) {
      const l = e[a], u = e[(a + 1) % o], c = Kt.intersectSegmentPolygon(l, u, n);
      c.status === "Coincident" ? (s.push(c), r.append(l, u)) : r.append(...c.points);
    }
    return s.length > 0 && s.length === e.length ? new Kt("Coincident") : (r.points.length > 0 && (r.status = "Intersection"), r);
  }
  static intersectPolygonRectangle(e, n, r) {
    const o = n.min(r), s = n.max(r), a = new ce(s.x, o.y), l = new ce(o.x, s.y);
    return Kt.intersectPolygonPolygon(e, [o, a, s, l]);
  }
}
class y4 extends kb {
  getX() {
    return this.getXY().x;
  }
  setX(e) {
    this.setXY(this.getXY().setX(e));
  }
  getY() {
    return this.getXY().y;
  }
  setY(e) {
    this.setXY(this.getXY().setY(e));
  }
  getRelativeX() {
    return this.left;
  }
  setRelativeX(e) {
    this.left = e;
  }
  getRelativeY() {
    return this.top;
  }
  setRelativeY(e) {
    this.top = e;
  }
  getXY() {
    const e = this.getRelativeXY();
    return this.group ? qn(e, this.group.calcTransformMatrix()) : e;
  }
  setXY(e, n, r) {
    this.group && (e = qn(e, Ni(this.group.calcTransformMatrix()))), this.setRelativeXY(e, n, r);
  }
  getRelativeXY() {
    return new ce(this.left, this.top);
  }
  setRelativeXY(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.originX, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.originY;
    this.setPositionByOrigin(e, n, r);
  }
  isStrokeAccountedForInDimensions() {
    return !1;
  }
  getCoords() {
    const { tl: e, tr: n, br: r, bl: o } = this.aCoords || (this.aCoords = this.calcACoords()), s = [e, n, r, o];
    if (this.group) {
      const a = this.group.calcTransformMatrix();
      return s.map((l) => qn(l, a));
    }
    return s;
  }
  intersectsWithRect(e, n) {
    return Kt.intersectPolygonRectangle(this.getCoords(), e, n).status === "Intersection";
  }
  intersectsWithObject(e) {
    const n = Kt.intersectPolygonPolygon(this.getCoords(), e.getCoords());
    return n.status === "Intersection" || n.status === "Coincident" || e.isContainedWithinObject(this) || this.isContainedWithinObject(e);
  }
  isContainedWithinObject(e) {
    return this.getCoords().every((n) => e.containsPoint(n));
  }
  isContainedWithinRect(e, n) {
    const { left: r, top: o, width: s, height: a } = this.getBoundingRect();
    return r >= e.x && r + s <= n.x && o >= e.y && o + a <= n.y;
  }
  isOverlapping(e) {
    return this.intersectsWithObject(e) || this.isContainedWithinObject(e) || e.isContainedWithinObject(this);
  }
  containsPoint(e) {
    return Kt.isPointInPolygon(e, this.getCoords());
  }
  isOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: n } = this.canvas.vptCoords;
    return !!this.getCoords().some((r) => r.x <= n.x && r.x >= e.x && r.y <= n.y && r.y >= e.y) || !!this.intersectsWithRect(e, n) || this.containsPoint(e.midPointFrom(n));
  }
  isPartiallyOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: n } = this.canvas.vptCoords;
    return this.intersectsWithRect(e, n) ? !0 : this.getCoords().every((r) => (r.x >= n.x || r.x <= e.x) && (r.y >= n.y || r.y <= e.y)) && this.containsPoint(e.midPointFrom(n));
  }
  getBoundingRect() {
    return Qr(this.getCoords());
  }
  getScaledWidth() {
    return this._getTransformedDimensions().x;
  }
  getScaledHeight() {
    return this._getTransformedDimensions().y;
  }
  scale(e) {
    this._set(ni, e), this._set(Si, e), this.setCoords();
  }
  scaleToWidth(e) {
    const n = this.getBoundingRect().width / this.getScaledWidth();
    return this.scale(e / this.width / n);
  }
  scaleToHeight(e) {
    const n = this.getBoundingRect().height / this.getScaledHeight();
    return this.scale(e / this.height / n);
  }
  getCanvasRetinaScaling() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.getRetinaScaling()) || 1;
  }
  getTotalAngle() {
    return this.group ? oo(Tb(this.calcTransformMatrix())) : this.angle;
  }
  getViewportTransform() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.viewportTransform) || Un.concat();
  }
  calcACoords() {
    const e = Ea({ angle: this.angle }), { x: n, y: r } = this.getRelativeCenterPoint(), o = cu(n, r), s = $n(o, e), a = this._getTransformedDimensions(), l = a.x / 2, u = a.y / 2;
    return { tl: qn({ x: -l, y: -u }, s), tr: qn({ x: l, y: -u }, s), bl: qn({ x: -l, y: u }, s), br: qn({ x: l, y: u }, s) };
  }
  setCoords() {
    this.aCoords = this.calcACoords();
  }
  transformMatrixKey() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], n = [];
    return !e && this.group && (n = this.group.transformMatrixKey(e)), n.push(this.top, this.left, this.width, this.height, this.scaleX, this.scaleY, this.angle, this.strokeWidth, this.skewX, this.skewY, +this.flipX, +this.flipY, fn(this.originX), fn(this.originY)), n;
  }
  calcTransformMatrix() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], n = this.calcOwnMatrix();
    if (e || !this.group) return n;
    const r = this.transformMatrixKey(e), o = this.matrixCache;
    return o && o.key.every((s, a) => s === r[a]) ? o.value : (this.group && (n = $n(this.group.calcTransformMatrix(!1), n)), this.matrixCache = { key: r, value: n }, n);
  }
  calcOwnMatrix() {
    const e = this.transformMatrixKey(!0), n = this.ownMatrixCache;
    if (n && n.key === e) return n.value;
    const r = this.getRelativeCenterPoint(), o = { angle: this.angle, translateX: r.x, translateY: r.y, scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }, s = N3(o);
    return this.ownMatrixCache = { key: e, value: s }, s;
  }
  _getNonTransformedDimensions() {
    return new ce(this.width, this.height).scalarAdd(this.strokeWidth);
  }
  _calculateCurrentDimensions(e) {
    return this._getTransformedDimensions(e).transform(this.getViewportTransform(), !0).scalarAdd(2 * this.padding);
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = K({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, width: this.width, height: this.height, strokeWidth: this.strokeWidth }, e), r = n.strokeWidth;
    let o = r, s = 0;
    this.strokeUniform && (o = 0, s = r);
    const a = n.width + o, l = n.height + o;
    let u;
    return u = n.skewX === 0 && n.skewY === 0 ? new ce(a * n.scaleX, l * n.scaleY) : hp(a, l, gd(n)), u.scalarAdd(s);
  }
  translateToGivenOrigin(e, n, r, o, s) {
    let a = e.x, l = e.y;
    const u = fn(o) - fn(n), c = fn(s) - fn(r);
    if (u || c) {
      const d = this._getTransformedDimensions();
      a += u * d.x, l += c * d.y;
    }
    return new ce(a, l);
  }
  translateToCenterPoint(e, n, r) {
    if (n === ut && r === ut) return e;
    const o = this.translateToGivenOrigin(e, n, r, ut, ut);
    return this.angle ? o.rotate(un(this.angle), e) : o;
  }
  translateToOriginPoint(e, n, r) {
    const o = this.translateToGivenOrigin(e, ut, ut, n, r);
    return this.angle ? o.rotate(un(this.angle), e) : o;
  }
  getCenterPoint() {
    const e = this.getRelativeCenterPoint();
    return this.group ? qn(e, this.group.calcTransformMatrix()) : e;
  }
  getRelativeCenterPoint() {
    return this.translateToCenterPoint(new ce(this.left, this.top), this.originX, this.originY);
  }
  getPointByOrigin(e, n) {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), e, n);
  }
  setPositionByOrigin(e, n, r) {
    const o = this.translateToCenterPoint(e, n, r), s = this.translateToOriginPoint(o, this.originX, this.originY);
    this.set({ left: s.x, top: s.y });
  }
  _getLeftTopCoords() {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), Tt, Qn);
  }
}
const b4 = ["type"], w4 = ["extraParam"];
let jr = class yc extends y4 {
  static getDefaults() {
    return yc.ownDefaults;
  }
  get type() {
    const e = this.constructor.type;
    return e === "FabricObject" ? "object" : e.toLowerCase();
  }
  set type(e) {
    Ro("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    super(), Y(this, "_cacheContext", null), Object.assign(this, yc.ownDefaults), this.setOptions(e);
  }
  _createCacheCanvas() {
    this._cacheCanvas = ro(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0;
  }
  _limitCacheSize(e) {
    const n = e.width, r = e.height, o = kt.maxCacheSideLimit, s = kt.minCacheSideLimit;
    if (n <= o && r <= o && n * r <= kt.perfLimitSizeTotal) return n < s && (e.width = s), r < s && (e.height = s), e;
    const a = n / r, [l, u] = hl.limitDimsByArea(a), c = _a(s, l, o), d = _a(s, u, o);
    return n > c && (e.zoomX /= n / c, e.width = c, e.capped = !0), r > d && (e.zoomY /= r / d, e.height = d, e.capped = !0), e;
  }
  _getCacheCanvasDimensions() {
    const e = this.getTotalObjectScaling(), n = this._getTransformedDimensions({ skewX: 0, skewY: 0 }), r = n.x * e.x / this.scaleX, o = n.y * e.y / this.scaleY;
    return { width: Math.ceil(r + 2), height: Math.ceil(o + 2), zoomX: e.x, zoomY: e.y, x: r, y: o };
  }
  _updateCacheCanvas() {
    const e = this._cacheCanvas, n = this._cacheContext, { width: r, height: o, zoomX: s, zoomY: a, x: l, y: u } = this._limitCacheSize(this._getCacheCanvasDimensions()), c = r !== e.width || o !== e.height, d = this.zoomX !== s || this.zoomY !== a;
    if (!e || !n) return !1;
    if (c || d) {
      r !== e.width || o !== e.height ? (e.width = r, e.height = o) : (n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, e.width, e.height));
      const h = l / 2, p = u / 2;
      return this.cacheTranslationX = Math.round(e.width / 2 - h) + h, this.cacheTranslationY = Math.round(e.height / 2 - p) + p, n.translate(this.cacheTranslationX, this.cacheTranslationY), n.scale(s, a), this.zoomX = s, this.zoomY = a, !0;
    }
    return !1;
  }
  setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setOptions(e);
  }
  transform(e) {
    const n = this.group && !this.group._transformDone || this.group && this.canvas && e === this.canvas.contextTop, r = this.calcTransformMatrix(!n);
    e.transform(r[0], r[1], r[2], r[3], r[4], r[5]);
  }
  getObjectScaling() {
    if (!this.group) return new ce(Math.abs(this.scaleX), Math.abs(this.scaleY));
    const e = Gc(this.calcTransformMatrix());
    return new ce(Math.abs(e.scaleX), Math.abs(e.scaleY));
  }
  getTotalObjectScaling() {
    const e = this.getObjectScaling();
    if (this.canvas) {
      const n = this.canvas.getZoom(), r = this.getCanvasRetinaScaling();
      return e.scalarMultiply(n * r);
    }
    return e;
  }
  getObjectOpacity() {
    let e = this.opacity;
    return this.group && (e *= this.group.getObjectOpacity()), e;
  }
  _constrainScale(e) {
    return Math.abs(e) < this.minScaleLimit ? e < 0 ? -this.minScaleLimit : this.minScaleLimit : e === 0 ? 1e-4 : e;
  }
  _set(e, n) {
    e !== ni && e !== Si || (n = this._constrainScale(n)), e === ni && n < 0 ? (this.flipX = !this.flipX, n *= -1) : e === "scaleY" && n < 0 ? (this.flipY = !this.flipY, n *= -1) : e !== "shadow" || !n || n instanceof eo || (n = new eo(n));
    const r = this[e] !== n;
    return this[e] = n, r && this.constructor.cacheProperties.includes(e) && (this.dirty = !0), this.parent && (this.dirty || r && this.constructor.stateProperties.includes(e)) && this.parent._set("dirty", !0), this;
  }
  isNotVisible() {
    return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
  }
  render(e) {
    this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (e.save(), this._setupCompositeOperation(e), this.drawSelectionBackground(e), this.transform(e), this._setOpacity(e), this._setShadow(e), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(e)) : (this._removeCacheCanvas(), this.drawObject(e, !1, {}), this.dirty = !1), e.restore());
  }
  drawSelectionBackground(e) {
  }
  renderCache(e) {
    if (e = e || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && this._cacheContext) {
      const { zoomX: n, zoomY: r, cacheTranslationX: o, cacheTranslationY: s } = this, { width: a, height: l } = this._cacheCanvas;
      this.drawObject(this._cacheContext, e.forClipping, { zoomX: n, zoomY: r, cacheTranslationX: o, cacheTranslationY: s, width: a, height: l, parentClipPaths: [] }), this.dirty = !1;
    }
  }
  _removeCacheCanvas() {
    this._cacheCanvas = void 0, this._cacheContext = null;
  }
  hasStroke() {
    return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
  }
  hasFill() {
    return this.fill && this.fill !== "transparent";
  }
  needsItsOwnCache() {
    return !!(this.paintFirst === ti && this.hasFill() && this.hasStroke() && this.shadow) || !!this.clipPath;
  }
  shouldCache() {
    return this.ownCaching = this.objectCaching && (!this.parent || !this.parent.isOnACache()) || this.needsItsOwnCache(), this.ownCaching;
  }
  willDrawShadow() {
    return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
  }
  drawClipPathOnCache(e, n, r) {
    e.save(), n.inverted ? e.globalCompositeOperation = "destination-out" : e.globalCompositeOperation = "destination-in", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(r, 0, 0), e.restore();
  }
  drawObject(e, n, r) {
    const o = this.fill, s = this.stroke;
    n ? (this.fill = "black", this.stroke = "", this._setClippingProperties(e)) : this._renderBackground(e), this._render(e), this._drawClipPath(e, this.clipPath, r), this.fill = o, this.stroke = s;
  }
  createClipPathLayer(e, n) {
    const r = Ci(n), o = r.getContext("2d");
    if (o.translate(n.cacheTranslationX, n.cacheTranslationY), o.scale(n.zoomX, n.zoomY), e._cacheCanvas = r, n.parentClipPaths.forEach((s) => {
      s.transform(o);
    }), n.parentClipPaths.push(e), e.absolutePositioned) {
      const s = Ni(this.calcTransformMatrix());
      o.transform(s[0], s[1], s[2], s[3], s[4], s[5]);
    }
    return e.transform(o), e.drawObject(o, !0, n), r;
  }
  _drawClipPath(e, n, r) {
    if (!n) return;
    n._transformDone = !0;
    const o = this.createClipPathLayer(n, r);
    this.drawClipPathOnCache(e, n, o);
  }
  drawCacheOnCanvas(e) {
    e.scale(1 / this.zoomX, 1 / this.zoomY), e.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
  }
  isCacheDirty() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
    if (this.isNotVisible()) return !1;
    const n = this._cacheCanvas, r = this._cacheContext;
    return !(!n || !r || e || !this._updateCacheCanvas()) || !!(this.dirty || this.clipPath && this.clipPath.absolutePositioned) && (n && r && !e && (r.save(), r.setTransform(1, 0, 0, 1, 0, 0), r.clearRect(0, 0, n.width, n.height), r.restore()), !0);
  }
  _renderBackground(e) {
    if (!this.backgroundColor) return;
    const n = this._getNonTransformedDimensions();
    e.fillStyle = this.backgroundColor, e.fillRect(-n.x / 2, -n.y / 2, n.x, n.y), this._removeShadow(e);
  }
  _setOpacity(e) {
    this.group && !this.group._transformDone ? e.globalAlpha = this.getObjectOpacity() : e.globalAlpha *= this.opacity;
  }
  _setStrokeStyles(e, n) {
    const r = n.stroke;
    r && (e.lineWidth = n.strokeWidth, e.lineCap = n.strokeLineCap, e.lineDashOffset = n.strokeDashOffset, e.lineJoin = n.strokeLineJoin, e.miterLimit = n.strokeMiterLimit, xi(r) ? r.gradientUnits === "percentage" || r.gradientTransform || r.patternTransform ? this._applyPatternForTransformedGradient(e, r) : (e.strokeStyle = r.toLive(e), this._applyPatternGradientTransform(e, r)) : e.strokeStyle = n.stroke);
  }
  _setFillStyles(e, n) {
    let { fill: r } = n;
    r && (xi(r) ? (e.fillStyle = r.toLive(e), this._applyPatternGradientTransform(e, r)) : e.fillStyle = r);
  }
  _setClippingProperties(e) {
    e.globalAlpha = 1, e.strokeStyle = "transparent", e.fillStyle = "#000000";
  }
  _setLineDash(e, n) {
    n && n.length !== 0 && e.setLineDash(n);
  }
  _setShadow(e) {
    if (!this.shadow) return;
    const n = this.shadow, r = this.canvas, o = this.getCanvasRetinaScaling(), [s, , , a] = (r == null ? void 0 : r.viewportTransform) || Un, l = s * o, u = a * o, c = n.nonScaling ? new ce(1, 1) : this.getObjectScaling();
    e.shadowColor = n.color, e.shadowBlur = n.blur * kt.browserShadowBlurConstant * (l + u) * (c.x + c.y) / 4, e.shadowOffsetX = n.offsetX * l * c.x, e.shadowOffsetY = n.offsetY * u * c.y;
  }
  _removeShadow(e) {
    this.shadow && (e.shadowColor = "", e.shadowBlur = e.shadowOffsetX = e.shadowOffsetY = 0);
  }
  _applyPatternGradientTransform(e, n) {
    if (!xi(n)) return { offsetX: 0, offsetY: 0 };
    const r = n.gradientTransform || n.patternTransform, o = -this.width / 2 + n.offsetX || 0, s = -this.height / 2 + n.offsetY || 0;
    return n.gradientUnits === "percentage" ? e.transform(this.width, 0, 0, this.height, o, s) : e.transform(1, 0, 0, 1, o, s), r && e.transform(r[0], r[1], r[2], r[3], r[4], r[5]), { offsetX: o, offsetY: s };
  }
  _renderPaintInOrder(e) {
    this.paintFirst === ti ? (this._renderStroke(e), this._renderFill(e)) : (this._renderFill(e), this._renderStroke(e));
  }
  _render(e) {
  }
  _renderFill(e) {
    this.fill && (e.save(), this._setFillStyles(e, this), this.fillRule === "evenodd" ? e.fill("evenodd") : e.fill(), e.restore());
  }
  _renderStroke(e) {
    if (this.stroke && this.strokeWidth !== 0) {
      if (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this.strokeUniform) {
        const n = this.getObjectScaling();
        e.scale(1 / n.x, 1 / n.y);
      }
      this._setLineDash(e, this.strokeDashArray), this._setStrokeStyles(e, this), e.stroke(), e.restore();
    }
  }
  _applyPatternForTransformedGradient(e, n) {
    var r;
    const o = this._limitCacheSize(this._getCacheCanvasDimensions()), s = this.getCanvasRetinaScaling(), a = o.x / this.scaleX / s, l = o.y / this.scaleY / s, u = Ci({ width: Math.ceil(a), height: Math.ceil(l) }), c = u.getContext("2d");
    c && (c.beginPath(), c.moveTo(0, 0), c.lineTo(a, 0), c.lineTo(a, l), c.lineTo(0, l), c.closePath(), c.translate(a / 2, l / 2), c.scale(o.zoomX / this.scaleX / s, o.zoomY / this.scaleY / s), this._applyPatternGradientTransform(c, n), c.fillStyle = n.toLive(e), c.fill(), e.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), e.scale(s * this.scaleX / o.zoomX, s * this.scaleY / o.zoomY), e.strokeStyle = (r = c.createPattern(u, "no-repeat")) !== null && r !== void 0 ? r : "");
  }
  _findCenterFromElement() {
    return new ce(this.left + this.width / 2, this.top + this.height / 2);
  }
  clone(e) {
    const n = this.toObject(e);
    return this.constructor.fromObject(n);
  }
  cloneAsImage(e) {
    const n = this.toCanvasElement(e);
    return new (Ne.getClass("image"))(n);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = Vb(this), r = this.group, o = this.shadow, s = Math.abs, a = e.enableRetinaScaling ? wb() : 1, l = (e.multiplier || 1) * a, u = e.canvasProvider || ((k) => new du(k, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }));
    delete this.group, e.withoutTransform && X3(this), e.withoutShadow && (this.shadow = null), e.viewportTransform && K3(this, this.getViewportTransform()), this.setCoords();
    const c = ro(), d = this.getBoundingRect(), h = this.shadow, p = new ce();
    if (h) {
      const k = h.blur, _ = h.nonScaling ? new ce(1, 1) : this.getObjectScaling();
      p.x = 2 * Math.round(s(h.offsetX) + k) * s(_.x), p.y = 2 * Math.round(s(h.offsetY) + k) * s(_.y);
    }
    const m = d.width + p.x, v = d.height + p.y;
    c.width = Math.ceil(m), c.height = Math.ceil(v);
    const y = u(c);
    e.format === "jpeg" && (y.backgroundColor = "#fff"), this.setPositionByOrigin(new ce(y.width / 2, y.height / 2), ut, ut);
    const w = this.canvas;
    y._objects = [this], this.set("canvas", y), this.setCoords();
    const g = y.toCanvasElement(l || 1, e);
    return this.set("canvas", w), this.shadow = o, r && (this.group = r), this.set(n), this.setCoords(), y._objects = [], y.destroy(), g;
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Ob(this.toCanvasElement(e), e.format || "png", e.quality || 1);
  }
  toBlob() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Eb(this.toCanvasElement(e), e.format || "png", e.quality || 1);
  }
  isType() {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
    return n.includes(this.constructor.type) || n.includes(this.type);
  }
  complexity() {
    return 1;
  }
  toJSON() {
    return this.toObject();
  }
  rotate(e) {
    const { centeredRotation: n, originX: r, originY: o } = this;
    if (n) {
      const { x: s, y: a } = this.getRelativeCenterPoint();
      this.originX = ut, this.originY = ut, this.left = s, this.top = a;
    }
    if (this.set("angle", e), n) {
      const { x: s, y: a } = this.translateToOriginPoint(this.getRelativeCenterPoint(), r, o);
      this.left = s, this.top = a, this.originX = r, this.originY = o;
    }
  }
  setOnGroup() {
  }
  _setupCompositeOperation(e) {
    this.globalCompositeOperation && (e.globalCompositeOperation = this.globalCompositeOperation);
  }
  dispose() {
    Wc.cancelByTarget(this), this.off(), this._set("canvas", void 0), this._cacheCanvas && Sr().dispose(this._cacheCanvas), this._cacheCanvas = void 0, this._cacheContext = null;
  }
  animate(e, n) {
    return Object.entries(e).reduce((r, o) => {
      let [s, a] = o;
      return r[s] = this._animate(s, a, n), r;
    }, {});
  }
  _animate(e, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const o = e.split("."), s = this.constructor.colorProperties.includes(o[o.length - 1]), { abort: a, startValue: l, onChange: u, onComplete: c } = r, d = K(K({}, r), {}, { target: this, startValue: l ?? o.reduce((h, p) => h[p], this), endValue: n, abort: a == null ? void 0 : a.bind(this), onChange: (h, p, m) => {
      o.reduce((v, y, w) => (w === o.length - 1 && (v[y] = h), v[y]), this), u && u(h, p, m);
    }, onComplete: (h, p, m) => {
      this.setCoords(), c && c(h, p, m);
    } });
    return s ? v4(d) : Kb(d);
  }
  isDescendantOf(e) {
    const { parent: n, group: r } = this;
    return n === e || r === e || !!n && n.isDescendantOf(e) || !!r && r !== n && r.isDescendantOf(e);
  }
  getAncestors() {
    const e = [];
    let n = this;
    do
      n = n.parent, n && e.push(n);
    while (n);
    return e;
  }
  findCommonAncestors(e) {
    if (this === e) return { fork: [], otherFork: [], common: [this, ...this.getAncestors()] };
    const n = this.getAncestors(), r = e.getAncestors();
    if (n.length === 0 && r.length > 0 && this === r[r.length - 1]) return { fork: [], otherFork: [e, ...r.slice(0, r.length - 1)], common: [this] };
    for (let o, s = 0; s < n.length; s++) {
      if (o = n[s], o === e) return { fork: [this, ...n.slice(0, s)], otherFork: [], common: n.slice(s) };
      for (let a = 0; a < r.length; a++) {
        if (this === r[a]) return { fork: [], otherFork: [e, ...r.slice(0, a)], common: [this, ...n] };
        if (o === r[a]) return { fork: [this, ...n.slice(0, s)], otherFork: [e, ...r.slice(0, a)], common: n.slice(s) };
      }
    }
    return { fork: [this, ...n], otherFork: [e, ...r], common: [] };
  }
  hasCommonAncestors(e) {
    const n = this.findCommonAncestors(e);
    return n && !!n.common.length;
  }
  isInFrontOf(e) {
    if (this === e) return;
    const n = this.findCommonAncestors(e);
    if (n.fork.includes(e)) return !0;
    if (n.otherFork.includes(this)) return !1;
    const r = n.common[0] || this.canvas;
    if (!r) return;
    const o = n.fork.pop(), s = n.otherFork.pop(), a = r._objects.indexOf(o), l = r._objects.indexOf(s);
    return a > -1 && a > l;
  }
  toObject() {
    const e = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).concat(yc.customProperties, this.constructor.customProperties || []);
    let n;
    const r = kt.NUM_FRACTION_DIGITS, { clipPath: o, fill: s, stroke: a, shadow: l, strokeDashArray: u, left: c, top: d, originX: h, originY: p, width: m, height: v, strokeWidth: y, strokeLineCap: w, strokeDashOffset: g, strokeLineJoin: k, strokeUniform: _, strokeMiterLimit: S, scaleX: b, scaleY: C, angle: x, flipX: I, flipY: F, opacity: B, visible: X, backgroundColor: j, fillRule: ee, paintFirst: ie, globalCompositeOperation: M, skewX: W, skewY: R } = this;
    o && !o.excludeFromExport && (n = o.toObject(e.concat("inverted", "absolutePositioned")));
    const V = ($e) => Nt($e, r), ae = K(K({}, Ta(this, e)), {}, { type: this.constructor.type, version: Xh, originX: h, originY: p, left: V(c), top: V(d), width: V(m), height: V(v), fill: Fg(s) ? s.toObject() : s, stroke: Fg(a) ? a.toObject() : a, strokeWidth: V(y), strokeDashArray: u && u.concat(), strokeLineCap: w, strokeDashOffset: g, strokeLineJoin: k, strokeUniform: _, strokeMiterLimit: V(S), scaleX: V(b), scaleY: V(C), angle: V(x), flipX: I, flipY: F, opacity: V(B), shadow: l && l.toObject(), visible: X, backgroundColor: j, fillRule: ee, paintFirst: ie, globalCompositeOperation: M, skewX: V(W), skewY: V(R) }, n ? { clipPath: n } : null);
    return this.includeDefaultValues ? ae : this._removeDefaultValues(ae);
  }
  toDatalessObject(e) {
    return this.toObject(e);
  }
  _removeDefaultValues(e) {
    const n = this.constructor.getDefaults(), r = Object.keys(n).length > 0 ? n : Object.getPrototypeOf(this);
    return dp(e, (o, s) => {
      if (s === Tt || s === Qn || s === "type") return !0;
      const a = r[s];
      return o !== a && !(Array.isArray(o) && Array.isArray(a) && o.length === 0 && a.length === 0);
    });
  }
  toString() {
    return "#<".concat(this.constructor.type, ">");
  }
  static _fromObject(e) {
    let n = zt(e, b4), r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { extraParam: o } = r, s = zt(r, w4);
    return vd(n, s).then((a) => o ? (delete a[o], new this(n[o], a)) : new this(a));
  }
  static fromObject(e, n) {
    return this._fromObject(e, n);
  }
};
Y(jr, "stateProperties", s4), Y(jr, "cacheProperties", lo), Y(jr, "ownDefaults", a4), Y(jr, "type", "FabricObject"), Y(jr, "colorProperties", [yn, ti, "backgroundColor"]), Y(jr, "customProperties", []), Ne.setClass(jr), Ne.setClass(jr, "object");
const Da = (i, e, n) => (r, o, s, a) => {
  const l = e(r, o, s, a);
  return l && Fb(i, K(K({}, Rb(r, o, s, a)), n)), l;
};
function $a(i) {
  return (e, n, r, o) => {
    const { target: s, originX: a, originY: l } = n, u = s.getRelativeCenterPoint(), c = s.translateToOriginPoint(u, a, l), d = i(e, n, r, o);
    return s.setPositionByOrigin(c, n.originX, n.originY), d;
  };
}
const Qg = Da($l, $a((i, e, n, r) => {
  const o = fp(e, e.originX, e.originY, n, r);
  if (fn(e.originX) === fn(ut) || fn(e.originX) === fn(an) && o.x < 0 || fn(e.originX) === fn(Tt) && o.x > 0) {
    const { target: s } = e, a = s.strokeWidth / (s.strokeUniform ? s.scaleX : 1), l = jb(e) ? 2 : 1, u = s.width, c = Math.abs(o.x * l / s.scaleX) - a;
    return s.set("width", Math.max(c, 1)), u !== s.width;
  }
  return !1;
}));
function _4(i, e, n, r, o) {
  r = r || {};
  const s = this.sizeX || r.cornerSize || o.cornerSize, a = this.sizeY || r.cornerSize || o.cornerSize, l = r.transparentCorners !== void 0 ? r.transparentCorners : o.transparentCorners, u = l ? ti : yn, c = !l && (r.cornerStrokeColor || o.cornerStrokeColor);
  let d, h = e, p = n;
  i.save(), i.fillStyle = r.cornerColor || o.cornerColor || "", i.strokeStyle = r.cornerStrokeColor || o.cornerStrokeColor || "", s > a ? (d = s, i.scale(1, a / s), p = n * s / a) : a > s ? (d = a, i.scale(s / a, 1), h = e * a / s) : d = s, i.beginPath(), i.arc(h, p, d / 2, 0, Bc, !1), i[u](), c && i.stroke(), i.restore();
}
function x4(i, e, n, r, o) {
  r = r || {};
  const s = this.sizeX || r.cornerSize || o.cornerSize, a = this.sizeY || r.cornerSize || o.cornerSize, l = r.transparentCorners !== void 0 ? r.transparentCorners : o.transparentCorners, u = l ? ti : yn, c = !l && (r.cornerStrokeColor || o.cornerStrokeColor), d = s / 2, h = a / 2;
  i.save(), i.fillStyle = r.cornerColor || o.cornerColor || "", i.strokeStyle = r.cornerStrokeColor || o.cornerStrokeColor || "", i.translate(e, n);
  const p = o.getTotalAngle();
  i.rotate(un(p)), i["".concat(u, "Rect")](-d, -h, s, a), c && i.strokeRect(-d, -h, s, a), i.restore();
}
class $i {
  constructor(e) {
    Y(this, "visible", !0), Y(this, "actionName", md), Y(this, "angle", 0), Y(this, "x", 0), Y(this, "y", 0), Y(this, "offsetX", 0), Y(this, "offsetY", 0), Y(this, "sizeX", 0), Y(this, "sizeY", 0), Y(this, "touchSizeX", 0), Y(this, "touchSizeY", 0), Y(this, "cursorStyle", "crosshair"), Y(this, "withConnection", !1), Object.assign(this, e);
  }
  shouldActivate(e, n, r, o) {
    var s;
    let { tl: a, tr: l, br: u, bl: c } = o;
    return ((s = n.canvas) === null || s === void 0 ? void 0 : s.getActiveObject()) === n && n.isControlVisible(e) && Kt.isPointInPolygon(r, [a, l, u, c]);
  }
  getActionHandler(e, n, r) {
    return this.actionHandler;
  }
  getMouseDownHandler(e, n, r) {
    return this.mouseDownHandler;
  }
  getMouseUpHandler(e, n, r) {
    return this.mouseUpHandler;
  }
  cursorStyleHandler(e, n, r) {
    return n.cursorStyle;
  }
  getActionName(e, n, r) {
    return n.actionName;
  }
  getVisibility(e, n) {
    var r, o;
    return (r = (o = e._controlsVisibility) === null || o === void 0 ? void 0 : o[n]) !== null && r !== void 0 ? r : this.visible;
  }
  setVisibility(e, n, r) {
    this.visible = e;
  }
  positionHandler(e, n, r, o) {
    return new ce(this.x * e.x + this.offsetX, this.y * e.y + this.offsetY).transform(n);
  }
  calcCornerCoords(e, n, r, o, s, a) {
    const l = up([cu(r, o), Ea({ angle: e }), cp((s ? this.touchSizeX : this.sizeX) || n, (s ? this.touchSizeY : this.sizeY) || n)]);
    return { tl: new ce(-0.5, -0.5).transform(l), tr: new ce(0.5, -0.5).transform(l), br: new ce(0.5, 0.5).transform(l), bl: new ce(-0.5, 0.5).transform(l) };
  }
  render(e, n, r, o, s) {
    ((o = o || {}).cornerStyle || s.cornerStyle) === "circle" ? _4.call(this, e, n, r, o, s) : x4.call(this, e, n, r, o, s);
  }
}
const S4 = (i, e, n) => n.lockRotation ? Yc : e.cursorStyle, C4 = Da(xb, $a((i, e, n, r) => {
  let { target: o, ex: s, ey: a, theta: l, originX: u, originY: c } = e;
  const d = o.translateToOriginPoint(o.getRelativeCenterPoint(), u, c);
  if (Wi(o, "lockRotation")) return !1;
  const h = Math.atan2(a - d.y, s - d.x), p = Math.atan2(r - d.y, n - d.x);
  let m = oo(p - h + l);
  if (o.snapAngle && o.snapAngle > 0) {
    const y = o.snapAngle, w = o.snapThreshold || y, g = Math.ceil(m / y) * y, k = Math.floor(m / y) * y;
    Math.abs(m - k) < w ? m = k : Math.abs(m - g) < w && (m = g);
  }
  m < 0 && (m = 360 + m), m %= 360;
  const v = o.angle !== m;
  return o.angle = m, v;
}));
function qb(i, e) {
  const n = e.canvas, r = i[n.uniScaleKey];
  return n.uniformScaling && !r || !n.uniformScaling && r;
}
function Zb(i, e, n) {
  const r = Wi(i, "lockScalingX"), o = Wi(i, "lockScalingY");
  if (r && o || !e && (r || o) && n || r && e === "x" || o && e === "y") return !0;
  const { width: s, height: a, strokeWidth: l } = i;
  return s === 0 && l === 0 && e !== "y" || a === 0 && l === 0 && e !== "x";
}
const k4 = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], Qa = (i, e, n) => {
  const r = qb(i, n);
  if (Zb(n, e.x !== 0 && e.y === 0 ? "x" : e.x === 0 && e.y !== 0 ? "y" : "", r)) return Yc;
  const o = Nb(n, e);
  return "".concat(k4[o], "-resize");
};
function gp(i, e, n, r) {
  let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const s = e.target, a = o.by, l = qb(i, s);
  let u, c, d, h, p, m;
  if (Zb(s, a, l)) return !1;
  if (e.gestureScale) c = e.scaleX * e.gestureScale, d = e.scaleY * e.gestureScale;
  else {
    if (u = fp(e, e.originX, e.originY, n, r), p = a !== "y" ? Math.sign(u.x || e.signX || 1) : 1, m = a !== "x" ? Math.sign(u.y || e.signY || 1) : 1, e.signX || (e.signX = p), e.signY || (e.signY = m), Wi(s, "lockScalingFlip") && (e.signX !== p || e.signY !== m)) return !1;
    if (h = s._getTransformedDimensions(), l && !a) {
      const w = Math.abs(u.x) + Math.abs(u.y), { original: g } = e, k = w / (Math.abs(h.x * g.scaleX / s.scaleX) + Math.abs(h.y * g.scaleY / s.scaleY));
      c = g.scaleX * k, d = g.scaleY * k;
    } else c = Math.abs(u.x * s.scaleX / h.x), d = Math.abs(u.y * s.scaleY / h.y);
    jb(e) && (c *= 2, d *= 2), e.signX !== p && a !== "y" && (e.originX = zg(e.originX), c *= -1, e.signX = p), e.signY !== m && a !== "x" && (e.originY = zg(e.originY), d *= -1, e.signY = m);
  }
  const v = s.scaleX, y = s.scaleY;
  return a ? (a === "x" && s.set(ni, c), a === "y" && s.set(Si, d)) : (!Wi(s, "lockScalingX") && s.set(ni, c), !Wi(s, "lockScalingY") && s.set(Si, d)), v !== s.scaleX || y !== s.scaleY;
}
const Iu = Da(pd, $a((i, e, n, r) => gp(i, e, n, r))), O4 = Da(pd, $a((i, e, n, r) => gp(i, e, n, r, { by: "x" }))), E4 = Da(pd, $a((i, e, n, r) => gp(i, e, n, r, { by: "y" }))), T4 = ["target", "ex", "ey", "skewingSide"], dh = { x: { counterAxis: "y", scale: ni, skew: ka, lockSkewing: "lockSkewingX", origin: "originX", flip: "flipX" }, y: { counterAxis: "x", scale: Si, skew: Oa, lockSkewing: "lockSkewingY", origin: "originY", flip: "flipY" } }, D4 = ["ns", "nesw", "ew", "nwse"], $4 = (i, e, n) => {
  if (e.x !== 0 && Wi(n, "lockSkewingY") || e.y !== 0 && Wi(n, "lockSkewingX")) return Yc;
  const r = Nb(n, e) % 4;
  return "".concat(D4[r], "-resize");
};
function Jb(i, e, n, r, o) {
  const { target: s } = n, { counterAxis: a, origin: l, lockSkewing: u, skew: c, flip: d } = dh[i];
  if (Wi(s, u)) return !1;
  const { origin: h, flip: p } = dh[a], m = fn(n[h]) * (s[p] ? -1 : 1), v = -Math.sign(m) * (s[d] ? -1 : 1), y = 0.5 * -((s[c] === 0 && fp(n, ut, ut, r, o)[i] > 0 || s[c] > 0 ? 1 : -1) * v) + 0.5;
  return Da(Sb, $a((g, k, _, S) => function(b, C, x) {
    let { target: I, ex: F, ey: B, skewingSide: X } = C, j = zt(C, T4);
    const { skew: ee } = dh[b], ie = x.subtract(new ce(F, B)).divide(new ce(I.scaleX, I.scaleY))[b], M = I[ee], W = j[ee], R = Math.tan(un(W)), V = b === "y" ? I._getTransformedDimensions({ scaleX: 1, scaleY: 1, skewX: 0 }).x : I._getTransformedDimensions({ scaleX: 1, scaleY: 1 }).y, ae = 2 * ie * X / Math.max(V, 1) + R, $e = oo(Math.atan(ae));
    I.set(ee, $e);
    const N = M !== I[ee];
    if (N && b === "y") {
      const { skewX: me, scaleX: we } = I, fe = I._getTransformedDimensions({ skewY: M }), te = I._getTransformedDimensions(), Me = me !== 0 ? fe.x / te.x : 1;
      Me !== 1 && I.set(ni, Me * we);
    }
    return N;
  }(i, k, new ce(_, S))))(e, K(K({}, n), {}, { [l]: y, skewingSide: v }), r, o);
}
const M4 = (i, e, n, r) => Jb("x", i, e, n, r), P4 = (i, e, n, r) => Jb("y", i, e, n, r);
function wd(i, e) {
  return i[e.canvas.altActionKey];
}
const Lu = (i, e, n) => {
  const r = wd(i, n);
  return e.x === 0 ? r ? ka : Si : e.y === 0 ? r ? Oa : ni : "";
}, ia = (i, e, n) => wd(i, n) ? $4(0, e, n) : Qa(i, e, n), ev = (i, e, n, r) => wd(i, e.target) ? P4(i, e, n, r) : O4(i, e, n, r), tv = (i, e, n, r) => wd(i, e.target) ? M4(i, e, n, r) : E4(i, e, n, r), Qb = () => ({ ml: new $i({ x: -0.5, y: 0, cursorStyleHandler: ia, actionHandler: ev, getActionName: Lu }), mr: new $i({ x: 0.5, y: 0, cursorStyleHandler: ia, actionHandler: ev, getActionName: Lu }), mb: new $i({ x: 0, y: 0.5, cursorStyleHandler: ia, actionHandler: tv, getActionName: Lu }), mt: new $i({ x: 0, y: -0.5, cursorStyleHandler: ia, actionHandler: tv, getActionName: Lu }), tl: new $i({ x: -0.5, y: -0.5, cursorStyleHandler: Qa, actionHandler: Iu }), tr: new $i({ x: 0.5, y: -0.5, cursorStyleHandler: Qa, actionHandler: Iu }), bl: new $i({ x: -0.5, y: 0.5, cursorStyleHandler: Qa, actionHandler: Iu }), br: new $i({ x: 0.5, y: 0.5, cursorStyleHandler: Qa, actionHandler: Iu }), mtr: new $i({ x: 0, y: -0.5, actionHandler: C4, cursorStyleHandler: S4, offsetY: -40, withConnection: !0, actionName: ap }) }), I4 = () => ({ mr: new $i({ x: 0.5, y: 0, actionHandler: Qg, cursorStyleHandler: ia, actionName: $l }), ml: new $i({ x: -0.5, y: 0, actionHandler: Qg, cursorStyleHandler: ia, actionName: $l }) }), L4 = () => K(K({}, Qb()), I4());
class Ll extends jr {
  static getDefaults() {
    return K(K({}, super.getDefaults()), Ll.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, this.constructor.createControls(), Ll.ownDefaults), this.setOptions(e);
  }
  static createControls() {
    return { controls: Qb() };
  }
  _updateCacheCanvas() {
    const e = this.canvas;
    if (this.noScaleCache && e && e._currentTransform) {
      const n = e._currentTransform, r = n.target, o = n.action;
      if (this === r && o && o.startsWith(md)) return !1;
    }
    return super._updateCacheCanvas();
  }
  getActiveControl() {
    const e = this.__corner;
    return e ? { key: e, control: this.controls[e], coord: this.oCoords[e] } : void 0;
  }
  findControl(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    if (!this.hasControls || !this.canvas) return;
    this.__corner = void 0;
    const r = Object.entries(this.oCoords);
    for (let o = r.length - 1; o >= 0; o--) {
      const [s, a] = r[o], l = this.controls[s];
      if (l.shouldActivate(s, this, e, n ? a.touchCorner : a.corner)) return this.__corner = s, { key: s, control: l, coord: this.oCoords[s] };
    }
  }
  calcOCoords() {
    const e = this.getViewportTransform(), n = this.getCenterPoint(), r = cu(n.x, n.y), o = Ea({ angle: this.getTotalAngle() - (this.group && this.flipX ? 180 : 0) }), s = $n(r, o), a = $n(e, s), l = $n(a, [1 / e[0], 0, 0, 1 / e[3], 0, 0]), u = this.group ? Gc(this.calcTransformMatrix()) : void 0;
    u && (u.scaleX = Math.abs(u.scaleX), u.scaleY = Math.abs(u.scaleY));
    const c = this._calculateCurrentDimensions(u), d = {};
    return this.forEachControl((h, p) => {
      const m = h.positionHandler(c, l, this, h);
      d[p] = Object.assign(m, this._calcCornerCoords(h, m));
    }), d;
  }
  _calcCornerCoords(e, n) {
    const r = this.getTotalAngle();
    return { corner: e.calcCornerCoords(r, this.cornerSize, n.x, n.y, !1, this), touchCorner: e.calcCornerCoords(r, this.touchCornerSize, n.x, n.y, !0, this) };
  }
  setCoords() {
    super.setCoords(), this.canvas && (this.oCoords = this.calcOCoords());
  }
  forEachControl(e) {
    for (const n in this.controls) e(this.controls[n], n, this);
  }
  drawSelectionBackground(e) {
    if (!this.selectionBackgroundColor || this.canvas && this.canvas._activeObject !== this) return;
    e.save();
    const n = this.getRelativeCenterPoint(), r = this._calculateCurrentDimensions(), o = this.getViewportTransform();
    e.translate(n.x, n.y), e.scale(1 / o[0], 1 / o[3]), e.rotate(un(this.angle)), e.fillStyle = this.selectionBackgroundColor, e.fillRect(-r.x / 2, -r.y / 2, r.x, r.y), e.restore();
  }
  strokeBorders(e, n) {
    e.strokeRect(-n.x / 2, -n.y / 2, n.x, n.y);
  }
  _drawBorders(e, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const o = K({ hasControls: this.hasControls, borderColor: this.borderColor, borderDashArray: this.borderDashArray }, r);
    e.save(), e.strokeStyle = o.borderColor, this._setLineDash(e, o.borderDashArray), this.strokeBorders(e, n), o.hasControls && this.drawControlsConnectingLines(e, n), e.restore();
  }
  _renderControls(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { hasBorders: r, hasControls: o } = this, s = K({ hasBorders: r, hasControls: o }, n), a = this.getViewportTransform(), l = s.hasBorders, u = s.hasControls, c = $n(a, this.calcTransformMatrix()), d = Gc(c);
    e.save(), e.translate(d.translateX, d.translateY), e.lineWidth = this.borderScaleFactor, this.group === this.parent && (e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (d.angle -= 180), e.rotate(un(this.group ? d.angle : this.angle)), l && this.drawBorders(e, d, n), u && this.drawControls(e, n), e.restore();
  }
  drawBorders(e, n, r) {
    let o;
    if (r && r.forActiveSelection || this.group) {
      const s = hp(this.width, this.height, gd(n)), a = this.isStrokeAccountedForInDimensions() ? lp : (this.strokeUniform ? new ce().scalarAdd(this.canvas ? this.canvas.getZoom() : 1) : new ce(n.scaleX, n.scaleY)).scalarMultiply(this.strokeWidth);
      o = s.add(a).scalarAdd(this.borderScaleFactor).scalarAdd(2 * this.padding);
    } else o = this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);
    this._drawBorders(e, o, r);
  }
  drawControlsConnectingLines(e, n) {
    let r = !1;
    e.beginPath(), this.forEachControl((o, s) => {
      o.withConnection && o.getVisibility(this, s) && (r = !0, e.moveTo(o.x * n.x, o.y * n.y), e.lineTo(o.x * n.x + o.offsetX, o.y * n.y + o.offsetY));
    }), r && e.stroke();
  }
  drawControls(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e.save();
    const r = this.getCanvasRetinaScaling(), { cornerStrokeColor: o, cornerDashArray: s, cornerColor: a } = this, l = K({ cornerStrokeColor: o, cornerDashArray: s, cornerColor: a }, n);
    e.setTransform(r, 0, 0, r, 0, 0), e.strokeStyle = e.fillStyle = l.cornerColor, this.transparentCorners || (e.strokeStyle = l.cornerStrokeColor), this._setLineDash(e, l.cornerDashArray), this.forEachControl((u, c) => {
      if (u.getVisibility(this, c)) {
        const d = this.oCoords[c];
        u.render(e, d.x, d.y, l, this);
      }
    }), e.restore();
  }
  isControlVisible(e) {
    return this.controls[e] && this.controls[e].getVisibility(this, e);
  }
  setControlVisible(e, n) {
    this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[e] = n;
  }
  setControlsVisibility() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.entries(e).forEach((n) => {
      let [r, o] = n;
      return this.setControlVisible(r, o);
    });
  }
  clearContextTop(e) {
    if (!this.canvas) return;
    const n = this.canvas.contextTop;
    if (!n) return;
    const r = this.canvas.viewportTransform;
    n.save(), n.transform(r[0], r[1], r[2], r[3], r[4], r[5]), this.transform(n);
    const o = this.width + 4, s = this.height + 4;
    return n.clearRect(-o / 2, -s / 2, o, s), e || n.restore(), n;
  }
  onDeselect(e) {
    return !1;
  }
  onSelect(e) {
    return !1;
  }
  shouldStartDragging(e) {
    return !1;
  }
  onDragStart(e) {
    return !1;
  }
  canDrop(e) {
    return !1;
  }
  renderDragSourceEffect(e) {
  }
  renderDropTargetEffect(e) {
  }
}
function e1(i, e) {
  return e.forEach((n) => {
    Object.getOwnPropertyNames(n.prototype).forEach((r) => {
      r !== "constructor" && Object.defineProperty(i.prototype, r, Object.getOwnPropertyDescriptor(n.prototype, r) || /* @__PURE__ */ Object.create(null));
    });
  }), i;
}
Y(Ll, "ownDefaults", { noScaleCache: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, cornerColor: "rgb(178,204,255)", cornerStrokeColor: "", cornerStyle: "rect", cornerDashArray: null, hasControls: !0, borderColor: "rgb(178,204,255)", borderDashArray: null, borderOpacityWhenMoving: 0.4, borderScaleFactor: 1, hasBorders: !0, selectionBackgroundColor: "", selectable: !0, evented: !0, perPixelTargetFind: !1, activeOn: "down", hoverCursor: null, moveCursor: null });
class An extends Ll {
}
e1(An, [zb]), Ne.setClass(An), Ne.setClass(An, "object");
const A4 = (i, e, n, r) => {
  const o = 2 * (r = Math.round(r)) + 1, { data: s } = i.getImageData(e - r, n - r, o, o);
  for (let a = 3; a < s.length; a += 4)
    if (s[a] > 0) return !1;
  return !0;
};
class t1 {
  constructor(e) {
    this.options = e, this.strokeProjectionMagnitude = this.options.strokeWidth / 2, this.scale = new ce(this.options.scaleX, this.options.scaleY), this.strokeUniformScalar = this.options.strokeUniform ? new ce(1 / this.options.scaleX, 1 / this.options.scaleY) : new ce(1, 1);
  }
  createSideVector(e, n) {
    const r = Zh(e, n);
    return this.options.strokeUniform ? r.multiply(this.scale) : r;
  }
  projectOrthogonally(e, n, r) {
    return this.applySkew(e.add(this.calcOrthogonalProjection(e, n, r)));
  }
  isSkewed() {
    return this.options.skewX !== 0 || this.options.skewY !== 0;
  }
  applySkew(e) {
    const n = new ce(e);
    return n.y += n.x * Math.tan(un(this.options.skewY)), n.x += n.y * Math.tan(un(this.options.skewX)), n;
  }
  scaleUnitVector(e, n) {
    return e.multiply(this.strokeUniformScalar).scalarMultiply(n);
  }
}
const V4 = new ce();
class fa extends t1 {
  static getOrthogonalRotationFactor(e, n) {
    const r = n ? Qh(e, n) : r4(e);
    return Math.abs(r) < uu ? -1 : 1;
  }
  constructor(e, n, r, o) {
    super(o), Y(this, "AB", void 0), Y(this, "AC", void 0), Y(this, "alpha", void 0), Y(this, "bisector", void 0), this.A = new ce(e), this.B = new ce(n), this.C = new ce(r), this.AB = this.createSideVector(this.A, this.B), this.AC = this.createSideVector(this.A, this.C), this.alpha = Qh(this.AB, this.AC), this.bisector = pp(Xb(this.AB.eq(V4) ? this.AC : this.AB, this.alpha / 2));
  }
  calcOrthogonalProjection(e, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const o = this.createSideVector(e, n), s = Yb(o), a = fa.getOrthogonalRotationFactor(s, this.bisector);
    return this.scaleUnitVector(s, r * a);
  }
  projectBevel() {
    const e = [];
    return (this.alpha % Bc == 0 ? [this.B] : [this.B, this.C]).forEach((n) => {
      e.push(this.projectOrthogonally(this.A, n)), e.push(this.projectOrthogonally(this.A, n, -this.strokeProjectionMagnitude));
    }), e;
  }
  projectMiter() {
    const e = [], n = Math.abs(this.alpha), r = 1 / Math.sin(n / 2), o = this.scaleUnitVector(this.bisector, -this.strokeProjectionMagnitude * r), s = this.options.strokeUniform ? Jh(this.scaleUnitVector(this.bisector, this.options.strokeMiterLimit)) : this.options.strokeMiterLimit;
    return Jh(o) / this.strokeProjectionMagnitude <= s && e.push(this.applySkew(this.A.add(o))), e.push(...this.projectBevel()), e;
  }
  projectRoundNoSkew(e, n) {
    const r = [], o = new ce(fa.getOrthogonalRotationFactor(this.bisector), fa.getOrthogonalRotationFactor(new ce(this.bisector.y, this.bisector.x)));
    return [new ce(1, 0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(o), new ce(0, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(o)].forEach((s) => {
      qg(s, e, n) && r.push(this.A.add(s));
    }), r;
  }
  projectRoundWithSkew(e, n) {
    const r = [], { skewX: o, skewY: s, scaleX: a, scaleY: l, strokeUniform: u } = this.options, c = new ce(Math.tan(un(o)), Math.tan(un(s))), d = this.strokeProjectionMagnitude, h = u ? d / l / Math.sqrt(1 / l ** 2 + 1 / a ** 2 * c.y ** 2) : d / Math.sqrt(1 + c.y ** 2), p = new ce(Math.sqrt(Math.max(d ** 2 - h ** 2, 0)), h), m = u ? d / Math.sqrt(1 + c.x ** 2 * (1 / l) ** 2 / (1 / a + 1 / a * c.x * c.y) ** 2) : d / Math.sqrt(1 + c.x ** 2 / (1 + c.x * c.y) ** 2), v = new ce(m, Math.sqrt(Math.max(d ** 2 - m ** 2, 0)));
    return [v, v.scalarMultiply(-1), p, p.scalarMultiply(-1)].map((y) => this.applySkew(u ? y.multiply(this.strokeUniformScalar) : y)).forEach((y) => {
      qg(y, e, n) && r.push(this.applySkew(this.A).add(y));
    }), r;
  }
  projectRound() {
    const e = [];
    e.push(...this.projectBevel());
    const n = this.alpha % Bc == 0, r = this.applySkew(this.A), o = e[n ? 0 : 2].subtract(r), s = e[n ? 1 : 0].subtract(r), a = n ? this.applySkew(this.AB.scalarMultiply(-1)) : this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)), l = ml(o, a) > 0, u = l ? o : s, c = l ? s : o;
    return this.isSkewed() ? e.push(...this.projectRoundWithSkew(u, c)) : e.push(...this.projectRoundNoSkew(u, c)), e;
  }
  projectPoints() {
    switch (this.options.strokeLineJoin) {
      case "miter":
        return this.projectMiter();
      case "round":
        return this.projectRound();
      default:
        return this.projectBevel();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e, angle: this.alpha, bisector: this.bisector }));
  }
}
class nv extends t1 {
  constructor(e, n, r) {
    super(r), this.A = new ce(e), this.T = new ce(n);
  }
  calcOrthogonalProjection(e, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const o = this.createSideVector(e, n);
    return this.scaleUnitVector(Yb(o), r);
  }
  projectButt() {
    return [this.projectOrthogonally(this.A, this.T, this.strokeProjectionMagnitude), this.projectOrthogonally(this.A, this.T, -this.strokeProjectionMagnitude)];
  }
  projectRound() {
    const e = [];
    if (!this.isSkewed() && this.A.eq(this.T)) {
      const n = new ce(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.applySkew(this.A.add(n)), this.applySkew(this.A.subtract(n)));
    } else e.push(...new fa(this.A, this.T, this.T, this.options).projectRound());
    return e;
  }
  projectSquare() {
    const e = [];
    if (this.A.eq(this.T)) {
      const n = new ce(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.A.add(n), this.A.subtract(n));
    } else {
      const n = this.calcOrthogonalProjection(this.A, this.T, this.strokeProjectionMagnitude), r = this.scaleUnitVector(pp(this.createSideVector(this.A, this.T)), -this.strokeProjectionMagnitude), o = this.A.add(r);
      e.push(o.add(n), o.subtract(n));
    }
    return e.map((n) => this.applySkew(n));
  }
  projectPoints() {
    switch (this.options.strokeLineCap) {
      case "round":
        return this.projectRound();
      case "square":
        return this.projectSquare();
      default:
        return this.projectButt();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e }));
  }
}
const F4 = function(i, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  const r = [];
  if (i.length === 0) return r;
  const o = i.reduce((s, a) => (s[s.length - 1].eq(a) || s.push(new ce(a)), s), [new ce(i[0])]);
  if (o.length === 1) n = !0;
  else if (!n) {
    const s = o[0], a = ((l, u) => {
      for (let c = l.length - 1; c >= 0; c--) if (u(l[c], c, l)) return c;
      return -1;
    })(o, (l) => !l.eq(s));
    o.splice(a + 1);
  }
  return o.forEach((s, a, l) => {
    let u, c;
    a === 0 ? (c = l[1], u = n ? s : l[l.length - 1]) : a === l.length - 1 ? (u = l[a - 1], c = n ? s : l[0]) : (u = l[a - 1], c = l[a + 1]), n && l.length === 1 ? r.push(...new nv(s, s, e).project()) : !n || a !== 0 && a !== l.length - 1 ? r.push(...new fa(s, u, c, e).project()) : r.push(...new nv(s, a === 0 ? c : u, e).project());
  }), r;
}, vp = (i) => {
  const e = {};
  return Object.keys(i).forEach((n) => {
    e[n] = {}, Object.keys(i[n]).forEach((r) => {
      e[n][r] = K({}, i[n][r]);
    });
  }), e;
}, j4 = (i) => i.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
let ja;
const yp = (i) => {
  if (ja || ja || (ja = "Intl" in fd() && "Segmenter" in Intl && new Intl.Segmenter(void 0, { granularity: "grapheme" })), ja) {
    const e = ja.segment(i);
    return Array.from(e).map((n) => {
      let { segment: r } = n;
      return r;
    });
  }
  return R4(i);
}, R4 = (i) => {
  const e = [];
  for (let n, r = 0; r < i.length; r++) (n = N4(i, r)) !== !1 && e.push(n);
  return e;
}, N4 = (i, e) => {
  const n = i.charCodeAt(e);
  if (isNaN(n)) return "";
  if (n < 55296 || n > 57343) return i.charAt(e);
  if (55296 <= n && n <= 56319) {
    if (i.length <= e + 1) throw "High surrogate without following low surrogate";
    const o = i.charCodeAt(e + 1);
    if (56320 > o || o > 57343) throw "High surrogate without following low surrogate";
    return i.charAt(e) + i.charAt(e + 1);
  }
  if (e === 0) throw "Low surrogate without preceding high surrogate";
  const r = i.charCodeAt(e - 1);
  if (55296 > r || r > 56319) throw "Low surrogate without preceding high surrogate";
  return !1;
}, bp = function(i, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  return i.fill !== e.fill || i.stroke !== e.stroke || i.strokeWidth !== e.strokeWidth || i.fontSize !== e.fontSize || i.fontFamily !== e.fontFamily || i.fontWeight !== e.fontWeight || i.fontStyle !== e.fontStyle || i.textDecorationThickness !== e.textDecorationThickness || i.textBackgroundColor !== e.textBackgroundColor || i.deltaY !== e.deltaY || n && (i.overline !== e.overline || i.underline !== e.underline || i.linethrough !== e.linethrough);
}, z4 = (i, e) => {
  const n = e.split(`
`), r = [];
  let o = -1, s = {};
  i = vp(i);
  for (let a = 0; a < n.length; a++) {
    const l = yp(n[a]);
    if (i[a]) for (let u = 0; u < l.length; u++) {
      o++;
      const c = i[a][u];
      c && Object.keys(c).length > 0 && (bp(s, c, !0) ? r.push({ start: o, end: o + 1, style: c }) : r[r.length - 1].end++), s = c || {};
    }
    else o += l.length, s = {};
  }
  return r;
}, B4 = (i, e) => {
  if (!Array.isArray(i)) return vp(i);
  const n = e.split(sp), r = {};
  let o = -1, s = 0;
  for (let a = 0; a < n.length; a++) {
    const l = yp(n[a]);
    for (let u = 0; u < l.length; u++) o++, i[s] && i[s].start <= o && o < i[s].end && (r[a] = r[a] || {}, r[a][u] = K({}, i[s].style), o === i[s].end - 1 && s++);
  }
  return r;
}, Bo = ["display", "transform", yn, "fill-opacity", "fill-rule", "opacity", ti, "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"];
function iv(i, e) {
  const n = i.nodeName, r = i.getAttribute("class"), o = i.getAttribute("id"), s = "(?![a-zA-Z\\-]+)";
  let a;
  if (a = new RegExp("^" + n, "i"), e = e.replace(a, ""), o && e.length && (a = new RegExp("#" + o + s, "i"), e = e.replace(a, "")), r && e.length) {
    const l = r.split(" ");
    for (let u = l.length; u--; ) a = new RegExp("\\." + l[u] + s, "i"), e = e.replace(a, "");
  }
  return e.length === 0;
}
function H4(i, e) {
  let n = !0;
  const r = iv(i, e.pop());
  return r && e.length && (n = function(o, s) {
    let a, l = !0;
    for (; o.parentElement && o.parentElement.nodeType === 1 && s.length; ) l && (a = s.pop()), l = iv(o = o.parentElement, a);
    return s.length === 0;
  }(i, e)), r && n && e.length === 0;
}
const U4 = (i) => {
  var e;
  return (e = n4[i]) !== null && e !== void 0 ? e : i;
}, W4 = new RegExp("(".concat(zi, ")"), "gi"), G4 = (i) => Kc(i.replace(W4, " $1 ").replace(/,/gi, " "));
var rv, ov, sv, av, lv, uv, cv;
const Bn = "(".concat(zi, ")"), X4 = String.raw(rv || (rv = Cr(["(skewX)(", ")"], ["(skewX)\\(", "\\)"])), Bn), Y4 = String.raw(ov || (ov = Cr(["(skewY)(", ")"], ["(skewY)\\(", "\\)"])), Bn), K4 = String.raw(sv || (sv = Cr(["(rotate)(", "(?: ", " ", ")?)"], ["(rotate)\\(", "(?: ", " ", ")?\\)"])), Bn, Bn, Bn), q4 = String.raw(av || (av = Cr(["(scale)(", "(?: ", ")?)"], ["(scale)\\(", "(?: ", ")?\\)"])), Bn, Bn), Z4 = String.raw(lv || (lv = Cr(["(translate)(", "(?: ", ")?)"], ["(translate)\\(", "(?: ", ")?\\)"])), Bn, Bn), J4 = String.raw(uv || (uv = Cr(["(matrix)(", " ", " ", " ", " ", " ", ")"], ["(matrix)\\(", " ", " ", " ", " ", " ", "\\)"])), Bn, Bn, Bn, Bn, Bn, Bn), wp = "(?:".concat(J4, "|").concat(Z4, "|").concat(K4, "|").concat(q4, "|").concat(X4, "|").concat(Y4, ")"), Q4 = "(?:".concat(wp, "*)"), eL = String.raw(cv || (cv = Cr(["^s*(?:", "?)s*$"], ["^\\s*(?:", "?)\\s*$"])), Q4), tL = new RegExp(eL), nL = new RegExp(wp), iL = new RegExp(wp, "g");
function ef(i) {
  const e = [];
  if (!(i = G4(i).replace(/\s*([()])\s*/gi, "$1")) || i && !tL.test(i)) return [...Un];
  for (const n of i.matchAll(iL)) {
    const r = nL.exec(n[0]);
    if (!r) continue;
    let o = Un;
    const s = r.filter((v) => !!v), [, a, ...l] = s, [u, c, d, h, p, m] = l.map((v) => parseFloat(v));
    switch (a) {
      case "translate":
        o = cu(u, c);
        break;
      case ap:
        o = Ea({ angle: u }, { x: c, y: d });
        break;
      case md:
        o = cp(u, c);
        break;
      case ka:
        o = $b(u);
        break;
      case Oa:
        o = Mb(u);
        break;
      case "matrix":
        o = [u, c, d, h, p, m];
    }
    e.push(o);
  }
  return up(e);
}
function rL(i, e, n, r) {
  const o = Array.isArray(e);
  let s, a = e;
  if (i !== yn && i !== ti || e !== ei) {
    if (i === "strokeUniform") return e === "non-scaling-stroke";
    if (i === "strokeDashArray") a = e === ei ? null : e.replace(/,/g, " ").split(/\s+/).map(parseFloat);
    else if (i === "transformMatrix") a = n && n.transformMatrix ? $n(n.transformMatrix, ef(e)) : ef(e);
    else if (i === "visible") a = e !== ei && e !== "hidden", n && n.visible === !1 && (a = !1);
    else if (i === "opacity") a = parseFloat(e), n && n.opacity !== void 0 && (a *= n.opacity);
    else if (i === "textAnchor") a = e === "start" ? Tt : e === "end" ? an : ut;
    else if (i === "charSpacing" || i === Ps) s = ha(e, r) / r * 1e3;
    else if (i === "paintFirst") {
      const l = e.indexOf(yn), u = e.indexOf(ti);
      a = yn, (l > -1 && u > -1 && u < l || l === -1 && u > -1) && (a = ti);
    } else {
      if (i === "href" || i === "xlink:href" || i === "font" || i === "id") return e;
      if (i === "imageSmoothing") return e === "optimizeQuality";
      s = o ? e.map(ha) : ha(e, r);
    }
  } else a = "";
  return !o && isNaN(s) ? a : s;
}
function oL(i, e) {
  const n = i.match(t4);
  if (!n) return;
  const r = n[1], o = n[3], s = n[4], a = n[5], l = n[6];
  r && (e.fontStyle = r), o && (e.fontWeight = isNaN(parseFloat(o)) ? o : parseFloat(o)), s && (e.fontSize = ha(s)), l && (e.fontFamily = l), a && (e.lineHeight = a === "normal" ? 1 : a);
}
function sL(i, e) {
  i.replace(/;\s*$/, "").split(";").forEach((n) => {
    if (!n) return;
    const [r, o] = n.split(":");
    e[r.trim().toLowerCase()] = o.trim();
  });
}
function aL(i) {
  const e = {}, n = i.getAttribute("style");
  return n && (typeof n == "string" ? sL(n, e) : function(r, o) {
    Object.entries(r).forEach((s) => {
      let [a, l] = s;
      l !== void 0 && (o[a.toLowerCase()] = l);
    });
  }(n, e)), e;
}
const lL = { stroke: "strokeOpacity", fill: "fillOpacity" };
function uo(i, e, n) {
  if (!i) return {};
  let r, o = {}, s = op;
  i.parentNode && Kg.test(i.parentNode.nodeName) && (o = uo(i.parentElement, e, n), o.fontSize && (r = s = ha(o.fontSize)));
  const a = K(K(K({}, e.reduce((c, d) => {
    const h = i.getAttribute(d);
    return h && (c[d] = h), c;
  }, {})), function(c) {
    let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, h = {};
    for (const p in d) H4(c, p.split(" ")) && (h = K(K({}, h), d[p]));
    return h;
  }(i, n)), aL(i));
  a[uh] && i.setAttribute(uh, a[uh]), a[lh] && (r = ha(a[lh], s), a[lh] = "".concat(r));
  const l = {};
  for (const c in a) {
    const d = U4(c), h = rL(d, a[c], o, r);
    l[d] = h;
  }
  l && l.font && oL(l.font, l);
  const u = K(K({}, o), l);
  return Kg.test(i.nodeName) ? u : function(c) {
    const d = An.getDefaults();
    return Object.entries(lL).forEach((h) => {
      let [p, m] = h;
      if (c[m] === void 0 || c[p] === "") return;
      if (c[p] === void 0) {
        if (!d[p]) return;
        c[p] = d[p];
      }
      if (c[p].indexOf("url(") === 0) return;
      const v = new $t(c[p]);
      c[p] = v.setAlpha(Nt(v.getAlpha() * c[m], 2)).toRgba();
    }), c;
  }(u);
}
const uL = ["left", "top", "width", "height", "visible"], n1 = ["rx", "ry"];
class hr extends An {
  static getDefaults() {
    return K(K({}, super.getDefaults()), hr.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, hr.ownDefaults), this.setOptions(e), this._initRxRy();
  }
  _initRxRy() {
    const { rx: e, ry: n } = this;
    e && !n ? this.ry = e : n && !e && (this.rx = n);
  }
  _render(e) {
    const { width: n, height: r } = this, o = -n / 2, s = -r / 2, a = this.rx ? Math.min(this.rx, n / 2) : 0, l = this.ry ? Math.min(this.ry, r / 2) : 0, u = a !== 0 || l !== 0;
    e.beginPath(), e.moveTo(o + a, s), e.lineTo(o + n - a, s), u && e.bezierCurveTo(o + n - wo * a, s, o + n, s + wo * l, o + n, s + l), e.lineTo(o + n, s + r - l), u && e.bezierCurveTo(o + n, s + r - wo * l, o + n - wo * a, s + r, o + n - a, s + r), e.lineTo(o + a, s + r), u && e.bezierCurveTo(o + wo * a, s + r, o, s + r - wo * l, o, s + r - l), e.lineTo(o, s + l), u && e.bezierCurveTo(o, s + wo * l, o + wo * a, s, o + a, s), e.closePath(), this._renderPaintInOrder(e);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...n1, ...e]);
  }
  _toSVG() {
    const { width: e, height: n, rx: r, ry: o } = this;
    return ["<rect ", "COMMON_PARTS", 'x="'.concat(-e / 2, '" y="').concat(-n / 2, '" rx="').concat(r, '" ry="').concat(o, '" width="').concat(e, '" height="').concat(n, `" />
`)];
  }
  static async fromElement(e, n, r) {
    const o = uo(e, this.ATTRIBUTE_NAMES, r), { left: s = 0, top: a = 0, width: l = 0, height: u = 0, visible: c = !0 } = o, d = zt(o, uL);
    return new this(K(K(K({}, n), d), {}, { left: s, top: a, width: l, height: u, visible: !!(c && l && u) }));
  }
}
Y(hr, "type", "Rect"), Y(hr, "cacheProperties", [...lo, ...n1]), Y(hr, "ownDefaults", { rx: 0, ry: 0 }), Y(hr, "ATTRIBUTE_NAMES", [...Bo, "x", "y", "rx", "ry", "width", "height"]), Ne.setClass(hr), Ne.setSVGClass(hr);
const Yr = "initialization", Zc = "added", _p = "removed", Jc = "imperative", i1 = (i, e) => {
  const { strokeUniform: n, strokeWidth: r, width: o, height: s, group: a } = e, l = a && a !== i ? yd(a.calcTransformMatrix(), i.calcTransformMatrix()) : null, u = l ? e.getRelativeCenterPoint().transform(l) : e.getRelativeCenterPoint(), c = !e.isStrokeAccountedForInDimensions(), d = n && c ? Y3(new ce(r, r), void 0, i.calcTransformMatrix()) : lp, h = !n && c ? r : 0, p = hp(o + h, s + h, up([l, e.calcOwnMatrix()], !0)).add(d).scalarDivide(2);
  return [u.subtract(p), u.add(p)];
};
class _d {
  calcLayoutResult(e, n) {
    if (this.shouldPerformLayout(e)) return this.calcBoundingBox(n, e);
  }
  shouldPerformLayout(e) {
    let { type: n, prevStrategy: r, strategy: o } = e;
    return n === Yr || n === Jc || !!r && o !== r;
  }
  shouldLayoutClipPath(e) {
    let { type: n, target: { clipPath: r } } = e;
    return n !== Yr && r && !r.absolutePositioned;
  }
  getInitialSize(e, n) {
    return n.size;
  }
  calcBoundingBox(e, n) {
    const { type: r, target: o } = n;
    if (r === Jc && n.overrides) return n.overrides;
    if (e.length === 0) return;
    const { left: s, top: a, width: l, height: u } = Qr(e.map((h) => i1(o, h)).reduce((h, p) => h.concat(p), [])), c = new ce(l, u), d = new ce(s, a).add(c.scalarDivide(2));
    if (r === Yr) {
      const h = this.getInitialSize(n, { size: c, center: d });
      return { center: d, relativeCorrection: new ce(0, 0), size: h };
    }
    return { center: d.transform(o.calcOwnMatrix()), size: c };
  }
}
Y(_d, "type", "strategy");
class tf extends _d {
  shouldPerformLayout(e) {
    return !0;
  }
}
Y(tf, "type", "fit-content"), Ne.setClass(tf);
const cL = ["strategy"], dL = ["target", "strategy", "bubbles", "prevStrategy"], r1 = "layoutManager";
class Al {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new tf();
    Y(this, "strategy", void 0), this.strategy = e, this._subscriptions = /* @__PURE__ */ new Map();
  }
  performLayout(e) {
    const n = K(K({ bubbles: !0, strategy: this.strategy }, e), {}, { prevStrategy: this._prevLayoutStrategy, stopPropagation() {
      this.bubbles = !1;
    } });
    this.onBeforeLayout(n);
    const r = this.getLayoutResult(n);
    r && this.commitLayout(n, r), this.onAfterLayout(n, r), this._prevLayoutStrategy = n.strategy;
  }
  attachHandlers(e, n) {
    const { target: r } = n;
    return [Uc, _b, $l, xb, pd, Sb, Hc, I3, L3].map((o) => e.on(o, (s) => this.performLayout(o === Uc ? { type: "object_modified", trigger: o, e: s, target: r } : { type: "object_modifying", trigger: o, e: s, target: r })));
  }
  subscribe(e, n) {
    this.unsubscribe(e, n);
    const r = this.attachHandlers(e, n);
    this._subscriptions.set(e, r);
  }
  unsubscribe(e, n) {
    (this._subscriptions.get(e) || []).forEach((r) => r()), this._subscriptions.delete(e);
  }
  unsubscribeTargets(e) {
    e.targets.forEach((n) => this.unsubscribe(n, e));
  }
  subscribeTargets(e) {
    e.targets.forEach((n) => this.subscribe(n, e));
  }
  onBeforeLayout(e) {
    const { target: n, type: r } = e, { canvas: o } = n;
    if (r === Yr || r === Zc ? this.subscribeTargets(e) : r === _p && this.unsubscribeTargets(e), n.fire("layout:before", { context: e }), o && o.fire("object:layout:before", { target: n, context: e }), r === Jc && e.deep) {
      const s = zt(e, cL);
      n.forEachObject((a) => a.layoutManager && a.layoutManager.performLayout(K(K({}, s), {}, { bubbles: !1, target: a })));
    }
  }
  getLayoutResult(e) {
    const { target: n, strategy: r, type: o } = e, s = r.calcLayoutResult(e, n.getObjects());
    if (!s) return;
    const a = o === Yr ? new ce() : n.getRelativeCenterPoint(), { center: l, correction: u = new ce(), relativeCorrection: c = new ce() } = s, d = a.subtract(l).add(u).transform(o === Yr ? Un : Ni(n.calcOwnMatrix()), !0).add(c);
    return { result: s, prevCenter: a, nextCenter: l, offset: d };
  }
  commitLayout(e, n) {
    const { target: r } = e, { result: { size: o }, nextCenter: s } = n;
    var a, l;
    r.set({ width: o.x, height: o.y }), this.layoutObjects(e, n), e.type === Yr ? r.set({ left: (a = e.x) !== null && a !== void 0 ? a : s.x + o.x * fn(r.originX), top: (l = e.y) !== null && l !== void 0 ? l : s.y + o.y * fn(r.originY) }) : (r.setPositionByOrigin(s, ut, ut), r.setCoords(), r.set("dirty", !0));
  }
  layoutObjects(e, n) {
    const { target: r } = e;
    r.forEachObject((o) => {
      o.group === r && this.layoutObject(e, n, o);
    }), e.strategy.shouldLayoutClipPath(e) && this.layoutObject(e, n, r.clipPath);
  }
  layoutObject(e, n, r) {
    let { offset: o } = n;
    r.set({ left: r.left + o.x, top: r.top + o.y });
  }
  onAfterLayout(e, n) {
    const { target: r, strategy: o, bubbles: s, prevStrategy: a } = e, l = zt(e, dL), { canvas: u } = r;
    r.fire("layout:after", { context: e, result: n }), u && u.fire("object:layout:after", { context: e, result: n, target: r });
    const c = r.parent;
    s && c != null && c.layoutManager && ((l.path || (l.path = [])).push(r), c.layoutManager.performLayout(K(K({}, l), {}, { target: c }))), r.set("dirty", !0);
  }
  dispose() {
    const { _subscriptions: e } = this;
    e.forEach((n) => n.forEach((r) => r())), e.clear();
  }
  toObject() {
    return { type: r1, strategy: this.strategy.constructor.type };
  }
  toJSON() {
    return this.toObject();
  }
}
Ne.setClass(Al, r1);
const hL = ["type", "objects", "layoutManager"];
class fL extends Al {
  performLayout() {
  }
}
class ks extends Cb(An) {
  static getDefaults() {
    return K(K({}, super.getDefaults()), ks.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Y(this, "_activeObjects", []), Y(this, "__objectSelectionTracker", void 0), Y(this, "__objectSelectionDisposer", void 0), Object.assign(this, ks.ownDefaults), this.setOptions(n), this.groupInit(e, n);
  }
  groupInit(e, n) {
    var r;
    this._objects = [...e], this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, !0), this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, !1), this.forEachObject((o) => {
      this.enterGroup(o, !1);
    }), this.layoutManager = (r = n.layoutManager) !== null && r !== void 0 ? r : new Al(), this.layoutManager.performLayout({ type: Yr, target: this, targets: [...e], x: n.left, y: n.top });
  }
  canEnterGroup(e) {
    return e === this || this.isDescendantOf(e) ? (Ro("error", "Group: circular object trees are not supported, this call has no effect"), !1) : this._objects.indexOf(e) === -1 || (Ro("error", "Group: duplicate objects are not supported inside group, this call has no effect"), !1);
  }
  _filterObjectsBeforeEnteringGroup(e) {
    return e.filter((n, r, o) => this.canEnterGroup(n) && o.indexOf(n) === r);
  }
  add() {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
    const o = this._filterObjectsBeforeEnteringGroup(n), s = super.add(...o);
    return this._onAfterObjectsChange(Zc, o), s;
  }
  insertAt(e) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) r[o - 1] = arguments[o];
    const s = this._filterObjectsBeforeEnteringGroup(r), a = super.insertAt(e, ...s);
    return this._onAfterObjectsChange(Zc, s), a;
  }
  remove() {
    const e = super.remove(...arguments);
    return this._onAfterObjectsChange(_p, e), e;
  }
  _onObjectAdded(e) {
    this.enterGroup(e, !0), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e, n) {
    this.exitGroup(e, n), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onAfterObjectsChange(e, n) {
    this.layoutManager.performLayout({ type: e, targets: n, target: this });
  }
  _onStackOrderChanged() {
    this._set("dirty", !0);
  }
  _set(e, n) {
    const r = this[e];
    return super._set(e, n), e === "canvas" && r !== n && (this._objects || []).forEach((o) => {
      o._set(e, n);
    }), this;
  }
  _shouldSetNestedCoords() {
    return this.subTargetCheck;
  }
  removeAll() {
    return this._activeObjects = [], this.remove(...this._objects);
  }
  __objectSelectionMonitor(e, n) {
    let { target: r } = n;
    const o = this._activeObjects;
    if (e) o.push(r), this._set("dirty", !0);
    else if (o.length > 0) {
      const s = o.indexOf(r);
      s > -1 && (o.splice(s, 1), this._set("dirty", !0));
    }
  }
  _watchObject(e, n) {
    e && this._watchObject(!1, n), e ? (n.on("selected", this.__objectSelectionTracker), n.on("deselected", this.__objectSelectionDisposer)) : (n.off("selected", this.__objectSelectionTracker), n.off("deselected", this.__objectSelectionDisposer));
  }
  enterGroup(e, n) {
    e.group && e.group.remove(e), e._set("parent", this), this._enterGroup(e, n);
  }
  _enterGroup(e, n) {
    n && Xc(e, $n(Ni(this.calcTransformMatrix()), e.calcTransformMatrix())), this._shouldSetNestedCoords() && e.setCoords(), e._set("group", this), e._set("canvas", this.canvas), this._watchObject(!0, e);
    const r = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
    r && (r === e || e.isDescendantOf(r)) && this._activeObjects.push(e);
  }
  exitGroup(e, n) {
    this._exitGroup(e, n), e._set("parent", void 0), e._set("canvas", void 0);
  }
  _exitGroup(e, n) {
    e._set("group", void 0), n || (Xc(e, $n(this.calcTransformMatrix(), e.calcTransformMatrix())), e.setCoords()), this._watchObject(!1, e);
    const r = this._activeObjects.length > 0 ? this._activeObjects.indexOf(e) : -1;
    r > -1 && this._activeObjects.splice(r, 1);
  }
  shouldCache() {
    const e = An.prototype.shouldCache.call(this);
    if (e) {
      for (let n = 0; n < this._objects.length; n++) if (this._objects[n].willDrawShadow()) return this.ownCaching = !1, !1;
    }
    return e;
  }
  willDrawShadow() {
    if (super.willDrawShadow()) return !0;
    for (let e = 0; e < this._objects.length; e++) if (this._objects[e].willDrawShadow()) return !0;
    return !1;
  }
  isOnACache() {
    return this.ownCaching || !!this.parent && this.parent.isOnACache();
  }
  drawObject(e, n, r) {
    this._renderBackground(e);
    for (let s = 0; s < this._objects.length; s++) {
      var o;
      const a = this._objects[s];
      (o = this.canvas) !== null && o !== void 0 && o.preserveObjectStacking && a.group !== this ? (e.save(), e.transform(...Ni(this.calcTransformMatrix())), a.render(e), e.restore()) : a.group === this && a.render(e);
    }
    this._drawClipPath(e, this.clipPath, r);
  }
  setCoords() {
    super.setCoords(), this._shouldSetNestedCoords() && this.forEachObject((e) => e.setCoords());
  }
  triggerLayout() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.layoutManager.performLayout(K({ target: this, type: Jc }, e));
  }
  render(e) {
    this._transformDone = !0, super.render(e), this._transformDone = !1;
  }
  __serializeObjects(e, n) {
    const r = this.includeDefaultValues;
    return this._objects.filter(function(o) {
      return !o.excludeFromExport;
    }).map(function(o) {
      const s = o.includeDefaultValues;
      o.includeDefaultValues = r;
      const a = o[e || "toObject"](n);
      return o.includeDefaultValues = s, a;
    });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = this.layoutManager.toObject();
    return K(K(K({}, super.toObject(["subTargetCheck", "interactive", ...e])), n.strategy !== "fit-content" || this.includeDefaultValues ? { layoutManager: n } : {}), {}, { objects: this.__serializeObjects("toObject", e) });
  }
  toString() {
    return "#<Group: (".concat(this.complexity(), ")>");
  }
  dispose() {
    this.layoutManager.unsubscribeTargets({ targets: this.getObjects(), target: this }), this._activeObjects = [], this.forEachObject((e) => {
      this._watchObject(!1, e), e.dispose();
    }), super.dispose();
  }
  _createSVGBgRect(e) {
    if (!this.backgroundColor) return "";
    const n = hr.prototype._toSVG.call(this), r = n.indexOf("COMMON_PARTS");
    n[r] = 'for="group" ';
    const o = n.join("");
    return e ? e(o) : o;
  }
  _toSVG(e) {
    const n = ["<g ", "COMMON_PARTS", ` >
`], r = this._createSVGBgRect(e);
    r && n.push("		", r);
    for (let o = 0; o < this._objects.length; o++) n.push("		", this._objects[o].toSVG(e));
    return n.push(`</g>
`), n;
  }
  getSvgStyles() {
    const e = this.opacity !== void 0 && this.opacity !== 1 ? "opacity: ".concat(this.opacity, ";") : "", n = this.visible ? "" : " visibility: hidden;";
    return [e, this.getSvgFilter(), n].join("");
  }
  toClipPathSVG(e) {
    const n = [], r = this._createSVGBgRect(e);
    r && n.push("	", r);
    for (let o = 0; o < this._objects.length; o++) n.push("	", this._objects[o].toClipPathSVG(e));
    return this._createBaseClipPathSVGMarkup(n, { reviver: e });
  }
  static fromObject(e, n) {
    let { type: r, objects: o = [], layoutManager: s } = e, a = zt(e, hL);
    return Promise.all([Ml(o, n), vd(a, n)]).then((l) => {
      let [u, c] = l;
      const d = new this(u, K(K(K({}, a), c), {}, { layoutManager: new fL() }));
      if (s) {
        const h = Ne.getClass(s.type), p = Ne.getClass(s.strategy);
        d.layoutManager = new h(new p());
      } else d.layoutManager = new Al();
      return d.layoutManager.subscribeTargets({ type: Yr, target: d, targets: d.getObjects() }), d.setCoords(), d;
    });
  }
}
Y(ks, "type", "Group"), Y(ks, "ownDefaults", { strokeWidth: 0, subTargetCheck: !1, interactive: !1 }), Ne.setClass(ks);
const pL = (i, e) => Math.min(e.width / i.width, e.height / i.height), mL = (i, e) => Math.max(e.width / i.width, e.height / i.height), nf = "\\s*,?\\s*", Ra = "".concat(nf, "(").concat(zi, ")"), gL = "".concat(Ra).concat(Ra).concat(Ra).concat(nf, "([01])").concat(nf, "([01])").concat(Ra).concat(Ra), vL = { m: "l", M: "L" }, yL = (i, e, n, r, o, s, a, l, u, c, d) => {
  const h = no(i), p = io(i), m = no(e), v = io(e), y = n * o * m - r * s * v + a, w = r * o * m + n * s * v + l;
  return ["C", c + u * (-n * o * p - r * s * h), d + u * (-r * o * p + n * s * h), y + u * (n * o * v + r * s * m), w + u * (r * o * v - n * s * m), y, w];
}, dv = (i, e, n, r) => {
  const o = Math.atan2(e, i), s = Math.atan2(r, n);
  return s >= o ? s - o : 2 * Math.PI - (o - s);
};
function hv(i, e, n, r, o, s, a, l) {
  let u;
  if (kt.cachesBoundsOfCurve && (u = [...arguments].join(), hl.boundsOfCurveCache[u])) return hl.boundsOfCurveCache[u];
  const c = Math.sqrt, d = Math.abs, h = [], p = [[0, 0], [0, 0]];
  let m = 6 * i - 12 * n + 6 * o, v = -3 * i + 9 * n - 9 * o + 3 * a, y = 3 * n - 3 * i;
  for (let S = 0; S < 2; ++S) {
    if (S > 0 && (m = 6 * e - 12 * r + 6 * s, v = -3 * e + 9 * r - 9 * s + 3 * l, y = 3 * r - 3 * e), d(v) < 1e-12) {
      if (d(m) < 1e-12) continue;
      const F = -y / m;
      0 < F && F < 1 && h.push(F);
      continue;
    }
    const b = m * m - 4 * y * v;
    if (b < 0) continue;
    const C = c(b), x = (-m + C) / (2 * v);
    0 < x && x < 1 && h.push(x);
    const I = (-m - C) / (2 * v);
    0 < I && I < 1 && h.push(I);
  }
  let w = h.length;
  const g = w, k = o1(i, e, n, r, o, s, a, l);
  for (; w--; ) {
    const { x: S, y: b } = k(h[w]);
    p[0][w] = S, p[1][w] = b;
  }
  p[0][g] = i, p[1][g] = e, p[0][g + 1] = a, p[1][g + 1] = l;
  const _ = [new ce(Math.min(...p[0]), Math.min(...p[1])), new ce(Math.max(...p[0]), Math.max(...p[1]))];
  return kt.cachesBoundsOfCurve && (hl.boundsOfCurveCache[u] = _), _;
}
const bL = (i, e, n) => {
  let [r, o, s, a, l, u, c, d] = n;
  const h = ((p, m, v, y, w, g, k) => {
    if (v === 0 || y === 0) return [];
    let _ = 0, S = 0, b = 0;
    const C = Math.PI, x = k * rp, I = io(x), F = no(x), B = 0.5 * (-F * p - I * m), X = 0.5 * (-F * m + I * p), j = v ** 2, ee = y ** 2, ie = X ** 2, M = B ** 2, W = j * ee - j * ie - ee * M;
    let R = Math.abs(v), V = Math.abs(y);
    if (W < 0) {
      const T = Math.sqrt(1 - W / (j * ee));
      R *= T, V *= T;
    } else b = (w === g ? -1 : 1) * Math.sqrt(W / (j * ie + ee * M));
    const ae = b * R * X / V, $e = -b * V * B / R, N = F * ae - I * $e + 0.5 * p, me = I * ae + F * $e + 0.5 * m;
    let we = dv(1, 0, (B - ae) / R, (X - $e) / V), fe = dv((B - ae) / R, (X - $e) / V, (-B - ae) / R, (-X - $e) / V);
    g === 0 && fe > 0 ? fe -= 2 * C : g === 1 && fe < 0 && (fe += 2 * C);
    const te = Math.ceil(Math.abs(fe / C * 2)), Me = [], Re = fe / te, Ce = 8 / 3 * Math.sin(Re / 4) * Math.sin(Re / 4) / Math.sin(Re / 2);
    let le = we + Re;
    for (let T = 0; T < te; T++) Me[T] = yL(we, le, F, I, R, V, N, me, Ce, _, S), _ = Me[T][5], S = Me[T][6], we = le, le += Re;
    return Me;
  })(c - i, d - e, o, s, l, u, a);
  for (let p = 0, m = h.length; p < m; p++) h[p][1] += i, h[p][2] += e, h[p][3] += i, h[p][4] += e, h[p][5] += i, h[p][6] += e;
  return h;
}, wL = (i) => {
  let e = 0, n = 0, r = 0, o = 0;
  const s = [];
  let a, l = 0, u = 0;
  for (const c of i) {
    const d = [...c];
    let h;
    switch (d[0]) {
      case "l":
        d[1] += e, d[2] += n;
      case "L":
        e = d[1], n = d[2], h = ["L", e, n];
        break;
      case "h":
        d[1] += e;
      case "H":
        e = d[1], h = ["L", e, n];
        break;
      case "v":
        d[1] += n;
      case "V":
        n = d[1], h = ["L", e, n];
        break;
      case "m":
        d[1] += e, d[2] += n;
      case "M":
        e = d[1], n = d[2], r = d[1], o = d[2], h = ["M", e, n];
        break;
      case "c":
        d[1] += e, d[2] += n, d[3] += e, d[4] += n, d[5] += e, d[6] += n;
      case "C":
        l = d[3], u = d[4], e = d[5], n = d[6], h = ["C", d[1], d[2], l, u, e, n];
        break;
      case "s":
        d[1] += e, d[2] += n, d[3] += e, d[4] += n;
      case "S":
        a === "C" ? (l = 2 * e - l, u = 2 * n - u) : (l = e, u = n), e = d[3], n = d[4], h = ["C", l, u, d[1], d[2], e, n], l = h[3], u = h[4];
        break;
      case "q":
        d[1] += e, d[2] += n, d[3] += e, d[4] += n;
      case "Q":
        l = d[1], u = d[2], e = d[3], n = d[4], h = ["Q", l, u, e, n];
        break;
      case "t":
        d[1] += e, d[2] += n;
      case "T":
        a === "Q" ? (l = 2 * e - l, u = 2 * n - u) : (l = e, u = n), e = d[1], n = d[2], h = ["Q", l, u, e, n];
        break;
      case "a":
        d[6] += e, d[7] += n;
      case "A":
        bL(e, n, d).forEach((p) => s.push(p)), e = d[6], n = d[7];
        break;
      case "z":
      case "Z":
        e = r, n = o, h = ["Z"];
    }
    h ? (s.push(h), a = h[0]) : a = "";
  }
  return s;
}, Qc = (i, e, n, r) => Math.sqrt((n - i) ** 2 + (r - e) ** 2), o1 = (i, e, n, r, o, s, a, l) => (u) => {
  const c = u ** 3, d = ((m) => 3 * m ** 2 * (1 - m))(u), h = ((m) => 3 * m * (1 - m) ** 2)(u), p = ((m) => (1 - m) ** 3)(u);
  return new ce(a * c + o * d + n * h + i * p, l * c + s * d + r * h + e * p);
}, s1 = (i) => i ** 2, a1 = (i) => 2 * i * (1 - i), l1 = (i) => (1 - i) ** 2, _L = (i, e, n, r, o, s, a, l) => (u) => {
  const c = s1(u), d = a1(u), h = l1(u), p = 3 * (h * (n - i) + d * (o - n) + c * (a - o)), m = 3 * (h * (r - e) + d * (s - r) + c * (l - s));
  return Math.atan2(m, p);
}, xL = (i, e, n, r, o, s) => (a) => {
  const l = s1(a), u = a1(a), c = l1(a);
  return new ce(o * l + n * u + i * c, s * l + r * u + e * c);
}, SL = (i, e, n, r, o, s) => (a) => {
  const l = 1 - a, u = 2 * (l * (n - i) + a * (o - n)), c = 2 * (l * (r - e) + a * (s - r));
  return Math.atan2(c, u);
}, fv = (i, e, n) => {
  let r = new ce(e, n), o = 0;
  for (let s = 1; s <= 100; s += 1) {
    const a = i(s / 100);
    o += Qc(r.x, r.y, a.x, a.y), r = a;
  }
  return o;
}, CL = (i, e) => {
  let n, r = 0, o = 0, s = { x: i.x, y: i.y }, a = K({}, s), l = 0.01, u = 0;
  const c = i.iterator, d = i.angleFinder;
  for (; o < e && l > 1e-4; ) a = c(r), u = r, n = Qc(s.x, s.y, a.x, a.y), n + o > e ? (r -= l, l /= 2) : (s = a, r += l, o += n);
  return K(K({}, a), {}, { angle: d(u) });
}, u1 = (i) => {
  let e, n, r = 0, o = 0, s = 0, a = 0, l = 0;
  const u = [];
  for (const c of i) {
    const d = { x: o, y: s, command: c[0], length: 0 };
    switch (c[0]) {
      case "M":
        n = d, n.x = a = o = c[1], n.y = l = s = c[2];
        break;
      case "L":
        n = d, n.length = Qc(o, s, c[1], c[2]), o = c[1], s = c[2];
        break;
      case "C":
        e = o1(o, s, c[1], c[2], c[3], c[4], c[5], c[6]), n = d, n.iterator = e, n.angleFinder = _L(o, s, c[1], c[2], c[3], c[4], c[5], c[6]), n.length = fv(e, o, s), o = c[5], s = c[6];
        break;
      case "Q":
        e = xL(o, s, c[1], c[2], c[3], c[4]), n = d, n.iterator = e, n.angleFinder = SL(o, s, c[1], c[2], c[3], c[4]), n.length = fv(e, o, s), o = c[3], s = c[4];
        break;
      case "Z":
        n = d, n.destX = a, n.destY = l, n.length = Qc(o, s, a, l), o = a, s = l;
    }
    r += n.length, u.push(n);
  }
  return u.push({ length: r, x: o, y: s }), u;
}, kL = function(i, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u1(i), r = 0;
  for (; e - n[r].length > 0 && r < n.length - 2; ) e -= n[r].length, r++;
  const o = n[r], s = e / o.length, a = i[r];
  switch (o.command) {
    case "M":
      return { x: o.x, y: o.y, angle: 0 };
    case "Z":
      return K(K({}, new ce(o.x, o.y).lerp(new ce(o.destX, o.destY), s)), {}, { angle: Math.atan2(o.destY - o.y, o.destX - o.x) });
    case "L":
      return K(K({}, new ce(o.x, o.y).lerp(new ce(a[1], a[2]), s)), {}, { angle: Math.atan2(a[2] - o.y, a[1] - o.x) });
    case "C":
    case "Q":
      return CL(o, e);
  }
}, OL = new RegExp("[mzlhvcsqta][^mzlhvcsqta]*", "gi"), pv = new RegExp(gL, "g"), EL = new RegExp(zi, "gi"), TL = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, DL = (i) => {
  var e;
  const n = [], r = (e = i.match(OL)) !== null && e !== void 0 ? e : [];
  for (const o of r) {
    const s = o[0];
    if (s === "z" || s === "Z") {
      n.push([s]);
      continue;
    }
    const a = TL[s.toLowerCase()];
    let l = [];
    if (s === "a" || s === "A") {
      pv.lastIndex = 0;
      for (let u = null; u = pv.exec(o); ) l.push(...u.slice(1));
    } else l = o.match(EL) || [];
    for (let u = 0; u < l.length; u += a) {
      const c = new Array(a), d = vL[s];
      c[0] = u > 0 && d ? d : s;
      for (let h = 0; h < a; h++) c[h + 1] = parseFloat(l[u + h]);
      n.push(c);
    }
  }
  return n;
}, $L = (i, e) => i.map((n) => n.map((r, o) => o === 0 || e === void 0 ? r : Nt(r, e)).join(" ")).join(" ");
function rf(i, e) {
  const n = i.style;
  n && e && (typeof e == "string" ? n.cssText += ";" + e : Object.entries(e).forEach((r) => {
    let [o, s] = r;
    return n.setProperty(o, s);
  }));
}
class ML extends Ab {
  constructor(e) {
    let { allowTouchScrolling: n = !1, containerClass: r = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e), Y(this, "upper", void 0), Y(this, "container", void 0);
    const { el: o } = this.lower, s = this.createUpperCanvas();
    this.upper = { el: s, ctx: s.getContext("2d") }, this.applyCanvasStyle(o, { allowTouchScrolling: n }), this.applyCanvasStyle(s, { allowTouchScrolling: n, styles: { position: "absolute", left: "0", top: "0" } });
    const a = this.createContainerElement();
    a.classList.add(r), o.parentNode && o.parentNode.replaceChild(a, o), a.append(o, s), this.container = a;
  }
  createUpperCanvas() {
    const { el: e } = this.lower, n = ro();
    return n.className = e.className, n.classList.remove("lower-canvas"), n.classList.add("upper-canvas"), n.setAttribute("data-fabric", "top"), n.style.cssText = e.style.cssText, n.setAttribute("draggable", "true"), n;
  }
  createContainerElement() {
    const e = Ca().createElement("div");
    return e.setAttribute("data-fabric", "wrapper"), rf(e, { position: "relative" }), Rg(e), e;
  }
  applyCanvasStyle(e, n) {
    const { styles: r, allowTouchScrolling: o } = n;
    rf(e, K(K({}, r), {}, { "touch-action": o ? "manipulation" : ei })), Rg(e);
  }
  setDimensions(e, n) {
    super.setDimensions(e, n);
    const { el: r, ctx: o } = this.upper;
    Lb(r, o, e, n);
  }
  setCSSDimensions(e) {
    super.setCSSDimensions(e), Kh(this.upper.el, e), Kh(this.container, e);
  }
  cleanupDOM(e) {
    const n = this.container, { el: r } = this.lower, { el: o } = this.upper;
    super.cleanupDOM(e), n.removeChild(o), n.removeChild(r), n.parentNode && n.parentNode.replaceChild(r, n);
  }
  dispose() {
    super.dispose(), Sr().dispose(this.upper.el), delete this.upper, delete this.container;
  }
}
class xd extends du {
  constructor() {
    super(...arguments), Y(this, "targets", []), Y(this, "_hoveredTargets", []), Y(this, "_currentTransform", null), Y(this, "_groupSelector", null), Y(this, "contextTopDirty", !1);
  }
  static getDefaults() {
    return K(K({}, super.getDefaults()), xd.ownDefaults);
  }
  get upperCanvasEl() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.el;
  }
  get contextTop() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.ctx;
  }
  get wrapperEl() {
    return this.elements.container;
  }
  initElements(e) {
    this.elements = new ML(e, { allowTouchScrolling: this.allowTouchScrolling, containerClass: this.containerClass }), this._createCacheCanvas();
  }
  _onObjectAdded(e) {
    this._objectsToRender = void 0, super._onObjectAdded(e);
  }
  _onObjectRemoved(e) {
    this._objectsToRender = void 0, e === this._activeObject && (this.fire("before:selection:cleared", { deselected: [e] }), this._discardActiveObject(), this.fire("selection:cleared", { deselected: [e] }), e.fire("deselected", { target: e })), e === this._hoveredTarget && (this._hoveredTarget = void 0, this._hoveredTargets = []), super._onObjectRemoved(e);
  }
  _onStackOrderChanged() {
    this._objectsToRender = void 0, super._onStackOrderChanged();
  }
  _chooseObjectsToRender() {
    const e = this._activeObject;
    return !this.preserveObjectStacking && e ? this._objects.filter((n) => !n.group && n !== e).concat(e) : this._objects;
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || (!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1), !this._objectsToRender && (this._objectsToRender = this._chooseObjectsToRender()), this.renderCanvas(this.getContext(), this._objectsToRender));
  }
  renderTopLayer(e) {
    e.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(e), this.contextTopDirty = !0), e.restore();
  }
  renderTop() {
    const e = this.contextTop;
    this.clearContext(e), this.renderTopLayer(e), this.fire("after:render", { ctx: e });
  }
  setTargetFindTolerance(e) {
    e = Math.round(e), this.targetFindTolerance = e;
    const n = this.getRetinaScaling(), r = Math.ceil((2 * e + 1) * n);
    this.pixelFindCanvasEl.width = this.pixelFindCanvasEl.height = r, this.pixelFindContext.scale(n, n);
  }
  isTargetTransparent(e, n, r) {
    const o = this.targetFindTolerance, s = this.pixelFindContext;
    this.clearContext(s), s.save(), s.translate(-n + o, -r + o), s.transform(...this.viewportTransform);
    const a = e.selectionBackgroundColor;
    e.selectionBackgroundColor = "", e.render(s), e.selectionBackgroundColor = a, s.restore();
    const l = Math.round(o * this.getRetinaScaling());
    return A4(s, l, l, l);
  }
  _isSelectionKeyPressed(e) {
    const n = this.selectionKey;
    return !!n && (Array.isArray(n) ? !!n.find((r) => !!r && e[r] === !0) : e[n]);
  }
  _shouldClearSelection(e, n) {
    const r = this.getActiveObjects(), o = this._activeObject;
    return !!(!n || n && o && r.length > 1 && r.indexOf(n) === -1 && o !== n && !this._isSelectionKeyPressed(e) || n && !n.evented || n && !n.selectable && o && o !== n);
  }
  _shouldCenterTransform(e, n, r) {
    if (!e) return;
    let o;
    return n === md || n === ni || n === Si || n === $l ? o = this.centeredScaling || e.centeredScaling : n === ap && (o = this.centeredRotation || e.centeredRotation), o ? !r : r;
  }
  _getOriginFromCorner(e, n) {
    const r = { x: e.originX, y: e.originY };
    return n && (["ml", "tl", "bl"].includes(n) ? r.x = an : ["mr", "tr", "br"].includes(n) && (r.x = Tt), ["tl", "mt", "tr"].includes(n) ? r.y = Yh : ["bl", "mb", "br"].includes(n) && (r.y = Qn)), r;
  }
  _setupCurrentTransform(e, n, r) {
    var o;
    const s = n.group ? da(this.getScenePoint(e), void 0, n.group.calcTransformMatrix()) : this.getScenePoint(e), { key: a = "", control: l } = n.getActiveControl() || {}, u = r && l ? (o = l.getActionHandler(e, n, l)) === null || o === void 0 ? void 0 : o.bind(l) : Z3, c = ((m, v, y, w) => {
      if (!v || !m) return "drag";
      const g = w.controls[v];
      return g.getActionName(y, g, w);
    })(r, a, e, n), d = e[this.centeredKey], h = this._shouldCenterTransform(n, c, d) ? { x: ut, y: ut } : this._getOriginFromCorner(n, a), p = { target: n, action: c, actionHandler: u, actionPerformed: !1, corner: a, scaleX: n.scaleX, scaleY: n.scaleY, skewX: n.skewX, skewY: n.skewY, offsetX: s.x - n.left, offsetY: s.y - n.top, originX: h.x, originY: h.y, ex: s.x, ey: s.y, lastX: s.x, lastY: s.y, theta: un(n.angle), width: n.width, height: n.height, shiftKey: e.shiftKey, altKey: d, original: K(K({}, Vb(n)), {}, { originX: h.x, originY: h.y }) };
    this._currentTransform = p, this.fire("before:transform", { e, transform: p });
  }
  setCursor(e) {
    this.upperCanvasEl.style.cursor = e;
  }
  _drawSelection(e) {
    const { x: n, y: r, deltaX: o, deltaY: s } = this._groupSelector, a = new ce(n, r).transform(this.viewportTransform), l = new ce(n + o, r + s).transform(this.viewportTransform), u = this.selectionLineWidth / 2;
    let c = Math.min(a.x, l.x), d = Math.min(a.y, l.y), h = Math.max(a.x, l.x), p = Math.max(a.y, l.y);
    this.selectionColor && (e.fillStyle = this.selectionColor, e.fillRect(c, d, h - c, p - d)), this.selectionLineWidth && this.selectionBorderColor && (e.lineWidth = this.selectionLineWidth, e.strokeStyle = this.selectionBorderColor, c += u, d += u, h -= u, p -= u, An.prototype._setLineDash.call(this, e, this.selectionDashArray), e.strokeRect(c, d, h - c, p - d));
  }
  findTarget(e) {
    if (this.skipTargetFind) return;
    const n = this.getViewportPoint(e), r = this._activeObject, o = this.getActiveObjects();
    if (this.targets = [], r && o.length >= 1) {
      if (r.findControl(n, qh(e)) || o.length > 1 && this.searchPossibleTargets([r], n)) return r;
      if (r === this.searchPossibleTargets([r], n)) {
        if (this.preserveObjectStacking) {
          const s = this.targets;
          this.targets = [];
          const a = this.searchPossibleTargets(this._objects, n);
          return e[this.altSelectionKey] && a && a !== r ? (this.targets = s, r) : a;
        }
        return r;
      }
    }
    return this.searchPossibleTargets(this._objects, n);
  }
  _pointIsInObjectSelectionArea(e, n) {
    let r = e.getCoords();
    const o = this.getZoom(), s = e.padding / o;
    if (s) {
      const [a, l, u, c] = r, d = Math.atan2(l.y - a.y, l.x - a.x), h = no(d) * s, p = io(d) * s, m = h + p, v = h - p;
      r = [new ce(a.x - v, a.y - m), new ce(l.x + m, l.y - v), new ce(u.x + v, u.y + m), new ce(c.x - m, c.y + v)];
    }
    return Kt.isPointInPolygon(n, r);
  }
  _checkTarget(e, n) {
    return !!(e && e.visible && e.evented && this._pointIsInObjectSelectionArea(e, da(n, void 0, this.viewportTransform)) && (!this.perPixelTargetFind && !e.perPixelTargetFind || e.isEditing || !this.isTargetTransparent(e, n.x, n.y)));
  }
  _searchPossibleTargets(e, n) {
    let r = e.length;
    for (; r--; ) {
      const o = e[r];
      if (this._checkTarget(o, n)) {
        if (mc(o) && o.subTargetCheck) {
          const s = this._searchPossibleTargets(o._objects, n);
          s && this.targets.push(s);
        }
        return o;
      }
    }
  }
  searchPossibleTargets(e, n) {
    const r = this._searchPossibleTargets(e, n);
    if (r && mc(r) && r.interactive && this.targets[0]) {
      const o = this.targets;
      for (let s = o.length - 1; s > 0; s--) {
        const a = o[s];
        if (!mc(a) || !a.interactive) return a;
      }
      return o[0];
    }
    return r;
  }
  getViewportPoint(e) {
    return this._pointer ? this._pointer : this.getPointer(e, !0);
  }
  getScenePoint(e) {
    return this._absolutePointer ? this._absolutePointer : this.getPointer(e);
  }
  getPointer(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    const r = this.upperCanvasEl, o = r.getBoundingClientRect();
    let s = U3(e), a = o.width || 0, l = o.height || 0;
    a && l || (Qn in o && Yh in o && (l = Math.abs(o.top - o.bottom)), an in o && Tt in o && (a = Math.abs(o.right - o.left))), this.calcOffset(), s.x = s.x - this._offset.left, s.y = s.y - this._offset.top, n || (s = da(s, void 0, this.viewportTransform));
    const u = this.getRetinaScaling();
    u !== 1 && (s.x /= u, s.y /= u);
    const c = a === 0 || l === 0 ? new ce(1, 1) : new ce(r.width / a, r.height / l);
    return s.multiply(c);
  }
  _setDimensionsImpl(e, n) {
    this._resetTransformEventData(), super._setDimensionsImpl(e, n), this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
  }
  _createCacheCanvas() {
    this.pixelFindCanvasEl = ro(), this.pixelFindContext = this.pixelFindCanvasEl.getContext("2d", { willReadFrequently: !0 }), this.setTargetFindTolerance(this.targetFindTolerance);
  }
  getTopContext() {
    return this.elements.upper.ctx;
  }
  getSelectionContext() {
    return this.elements.upper.ctx;
  }
  getSelectionElement() {
    return this.elements.upper.el;
  }
  getActiveObject() {
    return this._activeObject;
  }
  getActiveObjects() {
    const e = this._activeObject;
    return cs(e) ? e.getObjects() : e ? [e] : [];
  }
  _fireSelectionEvents(e, n) {
    let r = !1, o = !1;
    const s = this.getActiveObjects(), a = [], l = [];
    e.forEach((u) => {
      s.includes(u) || (r = !0, u.fire("deselected", { e: n, target: u }), l.push(u));
    }), s.forEach((u) => {
      e.includes(u) || (r = !0, u.fire("selected", { e: n, target: u }), a.push(u));
    }), e.length > 0 && s.length > 0 ? (o = !0, r && this.fire("selection:updated", { e: n, selected: a, deselected: l })) : s.length > 0 ? (o = !0, this.fire("selection:created", { e: n, selected: a })) : e.length > 0 && (o = !0, this.fire("selection:cleared", { e: n, deselected: l })), o && (this._objectsToRender = void 0);
  }
  setActiveObject(e, n) {
    const r = this.getActiveObjects(), o = this._setActiveObject(e, n);
    return this._fireSelectionEvents(r, n), o;
  }
  _setActiveObject(e, n) {
    const r = this._activeObject;
    return r !== e && !(!this._discardActiveObject(n, e) && this._activeObject) && !e.onSelect({ e: n }) && (this._activeObject = e, cs(e) && r !== e && e.set("canvas", this), e.setCoords(), !0);
  }
  _discardActiveObject(e, n) {
    const r = this._activeObject;
    return !!r && !r.onDeselect({ e, object: n }) && (this._currentTransform && this._currentTransform.target === r && this.endCurrentTransform(e), cs(r) && r === this._hoveredTarget && (this._hoveredTarget = void 0), this._activeObject = void 0, !0);
  }
  discardActiveObject(e) {
    const n = this.getActiveObjects(), r = this.getActiveObject();
    n.length && this.fire("before:selection:cleared", { e, deselected: [r] });
    const o = this._discardActiveObject(e);
    return this._fireSelectionEvents(n, e), o;
  }
  endCurrentTransform(e) {
    const n = this._currentTransform;
    this._finalizeCurrentTransform(e), n && n.target && (n.target.isMoving = !1), this._currentTransform = null;
  }
  _finalizeCurrentTransform(e) {
    const n = this._currentTransform, r = n.target, o = { e, target: r, transform: n, action: n.action };
    r._scaling && (r._scaling = !1), r.setCoords(), n.actionPerformed && (this.fire("object:modified", o), r.fire(Uc, o));
  }
  setViewportTransform(e) {
    super.setViewportTransform(e);
    const n = this._activeObject;
    n && n.setCoords();
  }
  destroy() {
    const e = this._activeObject;
    cs(e) && (e.removeAll(), e.dispose()), delete this._activeObject, super.destroy(), this.pixelFindContext = null, this.pixelFindCanvasEl = void 0;
  }
  clear() {
    this.discardActiveObject(), this._activeObject = void 0, this.clearContext(this.contextTop), super.clear();
  }
  drawControls(e) {
    const n = this._activeObject;
    n && n._renderControls(e);
  }
  _toObject(e, n, r) {
    const o = this._realizeGroupTransformOnObject(e), s = super._toObject(e, n, r);
    return e.set(o), s;
  }
  _realizeGroupTransformOnObject(e) {
    const { group: n } = e;
    if (n && cs(n) && this._activeObject === n) {
      const r = Ta(e, ["angle", "flipX", "flipY", Tt, ni, Si, ka, Oa, Qn]);
      return G3(e, n.calcOwnMatrix()), r;
    }
    return {};
  }
  _setSVGObject(e, n, r) {
    const o = this._realizeGroupTransformOnObject(n);
    super._setSVGObject(e, n, r), n.set(o);
  }
}
Y(xd, "ownDefaults", { uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", selection: !0, selectionKey: "shiftKey", selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, enablePointerEvents: !1, containerClass: "canvas-container", preserveObjectStacking: !1 });
class PL {
  constructor(e) {
    Y(this, "targets", []), Y(this, "__disposer", void 0);
    const n = () => {
      const { hiddenTextarea: o } = e.getActiveObject() || {};
      o && o.focus();
    }, r = e.upperCanvasEl;
    r.addEventListener("click", n), this.__disposer = () => r.removeEventListener("click", n);
  }
  exitTextEditing() {
    this.target = void 0, this.targets.forEach((e) => {
      e.isEditing && e.exitEditing();
    });
  }
  add(e) {
    this.targets.push(e);
  }
  remove(e) {
    this.unregister(e), ea(this.targets, e);
  }
  register(e) {
    this.target = e;
  }
  unregister(e) {
    e === this.target && (this.target = void 0);
  }
  onMouseMove(e) {
    var n;
    !((n = this.target) === null || n === void 0) && n.isEditing && this.target.updateSelectionOnMouseMove(e);
  }
  clear() {
    this.targets = [], this.target = void 0;
  }
  dispose() {
    this.clear(), this.__disposer(), delete this.__disposer;
  }
}
const IL = ["target", "oldTarget", "fireCanvas", "e"], oi = { passive: !1 }, Xs = (i, e) => {
  const n = i.getViewportPoint(e), r = i.getScenePoint(e);
  return { viewportPoint: n, scenePoint: r, pointer: n, absolutePointer: r };
}, _o = function(i) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
  return i.addEventListener(...n);
}, gi = function(i) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
  return i.removeEventListener(...n);
}, LL = { mouse: { in: "over", out: "out", targetIn: "mouseover", targetOut: "mouseout", canvasIn: "mouse:over", canvasOut: "mouse:out" }, drag: { in: "enter", out: "leave", targetIn: "dragenter", targetOut: "dragleave", canvasIn: "drag:enter", canvasOut: "drag:leave" } };
class of extends xd {
  constructor(e) {
    super(e, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}), Y(this, "_isClick", void 0), Y(this, "textEditingManager", new PL(this)), ["_onMouseDown", "_onTouchStart", "_onMouseMove", "_onMouseUp", "_onTouchEnd", "_onResize", "_onMouseWheel", "_onMouseOut", "_onMouseEnter", "_onContextMenu", "_onClick", "_onDragStart", "_onDragEnd", "_onDragProgress", "_onDragOver", "_onDragEnter", "_onDragLeave", "_onDrop"].forEach((n) => {
      this[n] = this[n].bind(this);
    }), this.addOrRemove(_o, "add");
  }
  _getEventPrefix() {
    return this.enablePointerEvents ? "pointer" : "mouse";
  }
  addOrRemove(e, n) {
    const r = this.upperCanvasEl, o = this._getEventPrefix();
    e(Ib(r), "resize", this._onResize), e(r, o + "down", this._onMouseDown), e(r, "".concat(o, "move"), this._onMouseMove, oi), e(r, "".concat(o, "out"), this._onMouseOut), e(r, "".concat(o, "enter"), this._onMouseEnter), e(r, "wheel", this._onMouseWheel, { passive: !1 }), e(r, "contextmenu", this._onContextMenu), e(r, "click", this._onClick), e(r, "dblclick", this._onClick), e(r, "dragstart", this._onDragStart), e(r, "dragend", this._onDragEnd), e(r, "dragover", this._onDragOver), e(r, "dragenter", this._onDragEnter), e(r, "dragleave", this._onDragLeave), e(r, "drop", this._onDrop), this.enablePointerEvents || e(r, "touchstart", this._onTouchStart, oi);
  }
  removeListeners() {
    this.addOrRemove(gi, "remove");
    const e = this._getEventPrefix(), n = Fi(this.upperCanvasEl);
    gi(n, "".concat(e, "up"), this._onMouseUp), gi(n, "touchend", this._onTouchEnd, oi), gi(n, "".concat(e, "move"), this._onMouseMove, oi), gi(n, "touchmove", this._onMouseMove, oi), clearTimeout(this._willAddMouseDown);
  }
  _onMouseWheel(e) {
    this.__onMouseWheel(e);
  }
  _onMouseOut(e) {
    const n = this._hoveredTarget, r = K({ e }, Xs(this, e));
    this.fire("mouse:out", K(K({}, r), {}, { target: n })), this._hoveredTarget = void 0, n && n.fire("mouseout", K({}, r)), this._hoveredTargets.forEach((o) => {
      this.fire("mouse:out", K(K({}, r), {}, { target: o })), o && o.fire("mouseout", K({}, r));
    }), this._hoveredTargets = [];
  }
  _onMouseEnter(e) {
    this._currentTransform || this.findTarget(e) || (this.fire("mouse:over", K({ e }, Xs(this, e))), this._hoveredTarget = void 0, this._hoveredTargets = []);
  }
  _onDragStart(e) {
    this._isClick = !1;
    const n = this.getActiveObject();
    if (n && n.onDragStart(e)) {
      this._dragSource = n;
      const r = { e, target: n };
      return this.fire("dragstart", r), n.fire("dragstart", r), void _o(this.upperCanvasEl, "drag", this._onDragProgress);
    }
    Ng(e);
  }
  _renderDragEffects(e, n, r) {
    let o = !1;
    const s = this._dropTarget;
    s && s !== n && s !== r && (s.clearContextTop(), o = !0), n == null || n.clearContextTop(), r !== n && (r == null || r.clearContextTop());
    const a = this.contextTop;
    a.save(), a.transform(...this.viewportTransform), n && (a.save(), n.transform(a), n.renderDragSourceEffect(e), a.restore(), o = !0), r && (a.save(), r.transform(a), r.renderDropTargetEffect(e), a.restore(), o = !0), a.restore(), o && (this.contextTopDirty = !0);
  }
  _onDragEnd(e) {
    const n = !!e.dataTransfer && e.dataTransfer.dropEffect !== ei, r = n ? this._activeObject : void 0, o = { e, target: this._dragSource, subTargets: this.targets, dragSource: this._dragSource, didDrop: n, dropTarget: r };
    gi(this.upperCanvasEl, "drag", this._onDragProgress), this.fire("dragend", o), this._dragSource && this._dragSource.fire("dragend", o), delete this._dragSource, this._onMouseUp(e);
  }
  _onDragProgress(e) {
    const n = { e, target: this._dragSource, dragSource: this._dragSource, dropTarget: this._draggedoverTarget };
    this.fire("drag", n), this._dragSource && this._dragSource.fire("drag", n);
  }
  findDragTargets(e) {
    return this.targets = [], { target: this._searchPossibleTargets(this._objects, this.getViewportPoint(e)), targets: [...this.targets] };
  }
  _onDragOver(e) {
    const n = "dragover", { target: r, targets: o } = this.findDragTargets(e), s = this._dragSource, a = { e, target: r, subTargets: o, dragSource: s, canDrop: !1, dropTarget: void 0 };
    let l;
    this.fire(n, a), this._fireEnterLeaveEvents(r, a), r && (r.canDrop(e) && (l = r), r.fire(n, a));
    for (let u = 0; u < o.length; u++) {
      const c = o[u];
      c.canDrop(e) && (l = c), c.fire(n, a);
    }
    this._renderDragEffects(e, s, l), this._dropTarget = l;
  }
  _onDragEnter(e) {
    const { target: n, targets: r } = this.findDragTargets(e), o = { e, target: n, subTargets: r, dragSource: this._dragSource };
    this.fire("dragenter", o), this._fireEnterLeaveEvents(n, o);
  }
  _onDragLeave(e) {
    const n = { e, target: this._draggedoverTarget, subTargets: this.targets, dragSource: this._dragSource };
    this.fire("dragleave", n), this._fireEnterLeaveEvents(void 0, n), this._renderDragEffects(e, this._dragSource), this._dropTarget = void 0, this.targets = [], this._hoveredTargets = [];
  }
  _onDrop(e) {
    const { target: n, targets: r } = this.findDragTargets(e), o = this._basicEventHandler("drop:before", K({ e, target: n, subTargets: r, dragSource: this._dragSource }, Xs(this, e)));
    o.didDrop = !1, o.dropTarget = void 0, this._basicEventHandler("drop", o), this.fire("drop:after", o);
  }
  _onContextMenu(e) {
    const n = this.findTarget(e), r = this.targets || [], o = this._basicEventHandler("contextmenu:before", { e, target: n, subTargets: r });
    return this.stopContextMenu && Ng(e), this._basicEventHandler("contextmenu", o), !1;
  }
  _onClick(e) {
    const n = e.detail;
    n > 3 || n < 2 || (this._cacheTransformEventData(e), n == 2 && e.type === "dblclick" && this._handleEvent(e, "dblclick"), n == 3 && this._handleEvent(e, "tripleclick"), this._resetTransformEventData());
  }
  getPointerId(e) {
    const n = e.changedTouches;
    return n ? n[0] && n[0].identifier : this.enablePointerEvents ? e.pointerId : -1;
  }
  _isMainEvent(e) {
    return e.isPrimary === !0 || e.isPrimary !== !1 && (e.type === "touchend" && e.touches.length === 0 || !e.changedTouches || e.changedTouches[0].identifier === this.mainTouchId);
  }
  _onTouchStart(e) {
    let n = !this.allowTouchScrolling;
    const r = this._activeObject;
    this.mainTouchId === void 0 && (this.mainTouchId = this.getPointerId(e)), this.__onMouseDown(e), (this.isDrawingMode || r && this._target === r) && (n = !0), n && e.preventDefault(), this._resetTransformEventData();
    const o = this.upperCanvasEl, s = this._getEventPrefix(), a = Fi(o);
    _o(a, "touchend", this._onTouchEnd, oi), n && _o(a, "touchmove", this._onMouseMove, oi), gi(o, "".concat(s, "down"), this._onMouseDown);
  }
  _onMouseDown(e) {
    this.__onMouseDown(e), this._resetTransformEventData();
    const n = this.upperCanvasEl, r = this._getEventPrefix();
    gi(n, "".concat(r, "move"), this._onMouseMove, oi);
    const o = Fi(n);
    _o(o, "".concat(r, "up"), this._onMouseUp), _o(o, "".concat(r, "move"), this._onMouseMove, oi);
  }
  _onTouchEnd(e) {
    if (e.touches.length > 0) return;
    this.__onMouseUp(e), this._resetTransformEventData(), delete this.mainTouchId;
    const n = this._getEventPrefix(), r = Fi(this.upperCanvasEl);
    gi(r, "touchend", this._onTouchEnd, oi), gi(r, "touchmove", this._onMouseMove, oi), this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(() => {
      _o(this.upperCanvasEl, "".concat(n, "down"), this._onMouseDown), this._willAddMouseDown = 0;
    }, 400);
  }
  _onMouseUp(e) {
    this.__onMouseUp(e), this._resetTransformEventData();
    const n = this.upperCanvasEl, r = this._getEventPrefix();
    if (this._isMainEvent(e)) {
      const o = Fi(this.upperCanvasEl);
      gi(o, "".concat(r, "up"), this._onMouseUp), gi(o, "".concat(r, "move"), this._onMouseMove, oi), _o(n, "".concat(r, "move"), this._onMouseMove, oi);
    }
  }
  _onMouseMove(e) {
    const n = this.getActiveObject();
    !this.allowTouchScrolling && (!n || !n.shouldStartDragging(e)) && e.preventDefault && e.preventDefault(), this.__onMouseMove(e);
  }
  _onResize() {
    this.calcOffset(), this._resetTransformEventData();
  }
  _shouldRender(e) {
    const n = this.getActiveObject();
    return !!n != !!e || n && e && n !== e;
  }
  __onMouseUp(e) {
    var n;
    this._cacheTransformEventData(e), this._handleEvent(e, "up:before");
    const r = this._currentTransform, o = this._isClick, s = this._target, { button: a } = e;
    if (a) return (this.fireMiddleClick && a === 1 || this.fireRightClick && a === 2) && this._handleEvent(e, "up"), void this._resetTransformEventData();
    if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    let l, u, c = !1;
    if (r && (this._finalizeCurrentTransform(e), c = r.actionPerformed), !o) {
      const d = s === this._activeObject;
      this.handleSelection(e), c || (c = this._shouldRender(s) || !d && s === this._activeObject);
    }
    if (s) {
      const d = s.findControl(this.getViewportPoint(e), qh(e)), { key: h, control: p } = d || {};
      if (u = h, s.selectable && s !== this._activeObject && s.activeOn === "up") this.setActiveObject(s, e), c = !0;
      else if (p) {
        const m = p.getMouseUpHandler(e, s, p);
        m && (l = this.getScenePoint(e), m.call(p, e, r, l.x, l.y));
      }
      s.isMoving = !1;
    }
    if (r && (r.target !== s || r.corner !== u)) {
      const d = r.target && r.target.controls[r.corner], h = d && d.getMouseUpHandler(e, r.target, d);
      l = l || this.getScenePoint(e), h && h.call(d, e, r, l.x, l.y);
    }
    this._setCursorFromEvent(e, s), this._handleEvent(e, "up"), this._groupSelector = null, this._currentTransform = null, s && (s.__corner = void 0), c ? this.requestRenderAll() : o || (n = this._activeObject) !== null && n !== void 0 && n.isEditing || this.renderTop();
  }
  _basicEventHandler(e, n) {
    const { target: r, subTargets: o = [] } = n;
    this.fire(e, n), r && r.fire(e, n);
    for (let s = 0; s < o.length; s++) o[s] !== r && o[s].fire(e, n);
    return n;
  }
  _handleEvent(e, n, r) {
    const o = this._target, s = this.targets || [], a = K(K(K({ e, target: o, subTargets: s }, Xs(this, e)), {}, { transform: this._currentTransform }, n === "up:before" || n === "up" ? { isClick: this._isClick, currentTarget: this.findTarget(e), currentSubTargets: this.targets } : {}), n === "down:before" || n === "down" ? r : {});
    this.fire("mouse:".concat(n), a), o && o.fire("mouse".concat(n), a);
    for (let l = 0; l < s.length; l++) s[l] !== o && s[l].fire("mouse".concat(n), a);
  }
  _onMouseDownInDrawingMode(e) {
    this._isCurrentlyDrawing = !0, this.getActiveObject() && (this.discardActiveObject(e), this.requestRenderAll());
    const n = this.getScenePoint(e);
    this.freeDrawingBrush && this.freeDrawingBrush.onMouseDown(n, { e, pointer: n }), this._handleEvent(e, "down", { alreadySelected: !1 });
  }
  _onMouseMoveInDrawingMode(e) {
    if (this._isCurrentlyDrawing) {
      const n = this.getScenePoint(e);
      this.freeDrawingBrush && this.freeDrawingBrush.onMouseMove(n, { e, pointer: n });
    }
    this.setCursor(this.freeDrawingCursor), this._handleEvent(e, "move");
  }
  _onMouseUpInDrawingMode(e) {
    const n = this.getScenePoint(e);
    this.freeDrawingBrush ? this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({ e, pointer: n }) : this._isCurrentlyDrawing = !1, this._handleEvent(e, "up");
  }
  __onMouseDown(e) {
    this._isClick = !0, this._cacheTransformEventData(e), this._handleEvent(e, "down:before");
    let n = this._target, r = !!n && n === this._activeObject;
    const { button: o } = e;
    if (o) return (this.fireMiddleClick && o === 1 || this.fireRightClick && o === 2) && this._handleEvent(e, "down", { alreadySelected: r }), void this._resetTransformEventData();
    if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(e);
    if (!this._isMainEvent(e) || this._currentTransform) return;
    let s = this._shouldRender(n), a = !1;
    if (this.handleMultiSelection(e, n) ? (n = this._activeObject, a = !0, s = !0) : this._shouldClearSelection(e, n) && this.discardActiveObject(e), this.selection && (!n || !n.selectable && !n.isEditing && n !== this._activeObject)) {
      const l = this.getScenePoint(e);
      this._groupSelector = { x: l.x, y: l.y, deltaY: 0, deltaX: 0 };
    }
    if (r = !!n && n === this._activeObject, n) {
      n.selectable && n.activeOn === "down" && this.setActiveObject(n, e);
      const l = n.findControl(this.getViewportPoint(e), qh(e));
      if (n === this._activeObject && (l || !a)) {
        this._setupCurrentTransform(e, n, r);
        const u = l ? l.control : void 0, c = this.getScenePoint(e), d = u && u.getMouseDownHandler(e, n, u);
        d && d.call(u, e, this._currentTransform, c.x, c.y);
      }
    }
    s && (this._objectsToRender = void 0), this._handleEvent(e, "down", { alreadySelected: r }), s && this.requestRenderAll();
  }
  _resetTransformEventData() {
    this._target = this._pointer = this._absolutePointer = void 0;
  }
  _cacheTransformEventData(e) {
    this._resetTransformEventData(), this._pointer = this.getViewportPoint(e), this._absolutePointer = da(this._pointer, void 0, this.viewportTransform), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e);
  }
  __onMouseMove(e) {
    if (this._isClick = !1, this._cacheTransformEventData(e), this._handleEvent(e, "move:before"), this.isDrawingMode) return void this._onMouseMoveInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    const n = this._groupSelector;
    if (n) {
      const r = this.getScenePoint(e);
      n.deltaX = r.x - n.x, n.deltaY = r.y - n.y, this.renderTop();
    } else if (this._currentTransform) this._transformObject(e);
    else {
      const r = this.findTarget(e);
      this._setCursorFromEvent(e, r), this._fireOverOutEvents(e, r);
    }
    this.textEditingManager.onMouseMove(e), this._handleEvent(e, "move"), this._resetTransformEventData();
  }
  _fireOverOutEvents(e, n) {
    const r = this._hoveredTarget, o = this._hoveredTargets, s = this.targets, a = Math.max(o.length, s.length);
    this.fireSyntheticInOutEvents("mouse", { e, target: n, oldTarget: r, fireCanvas: !0 });
    for (let l = 0; l < a; l++) s[l] === n || o[l] && o[l] === r || this.fireSyntheticInOutEvents("mouse", { e, target: s[l], oldTarget: o[l] });
    this._hoveredTarget = n, this._hoveredTargets = this.targets.concat();
  }
  _fireEnterLeaveEvents(e, n) {
    const r = this._draggedoverTarget, o = this._hoveredTargets, s = this.targets, a = Math.max(o.length, s.length);
    this.fireSyntheticInOutEvents("drag", K(K({}, n), {}, { target: e, oldTarget: r, fireCanvas: !0 }));
    for (let l = 0; l < a; l++) this.fireSyntheticInOutEvents("drag", K(K({}, n), {}, { target: s[l], oldTarget: o[l] }));
    this._draggedoverTarget = e;
  }
  fireSyntheticInOutEvents(e, n) {
    let { target: r, oldTarget: o, fireCanvas: s, e: a } = n, l = zt(n, IL);
    const { targetIn: u, targetOut: c, canvasIn: d, canvasOut: h } = LL[e], p = o !== r;
    if (o && p) {
      const m = K(K({}, l), {}, { e: a, target: o, nextTarget: r }, Xs(this, a));
      s && this.fire(h, m), o.fire(c, m);
    }
    if (r && p) {
      const m = K(K({}, l), {}, { e: a, target: r, previousTarget: o }, Xs(this, a));
      s && this.fire(d, m), r.fire(u, m);
    }
  }
  __onMouseWheel(e) {
    this._cacheTransformEventData(e), this._handleEvent(e, "wheel"), this._resetTransformEventData();
  }
  _transformObject(e) {
    const n = this.getScenePoint(e), r = this._currentTransform, o = r.target, s = o.group ? da(n, void 0, o.group.calcTransformMatrix()) : n;
    r.shiftKey = e.shiftKey, r.altKey = !!this.centeredKey && e[this.centeredKey], this._performTransformAction(e, r, s), r.actionPerformed && this.requestRenderAll();
  }
  _performTransformAction(e, n, r) {
    const { action: o, actionHandler: s, target: a } = n, l = !!s && s(e, n, r.x, r.y);
    l && a.setCoords(), o === "drag" && l && (n.target.isMoving = !0, this.setCursor(n.target.moveCursor || this.moveCursor)), n.actionPerformed = n.actionPerformed || l;
  }
  _setCursorFromEvent(e, n) {
    if (!n) return void this.setCursor(this.defaultCursor);
    let r = n.hoverCursor || this.hoverCursor;
    const o = cs(this._activeObject) ? this._activeObject : null, s = (!o || n.group !== o) && n.findControl(this.getViewportPoint(e));
    if (s) {
      const a = s.control;
      this.setCursor(a.cursorStyleHandler(e, a, n));
    } else n.subTargetCheck && this.targets.concat().reverse().map((a) => {
      r = a.hoverCursor || r;
    }), this.setCursor(r);
  }
  handleMultiSelection(e, n) {
    const r = this._activeObject, o = cs(r);
    if (r && this._isSelectionKeyPressed(e) && this.selection && n && n.selectable && (r !== n || o) && (o || !n.isDescendantOf(r) && !r.isDescendantOf(n)) && !n.onSelect({ e }) && !r.getActiveControl()) {
      if (o) {
        const s = r.getObjects();
        if (n === r) {
          const a = this.getViewportPoint(e);
          if (!(n = this.searchPossibleTargets(s, a) || this.searchPossibleTargets(this._objects, a)) || !n.selectable) return !1;
        }
        n.group === r ? (r.remove(n), this._hoveredTarget = n, this._hoveredTargets = [...this.targets], r.size() === 1 && this._setActiveObject(r.item(0), e)) : (r.multiSelectAdd(n), this._hoveredTarget = r, this._hoveredTargets = [...this.targets]), this._fireSelectionEvents(s, e);
      } else {
        r.isEditing && r.exitEditing();
        const s = new (Ne.getClass("ActiveSelection"))([], { canvas: this });
        s.multiSelectAdd(r, n), this._hoveredTarget = s, this._setActiveObject(s, e), this._fireSelectionEvents([r], e);
      }
      return !0;
    }
    return !1;
  }
  handleSelection(e) {
    if (!this.selection || !this._groupSelector) return !1;
    const { x: n, y: r, deltaX: o, deltaY: s } = this._groupSelector, a = new ce(n, r), l = a.add(new ce(o, s)), u = a.min(l), c = a.max(l).subtract(u), d = this.collectObjects({ left: u.x, top: u.y, width: c.x, height: c.y }, { includeIntersecting: !this.selectionFullyContained }), h = a.eq(l) ? d[0] ? [d[0]] : [] : d.length > 1 ? d.filter((p) => !p.onSelect({ e })).reverse() : d;
    if (h.length === 1) this.setActiveObject(h[0], e);
    else if (h.length > 1) {
      const p = Ne.getClass("ActiveSelection");
      this.setActiveObject(new p(h, { canvas: this }), e);
    }
    return this._groupSelector = null, !0;
  }
  clear() {
    this.textEditingManager.clear(), super.clear();
  }
  destroy() {
    this.removeListeners(), this.textEditingManager.dispose(), super.destroy();
  }
}
const c1 = { x1: 0, y1: 0, x2: 0, y2: 0 }, AL = K(K({}, c1), {}, { r1: 0, r2: 0 }), ra = (i, e) => isNaN(i) && typeof e == "number" ? e : i;
function d1(i) {
  return i && /%$/.test(i) && Number.isFinite(parseFloat(i));
}
function h1(i, e) {
  const n = typeof i == "number" ? i : typeof i == "string" ? parseFloat(i) / (d1(i) ? 100 : 1) : NaN;
  return _a(0, ra(n, e), 1);
}
const VL = /\s*;\s*/, FL = /\s*:\s*/;
function jL(i, e) {
  let n, r;
  const o = i.getAttribute("style");
  if (o) {
    const a = o.split(VL);
    a[a.length - 1] === "" && a.pop();
    for (let l = a.length; l--; ) {
      const [u, c] = a[l].split(FL).map((d) => d.trim());
      u === "stop-color" ? n = c : u === "stop-opacity" && (r = c);
    }
  }
  const s = new $t(n || i.getAttribute("stop-color") || "rgb(0,0,0)");
  return { offset: h1(i.getAttribute("offset"), 0), color: s.toRgb(), opacity: ra(parseFloat(r || i.getAttribute("stop-opacity") || ""), 1) * s.getAlpha() * e };
}
function RL(i, e) {
  const n = [], r = i.getElementsByTagName("stop"), o = h1(e, 1);
  for (let s = r.length; s--; ) n.push(jL(r[s], o));
  return n;
}
function f1(i) {
  return i.nodeName === "linearGradient" || i.nodeName === "LINEARGRADIENT" ? "linear" : "radial";
}
function p1(i) {
  return i.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage";
}
function Ti(i, e) {
  return i.getAttribute(e);
}
function NL(i, e) {
  return function(n, r) {
    let o, { width: s, height: a, gradientUnits: l } = r;
    return Object.entries(n).reduce((u, c) => {
      let [d, h] = c;
      if (h === "Infinity") o = 1;
      else if (h === "-Infinity") o = 0;
      else {
        const p = typeof h == "string";
        o = p ? parseFloat(h) : h, p && d1(h) && (o *= 0.01, l === "pixels" && (d !== "x1" && d !== "x2" && d !== "r2" || (o *= s), d !== "y1" && d !== "y2" || (o *= a)));
      }
      return u[d] = o, u;
    }, {});
  }(f1(i) === "linear" ? function(n) {
    return { x1: Ti(n, "x1") || 0, y1: Ti(n, "y1") || 0, x2: Ti(n, "x2") || "100%", y2: Ti(n, "y2") || 0 };
  }(i) : function(n) {
    return { x1: Ti(n, "fx") || Ti(n, "cx") || "50%", y1: Ti(n, "fy") || Ti(n, "cy") || "50%", r1: 0, x2: Ti(n, "cx") || "50%", y2: Ti(n, "cy") || "50%", r2: Ti(n, "r") || "50%" };
  }(i), K(K({}, e), {}, { gradientUnits: p1(i) }));
}
class Au {
  constructor(e) {
    const { type: n = "linear", gradientUnits: r = "pixels", coords: o = {}, colorStops: s = [], offsetX: a = 0, offsetY: l = 0, gradientTransform: u, id: c } = e || {};
    Object.assign(this, { type: n, gradientUnits: r, coords: K(K({}, n === "radial" ? AL : c1), o), colorStops: s, offsetX: a, offsetY: l, gradientTransform: u, id: c ? "".concat(c, "_").concat(No()) : No() });
  }
  addColorStop(e) {
    for (const n in e) {
      const r = new $t(e[n]);
      this.colorStops.push({ offset: parseFloat(n), color: r.toRgb(), opacity: r.getAlpha() });
    }
    return this;
  }
  toObject(e) {
    return K(K({}, Ta(this, e)), {}, { type: this.type, coords: K({}, this.coords), colorStops: this.colorStops.map((n) => K({}, n)), offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? [...this.gradientTransform] : void 0 });
  }
  toSVG(e) {
    let { additionalTransform: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = [], o = this.gradientTransform ? this.gradientTransform.concat() : Un.concat(), s = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox", a = this.colorStops.map((h) => K({}, h)).sort((h, p) => h.offset - p.offset);
    let l = -this.offsetX, u = -this.offsetY;
    var c;
    s === "objectBoundingBox" ? (l /= e.width, u /= e.height) : (l += e.width / 2, u += e.height / 2), (c = e) && typeof c._renderPathCommands == "function" && this.gradientUnits !== "percentage" && (l -= e.pathOffset.x, u -= e.pathOffset.y), o[4] -= l, o[5] -= u;
    const d = ['id="SVGID_'.concat(this.id, '"'), 'gradientUnits="'.concat(s, '"'), 'gradientTransform="'.concat(n ? n + " " : "").concat(Pl(o), '"'), ""].join(" ");
    if (this.type === "linear") {
      const { x1: h, y1: p, x2: m, y2: v } = this.coords;
      r.push("<linearGradient ", d, ' x1="', h, '" y1="', p, '" x2="', m, '" y2="', v, `">
`);
    } else if (this.type === "radial") {
      const { x1: h, y1: p, x2: m, y2: v, r1: y, r2: w } = this.coords, g = y > w;
      r.push("<radialGradient ", d, ' cx="', g ? h : m, '" cy="', g ? p : v, '" r="', g ? y : w, '" fx="', g ? m : h, '" fy="', g ? v : p, `">
`), g && (a.reverse(), a.forEach((_) => {
        _.offset = 1 - _.offset;
      }));
      const k = Math.min(y, w);
      if (k > 0) {
        const _ = k / Math.max(y, w);
        a.forEach((S) => {
          S.offset += _ * (1 - S.offset);
        });
      }
    }
    return a.forEach((h) => {
      let { color: p, offset: m, opacity: v } = h;
      r.push("<stop ", 'offset="', 100 * m + "%", '" style="stop-color:', p, v !== void 0 ? ";stop-opacity: " + v : ";", `"/>
`);
    }), r.push(this.type === "linear" ? "</linearGradient>" : "</radialGradient>", `
`), r.join("");
  }
  toLive(e) {
    const { x1: n, y1: r, x2: o, y2: s, r1: a, r2: l } = this.coords, u = this.type === "linear" ? e.createLinearGradient(n, r, o, s) : e.createRadialGradient(n, r, a, o, s, l);
    return this.colorStops.forEach((c) => {
      let { color: d, opacity: h, offset: p } = c;
      u.addColorStop(p, h !== void 0 ? new $t(d).setAlpha(h).toRgba() : d);
    }), u;
  }
  static async fromObject(e) {
    const { colorStops: n, gradientTransform: r } = e;
    return new this(K(K({}, e), {}, { colorStops: n ? n.map((o) => K({}, o)) : void 0, gradientTransform: r ? [...r] : void 0 }));
  }
  static fromElement(e, n, r) {
    const o = p1(e), s = n._findCenterFromElement();
    return new this(K({ id: e.getAttribute("id") || void 0, type: f1(e), coords: NL(e, { width: r.viewBoxWidth || r.width, height: r.viewBoxHeight || r.height }), colorStops: RL(e, r.opacity), gradientUnits: o, gradientTransform: ef(e.getAttribute("gradientTransform") || "") }, o === "pixels" ? { offsetX: n.width / 2 - s.x, offsetY: n.height / 2 - s.y } : { offsetX: 0, offsetY: 0 }));
  }
}
Y(Au, "type", "Gradient"), Ne.setClass(Au, "gradient"), Ne.setClass(Au, "linear"), Ne.setClass(Au, "radial");
const zL = ["type", "source", "patternTransform"];
class hh {
  get type() {
    return "pattern";
  }
  set type(e) {
    Ro("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    Y(this, "repeat", "repeat"), Y(this, "offsetX", 0), Y(this, "offsetY", 0), Y(this, "crossOrigin", ""), this.id = No(), Object.assign(this, e);
  }
  isImageSource() {
    return !!this.source && typeof this.source.src == "string";
  }
  isCanvasSource() {
    return !!this.source && !!this.source.toDataURL;
  }
  sourceToString() {
    return this.isImageSource() ? this.source.src : this.isCanvasSource() ? this.source.toDataURL() : "";
  }
  toLive(e) {
    return this.source && (!this.isImageSource() || this.source.complete && this.source.naturalWidth !== 0 && this.source.naturalHeight !== 0) ? e.createPattern(this.source, this.repeat) : null;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const { repeat: n, crossOrigin: r } = this;
    return K(K({}, Ta(this, e)), {}, { type: "pattern", source: this.sourceToString(), repeat: n, crossOrigin: r, offsetX: Nt(this.offsetX, kt.NUM_FRACTION_DIGITS), offsetY: Nt(this.offsetY, kt.NUM_FRACTION_DIGITS), patternTransform: this.patternTransform ? [...this.patternTransform] : null });
  }
  toSVG(e) {
    let { width: n, height: r } = e;
    const { source: o, repeat: s, id: a } = this, l = ra(this.offsetX / n, 0), u = ra(this.offsetY / r, 0), c = s === "repeat-y" || s === "no-repeat" ? 1 + Math.abs(l || 0) : ra(o.width / n, 0), d = s === "repeat-x" || s === "no-repeat" ? 1 + Math.abs(u || 0) : ra(o.height / r, 0);
    return ['<pattern id="SVGID_'.concat(a, '" x="').concat(l, '" y="').concat(u, '" width="').concat(c, '" height="').concat(d, '">'), '<image x="0" y="0" width="'.concat(o.width, '" height="').concat(o.height, '" xlink:href="').concat(this.sourceToString(), '"></image>'), "</pattern>", ""].join(`
`);
  }
  static async fromObject(e, n) {
    let { type: r, source: o, patternTransform: s } = e, a = zt(e, zL);
    const l = await vc(o, K(K({}, n), {}, { crossOrigin: a.crossOrigin }));
    return new this(K(K({}, a), {}, { patternTransform: s && s.slice(0), source: l }));
  }
}
Y(hh, "type", "Pattern"), Ne.setClass(hh), Ne.setClass(hh, "pattern");
const BL = ["path", "left", "top"], HL = ["d"];
class $o extends An {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { path: r, left: o, top: s } = n, a = zt(n, BL);
    super(), Object.assign(this, $o.ownDefaults), this.setOptions(a), this._setPath(e || [], !0), typeof o == "number" && this.set(Tt, o), typeof s == "number" && this.set(Qn, s);
  }
  _setPath(e, n) {
    this.path = wL(Array.isArray(e) ? e : DL(e)), this.setBoundingBox(n);
  }
  _findCenterFromElement() {
    const e = this._calcBoundsFromPath();
    return new ce(e.left + e.width / 2, e.top + e.height / 2);
  }
  _renderPathCommands(e) {
    const n = -this.pathOffset.x, r = -this.pathOffset.y;
    e.beginPath();
    for (const o of this.path) switch (o[0]) {
      case "L":
        e.lineTo(o[1] + n, o[2] + r);
        break;
      case "M":
        e.moveTo(o[1] + n, o[2] + r);
        break;
      case "C":
        e.bezierCurveTo(o[1] + n, o[2] + r, o[3] + n, o[4] + r, o[5] + n, o[6] + r);
        break;
      case "Q":
        e.quadraticCurveTo(o[1] + n, o[2] + r, o[3] + n, o[4] + r);
        break;
      case "Z":
        e.closePath();
    }
  }
  _render(e) {
    this._renderPathCommands(e), this._renderPaintInOrder(e);
  }
  toString() {
    return "#<Path (".concat(this.complexity(), '): { "top": ').concat(this.top, ', "left": ').concat(this.left, " }>");
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return K(K({}, super.toObject(e)), {}, { path: this.path.map((n) => n.slice()) });
  }
  toDatalessObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = this.toObject(e);
    return this.sourcePath && (delete n.path, n.sourcePath = this.sourcePath), n;
  }
  _toSVG() {
    const e = $L(this.path, kt.NUM_FRACTION_DIGITS);
    return ["<path ", "COMMON_PARTS", 'd="'.concat(e, `" stroke-linecap="round" />
`)];
  }
  _getOffsetTransform() {
    const e = kt.NUM_FRACTION_DIGITS;
    return " translate(".concat(Nt(-this.pathOffset.x, e), ", ").concat(Nt(-this.pathOffset.y, e), ")");
  }
  toClipPathSVG(e) {
    const n = this._getOffsetTransform();
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: n });
  }
  toSVG(e) {
    const n = this._getOffsetTransform();
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: n });
  }
  complexity() {
    return this.path.length;
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { width: n, height: r, pathOffset: o } = this._calcDimensions();
    this.set({ width: n, height: r, pathOffset: o }), e && this.setPositionByOrigin(o, ut, ut);
  }
  _calcBoundsFromPath() {
    const e = [];
    let n = 0, r = 0, o = 0, s = 0;
    for (const a of this.path) switch (a[0]) {
      case "L":
        o = a[1], s = a[2], e.push({ x: n, y: r }, { x: o, y: s });
        break;
      case "M":
        o = a[1], s = a[2], n = o, r = s;
        break;
      case "C":
        e.push(...hv(o, s, a[1], a[2], a[3], a[4], a[5], a[6])), o = a[5], s = a[6];
        break;
      case "Q":
        e.push(...hv(o, s, a[1], a[2], a[1], a[2], a[3], a[4])), o = a[3], s = a[4];
        break;
      case "Z":
        o = n, s = r;
    }
    return Qr(e);
  }
  _calcDimensions() {
    const e = this._calcBoundsFromPath();
    return K(K({}, e), {}, { pathOffset: new ce(e.left + e.width / 2, e.top + e.height / 2) });
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "path" });
  }
  static async fromElement(e, n, r) {
    const o = uo(e, this.ATTRIBUTE_NAMES, r), { d: s } = o;
    return new this(s, K(K(K({}, zt(o, HL)), n), {}, { left: void 0, top: void 0 }));
  }
}
Y($o, "type", "Path"), Y($o, "cacheProperties", [...lo, "path", "fillRule"]), Y($o, "ATTRIBUTE_NAMES", [...Bo, "d"]), Ne.setClass($o), Ne.setSVGClass($o);
const UL = ["left", "top", "radius"], m1 = ["radius", "startAngle", "endAngle", "counterClockwise"];
class Ur extends An {
  static getDefaults() {
    return K(K({}, super.getDefaults()), Ur.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Ur.ownDefaults), this.setOptions(e);
  }
  _set(e, n) {
    return super._set(e, n), e === "radius" && this.setRadius(n), this;
  }
  _render(e) {
    e.beginPath(), e.arc(0, 0, this.radius, un(this.startAngle), un(this.endAngle), this.counterClockwise), this._renderPaintInOrder(e);
  }
  getRadiusX() {
    return this.get("radius") * this.get(ni);
  }
  getRadiusY() {
    return this.get("radius") * this.get(Si);
  }
  setRadius(e) {
    this.radius = e, this.set({ width: 2 * e, height: 2 * e });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...m1, ...e]);
  }
  _toSVG() {
    const e = (this.endAngle - this.startAngle) % 360;
    if (e === 0) return ["<circle ", "COMMON_PARTS", 'cx="0" cy="0" ', 'r="', "".concat(this.radius), `" />
`];
    {
      const { radius: n } = this, r = un(this.startAngle), o = un(this.endAngle), s = no(r) * n, a = io(r) * n, l = no(o) * n, u = io(o) * n, c = e > 180 ? 1 : 0, d = this.counterClockwise ? 0 : 1;
      return ['<path d="M '.concat(s, " ").concat(a, " A ").concat(n, " ").concat(n, " 0 ").concat(c, " ").concat(d, " ").concat(l, " ").concat(u, '" '), "COMMON_PARTS", ` />
`];
    }
  }
  static async fromElement(e, n, r) {
    const o = uo(e, this.ATTRIBUTE_NAMES, r), { left: s = 0, top: a = 0, radius: l = 0 } = o;
    return new this(K(K({}, zt(o, UL)), {}, { radius: l, left: s - l, top: a - l }));
  }
  static fromObject(e) {
    return super._fromObject(e);
  }
}
Y(Ur, "type", "Circle"), Y(Ur, "cacheProperties", [...lo, ...m1]), Y(Ur, "ownDefaults", { radius: 0, startAngle: 0, endAngle: 360, counterClockwise: !1 }), Y(Ur, "ATTRIBUTE_NAMES", ["cx", "cy", "r", ...Bo]), Ne.setClass(Ur), Ne.setSVGClass(Ur);
const WL = ["x1", "y1", "x2", "y2"], GL = ["x1", "y1", "x2", "y2"], sf = ["x1", "x2", "y1", "y2"];
class ds extends An {
  constructor() {
    let [e, n, r, o] = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0, 0], s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, ds.ownDefaults), this.setOptions(s), this.x1 = e, this.x2 = r, this.y1 = n, this.y2 = o, this._setWidthHeight();
    const { left: a, top: l } = s;
    typeof a == "number" && this.set(Tt, a), typeof l == "number" && this.set(Qn, l);
  }
  _setWidthHeight() {
    const { x1: e, y1: n, x2: r, y2: o } = this;
    this.width = Math.abs(r - e), this.height = Math.abs(o - n);
    const { left: s, top: a, width: l, height: u } = Qr([{ x: e, y: n }, { x: r, y: o }]), c = new ce(s + l / 2, a + u / 2);
    this.setPositionByOrigin(c, ut, ut);
  }
  _set(e, n) {
    return super._set(e, n), sf.includes(e) && this._setWidthHeight(), this;
  }
  _render(e) {
    e.beginPath();
    const n = this.calcLinePoints();
    e.moveTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineWidth = this.strokeWidth;
    const r = e.strokeStyle;
    var o;
    xi(this.stroke) ? e.strokeStyle = this.stroke.toLive(e) : e.strokeStyle = (o = this.stroke) !== null && o !== void 0 ? o : e.fillStyle, this.stroke && this._renderStroke(e), e.strokeStyle = r;
  }
  _findCenterFromElement() {
    return new ce((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return K(K({}, super.toObject(e)), this.calcLinePoints());
  }
  _getNonTransformedDimensions() {
    const e = super._getNonTransformedDimensions();
    return this.strokeLineCap === "butt" && (this.width === 0 && (e.y -= this.strokeWidth), this.height === 0 && (e.x -= this.strokeWidth)), e;
  }
  calcLinePoints() {
    const { x1: e, x2: n, y1: r, y2: o, width: s, height: a } = this, l = e <= n ? -1 : 1, u = r <= o ? -1 : 1;
    return { x1: l * s / 2, x2: l * -s / 2, y1: u * a / 2, y2: u * -a / 2 };
  }
  _toSVG() {
    const { x1: e, x2: n, y1: r, y2: o } = this.calcLinePoints();
    return ["<line ", "COMMON_PARTS", 'x1="'.concat(e, '" y1="').concat(r, '" x2="').concat(n, '" y2="').concat(o, `" />
`)];
  }
  static async fromElement(e, n, r) {
    const o = uo(e, this.ATTRIBUTE_NAMES, r), { x1: s = 0, y1: a = 0, x2: l = 0, y2: u = 0 } = o;
    return new this([s, a, l, u], zt(o, WL));
  }
  static fromObject(e) {
    let { x1: n, y1: r, x2: o, y2: s } = e, a = zt(e, GL);
    return this._fromObject(K(K({}, a), {}, { points: [n, r, o, s] }), { extraParam: "points" });
  }
}
Y(ds, "type", "Line"), Y(ds, "cacheProperties", [...lo, ...sf]), Y(ds, "ATTRIBUTE_NAMES", Bo.concat(sf)), Ne.setClass(ds), Ne.setSVGClass(ds);
class fs extends An {
  static getDefaults() {
    return K(K({}, super.getDefaults()), fs.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, fs.ownDefaults), this.setOptions(e);
  }
  _render(e) {
    const n = this.width / 2, r = this.height / 2;
    e.beginPath(), e.moveTo(-n, r), e.lineTo(0, -r), e.lineTo(n, r), e.closePath(), this._renderPaintInOrder(e);
  }
  _toSVG() {
    const e = this.width / 2, n = this.height / 2;
    return ["<polygon ", "COMMON_PARTS", 'points="', "".concat(-e, " ").concat(n, ",0 ").concat(-n, ",").concat(e, " ").concat(n), '" />'];
  }
}
Y(fs, "type", "Triangle"), Y(fs, "ownDefaults", { width: 100, height: 100 }), Ne.setClass(fs), Ne.setSVGClass(fs);
const g1 = ["rx", "ry"];
class Wr extends An {
  static getDefaults() {
    return K(K({}, super.getDefaults()), Wr.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Wr.ownDefaults), this.setOptions(e);
  }
  _set(e, n) {
    switch (super._set(e, n), e) {
      case "rx":
        this.rx = n, this.set("width", 2 * n);
        break;
      case "ry":
        this.ry = n, this.set("height", 2 * n);
    }
    return this;
  }
  getRx() {
    return this.get("rx") * this.get(ni);
  }
  getRy() {
    return this.get("ry") * this.get(Si);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...g1, ...e]);
  }
  _toSVG() {
    return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" rx="'.concat(this.rx, '" ry="').concat(this.ry, `" />
`)];
  }
  _render(e) {
    e.beginPath(), e.save(), e.transform(1, 0, 0, this.ry / this.rx, 0, 0), e.arc(0, 0, this.rx, 0, Bc, !1), e.restore(), this._renderPaintInOrder(e);
  }
  static async fromElement(e, n, r) {
    const o = uo(e, this.ATTRIBUTE_NAMES, r);
    return o.left = (o.left || 0) - o.rx, o.top = (o.top || 0) - o.ry, new this(o);
  }
}
function XL(i) {
  if (!i) return [];
  const e = i.replace(/,/g, " ").trim().split(/\s+/), n = [];
  for (let r = 0; r < e.length; r += 2) n.push({ x: parseFloat(e[r]), y: parseFloat(e[r + 1]) });
  return n;
}
Y(Wr, "type", "Ellipse"), Y(Wr, "cacheProperties", [...lo, ...g1]), Y(Wr, "ownDefaults", { rx: 0, ry: 0 }), Y(Wr, "ATTRIBUTE_NAMES", [...Bo, "cx", "cy", "rx", "ry"]), Ne.setClass(Wr), Ne.setSVGClass(Wr);
const YL = ["left", "top"], v1 = { exactBoundingBox: !1 };
class Ii extends An {
  static getDefaults() {
    return K(K({}, super.getDefaults()), Ii.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Y(this, "strokeDiff", void 0), Object.assign(this, Ii.ownDefaults), this.setOptions(n), this.points = e;
    const { left: r, top: o } = n;
    this.initialized = !0, this.setBoundingBox(!0), typeof r == "number" && this.set(Tt, r), typeof o == "number" && this.set(Qn, o);
  }
  isOpen() {
    return !0;
  }
  _projectStrokeOnPoints(e) {
    return F4(this.points, e, this.isOpen());
  }
  _calcDimensions(e) {
    e = K({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: this.strokeMiterLimit, strokeUniform: this.strokeUniform, strokeWidth: this.strokeWidth }, e || {});
    const n = this.exactBoundingBox ? this._projectStrokeOnPoints(e).map((c) => c.projectedPoint) : this.points;
    if (n.length === 0) return { left: 0, top: 0, width: 0, height: 0, pathOffset: new ce(), strokeOffset: new ce(), strokeDiff: new ce() };
    const r = Qr(n), o = gd(K(K({}, e), {}, { scaleX: 1, scaleY: 1 })), s = Qr(this.points.map((c) => qn(c, o, !0))), a = new ce(this.scaleX, this.scaleY);
    let l = r.left + r.width / 2, u = r.top + r.height / 2;
    return this.exactBoundingBox && (l -= u * Math.tan(un(this.skewX)), u -= l * Math.tan(un(this.skewY))), K(K({}, r), {}, { pathOffset: new ce(l, u), strokeOffset: new ce(s.left, s.top).subtract(new ce(r.left, r.top)).multiply(a), strokeDiff: new ce(r.width, r.height).subtract(new ce(s.width, s.height)).multiply(a) });
  }
  _findCenterFromElement() {
    const e = Qr(this.points);
    return new ce(e.left + e.width / 2, e.top + e.height / 2);
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { left: n, top: r, width: o, height: s, pathOffset: a, strokeOffset: l, strokeDiff: u } = this._calcDimensions();
    this.set({ width: o, height: s, pathOffset: a, strokeOffset: l, strokeDiff: u }), e && this.setPositionByOrigin(new ce(n + o / 2, r + s / 2), ut, ut);
  }
  isStrokeAccountedForInDimensions() {
    return this.exactBoundingBox;
  }
  _getNonTransformedDimensions() {
    return this.exactBoundingBox ? new ce(this.width, this.height) : super._getNonTransformedDimensions();
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this.exactBoundingBox) {
      let a;
      if (Object.keys(e).some((l) => this.strokeUniform || this.constructor.layoutProperties.includes(l))) {
        var n, r;
        const { width: l, height: u } = this._calcDimensions(e);
        a = new ce((n = e.width) !== null && n !== void 0 ? n : l, (r = e.height) !== null && r !== void 0 ? r : u);
      } else {
        var o, s;
        a = new ce((o = e.width) !== null && o !== void 0 ? o : this.width, (s = e.height) !== null && s !== void 0 ? s : this.height);
      }
      return a.multiply(new ce(e.scaleX || this.scaleX, e.scaleY || this.scaleY));
    }
    return super._getTransformedDimensions(e);
  }
  _set(e, n) {
    const r = this.initialized && this[e] !== n, o = super._set(e, n);
    return this.exactBoundingBox && r && ((e === ni || e === Si) && this.strokeUniform && this.constructor.layoutProperties.includes("strokeUniform") || this.constructor.layoutProperties.includes(e)) && this.setDimensions(), o;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return K(K({}, super.toObject(e)), {}, { points: this.points.map((n) => {
      let { x: r, y: o } = n;
      return { x: r, y: o };
    }) });
  }
  _toSVG() {
    const e = [], n = this.pathOffset.x, r = this.pathOffset.y, o = kt.NUM_FRACTION_DIGITS;
    for (let s = 0, a = this.points.length; s < a; s++) e.push(Nt(this.points[s].x - n, o), ",", Nt(this.points[s].y - r, o), " ");
    return ["<".concat(this.constructor.type.toLowerCase(), " "), "COMMON_PARTS", 'points="'.concat(e.join(""), `" />
`)];
  }
  _render(e) {
    const n = this.points.length, r = this.pathOffset.x, o = this.pathOffset.y;
    if (n && !isNaN(this.points[n - 1].y)) {
      e.beginPath(), e.moveTo(this.points[0].x - r, this.points[0].y - o);
      for (let s = 0; s < n; s++) {
        const a = this.points[s];
        e.lineTo(a.x - r, a.y - o);
      }
      !this.isOpen() && e.closePath(), this._renderPaintInOrder(e);
    }
  }
  complexity() {
    return this.points.length;
  }
  static async fromElement(e, n, r) {
    return new this(XL(e.getAttribute("points")), K(K({}, zt(uo(e, this.ATTRIBUTE_NAMES, r), YL)), n));
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "points" });
  }
}
Y(Ii, "ownDefaults", v1), Y(Ii, "type", "Polyline"), Y(Ii, "layoutProperties", [ka, Oa, "strokeLineCap", "strokeLineJoin", "strokeMiterLimit", "strokeWidth", "strokeUniform", "points"]), Y(Ii, "cacheProperties", [...lo, "points"]), Y(Ii, "ATTRIBUTE_NAMES", [...Bo]), Ne.setClass(Ii), Ne.setSVGClass(Ii);
class Vu extends Ii {
  isOpen() {
    return !1;
  }
}
Y(Vu, "ownDefaults", v1), Y(Vu, "type", "Polygon"), Ne.setClass(Vu), Ne.setSVGClass(Vu);
class y1 extends An {
  isEmptyStyles(e) {
    if (!this.styles || e !== void 0 && !this.styles[e]) return !0;
    const n = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const r in n) for (const o in n[r]) for (const s in n[r][o]) return !1;
    return !0;
  }
  styleHas(e, n) {
    if (!this.styles || n !== void 0 && !this.styles[n]) return !1;
    const r = n === void 0 ? this.styles : { 0: this.styles[n] };
    for (const o in r) for (const s in r[o]) if (r[o][s][e] !== void 0) return !0;
    return !1;
  }
  cleanStyle(e) {
    if (!this.styles) return !1;
    const n = this.styles;
    let r, o, s = 0, a = !0, l = 0;
    for (const u in n) {
      r = 0;
      for (const c in n[u]) {
        const d = n[u][c] || {};
        s++, d[e] !== void 0 ? (o ? d[e] !== o && (a = !1) : o = d[e], d[e] === this[e] && delete d[e]) : a = !1, Object.keys(d).length !== 0 ? r++ : delete n[u][c];
      }
      r === 0 && delete n[u];
    }
    for (let u = 0; u < this._textLines.length; u++) l += this._textLines[u].length;
    a && s === l && (this[e] = o, this.removeStyle(e));
  }
  removeStyle(e) {
    if (!this.styles) return;
    const n = this.styles;
    let r, o, s;
    for (o in n) {
      for (s in r = n[o], r) delete r[s][e], Object.keys(r[s]).length === 0 && delete r[s];
      Object.keys(r).length === 0 && delete n[o];
    }
  }
  _extendStyles(e, n) {
    const { lineIndex: r, charIndex: o } = this.get2DCursorLocation(e);
    this._getLineStyle(r) || this._setLineStyle(r);
    const s = dp(K(K({}, this._getStyleDeclaration(r, o)), n), (a) => a !== void 0);
    this._setStyleDeclaration(r, o, s);
  }
  getSelectionStyles(e, n, r) {
    const o = [];
    for (let s = e; s < (n || e); s++) o.push(this.getStyleAtPosition(s, r));
    return o;
  }
  getStyleAtPosition(e, n) {
    const { lineIndex: r, charIndex: o } = this.get2DCursorLocation(e);
    return n ? this.getCompleteStyleDeclaration(r, o) : this._getStyleDeclaration(r, o);
  }
  setSelectionStyles(e, n, r) {
    for (let o = n; o < (r || n); o++) this._extendStyles(o, e);
    this._forceClearCache = !0;
  }
  _getStyleDeclaration(e, n) {
    var r;
    const o = this.styles && this.styles[e];
    return o && (r = o[n]) !== null && r !== void 0 ? r : {};
  }
  getCompleteStyleDeclaration(e, n) {
    return K(K({}, Ta(this, this.constructor._styleProperties)), this._getStyleDeclaration(e, n));
  }
  _setStyleDeclaration(e, n, r) {
    this.styles[e][n] = r;
  }
  _deleteStyleDeclaration(e, n) {
    delete this.styles[e][n];
  }
  _getLineStyle(e) {
    return !!this.styles[e];
  }
  _setLineStyle(e) {
    this.styles[e] = {};
  }
  _deleteLineStyle(e) {
    delete this.styles[e];
  }
}
Y(y1, "_styleProperties", Q3);
const KL = /  +/g, qL = /"/g;
function fh(i, e, n, r, o) {
  return "		".concat(function(s, a) {
    let { left: l, top: u, width: c, height: d } = a, h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : kt.NUM_FRACTION_DIGITS;
    const p = Il(yn, s, !1), [m, v, y, w] = [l, u, c, d].map((g) => Nt(g, h));
    return "<rect ".concat(p, ' x="').concat(m, '" y="').concat(v, '" width="').concat(y, '" height="').concat(w, '"></rect>');
  }(i, { left: e, top: n, width: r, height: o }), `
`);
}
const ZL = ["textAnchor", "textDecoration", "dx", "dy", "top", "left", "fontSize", "strokeWidth"];
let ph;
class Nn extends y1 {
  static getDefaults() {
    return K(K({}, super.getDefaults()), Nn.ownDefaults);
  }
  constructor(e, n) {
    super(), Y(this, "__charBounds", []), Object.assign(this, Nn.ownDefaults), this.setOptions(n), this.styles || (this.styles = {}), this.text = e, this.initialized = !0, this.path && this.setPathInfo(), this.initDimensions(), this.setCoords();
  }
  setPathInfo() {
    const e = this.path;
    e && (e.segmentsInfo = u1(e.path));
  }
  _splitText() {
    const e = this._splitTextIntoLines(this.text);
    return this.textLines = e.lines, this._textLines = e.graphemeLines, this._unwrappedTextLines = e._unwrappedLines, this._text = e.graphemeText, e;
  }
  initDimensions() {
    this._splitText(), this._clearCache(), this.dirty = !0, this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.includes(mr) && this.enlargeSpaces();
  }
  enlargeSpaces() {
    let e, n, r, o, s, a, l;
    for (let u = 0, c = this._textLines.length; u < c; u++) if ((this.textAlign === mr || u !== c - 1 && !this.isEndOfWrapping(u)) && (o = 0, s = this._textLines[u], n = this.getLineWidth(u), n < this.width && (l = this.textLines[u].match(this._reSpacesAndTabs)))) {
      r = l.length, e = (this.width - n) / r;
      for (let d = 0; d <= s.length; d++) a = this.__charBounds[u][d], this._reSpaceAndTab.test(s[d]) ? (a.width += e, a.kernedWidth += e, a.left += o, o += e) : a.left += o;
    }
  }
  isEndOfWrapping(e) {
    return e === this._textLines.length - 1;
  }
  missingNewlineOffset(e) {
    return 1;
  }
  get2DCursorLocation(e, n) {
    const r = n ? this._unwrappedTextLines : this._textLines;
    let o;
    for (o = 0; o < r.length; o++) {
      if (e <= r[o].length) return { lineIndex: o, charIndex: e };
      e -= r[o].length + this.missingNewlineOffset(o, n);
    }
    return { lineIndex: o - 1, charIndex: r[o - 1].length < e ? r[o - 1].length : e };
  }
  toString() {
    return "#<Text (".concat(this.complexity(), '): { "text": "').concat(this.text, '", "fontFamily": "').concat(this.fontFamily, '" }>');
  }
  _getCacheCanvasDimensions() {
    const e = super._getCacheCanvasDimensions(), n = this.fontSize;
    return e.width += n * e.zoomX, e.height += n * e.zoomY, e;
  }
  _render(e) {
    const n = this.path;
    n && !n.isNotVisible() && n._render(e), this._setTextStyles(e), this._renderTextLinesBackground(e), this._renderTextDecoration(e, "underline"), this._renderText(e), this._renderTextDecoration(e, "overline"), this._renderTextDecoration(e, "linethrough");
  }
  _renderText(e) {
    this.paintFirst === ti ? (this._renderTextStroke(e), this._renderTextFill(e)) : (this._renderTextFill(e), this._renderTextStroke(e));
  }
  _setTextStyles(e, n, r) {
    if (e.textBaseline = "alphabetic", this.path) switch (this.pathAlign) {
      case ut:
        e.textBaseline = "middle";
        break;
      case "ascender":
        e.textBaseline = Qn;
        break;
      case "descender":
        e.textBaseline = Yh;
    }
    e.font = this._getFontDeclaration(n, r);
  }
  calcTextWidth() {
    let e = this.getLineWidth(0);
    for (let n = 1, r = this._textLines.length; n < r; n++) {
      const o = this.getLineWidth(n);
      o > e && (e = o);
    }
    return e;
  }
  _renderTextLine(e, n, r, o, s, a) {
    this._renderChars(e, n, r, o, s, a);
  }
  _renderTextLinesBackground(e) {
    if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor")) return;
    const n = e.fillStyle, r = this._getLeftOffset();
    let o = this._getTopOffset();
    for (let s = 0, a = this._textLines.length; s < a; s++) {
      const l = this.getHeightOfLine(s);
      if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", s)) {
        o += l;
        continue;
      }
      const u = this._textLines[s].length, c = this._getLineLeftOffset(s);
      let d, h, p = 0, m = 0, v = this.getValueOfPropertyAt(s, 0, "textBackgroundColor");
      const y = this.getHeightOfLineImpl(s);
      for (let w = 0; w < u; w++) {
        const g = this.__charBounds[s][w];
        h = this.getValueOfPropertyAt(s, w, "textBackgroundColor"), this.path ? (e.save(), e.translate(g.renderLeft, g.renderTop), e.rotate(g.angle), e.fillStyle = h, h && e.fillRect(-g.width / 2, -y * (1 - this._fontSizeFraction), g.width, y), e.restore()) : h !== v ? (d = r + c + m, this.direction === "rtl" && (d = this.width - d - p), e.fillStyle = v, v && e.fillRect(d, o, p, y), m = g.left, p = g.width, v = h) : p += g.kernedWidth;
      }
      h && !this.path && (d = r + c + m, this.direction === "rtl" && (d = this.width - d - p), e.fillStyle = h, e.fillRect(d, o, p, y)), o += l;
    }
    e.fillStyle = n, this._removeShadow(e);
  }
  _measureChar(e, n, r, o) {
    const s = hl.getFontCache(n), a = this._getFontDeclaration(n), l = r + e, u = r && a === this._getFontDeclaration(o), c = n.fontSize / this.CACHE_FONT_SIZE;
    let d, h, p, m;
    if (r && s.has(r) && (p = s.get(r)), s.has(e) && (m = d = s.get(e)), u && s.has(l) && (h = s.get(l), m = h - p), d === void 0 || p === void 0 || h === void 0) {
      const v = function() {
        return ph || (ph = Ci({ width: 0, height: 0 }).getContext("2d")), ph;
      }();
      this._setTextStyles(v, n, !0), d === void 0 && (m = d = v.measureText(e).width, s.set(e, d)), p === void 0 && u && r && (p = v.measureText(r).width, s.set(r, p)), u && h === void 0 && (h = v.measureText(l).width, s.set(l, h), m = h - p);
    }
    return { width: d * c, kernedWidth: m * c };
  }
  getHeightOfChar(e, n) {
    return this.getValueOfPropertyAt(e, n, "fontSize");
  }
  measureLine(e) {
    const n = this._measureLine(e);
    return this.charSpacing !== 0 && (n.width -= this._getWidthOfCharSpacing()), n.width < 0 && (n.width = 0), n;
  }
  _measureLine(e) {
    let n, r, o = 0;
    const s = this.pathSide === an, a = this.path, l = this._textLines[e], u = l.length, c = new Array(u);
    this.__charBounds[e] = c;
    for (let d = 0; d < u; d++) {
      const h = l[d];
      r = this._getGraphemeBox(h, e, d, n), c[d] = r, o += r.kernedWidth, n = h;
    }
    if (c[u] = { left: r ? r.left + r.width : 0, width: 0, kernedWidth: 0, height: this.fontSize, deltaY: 0 }, a && a.segmentsInfo) {
      let d = 0;
      const h = a.segmentsInfo[a.segmentsInfo.length - 1].length;
      switch (this.textAlign) {
        case Tt:
          d = s ? h - o : 0;
          break;
        case ut:
          d = (h - o) / 2;
          break;
        case an:
          d = s ? 0 : h - o;
      }
      d += this.pathStartOffset * (s ? -1 : 1);
      for (let p = s ? u - 1 : 0; s ? p >= 0 : p < u; s ? p-- : p++) r = c[p], d > h ? d %= h : d < 0 && (d += h), this._setGraphemeOnPath(d, r), d += r.kernedWidth;
    }
    return { width: o, numOfSpaces: 0 };
  }
  _setGraphemeOnPath(e, n) {
    const r = e + n.kernedWidth / 2, o = this.path, s = kL(o.path, r, o.segmentsInfo);
    n.renderLeft = s.x - o.pathOffset.x, n.renderTop = s.y - o.pathOffset.y, n.angle = s.angle + (this.pathSide === an ? Math.PI : 0);
  }
  _getGraphemeBox(e, n, r, o, s) {
    const a = this.getCompleteStyleDeclaration(n, r), l = o ? this.getCompleteStyleDeclaration(n, r - 1) : {}, u = this._measureChar(e, a, o, l);
    let c, d = u.kernedWidth, h = u.width;
    this.charSpacing !== 0 && (c = this._getWidthOfCharSpacing(), h += c, d += c);
    const p = { width: h, left: 0, height: a.fontSize, kernedWidth: d, deltaY: a.deltaY };
    if (r > 0 && !s) {
      const m = this.__charBounds[n][r - 1];
      p.left = m.left + m.width + u.kernedWidth - u.width;
    }
    return p;
  }
  getHeightOfLineImpl(e) {
    const n = this.__lineHeights;
    if (n[e]) return n[e];
    let r = this.getHeightOfChar(e, 0);
    for (let o = 1, s = this._textLines[e].length; o < s; o++) r = Math.max(this.getHeightOfChar(e, o), r);
    return n[e] = r * this._fontSizeMult;
  }
  getHeightOfLine(e) {
    return this.getHeightOfLineImpl(e) * this.lineHeight;
  }
  calcTextHeight() {
    let e = 0;
    for (let n = 0, r = this._textLines.length; n < r; n++) e += n === r - 1 ? this.getHeightOfLineImpl(n) : this.getHeightOfLine(n);
    return e;
  }
  _getLeftOffset() {
    return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
  }
  _getTopOffset() {
    return -this.height / 2;
  }
  _renderTextCommon(e, n) {
    e.save();
    let r = 0;
    const o = this._getLeftOffset(), s = this._getTopOffset();
    for (let a = 0, l = this._textLines.length; a < l; a++) this._renderTextLine(n, e, this._textLines[a], o + this._getLineLeftOffset(a), s + r + this.getHeightOfLineImpl(a), a), r += this.getHeightOfLine(a);
    e.restore();
  }
  _renderTextFill(e) {
    (this.fill || this.styleHas(yn)) && this._renderTextCommon(e, "fillText");
  }
  _renderTextStroke(e) {
    (this.stroke && this.strokeWidth !== 0 || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this._setLineDash(e, this.strokeDashArray), e.beginPath(), this._renderTextCommon(e, "strokeText"), e.closePath(), e.restore());
  }
  _renderChars(e, n, r, o, s, a) {
    const l = this.textAlign.includes(mr), u = this.path, c = !l && this.charSpacing === 0 && this.isEmptyStyles(a) && !u, d = this.direction === "ltr", h = this.direction === "ltr" ? 1 : -1, p = n.direction;
    let m, v, y, w, g, k = "", _ = 0;
    if (n.save(), p !== this.direction && (n.canvas.setAttribute("dir", d ? "ltr" : "rtl"), n.direction = d ? "ltr" : "rtl", n.textAlign = d ? Tt : an), s -= this.getHeightOfLineImpl(a) * this._fontSizeFraction, c) return this._renderChar(e, n, a, 0, r.join(""), o, s), void n.restore();
    for (let S = 0, b = r.length - 1; S <= b; S++) w = S === b || this.charSpacing || u, k += r[S], y = this.__charBounds[a][S], _ === 0 ? (o += h * (y.kernedWidth - y.width), _ += y.width) : _ += y.kernedWidth, l && !w && this._reSpaceAndTab.test(r[S]) && (w = !0), w || (m = m || this.getCompleteStyleDeclaration(a, S), v = this.getCompleteStyleDeclaration(a, S + 1), w = bp(m, v, !1)), w && (u ? (n.save(), n.translate(y.renderLeft, y.renderTop), n.rotate(y.angle), this._renderChar(e, n, a, S, k, -_ / 2, 0), n.restore()) : (g = o, this._renderChar(e, n, a, S, k, g, s)), k = "", m = v, o += h * _, _ = 0);
    n.restore();
  }
  _applyPatternGradientTransformText(e) {
    const n = this.width + this.strokeWidth, r = this.height + this.strokeWidth, o = Ci({ width: n, height: r }), s = o.getContext("2d");
    return o.width = n, o.height = r, s.beginPath(), s.moveTo(0, 0), s.lineTo(n, 0), s.lineTo(n, r), s.lineTo(0, r), s.closePath(), s.translate(n / 2, r / 2), s.fillStyle = e.toLive(s), this._applyPatternGradientTransform(s, e), s.fill(), s.createPattern(o, "no-repeat");
  }
  handleFiller(e, n, r) {
    let o, s;
    return xi(r) ? r.gradientUnits === "percentage" || r.gradientTransform || r.patternTransform ? (o = -this.width / 2, s = -this.height / 2, e.translate(o, s), e[n] = this._applyPatternGradientTransformText(r), { offsetX: o, offsetY: s }) : (e[n] = r.toLive(e), this._applyPatternGradientTransform(e, r)) : (e[n] = r, { offsetX: 0, offsetY: 0 });
  }
  _setStrokeStyles(e, n) {
    let { stroke: r, strokeWidth: o } = n;
    return e.lineWidth = o, e.lineCap = this.strokeLineCap, e.lineDashOffset = this.strokeDashOffset, e.lineJoin = this.strokeLineJoin, e.miterLimit = this.strokeMiterLimit, this.handleFiller(e, "strokeStyle", r);
  }
  _setFillStyles(e, n) {
    let { fill: r } = n;
    return this.handleFiller(e, "fillStyle", r);
  }
  _renderChar(e, n, r, o, s, a, l) {
    const u = this._getStyleDeclaration(r, o), c = this.getCompleteStyleDeclaration(r, o), d = e === "fillText" && c.fill, h = e === "strokeText" && c.stroke && c.strokeWidth;
    if (h || d) {
      if (n.save(), n.font = this._getFontDeclaration(c), u.textBackgroundColor && this._removeShadow(n), u.deltaY && (l += u.deltaY), d) {
        const p = this._setFillStyles(n, c);
        n.fillText(s, a - p.offsetX, l - p.offsetY);
      }
      if (h) {
        const p = this._setStrokeStyles(n, c);
        n.strokeText(s, a - p.offsetX, l - p.offsetY);
      }
      n.restore();
    }
  }
  setSuperscript(e, n) {
    this._setScript(e, n, this.superscript);
  }
  setSubscript(e, n) {
    this._setScript(e, n, this.subscript);
  }
  _setScript(e, n, r) {
    const o = this.get2DCursorLocation(e, !0), s = this.getValueOfPropertyAt(o.lineIndex, o.charIndex, "fontSize"), a = this.getValueOfPropertyAt(o.lineIndex, o.charIndex, "deltaY"), l = { fontSize: s * r.size, deltaY: a + s * r.baseline };
    this.setSelectionStyles(l, e, n);
  }
  _getLineLeftOffset(e) {
    const n = this.getLineWidth(e), r = this.width - n, o = this.textAlign, s = this.direction, a = this.isEndOfWrapping(e);
    let l = 0;
    return o === mr || o === pl && !a || o === fl && !a || o === qc && !a ? 0 : (o === ut && (l = r / 2), o === an && (l = r), o === pl && (l = r / 2), o === fl && (l = r), s === "rtl" && (o === an || o === mr || o === fl ? l = 0 : o === Tt || o === qc ? l = -r : o !== ut && o !== pl || (l = -r / 2)), l);
  }
  _clearCache() {
    this._forceClearCache = !1, this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
  }
  getLineWidth(e) {
    if (this.__lineWidths[e] !== void 0) return this.__lineWidths[e];
    const { width: n } = this.measureLine(e);
    return this.__lineWidths[e] = n, n;
  }
  _getWidthOfCharSpacing() {
    return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0;
  }
  getValueOfPropertyAt(e, n, r) {
    var o;
    return (o = this._getStyleDeclaration(e, n)[r]) !== null && o !== void 0 ? o : this[r];
  }
  _renderTextDecoration(e, n) {
    if (!this[n] && !this.styleHas(n)) return;
    let r = this._getTopOffset();
    const o = this._getLeftOffset(), s = this.path, a = this._getWidthOfCharSpacing(), l = n === "linethrough" ? 0.5 : n === "overline" ? 1 : 0, u = this.offsets[n];
    for (let c = 0, d = this._textLines.length; c < d; c++) {
      const h = this.getHeightOfLine(c);
      if (!this[n] && !this.styleHas(n, c)) {
        r += h;
        continue;
      }
      const p = this._textLines[c], m = h / this.lineHeight, v = this._getLineLeftOffset(c);
      let y = 0, w = 0, g = this.getValueOfPropertyAt(c, 0, n), k = this.getValueOfPropertyAt(c, 0, yn), _ = this.getValueOfPropertyAt(c, 0, Ps), S = g, b = k, C = _;
      const x = r + m * (1 - this._fontSizeFraction);
      let I = this.getHeightOfChar(c, 0), F = this.getValueOfPropertyAt(c, 0, "deltaY");
      for (let j = 0, ee = p.length; j < ee; j++) {
        const ie = this.__charBounds[c][j];
        S = this.getValueOfPropertyAt(c, j, n), b = this.getValueOfPropertyAt(c, j, yn), C = this.getValueOfPropertyAt(c, j, Ps);
        const M = this.getHeightOfChar(c, j), W = this.getValueOfPropertyAt(c, j, "deltaY");
        if (s && S && b) {
          const R = this.fontSize * C / 1e3;
          e.save(), e.fillStyle = k, e.translate(ie.renderLeft, ie.renderTop), e.rotate(ie.angle), e.fillRect(-ie.kernedWidth / 2, u * M + W - l * R, ie.kernedWidth, R), e.restore();
        } else if ((S !== g || b !== k || M !== I || C !== _ || W !== F) && w > 0) {
          const R = this.fontSize * _ / 1e3;
          let V = o + v + y;
          this.direction === "rtl" && (V = this.width - V - w), g && k && _ && (e.fillStyle = k, e.fillRect(V, x + u * I + F - l * R, w, R)), y = ie.left, w = ie.width, g = S, _ = C, k = b, I = M, F = W;
        } else w += ie.kernedWidth;
      }
      let B = o + v + y;
      this.direction === "rtl" && (B = this.width - B - w), e.fillStyle = b;
      const X = this.fontSize * C / 1e3;
      S && b && C && e.fillRect(B, x + u * I + F - l * X, w - a, X), r += h;
    }
    this._removeShadow(e);
  }
  _getFontDeclaration() {
    let { fontFamily: e = this.fontFamily, fontStyle: n = this.fontStyle, fontWeight: r = this.fontWeight, fontSize: o = this.fontSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 ? arguments[1] : void 0;
    const a = e.includes("'") || e.includes('"') || e.includes(",") || Nn.genericFonts.includes(e.toLowerCase()) ? e : '"'.concat(e, '"');
    return [n, r, "".concat(s ? this.CACHE_FONT_SIZE : o, "px"), a].join(" ");
  }
  render(e) {
    this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._forceClearCache && this.initDimensions(), super.render(e)));
  }
  graphemeSplit(e) {
    return yp(e);
  }
  _splitTextIntoLines(e) {
    const n = e.split(this._reNewline), r = new Array(n.length), o = [`
`];
    let s = [];
    for (let a = 0; a < n.length; a++) r[a] = this.graphemeSplit(n[a]), s = s.concat(r[a], o);
    return s.pop(), { _unwrappedLines: r, lines: n, graphemeText: s, graphemeLines: r };
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return K(K({}, super.toObject([...Wb, ...e])), {}, { styles: z4(this.styles, this.text) }, this.path ? { path: this.path.toObject() } : {});
  }
  set(e, n) {
    const { textLayoutProperties: r } = this.constructor;
    super.set(e, n);
    let o = !1, s = !1;
    if (typeof e == "object") for (const a in e) a === "path" && this.setPathInfo(), o = o || r.includes(a), s = s || a === "path";
    else o = r.includes(e), s = e === "path";
    return s && this.setPathInfo(), o && this.initialized && (this.initDimensions(), this.setCoords()), this;
  }
  complexity() {
    return 1;
  }
  static async fromElement(e, n, r) {
    const o = uo(e, Nn.ATTRIBUTE_NAMES, r), s = K(K({}, n), o), { textAnchor: a = Tt, textDecoration: l = "", dx: u = 0, dy: c = 0, top: d = 0, left: h = 0, fontSize: p = op, strokeWidth: m = 1 } = s, v = zt(s, ZL), y = new this(Kc(e.textContent || "").trim(), K({ left: h + u, top: d + c, underline: l.includes("underline"), overline: l.includes("overline"), linethrough: l.includes("line-through"), strokeWidth: 0, fontSize: p }, v)), w = y.getScaledHeight() / y.height, g = ((y.height + y.strokeWidth) * y.lineHeight - y.height) * w, k = y.getScaledHeight() + g;
    let _ = 0;
    return a === ut && (_ = y.getScaledWidth() / 2), a === an && (_ = y.getScaledWidth()), y.set({ left: y.left - _, top: y.top - (k - y.fontSize * (0.07 + y._fontSizeFraction)) / y.lineHeight, strokeWidth: m }), y;
  }
  static fromObject(e) {
    return this._fromObject(K(K({}, e), {}, { styles: B4(e.styles || {}, e.text) }), { extraParam: "text" });
  }
}
Y(Nn, "textLayoutProperties", Ub), Y(Nn, "cacheProperties", [...lo, ...Wb]), Y(Nn, "ownDefaults", e4), Y(Nn, "type", "Text"), Y(Nn, "genericFonts", ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), Y(Nn, "ATTRIBUTE_NAMES", Bo.concat("x", "y", "dx", "dy", "font-family", "font-style", "font-weight", "font-size", "letter-spacing", "text-decoration", "text-anchor")), e1(Nn, [class extends zb {
  _toSVG() {
    const i = this._getSVGLeftTopOffsets(), e = this._getSVGTextAndBg(i.textTop, i.textLeft);
    return this._wrapSVGTextAndBg(e);
  }
  toSVG(i) {
    const e = this._createBaseSVGMarkup(this._toSVG(), { reviver: i, noStyle: !0, withShadow: !0 }), n = this.path;
    return n ? e + n._createBaseSVGMarkup(n._toSVG(), { reviver: i, withShadow: !0, additionalTransform: Pl(this.calcOwnMatrix()) }) : e;
  }
  _getSVGLeftTopOffsets() {
    return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) };
  }
  _wrapSVGTextAndBg(i) {
    let { textBgRects: e, textSpans: n } = i;
    const r = this.getSvgTextDecoration(this);
    return [e.join(""), '		<text xml:space="preserve" ', 'font-family="'.concat(this.fontFamily.replace(qL, "'"), '" '), 'font-size="'.concat(this.fontSize, '" '), this.fontStyle ? 'font-style="'.concat(this.fontStyle, '" ') : "", this.fontWeight ? 'font-weight="'.concat(this.fontWeight, '" ') : "", r ? 'text-decoration="'.concat(r, '" ') : "", this.direction === "rtl" ? 'direction="'.concat(this.direction, '" ') : "", 'style="', this.getSvgStyles(!0), '"', this.addPaintOrder(), " >", n.join(""), `</text>
`];
  }
  _getSVGTextAndBg(i, e) {
    const n = [], r = [];
    let o, s = i;
    this.backgroundColor && r.push(...fh(this.backgroundColor, -this.width / 2, -this.height / 2, this.width, this.height));
    for (let a = 0, l = this._textLines.length; a < l; a++) o = this._getLineLeftOffset(a), this.direction === "rtl" && (o += this.width), (this.textBackgroundColor || this.styleHas("textBackgroundColor", a)) && this._setSVGTextLineBg(r, a, e + o, s), this._setSVGTextLineText(n, a, e + o, s), s += this.getHeightOfLine(a);
    return { textSpans: n, textBgRects: r };
  }
  _createTextCharSpan(i, e, n, r, o) {
    const s = kt.NUM_FRACTION_DIGITS, a = this.getSvgSpanStyles(e, i !== i.trim() || !!i.match(KL)), l = a ? 'style="'.concat(a, '"') : "", u = e.deltaY, c = u ? ' dy="'.concat(Nt(u, s), '" ') : "", { angle: d, renderLeft: h, renderTop: p, width: m } = o;
    let v = "";
    if (h !== void 0) {
      const y = m / 2;
      d && (v = ' rotate="'.concat(Nt(oo(d), s), '"'));
      const w = Ea({ angle: oo(d) });
      w[4] = h, w[5] = p;
      const g = new ce(-y, 0).transform(w);
      n = g.x, r = g.y;
    }
    return '<tspan x="'.concat(Nt(n, s), '" y="').concat(Nt(r, s), '" ').concat(c).concat(v).concat(l, ">").concat(j4(i), "</tspan>");
  }
  _setSVGTextLineText(i, e, n, r) {
    const o = this.getHeightOfLine(e), s = this.textAlign.includes(mr), a = this._textLines[e];
    let l, u, c, d, h, p = "", m = 0;
    r += o * (1 - this._fontSizeFraction) / this.lineHeight;
    for (let v = 0, y = a.length - 1; v <= y; v++) h = v === y || this.charSpacing || this.path, p += a[v], c = this.__charBounds[e][v], m === 0 ? (n += c.kernedWidth - c.width, m += c.width) : m += c.kernedWidth, s && !h && this._reSpaceAndTab.test(a[v]) && (h = !0), h || (l = l || this.getCompleteStyleDeclaration(e, v), u = this.getCompleteStyleDeclaration(e, v + 1), h = bp(l, u, !0)), h && (d = this._getStyleDeclaration(e, v), i.push(this._createTextCharSpan(p, d, n, r, c)), p = "", l = u, this.direction === "rtl" ? n -= m : n += m, m = 0);
  }
  _setSVGTextLineBg(i, e, n, r) {
    const o = this._textLines[e], s = this.getHeightOfLine(e) / this.lineHeight;
    let a, l = 0, u = 0, c = this.getValueOfPropertyAt(e, 0, "textBackgroundColor");
    for (let d = 0; d < o.length; d++) {
      const { left: h, width: p, kernedWidth: m } = this.__charBounds[e][d];
      a = this.getValueOfPropertyAt(e, d, "textBackgroundColor"), a !== c ? (c && i.push(...fh(c, n + u, r, l, s)), u = h, l = p, c = a) : l += m;
    }
    a && i.push(...fh(c, n + u, r, l, s));
  }
  _getSVGLineTopOffset(i) {
    let e, n = 0;
    for (e = 0; e < i; e++) n += this.getHeightOfLine(e);
    const r = this.getHeightOfLine(e);
    return { lineTop: n, offset: (this._fontSizeMult - this._fontSizeFraction) * r / (this.lineHeight * this._fontSizeMult) };
  }
  getSvgStyles(i) {
    return "".concat(super.getSvgStyles(i), " text-decoration-thickness: ").concat(Nt(this.textDecorationThickness * this.getObjectScaling().y / 10, kt.NUM_FRACTION_DIGITS), "%; white-space: pre;");
  }
  getSvgSpanStyles(i, e) {
    const { fontFamily: n, strokeWidth: r, stroke: o, fill: s, fontSize: a, fontStyle: l, fontWeight: u, deltaY: c, textDecorationThickness: d, linethrough: h, overline: p, underline: m } = i, v = this.getSvgTextDecoration({ underline: m ?? this.underline, overline: p ?? this.overline, linethrough: h ?? this.linethrough }), y = d || this.textDecorationThickness;
    return [o ? Il(ti, o) : "", r ? "stroke-width: ".concat(r, "; ") : "", n ? "font-family: ".concat(n.includes("'") || n.includes('"') ? n : "'".concat(n, "'"), "; ") : "", a ? "font-size: ".concat(a, "px; ") : "", l ? "font-style: ".concat(l, "; ") : "", u ? "font-weight: ".concat(u, "; ") : "", v ? "text-decoration: ".concat(v, "; text-decoration-thickness: ").concat(Nt(y * this.getObjectScaling().y / 10, kt.NUM_FRACTION_DIGITS), "%; ") : "", s ? Il(yn, s) : "", c ? "baseline-shift: ".concat(-c, "; ") : "", e ? "white-space: pre; " : ""].join("");
  }
  getSvgTextDecoration(i) {
    return ["overline", "underline", "line-through"].filter((e) => i[e.replace("-", "")]).join(" ");
  }
}]), Ne.setClass(Nn), Ne.setSVGClass(Nn);
class JL {
  constructor(e) {
    Y(this, "target", void 0), Y(this, "__mouseDownInPlace", !1), Y(this, "__dragStartFired", !1), Y(this, "__isDraggingOver", !1), Y(this, "__dragStartSelection", void 0), Y(this, "__dragImageDisposer", void 0), Y(this, "_dispose", void 0), this.target = e;
    const n = [this.target.on("dragenter", this.dragEnterHandler.bind(this)), this.target.on("dragover", this.dragOverHandler.bind(this)), this.target.on("dragleave", this.dragLeaveHandler.bind(this)), this.target.on("dragend", this.dragEndHandler.bind(this)), this.target.on("drop", this.dropHandler.bind(this))];
    this._dispose = () => {
      n.forEach((r) => r()), this._dispose = void 0;
    };
  }
  isPointerOverSelection(e) {
    const n = this.target, r = n.getSelectionStartFromPointer(e);
    return n.isEditing && r >= n.selectionStart && r <= n.selectionEnd && n.selectionStart < n.selectionEnd;
  }
  start(e) {
    return this.__mouseDownInPlace = this.isPointerOverSelection(e);
  }
  isActive() {
    return this.__mouseDownInPlace;
  }
  end(e) {
    const n = this.isActive();
    return n && !this.__dragStartFired && (this.target.setCursorByClick(e), this.target.initDelayedCursor(!0)), this.__mouseDownInPlace = !1, this.__dragStartFired = !1, this.__isDraggingOver = !1, n;
  }
  getDragStartSelection() {
    return this.__dragStartSelection;
  }
  setDragImage(e, n) {
    var r;
    let { selectionStart: o, selectionEnd: s } = n;
    const a = this.target, l = a.canvas, u = new ce(a.flipX ? -1 : 1, a.flipY ? -1 : 1), c = a._getCursorBoundaries(o), d = new ce(c.left + c.leftOffset, c.top + c.topOffset).multiply(u).transform(a.calcTransformMatrix()), h = l.getScenePoint(e).subtract(d), p = a.getCanvasRetinaScaling(), m = a.getBoundingRect(), v = d.subtract(new ce(m.left, m.top)), y = l.viewportTransform, w = v.add(h).transform(y, !0), g = a.backgroundColor, k = vp(a.styles);
    a.backgroundColor = "";
    const _ = { stroke: "transparent", fill: "transparent", textBackgroundColor: "transparent" };
    a.setSelectionStyles(_, 0, o), a.setSelectionStyles(_, s, a.text.length), a.dirty = !0;
    const S = a.toCanvasElement({ enableRetinaScaling: l.enableRetinaScaling, viewportTransform: !0 });
    a.backgroundColor = g, a.styles = k, a.dirty = !0, rf(S, { position: "fixed", left: "".concat(-S.width, "px"), border: ei, width: "".concat(S.width / p, "px"), height: "".concat(S.height / p, "px") }), this.__dragImageDisposer && this.__dragImageDisposer(), this.__dragImageDisposer = () => {
      S.remove();
    }, Fi(e.target || this.target.hiddenTextarea).body.appendChild(S), (r = e.dataTransfer) === null || r === void 0 || r.setDragImage(S, w.x, w.y);
  }
  onDragStart(e) {
    this.__dragStartFired = !0;
    const n = this.target, r = this.isActive();
    if (r && e.dataTransfer) {
      const o = this.__dragStartSelection = { selectionStart: n.selectionStart, selectionEnd: n.selectionEnd }, s = n._text.slice(o.selectionStart, o.selectionEnd).join(""), a = K({ text: n.text, value: s }, o);
      e.dataTransfer.setData("text/plain", s), e.dataTransfer.setData("application/fabric", JSON.stringify({ value: s, styles: n.getSelectionStyles(o.selectionStart, o.selectionEnd, !0) })), e.dataTransfer.effectAllowed = "copyMove", this.setDragImage(e, a);
    }
    return n.abortCursorAnimation(), r;
  }
  canDrop(e) {
    if (this.target.editable && !this.target.getActiveControl() && !e.defaultPrevented) {
      if (this.isActive() && this.__dragStartSelection) {
        const n = this.target.getSelectionStartFromPointer(e), r = this.__dragStartSelection;
        return n < r.selectionStart || n > r.selectionEnd;
      }
      return !0;
    }
    return !1;
  }
  targetCanDrop(e) {
    return this.target.canDrop(e);
  }
  dragEnterHandler(e) {
    let { e: n } = e;
    const r = this.targetCanDrop(n);
    !this.__isDraggingOver && r && (this.__isDraggingOver = !0);
  }
  dragOverHandler(e) {
    const { e: n } = e, r = this.targetCanDrop(n);
    !this.__isDraggingOver && r ? this.__isDraggingOver = !0 : this.__isDraggingOver && !r && (this.__isDraggingOver = !1), this.__isDraggingOver && (n.preventDefault(), e.canDrop = !0, e.dropTarget = this.target);
  }
  dragLeaveHandler() {
    (this.__isDraggingOver || this.isActive()) && (this.__isDraggingOver = !1);
  }
  dropHandler(e) {
    var n;
    const { e: r } = e, o = r.defaultPrevented;
    this.__isDraggingOver = !1, r.preventDefault();
    let s = (n = r.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain");
    if (s && !o) {
      const a = this.target, l = a.canvas;
      let u = a.getSelectionStartFromPointer(r);
      const { styles: c } = r.dataTransfer.types.includes("application/fabric") ? JSON.parse(r.dataTransfer.getData("application/fabric")) : {}, d = s[Math.max(0, s.length - 1)], h = 0;
      if (this.__dragStartSelection) {
        const p = this.__dragStartSelection.selectionStart, m = this.__dragStartSelection.selectionEnd;
        u > p && u <= m ? u = p : u > m && (u -= m - p), a.removeChars(p, m), delete this.__dragStartSelection;
      }
      a._reNewline.test(d) && (a._reNewline.test(a._text[u]) || u === a._text.length) && (s = s.trimEnd()), e.didDrop = !0, e.dropTarget = a, a.insertChars(s, c, u), l.setActiveObject(a), a.enterEditing(r), a.selectionStart = Math.min(u + h, a._text.length), a.selectionEnd = Math.min(a.selectionStart + s.length, a._text.length), a.hiddenTextarea.value = a.text, a._updateTextarea(), a.hiddenTextarea.focus(), a.fire(Hc, { index: u + h, action: "drop" }), l.fire("text:changed", { target: a }), l.contextTopDirty = !0, l.requestRenderAll();
    }
  }
  dragEndHandler(e) {
    let { e: n } = e;
    if (this.isActive() && this.__dragStartFired && this.__dragStartSelection) {
      var r;
      const o = this.target, s = this.target.canvas, { selectionStart: a, selectionEnd: l } = this.__dragStartSelection, u = ((r = n.dataTransfer) === null || r === void 0 ? void 0 : r.dropEffect) || ei;
      u === ei ? (o.selectionStart = a, o.selectionEnd = l, o._updateTextarea(), o.hiddenTextarea.focus()) : (o.clearContextTop(), u === "move" && (o.removeChars(a, l), o.selectionStart = o.selectionEnd = a, o.hiddenTextarea && (o.hiddenTextarea.value = o.text), o._updateTextarea(), o.fire(Hc, { index: a, action: "dragend" }), s.fire("text:changed", { target: o }), s.requestRenderAll()), o.exitEditing());
    }
    this.__dragImageDisposer && this.__dragImageDisposer(), delete this.__dragImageDisposer, delete this.__dragStartSelection, this.__isDraggingOver = !1;
  }
  dispose() {
    this._dispose && this._dispose();
  }
}
const mv = /[ \n\.,;!\?\-]/;
class QL extends Nn {
  constructor() {
    super(...arguments), Y(this, "_currentCursorOpacity", 1);
  }
  initBehavior() {
    this._tick = this._tick.bind(this), this._onTickComplete = this._onTickComplete.bind(this), this.updateSelectionOnMouseMove = this.updateSelectionOnMouseMove.bind(this);
  }
  onDeselect(e) {
    return this.isEditing && this.exitEditing(), this.selected = !1, super.onDeselect(e);
  }
  _animateCursor(e) {
    let { toValue: n, duration: r, delay: o, onComplete: s } = e;
    return Kb({ startValue: this._currentCursorOpacity, endValue: n, duration: r, delay: o, onComplete: s, abort: () => !this.canvas || this.selectionStart !== this.selectionEnd, onChange: (a) => {
      this._currentCursorOpacity = a, this.renderCursorOrSelection();
    } });
  }
  _tick(e) {
    this._currentTickState = this._animateCursor({ toValue: 0, duration: this.cursorDuration / 2, delay: Math.max(e || 0, 100), onComplete: this._onTickComplete });
  }
  _onTickComplete() {
    var e;
    (e = this._currentTickCompleteState) === null || e === void 0 || e.abort(), this._currentTickCompleteState = this._animateCursor({ toValue: 1, duration: this.cursorDuration, onComplete: this._tick });
  }
  initDelayedCursor(e) {
    this.abortCursorAnimation(), this._tick(e ? 0 : this.cursorDelay);
  }
  abortCursorAnimation() {
    let e = !1;
    [this._currentTickState, this._currentTickCompleteState].forEach((n) => {
      n && !n.isDone() && (e = !0, n.abort());
    }), this._currentCursorOpacity = 1, e && this.clearContextTop();
  }
  restartCursorIfNeeded() {
    [this._currentTickState, this._currentTickCompleteState].some((e) => !e || e.isDone()) && this.initDelayedCursor();
  }
  selectAll() {
    return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  cmdAll() {
    this.selectAll(), this.renderCursorOrSelection();
  }
  getSelectedText() {
    return this._text.slice(this.selectionStart, this.selectionEnd).join("");
  }
  findWordBoundaryLeft(e) {
    let n = 0, r = e - 1;
    if (this._reSpace.test(this._text[r])) for (; this._reSpace.test(this._text[r]); ) n++, r--;
    for (; /\S/.test(this._text[r]) && r > -1; ) n++, r--;
    return e - n;
  }
  findWordBoundaryRight(e) {
    let n = 0, r = e;
    if (this._reSpace.test(this._text[r])) for (; this._reSpace.test(this._text[r]); ) n++, r++;
    for (; /\S/.test(this._text[r]) && r < this._text.length; ) n++, r++;
    return e + n;
  }
  findLineBoundaryLeft(e) {
    let n = 0, r = e - 1;
    for (; !/\n/.test(this._text[r]) && r > -1; ) n++, r--;
    return e - n;
  }
  findLineBoundaryRight(e) {
    let n = 0, r = e;
    for (; !/\n/.test(this._text[r]) && r < this._text.length; ) n++, r++;
    return e + n;
  }
  searchWordBoundary(e, n) {
    const r = this._text;
    let o = e > 0 && this._reSpace.test(r[e]) && (n === -1 || !sp.test(r[e - 1])) ? e - 1 : e, s = r[o];
    for (; o > 0 && o < r.length && !mv.test(s); ) o += n, s = r[o];
    return n === -1 && mv.test(s) && o++, o;
  }
  selectWord(e) {
    var n;
    e = (n = e) !== null && n !== void 0 ? n : this.selectionStart;
    const r = this.searchWordBoundary(e, -1), o = Math.max(r, this.searchWordBoundary(e, 1));
    this.selectionStart = r, this.selectionEnd = o, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
  }
  selectLine(e) {
    var n;
    e = (n = e) !== null && n !== void 0 ? n : this.selectionStart;
    const r = this.findLineBoundaryLeft(e), o = this.findLineBoundaryRight(e);
    this.selectionStart = r, this.selectionEnd = o, this._fireSelectionChanged(), this._updateTextarea();
  }
  enterEditing(e) {
    !this.isEditing && this.editable && (this.enterEditingImpl(), this.fire("editing:entered", e ? { e } : void 0), this._fireSelectionChanged(), this.canvas && (this.canvas.fire("text:editing:entered", { target: this, e }), this.canvas.requestRenderAll()));
  }
  enterEditingImpl() {
    this.canvas && (this.canvas.calcOffset(), this.canvas.textEditingManager.exitTextEditing()), this.isEditing = !0, this.initHiddenTextarea(), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick();
  }
  updateSelectionOnMouseMove(e) {
    if (this.getActiveControl()) return;
    const n = this.hiddenTextarea;
    Fi(n).activeElement !== n && n.focus();
    const r = this.getSelectionStartFromPointer(e), o = this.selectionStart, s = this.selectionEnd;
    (r === this.__selectionStartOnMouseDown && o !== s || o !== r && s !== r) && (r > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = r) : (this.selectionStart = r, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === o && this.selectionEnd === s || (this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
  }
  _setEditingProps() {
    this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;
  }
  fromStringToGraphemeSelection(e, n, r) {
    const o = r.slice(0, e), s = this.graphemeSplit(o).length;
    if (e === n) return { selectionStart: s, selectionEnd: s };
    const a = r.slice(e, n);
    return { selectionStart: s, selectionEnd: s + this.graphemeSplit(a).length };
  }
  fromGraphemeToStringSelection(e, n, r) {
    const o = r.slice(0, e).join("").length;
    return e === n ? { selectionStart: o, selectionEnd: o } : { selectionStart: o, selectionEnd: o + r.slice(e, n).join("").length };
  }
  _updateTextarea() {
    if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
      if (!this.inCompositionMode) {
        const e = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = e.selectionStart, this.hiddenTextarea.selectionEnd = e.selectionEnd;
      }
      this.updateTextareaPosition();
    }
  }
  updateFromTextArea() {
    if (!this.hiddenTextarea) return;
    this.cursorOffsetCache = {};
    const e = this.hiddenTextarea;
    this.text = e.value, this.set("dirty", !0), this.initDimensions(), this.setCoords();
    const n = this.fromStringToGraphemeSelection(e.selectionStart, e.selectionEnd, e.value);
    this.selectionEnd = this.selectionStart = n.selectionEnd, this.inCompositionMode || (this.selectionStart = n.selectionStart), this.updateTextareaPosition();
  }
  updateTextareaPosition() {
    if (this.selectionStart === this.selectionEnd) {
      const e = this._calcTextareaPosition();
      this.hiddenTextarea.style.left = e.left, this.hiddenTextarea.style.top = e.top;
    }
  }
  _calcTextareaPosition() {
    if (!this.canvas) return { left: "1px", top: "1px" };
    const e = this.inCompositionMode ? this.compositionStart : this.selectionStart, n = this._getCursorBoundaries(e), r = this.get2DCursorLocation(e), o = r.lineIndex, s = r.charIndex, a = this.getValueOfPropertyAt(o, s, "fontSize") * this.lineHeight, l = n.leftOffset, u = this.getCanvasRetinaScaling(), c = this.canvas.upperCanvasEl, d = c.width / u, h = c.height / u, p = d - a, m = h - a, v = new ce(n.left + l, n.top + n.topOffset + a).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new ce(c.clientWidth / d, c.clientHeight / h));
    return v.x < 0 && (v.x = 0), v.x > p && (v.x = p), v.y < 0 && (v.y = 0), v.y > m && (v.y = m), v.x += this.canvas._offset.left, v.y += this.canvas._offset.top, { left: "".concat(v.x, "px"), top: "".concat(v.y, "px"), fontSize: "".concat(a, "px"), charHeight: a };
  }
  _saveEditingProps() {
    this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor };
  }
  _restoreEditingProps() {
    this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor || this.canvas.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor || this.canvas.moveCursor), delete this._savedProps);
  }
  _exitEditing() {
    const e = this.hiddenTextarea;
    this.selected = !1, this.isEditing = !1, e && (e.blur && e.blur(), e.parentNode && e.parentNode.removeChild(e)), this.hiddenTextarea = null, this.abortCursorAnimation(), this.selectionStart !== this.selectionEnd && this.clearContextTop();
  }
  exitEditingImpl() {
    this._exitEditing(), this.selectionEnd = this.selectionStart, this._restoreEditingProps(), this._forceClearCache && (this.initDimensions(), this.setCoords());
  }
  exitEditing() {
    const e = this._textBeforeEdit !== this.text;
    return this.exitEditingImpl(), this.fire("editing:exited"), e && this.fire(Uc), this.canvas && (this.canvas.fire("text:editing:exited", { target: this }), e && this.canvas.fire("object:modified", { target: this })), this;
  }
  _removeExtraneousStyles() {
    for (const e in this.styles) this._textLines[e] || delete this.styles[e];
  }
  removeStyleFromTo(e, n) {
    const { lineIndex: r, charIndex: o } = this.get2DCursorLocation(e, !0), { lineIndex: s, charIndex: a } = this.get2DCursorLocation(n, !0);
    if (r !== s) {
      if (this.styles[r]) for (let l = o; l < this._unwrappedTextLines[r].length; l++) delete this.styles[r][l];
      if (this.styles[s]) for (let l = a; l < this._unwrappedTextLines[s].length; l++) {
        const u = this.styles[s][l];
        u && (this.styles[r] || (this.styles[r] = {}), this.styles[r][o + l - a] = u);
      }
      for (let l = r + 1; l <= s; l++) delete this.styles[l];
      this.shiftLineStyles(s, r - s);
    } else if (this.styles[r]) {
      const l = this.styles[r], u = a - o;
      for (let c = o; c < a; c++) delete l[c];
      for (const c in this.styles[r]) {
        const d = parseInt(c, 10);
        d >= a && (l[d - u] = l[c], delete l[c]);
      }
    }
  }
  shiftLineStyles(e, n) {
    const r = Object.assign({}, this.styles);
    for (const o in this.styles) {
      const s = parseInt(o, 10);
      s > e && (this.styles[s + n] = r[s], r[s - n] || delete this.styles[s]);
    }
  }
  insertNewlineStyleObject(e, n, r, o) {
    const s = {}, a = this._unwrappedTextLines[e].length, l = a === n;
    let u = !1;
    r || (r = 1), this.shiftLineStyles(e, r);
    const c = this.styles[e] ? this.styles[e][n === 0 ? n : n - 1] : void 0;
    for (const h in this.styles[e]) {
      const p = parseInt(h, 10);
      p >= n && (u = !0, s[p - n] = this.styles[e][h], l && n === 0 || delete this.styles[e][h]);
    }
    let d = !1;
    for (u && !l && (this.styles[e + r] = s, d = !0), (d || a > n) && r--; r > 0; ) o && o[r - 1] ? this.styles[e + r] = { 0: K({}, o[r - 1]) } : c ? this.styles[e + r] = { 0: K({}, c) } : delete this.styles[e + r], r--;
    this._forceClearCache = !0;
  }
  insertCharStyleObject(e, n, r, o) {
    this.styles || (this.styles = {});
    const s = this.styles[e], a = s ? K({}, s) : {};
    r || (r = 1);
    for (const u in a) {
      const c = parseInt(u, 10);
      c >= n && (s[c + r] = a[c], a[c - r] || delete s[c]);
    }
    if (this._forceClearCache = !0, o) {
      for (; r--; ) Object.keys(o[r]).length && (this.styles[e] || (this.styles[e] = {}), this.styles[e][n + r] = K({}, o[r]));
      return;
    }
    if (!s) return;
    const l = s[n ? n - 1 : 1];
    for (; l && r--; ) this.styles[e][n + r] = K({}, l);
  }
  insertNewStyleBlock(e, n, r) {
    const o = this.get2DCursorLocation(n, !0), s = [0];
    let a, l = 0;
    for (let u = 0; u < e.length; u++) e[u] === `
` ? (l++, s[l] = 0) : s[l]++;
    for (s[0] > 0 && (this.insertCharStyleObject(o.lineIndex, o.charIndex, s[0], r), r = r && r.slice(s[0] + 1)), l && this.insertNewlineStyleObject(o.lineIndex, o.charIndex + s[0], l), a = 1; a < l; a++) s[a] > 0 ? this.insertCharStyleObject(o.lineIndex + a, 0, s[a], r) : r && this.styles[o.lineIndex + a] && r[0] && (this.styles[o.lineIndex + a][0] = r[0]), r = r && r.slice(s[a] + 1);
    s[a] > 0 && this.insertCharStyleObject(o.lineIndex + a, 0, s[a], r);
  }
  removeChars(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e + 1;
    this.removeStyleFromTo(e, n), this._text.splice(e, n - e), this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  insertChars(e, n, r) {
    let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : r;
    o > r && this.removeStyleFromTo(r, o);
    const s = this.graphemeSplit(e);
    this.insertNewStyleBlock(s, r, n), this._text = [...this._text.slice(0, r), ...s, ...this._text.slice(o)], this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  setSelectionStartEndWithShift(e, n, r) {
    r <= e ? (n === e ? this._selectionDirection = Tt : this._selectionDirection === an && (this._selectionDirection = Tt, this.selectionEnd = e), this.selectionStart = r) : r > e && r < n ? this._selectionDirection === an ? this.selectionEnd = r : this.selectionStart = r : (n === e ? this._selectionDirection = an : this._selectionDirection === Tt && (this._selectionDirection = an, this.selectionStart = n), this.selectionEnd = r);
  }
}
class eA extends QL {
  initHiddenTextarea() {
    const e = this.canvas && Fi(this.canvas.getElement()) || Ca(), n = e.createElement("textarea");
    Object.entries({ autocapitalize: "off", autocorrect: "off", autocomplete: "off", spellcheck: "false", "data-fabric": "textarea", wrap: "off", name: "fabricTextarea" }).map((a) => {
      let [l, u] = a;
      return n.setAttribute(l, u);
    });
    const { top: r, left: o, fontSize: s } = this._calcTextareaPosition();
    n.style.cssText = "position: absolute; top: ".concat(r, "; left: ").concat(o, "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(s, ";"), (this.hiddenTextareaContainer || e.body).appendChild(n), Object.entries({ blur: "blur", keydown: "onKeyDown", keyup: "onKeyUp", input: "onInput", copy: "copy", cut: "copy", paste: "paste", compositionstart: "onCompositionStart", compositionupdate: "onCompositionUpdate", compositionend: "onCompositionEnd" }).map((a) => {
      let [l, u] = a;
      return n.addEventListener(l, this[u].bind(this));
    }), this.hiddenTextarea = n;
  }
  blur() {
    this.abortCursorAnimation();
  }
  onKeyDown(e) {
    if (!this.isEditing) return;
    const n = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
    if (e.keyCode in n) this[n[e.keyCode]](e);
    else {
      if (!(e.keyCode in this.ctrlKeysMapDown) || !e.ctrlKey && !e.metaKey) return;
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    e.stopImmediatePropagation(), e.preventDefault(), e.keyCode >= 33 && e.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
  }
  onKeyUp(e) {
    !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey) && (this[this.ctrlKeysMapUp[e.keyCode]](e), e.stopImmediatePropagation(), e.preventDefault(), this.canvas && this.canvas.requestRenderAll());
  }
  onInput(e) {
    const n = this.fromPaste, { value: r, selectionStart: o, selectionEnd: s } = this.hiddenTextarea;
    if (this.fromPaste = !1, e && e.stopPropagation(), !this.isEditing) return;
    const a = () => {
      this.updateFromTextArea(), this.fire(Hc), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
    };
    if (this.hiddenTextarea.value === "") return this.styles = {}, void a();
    const l = this._splitTextIntoLines(r).graphemeText, u = this._text.length, c = l.length, d = this.selectionStart, h = this.selectionEnd, p = d !== h;
    let m, v, y, w, g = c - u;
    const k = this.fromStringToGraphemeSelection(o, s, r), _ = d > k.selectionStart;
    p ? (v = this._text.slice(d, h), g += h - d) : c < u && (v = _ ? this._text.slice(h + g, h) : this._text.slice(d, d - g));
    const S = l.slice(k.selectionEnd - g, k.selectionEnd);
    if (v && v.length && (S.length && (m = this.getSelectionStyles(d, d + 1, !1), m = S.map(() => m[0])), p ? (y = d, w = h) : _ ? (y = h - v.length, w = h) : (y = h, w = h + v.length), this.removeStyleFromTo(y, w)), S.length) {
      const { copyPasteData: b } = Sr();
      n && S.join("") === b.copiedText && !kt.disableStyleCopyPaste && (m = b.copiedTextStyle), this.insertNewStyleBlock(S, d, m);
    }
    a();
  }
  onCompositionStart() {
    this.inCompositionMode = !0;
  }
  onCompositionEnd() {
    this.inCompositionMode = !1;
  }
  onCompositionUpdate(e) {
    let { target: n } = e;
    const { selectionStart: r, selectionEnd: o } = n;
    this.compositionStart = r, this.compositionEnd = o, this.updateTextareaPosition();
  }
  copy() {
    if (this.selectionStart === this.selectionEnd) return;
    const { copyPasteData: e } = Sr();
    e.copiedText = this.getSelectedText(), kt.disableStyleCopyPaste ? e.copiedTextStyle = void 0 : e.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0;
  }
  paste() {
    this.fromPaste = !0;
  }
  _getWidthBeforeCursor(e, n) {
    let r, o = this._getLineLeftOffset(e);
    return n > 0 && (r = this.__charBounds[e][n - 1], o += r.left + r.width), o;
  }
  getDownCursorOffset(e, n) {
    const r = this._getSelectionForOffset(e, n), o = this.get2DCursorLocation(r), s = o.lineIndex;
    if (s === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) return this._text.length - r;
    const a = o.charIndex, l = this._getWidthBeforeCursor(s, a), u = this._getIndexOnLine(s + 1, l);
    return this._textLines[s].slice(a).length + u + 1 + this.missingNewlineOffset(s);
  }
  _getSelectionForOffset(e, n) {
    return e.shiftKey && this.selectionStart !== this.selectionEnd && n ? this.selectionEnd : this.selectionStart;
  }
  getUpCursorOffset(e, n) {
    const r = this._getSelectionForOffset(e, n), o = this.get2DCursorLocation(r), s = o.lineIndex;
    if (s === 0 || e.metaKey || e.keyCode === 33) return -r;
    const a = o.charIndex, l = this._getWidthBeforeCursor(s, a), u = this._getIndexOnLine(s - 1, l), c = this._textLines[s].slice(0, a), d = this.missingNewlineOffset(s - 1);
    return -this._textLines[s - 1].length + u - c.length + (1 - d);
  }
  _getIndexOnLine(e, n) {
    const r = this._textLines[e];
    let o, s, a = this._getLineLeftOffset(e), l = 0;
    for (let u = 0, c = r.length; u < c; u++) if (o = this.__charBounds[e][u].width, a += o, a > n) {
      s = !0;
      const d = a - o, h = a, p = Math.abs(d - n);
      l = Math.abs(h - n) < p ? u : u - 1;
      break;
    }
    return s || (l = r.length - 1), l;
  }
  moveCursorDown(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", e);
  }
  moveCursorUp(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", e);
  }
  _moveCursorUpOrDown(e, n) {
    const r = this["get".concat(e, "CursorOffset")](n, this._selectionDirection === an);
    if (n.shiftKey ? this.moveCursorWithShift(r) : this.moveCursorWithoutShift(r), r !== 0) {
      const o = this.text.length;
      this.selectionStart = _a(0, this.selectionStart, o), this.selectionEnd = _a(0, this.selectionEnd, o), this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea();
    }
  }
  moveCursorWithShift(e) {
    const n = this._selectionDirection === Tt ? this.selectionStart + e : this.selectionEnd + e;
    return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, n), e !== 0;
  }
  moveCursorWithoutShift(e) {
    return e < 0 ? (this.selectionStart += e, this.selectionEnd = this.selectionStart) : (this.selectionEnd += e, this.selectionStart = this.selectionEnd), e !== 0;
  }
  moveCursorLeft(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", e);
  }
  _move(e, n, r) {
    let o;
    if (e.altKey) o = this["findWordBoundary".concat(r)](this[n]);
    else {
      if (!e.metaKey && e.keyCode !== 35 && e.keyCode !== 36) return this[n] += r === "Left" ? -1 : 1, !0;
      o = this["findLineBoundary".concat(r)](this[n]);
    }
    return o !== void 0 && this[n] !== o && (this[n] = o, !0);
  }
  _moveLeft(e, n) {
    return this._move(e, n, "Left");
  }
  _moveRight(e, n) {
    return this._move(e, n, "Right");
  }
  moveCursorLeftWithoutShift(e) {
    let n = !0;
    return this._selectionDirection = Tt, this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (n = this._moveLeft(e, "selectionStart")), this.selectionEnd = this.selectionStart, n;
  }
  moveCursorLeftWithShift(e) {
    return this._selectionDirection === an && this.selectionStart !== this.selectionEnd ? this._moveLeft(e, "selectionEnd") : this.selectionStart !== 0 ? (this._selectionDirection = Tt, this._moveLeft(e, "selectionStart")) : void 0;
  }
  moveCursorRight(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", e);
  }
  _moveCursorLeftOrRight(e, n) {
    const r = "moveCursor".concat(e).concat(n.shiftKey ? "WithShift" : "WithoutShift");
    this._currentCursorOpacity = 1, this[r](n) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
  }
  moveCursorRightWithShift(e) {
    return this._selectionDirection === Tt && this.selectionStart !== this.selectionEnd ? this._moveRight(e, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = an, this._moveRight(e, "selectionEnd")) : void 0;
  }
  moveCursorRightWithoutShift(e) {
    let n = !0;
    return this._selectionDirection = an, this.selectionStart === this.selectionEnd ? (n = this._moveRight(e, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, n;
  }
}
const gv = (i) => !!i.button;
class tA extends eA {
  constructor() {
    super(...arguments), Y(this, "draggableTextDelegate", void 0);
  }
  initBehavior() {
    this.on("mousedown", this._mouseDownHandler), this.on("mouseup", this.mouseUpHandler), this.on("mousedblclick", this.doubleClickHandler), this.on("mousetripleclick", this.tripleClickHandler), this.draggableTextDelegate = new JL(this), super.initBehavior();
  }
  shouldStartDragging() {
    return this.draggableTextDelegate.isActive();
  }
  onDragStart(e) {
    return this.draggableTextDelegate.onDragStart(e);
  }
  canDrop(e) {
    return this.draggableTextDelegate.canDrop(e);
  }
  doubleClickHandler(e) {
    this.isEditing && (this.selectWord(this.getSelectionStartFromPointer(e.e)), this.renderCursorOrSelection());
  }
  tripleClickHandler(e) {
    this.isEditing && (this.selectLine(this.getSelectionStartFromPointer(e.e)), this.renderCursorOrSelection());
  }
  _mouseDownHandler(e) {
    let { e: n, alreadySelected: r } = e;
    this.canvas && this.editable && !gv(n) && !this.getActiveControl() && (this.draggableTextDelegate.start(n) || (this.canvas.textEditingManager.register(this), r && (this.inCompositionMode = !1, this.setCursorByClick(n)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection()), this.selected || (this.selected = r || this.isEditing)));
  }
  mouseUpHandler(e) {
    let { e: n, transform: r } = e;
    const o = this.draggableTextDelegate.end(n);
    if (this.canvas) {
      this.canvas.textEditingManager.unregister(this);
      const s = this.canvas._activeObject;
      if (s && s !== this) return;
    }
    !this.editable || this.group && !this.group.interactive || r && r.actionPerformed || gv(n) || o || this.selected && !this.getActiveControl() && (this.enterEditing(n), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection());
  }
  setCursorByClick(e) {
    const n = this.getSelectionStartFromPointer(e), r = this.selectionStart, o = this.selectionEnd;
    e.shiftKey ? this.setSelectionStartEndWithShift(r, o, n) : (this.selectionStart = n, this.selectionEnd = n), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
  }
  getSelectionStartFromPointer(e) {
    const n = this.canvas.getScenePoint(e).transform(Ni(this.calcTransformMatrix())).add(new ce(-this._getLeftOffset(), -this._getTopOffset()));
    let r = 0, o = 0, s = 0;
    for (let c = 0; c < this._textLines.length && r <= n.y; c++) r += this.getHeightOfLine(c), s = c, c > 0 && (o += this._textLines[c - 1].length + this.missingNewlineOffset(c - 1));
    let a = Math.abs(this._getLineLeftOffset(s));
    const l = this._textLines[s].length, u = this.__charBounds[s];
    for (let c = 0; c < l; c++) {
      const d = a + u[c].kernedWidth;
      if (n.x <= d) {
        Math.abs(n.x - d) <= Math.abs(n.x - a) && o++;
        break;
      }
      a = d, o++;
    }
    return Math.min(this.flipX ? l - o : o, this._text.length);
  }
}
const Fu = "moveCursorUp", ju = "moveCursorDown", Ru = "moveCursorLeft", Nu = "moveCursorRight", zu = "exitEditing", vv = (i, e) => {
  const n = e.getRetinaScaling();
  i.setTransform(n, 0, 0, n, 0, 0);
  const r = e.viewportTransform;
  i.transform(r[0], r[1], r[2], r[3], r[4], r[5]);
}, nA = K({ selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, keysMap: { 9: zu, 27: zu, 33: Fu, 34: ju, 35: Nu, 36: Ru, 37: Ru, 38: Fu, 39: Nu, 40: ju }, keysMapRtl: { 9: zu, 27: zu, 33: Fu, 34: ju, 35: Ru, 36: Nu, 37: Nu, 38: Fu, 39: Ru, 40: ju }, ctrlKeysMapDown: { 65: "cmdAll" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" } }, { _selectionDirection: null, _reSpace: /\s|\r?\n/, inCompositionMode: !1 });
class Kr extends tA {
  static getDefaults() {
    return K(K({}, super.getDefaults()), Kr.ownDefaults);
  }
  get type() {
    const e = super.type;
    return e === "itext" ? "i-text" : e;
  }
  constructor(e, n) {
    super(e, K(K({}, Kr.ownDefaults), n)), this.initBehavior();
  }
  _set(e, n) {
    return this.isEditing && this._savedProps && e in this._savedProps ? (this._savedProps[e] = n, this) : (e === "canvas" && (this.canvas instanceof of && this.canvas.textEditingManager.remove(this), n instanceof of && n.textEditingManager.add(this)), super._set(e, n));
  }
  setSelectionStart(e) {
    e = Math.max(e, 0), this._updateAndFire("selectionStart", e);
  }
  setSelectionEnd(e) {
    e = Math.min(e, this.text.length), this._updateAndFire("selectionEnd", e);
  }
  _updateAndFire(e, n) {
    this[e] !== n && (this._fireSelectionChanged(), this[e] = n), this._updateTextarea();
  }
  _fireSelectionChanged() {
    this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
  }
  initDimensions() {
    this.isEditing && this.initDelayedCursor(), super.initDimensions();
  }
  getSelectionStyles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart || 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionEnd, r = arguments.length > 2 ? arguments[2] : void 0;
    return super.getSelectionStyles(e, n, r);
  }
  setSelectionStyles(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionStart || 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.selectionEnd;
    return super.setSelectionStyles(e, n, r);
  }
  get2DCursorLocation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 ? arguments[1] : void 0;
    return super.get2DCursorLocation(e, n);
  }
  render(e) {
    super.render(e), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
  }
  toCanvasElement(e) {
    const n = this.isEditing;
    this.isEditing = !1;
    const r = super.toCanvasElement(e);
    return this.isEditing = n, r;
  }
  renderCursorOrSelection() {
    if (!this.isEditing || !this.canvas) return;
    const e = this.clearContextTop(!0);
    if (!e) return;
    const n = this._getCursorBoundaries(), r = this.findAncestorsWithClipPath(), o = r.length > 0;
    let s, a = e;
    if (o) {
      s = Ci(e.canvas), a = s.getContext("2d"), vv(a, this.canvas);
      const l = this.calcTransformMatrix();
      a.transform(l[0], l[1], l[2], l[3], l[4], l[5]);
    }
    if (this.selectionStart !== this.selectionEnd || this.inCompositionMode ? this.renderSelection(a, n) : this.renderCursor(a, n), o) for (const l of r) {
      const u = l.clipPath, c = Ci(e.canvas), d = c.getContext("2d");
      if (vv(d, this.canvas), !u.absolutePositioned) {
        const h = l.calcTransformMatrix();
        d.transform(h[0], h[1], h[2], h[3], h[4], h[5]);
      }
      u.transform(d), u.drawObject(d, !0, {}), this.drawClipPathOnCache(a, u, c);
    }
    o && (e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(s, 0, 0)), this.canvas.contextTopDirty = !0, e.restore();
  }
  findAncestorsWithClipPath() {
    const e = [];
    let n = this;
    for (; n; ) n.clipPath && e.push(n), n = n.parent;
    return e;
  }
  _getCursorBoundaries() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 ? arguments[1] : void 0;
    const r = this._getLeftOffset(), o = this._getTopOffset(), s = this._getCursorBoundariesOffsets(e, n);
    return { left: r, top: o, leftOffset: s.left, topOffset: s.top };
  }
  _getCursorBoundariesOffsets(e, n) {
    return n ? this.__getCursorBoundariesOffsets(e) : this.cursorOffsetCache && "top" in this.cursorOffsetCache ? this.cursorOffsetCache : this.cursorOffsetCache = this.__getCursorBoundariesOffsets(e);
  }
  __getCursorBoundariesOffsets(e) {
    let n = 0, r = 0;
    const { charIndex: o, lineIndex: s } = this.get2DCursorLocation(e);
    for (let c = 0; c < s; c++) n += this.getHeightOfLine(c);
    const a = this._getLineLeftOffset(s), l = this.__charBounds[s][o];
    l && (r = l.left), this.charSpacing !== 0 && o === this._textLines[s].length && (r -= this._getWidthOfCharSpacing());
    const u = { top: n, left: a + (r > 0 ? r : 0) };
    return this.direction === "rtl" && (this.textAlign === an || this.textAlign === mr || this.textAlign === fl ? u.left *= -1 : this.textAlign === Tt || this.textAlign === qc ? u.left = a - (r > 0 ? r : 0) : this.textAlign !== ut && this.textAlign !== pl || (u.left = a - (r > 0 ? r : 0))), u;
  }
  renderCursorAt(e) {
    this._renderCursor(this.canvas.contextTop, this._getCursorBoundaries(e, !0), e);
  }
  renderCursor(e, n) {
    this._renderCursor(e, n, this.selectionStart);
  }
  getCursorRenderingData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getCursorBoundaries(e);
    const r = this.get2DCursorLocation(e), o = r.lineIndex, s = r.charIndex > 0 ? r.charIndex - 1 : 0, a = this.getValueOfPropertyAt(o, s, "fontSize"), l = this.getObjectScaling().x * this.canvas.getZoom(), u = this.cursorWidth / l, c = this.getValueOfPropertyAt(o, s, "deltaY"), d = n.topOffset + (1 - this._fontSizeFraction) * this.getHeightOfLine(o) / this.lineHeight - a * (1 - this._fontSizeFraction);
    return { color: this.cursorColor || this.getValueOfPropertyAt(o, s, "fill"), opacity: this._currentCursorOpacity, left: n.left + n.leftOffset - u / 2, top: d + n.top + c, width: u, height: a };
  }
  _renderCursor(e, n, r) {
    const { color: o, opacity: s, left: a, top: l, width: u, height: c } = this.getCursorRenderingData(r, n);
    e.fillStyle = o, e.globalAlpha = s, e.fillRect(a, l, u, c);
  }
  renderSelection(e, n) {
    const r = { selectionStart: this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd: this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd };
    this._renderSelection(e, r, n);
  }
  renderDragSourceEffect() {
    const e = this.draggableTextDelegate.getDragStartSelection();
    this._renderSelection(this.canvas.contextTop, e, this._getCursorBoundaries(e.selectionStart, !0));
  }
  renderDropTargetEffect(e) {
    const n = this.getSelectionStartFromPointer(e);
    this.renderCursorAt(n);
  }
  _renderSelection(e, n, r) {
    const o = n.selectionStart, s = n.selectionEnd, a = this.textAlign.includes(mr), l = this.get2DCursorLocation(o), u = this.get2DCursorLocation(s), c = l.lineIndex, d = u.lineIndex, h = l.charIndex < 0 ? 0 : l.charIndex, p = u.charIndex < 0 ? 0 : u.charIndex;
    for (let m = c; m <= d; m++) {
      const v = this._getLineLeftOffset(m) || 0;
      let y = this.getHeightOfLine(m), w = 0, g = 0, k = 0;
      if (m === c && (g = this.__charBounds[c][h].left), m >= c && m < d) k = a && !this.isEndOfWrapping(m) ? this.width : this.getLineWidth(m) || 5;
      else if (m === d) if (p === 0) k = this.__charBounds[d][p].left;
      else {
        const x = this._getWidthOfCharSpacing();
        k = this.__charBounds[d][p - 1].left + this.__charBounds[d][p - 1].width - x;
      }
      w = y, (this.lineHeight < 1 || m === d && this.lineHeight > 1) && (y /= this.lineHeight);
      let _ = r.left + v + g, S = y, b = 0;
      const C = k - g;
      this.inCompositionMode ? (e.fillStyle = this.compositionColor || "black", S = 1, b = y) : e.fillStyle = this.selectionColor, this.direction === "rtl" && (this.textAlign === an || this.textAlign === mr || this.textAlign === fl ? _ = this.width - _ - C : this.textAlign === Tt || this.textAlign === qc ? _ = r.left + v - k : this.textAlign !== ut && this.textAlign !== pl || (_ = r.left + v - k)), e.fillRect(_, r.top + r.topOffset + b, C, S), r.topOffset += w;
    }
  }
  getCurrentCharFontSize() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, "fontSize");
  }
  getCurrentCharColor() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, yn);
  }
  _getCurrentCharIndex() {
    const e = this.get2DCursorLocation(this.selectionStart, !0), n = e.charIndex > 0 ? e.charIndex - 1 : 0;
    return { l: e.lineIndex, c: n };
  }
  dispose() {
    this.exitEditingImpl(), this.draggableTextDelegate.dispose(), super.dispose();
  }
}
Y(Kr, "ownDefaults", nA), Y(Kr, "type", "IText"), Ne.setClass(Kr), Ne.setClass(Kr, "i-text");
class ps extends Kr {
  static getDefaults() {
    return K(K({}, super.getDefaults()), ps.ownDefaults);
  }
  constructor(e, n) {
    super(e, K(K({}, ps.ownDefaults), n));
  }
  static createControls() {
    return { controls: L4() };
  }
  initDimensions() {
    this.initialized && (this.isEditing && this.initDelayedCursor(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.includes(mr) && this.enlargeSpaces(), this.height = this.calcTextHeight());
  }
  _generateStyleMap(e) {
    let n = 0, r = 0, o = 0;
    const s = {};
    for (let a = 0; a < e.graphemeLines.length; a++) e.graphemeText[o] === `
` && a > 0 ? (r = 0, o++, n++) : !this.splitByGrapheme && this._reSpaceAndTab.test(e.graphemeText[o]) && a > 0 && (r++, o++), s[a] = { line: n, offset: r }, o += e.graphemeLines[a].length, r += e.graphemeLines[a].length;
    return s;
  }
  styleHas(e, n) {
    if (this._styleMap && !this.isWrapping) {
      const r = this._styleMap[n];
      r && (n = r.line);
    }
    return super.styleHas(e, n);
  }
  isEmptyStyles(e) {
    if (!this.styles) return !0;
    let n, r = 0, o = e + 1, s = !1;
    const a = this._styleMap[e], l = this._styleMap[e + 1];
    a && (e = a.line, r = a.offset), l && (o = l.line, s = o === e, n = l.offset);
    const u = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const c in u) for (const d in u[c]) {
      const h = parseInt(d, 10);
      if (h >= r && (!s || h < n)) for (const p in u[c][d]) return !1;
    }
    return !0;
  }
  _getStyleDeclaration(e, n) {
    if (this._styleMap && !this.isWrapping) {
      const r = this._styleMap[e];
      if (!r) return {};
      e = r.line, n = r.offset + n;
    }
    return super._getStyleDeclaration(e, n);
  }
  _setStyleDeclaration(e, n, r) {
    const o = this._styleMap[e];
    super._setStyleDeclaration(o.line, o.offset + n, r);
  }
  _deleteStyleDeclaration(e, n) {
    const r = this._styleMap[e];
    super._deleteStyleDeclaration(r.line, r.offset + n);
  }
  _getLineStyle(e) {
    const n = this._styleMap[e];
    return !!this.styles[n.line];
  }
  _setLineStyle(e) {
    const n = this._styleMap[e];
    super._setLineStyle(n.line);
  }
  _wrapText(e, n) {
    this.isWrapping = !0;
    const r = this.getGraphemeDataForRender(e), o = [];
    for (let s = 0; s < r.wordsData.length; s++) o.push(...this._wrapLine(s, n, r));
    return this.isWrapping = !1, o;
  }
  getGraphemeDataForRender(e) {
    const n = this.splitByGrapheme, r = n ? "" : " ";
    let o = 0;
    return { wordsData: e.map((s, a) => {
      let l = 0;
      const u = n ? this.graphemeSplit(s) : this.wordSplit(s);
      return u.length === 0 ? [{ word: [], width: 0 }] : u.map((c) => {
        const d = n ? [c] : this.graphemeSplit(c), h = this._measureWord(d, a, l);
        return o = Math.max(h, o), l += d.length + r.length, { word: d, width: h };
      });
    }), largestWordWidth: o };
  }
  _measureWord(e, n) {
    let r, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, s = 0;
    for (let a = 0, l = e.length; a < l; a++)
      s += this._getGraphemeBox(e[a], n, a + o, r, !0).kernedWidth, r = e[a];
    return s;
  }
  wordSplit(e) {
    return e.split(this._wordJoiners);
  }
  _wrapLine(e, n, r) {
    let { largestWordWidth: o, wordsData: s } = r, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const l = this._getWidthOfCharSpacing(), u = this.splitByGrapheme, c = [], d = u ? "" : " ";
    let h = 0, p = [], m = 0, v = 0, y = !0;
    n -= a;
    const w = Math.max(n, o, this.dynamicMinWidth), g = s[e];
    let k;
    for (m = 0, k = 0; k < g.length; k++) {
      const { word: _, width: S } = g[k];
      m += _.length, h += v + S - l, h > w && !y ? (c.push(p), p = [], h = S, y = !0) : h += l, y || u || p.push(d), p = p.concat(_), v = u ? 0 : this._measureWord([d], e, m), m++, y = !1;
    }
    return k && c.push(p), o + a > this.dynamicMinWidth && (this.dynamicMinWidth = o - l + a), c;
  }
  isEndOfWrapping(e) {
    return !this._styleMap[e + 1] || this._styleMap[e + 1].line !== this._styleMap[e].line;
  }
  missingNewlineOffset(e, n) {
    return this.splitByGrapheme && !n ? this.isEndOfWrapping(e) ? 1 : 0 : 1;
  }
  _splitTextIntoLines(e) {
    const n = super._splitTextIntoLines(e), r = this._wrapText(n.lines, this.width), o = new Array(r.length);
    for (let s = 0; s < r.length; s++) o[s] = r[s].join("");
    return n.lines = o, n.graphemeLines = r, n;
  }
  getMinWidth() {
    return Math.max(this.minWidth, this.dynamicMinWidth);
  }
  _removeExtraneousStyles() {
    const e = /* @__PURE__ */ new Map();
    for (const n in this._styleMap) {
      const r = parseInt(n, 10);
      if (this._textLines[r]) {
        const o = this._styleMap[n].line;
        e.set("".concat(o), !0);
      }
    }
    for (const n in this.styles) e.has(n) || delete this.styles[n];
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject(["minWidth", "splitByGrapheme", ...e]);
  }
}
Y(ps, "type", "Textbox"), Y(ps, "textLayoutProperties", [...Kr.textLayoutProperties, "width"]), Y(ps, "ownDefaults", { minWidth: 20, dynamicMinWidth: 2, lockScalingFlip: !0, noScaleCache: !1, _wordJoiners: /[ \t\r]/, splitByGrapheme: !1 }), Ne.setClass(ps);
class yv extends _d {
  shouldPerformLayout(e) {
    return !!e.target.clipPath && super.shouldPerformLayout(e);
  }
  shouldLayoutClipPath() {
    return !1;
  }
  calcLayoutResult(e, n) {
    const { target: r } = e, { clipPath: o, group: s } = r;
    if (!o || !this.shouldPerformLayout(e)) return;
    const { width: a, height: l } = Qr(i1(r, o)), u = new ce(a, l);
    if (o.absolutePositioned)
      return { center: da(o.getRelativeCenterPoint(), void 0, s ? s.calcTransformMatrix() : void 0), size: u };
    {
      const c = o.getRelativeCenterPoint().transform(r.calcOwnMatrix(), !0);
      if (this.shouldPerformLayout(e)) {
        const { center: d = new ce(), correction: h = new ce() } = this.calcBoundingBox(n, e) || {};
        return { center: d.add(c), correction: h.subtract(c), size: u };
      }
      return { center: r.getRelativeCenterPoint().add(c), size: u };
    }
  }
}
Y(yv, "type", "clip-path"), Ne.setClass(yv);
class bv extends _d {
  getInitialSize(e, n) {
    let { target: r } = e, { size: o } = n;
    return new ce(r.width || o.x, r.height || o.y);
  }
}
Y(bv, "type", "fixed"), Ne.setClass(bv);
class iA extends Al {
  subscribeTargets(e) {
    const n = e.target;
    e.targets.reduce((r, o) => (o.parent && r.add(o.parent), r), /* @__PURE__ */ new Set()).forEach((r) => {
      r.layoutManager.subscribeTargets({ target: r, targets: [n] });
    });
  }
  unsubscribeTargets(e) {
    const n = e.target, r = n.getObjects();
    e.targets.reduce((o, s) => (s.parent && o.add(s.parent), o), /* @__PURE__ */ new Set()).forEach((o) => {
      !r.some((s) => s.parent === o) && o.layoutManager.unsubscribeTargets({ target: o, targets: [n] });
    });
  }
}
class ms extends ks {
  static getDefaults() {
    return K(K({}, super.getDefaults()), ms.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, ms.ownDefaults), this.setOptions(n);
    const { left: r, top: o, layoutManager: s } = n;
    this.groupInit(e, { left: r, top: o, layoutManager: s ?? new iA() });
  }
  _shouldSetNestedCoords() {
    return !0;
  }
  __objectSelectionMonitor() {
  }
  multiSelectAdd() {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
    this.multiSelectionStacking === "selection-order" ? this.add(...n) : n.forEach((o) => {
      const s = this._objects.findIndex((l) => l.isInFrontOf(o)), a = s === -1 ? this.size() : s;
      this.insertAt(a, o);
    });
  }
  canEnterGroup(e) {
    return this.getObjects().some((n) => n.isDescendantOf(e) || e.isDescendantOf(n)) ? (Ro("error", "ActiveSelection: circular object trees are not supported, this call has no effect"), !1) : super.canEnterGroup(e);
  }
  enterGroup(e, n) {
    e.parent && e.parent === e.group ? e.parent._exitGroup(e) : e.group && e.parent !== e.group && e.group.remove(e), this._enterGroup(e, n);
  }
  exitGroup(e, n) {
    this._exitGroup(e, n), e.parent && e.parent._enterGroup(e, !0);
  }
  _onAfterObjectsChange(e, n) {
    super._onAfterObjectsChange(e, n);
    const r = /* @__PURE__ */ new Set();
    n.forEach((o) => {
      const { parent: s } = o;
      s && r.add(s);
    }), e === _p ? r.forEach((o) => {
      o._onAfterObjectsChange(Zc, n);
    }) : r.forEach((o) => {
      o._set("dirty", !0);
    });
  }
  onDeselect() {
    return this.removeAll(), !1;
  }
  toString() {
    return "#<ActiveSelection: (".concat(this.complexity(), ")>");
  }
  shouldCache() {
    return !1;
  }
  isOnACache() {
    return !1;
  }
  _renderControls(e, n, r) {
    e.save(), e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
    const o = K(K({ hasControls: !1 }, r), {}, { forActiveSelection: !0 });
    for (let s = 0; s < this._objects.length; s++) this._objects[s]._renderControls(e, o);
    super._renderControls(e, n), e.restore();
  }
}
Y(ms, "type", "ActiveSelection"), Y(ms, "ownDefaults", { multiSelectionStacking: "canvas-stacking" }), Ne.setClass(ms), Ne.setClass(ms, "activeSelection");
class rA {
  constructor() {
    Y(this, "resources", {});
  }
  applyFilters(e, n, r, o, s) {
    const a = s.getContext("2d");
    if (!a) return;
    a.drawImage(n, 0, 0, r, o);
    const l = { sourceWidth: r, sourceHeight: o, imageData: a.getImageData(0, 0, r, o), originalEl: n, originalImageData: a.getImageData(0, 0, r, o), canvasEl: s, ctx: a, filterBackend: this };
    e.forEach((c) => {
      c.applyTo(l);
    });
    const { imageData: u } = l;
    return u.width === r && u.height === o || (s.width = u.width, s.height = u.height), a.putImageData(u, 0, 0), l;
  }
}
class b1 {
  constructor() {
    let { tileSize: e = kt.textureSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Y(this, "aPosition", new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])), Y(this, "resources", {}), this.tileSize = e, this.setupGLContext(e, e), this.captureGPUInfo();
  }
  setupGLContext(e, n) {
    this.dispose(), this.createWebGLCanvas(e, n);
  }
  createWebGLCanvas(e, n) {
    const r = Ci({ width: e, height: n }), o = r.getContext("webgl", { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 });
    o && (o.clearColor(0, 0, 0, 0), this.canvas = r, this.gl = o);
  }
  applyFilters(e, n, r, o, s, a) {
    const l = this.gl, u = s.getContext("2d");
    if (!l || !u) return;
    let c;
    a && (c = this.getCachedTexture(a, n));
    const d = { originalWidth: n.width || n.naturalWidth || 0, originalHeight: n.height || n.naturalHeight || 0, sourceWidth: r, sourceHeight: o, destinationWidth: r, destinationHeight: o, context: l, sourceTexture: this.createTexture(l, r, o, c ? void 0 : n), targetTexture: this.createTexture(l, r, o), originalTexture: c || this.createTexture(l, r, o, c ? void 0 : n), passes: e.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: s }, h = l.createFramebuffer();
    return l.bindFramebuffer(l.FRAMEBUFFER, h), e.forEach((p) => {
      p && p.applyTo(d);
    }), function(p) {
      const m = p.targetCanvas, v = m.width, y = m.height, w = p.destinationWidth, g = p.destinationHeight;
      v === w && y === g || (m.width = w, m.height = g);
    }(d), this.copyGLTo2D(l, d), l.bindTexture(l.TEXTURE_2D, null), l.deleteTexture(d.sourceTexture), l.deleteTexture(d.targetTexture), l.deleteFramebuffer(h), u.setTransform(1, 0, 0, 1, 0, 0), d;
  }
  dispose() {
    this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
  }
  clearWebGLCaches() {
    this.programCache = {}, this.textureCache = {};
  }
  createTexture(e, n, r, o, s) {
    const { NEAREST: a, TEXTURE_2D: l, RGBA: u, UNSIGNED_BYTE: c, CLAMP_TO_EDGE: d, TEXTURE_MAG_FILTER: h, TEXTURE_MIN_FILTER: p, TEXTURE_WRAP_S: m, TEXTURE_WRAP_T: v } = e, y = e.createTexture();
    return e.bindTexture(l, y), e.texParameteri(l, h, s || a), e.texParameteri(l, p, s || a), e.texParameteri(l, m, d), e.texParameteri(l, v, d), o ? e.texImage2D(l, 0, u, u, c, o) : e.texImage2D(l, 0, u, n, r, 0, u, c, null), y;
  }
  getCachedTexture(e, n, r) {
    const { textureCache: o } = this;
    if (o[e]) return o[e];
    {
      const s = this.createTexture(this.gl, n.width, n.height, n, r);
      return s && (o[e] = s), s;
    }
  }
  evictCachesForKey(e) {
    this.textureCache[e] && (this.gl.deleteTexture(this.textureCache[e]), delete this.textureCache[e]);
  }
  copyGLTo2D(e, n) {
    const r = e.canvas, o = n.targetCanvas, s = o.getContext("2d");
    if (!s) return;
    s.translate(0, o.height), s.scale(1, -1);
    const a = r.height - o.height;
    s.drawImage(r, 0, a, o.width, o.height, 0, 0, o.width, o.height);
  }
  copyGLTo2DPutImageData(e, n) {
    const r = n.targetCanvas.getContext("2d"), o = n.destinationWidth, s = n.destinationHeight, a = o * s * 4;
    if (!r) return;
    const l = new Uint8Array(this.imageBuffer, 0, a), u = new Uint8ClampedArray(this.imageBuffer, 0, a);
    e.readPixels(0, 0, o, s, e.RGBA, e.UNSIGNED_BYTE, l);
    const c = new ImageData(u, o, s);
    r.putImageData(c, 0, 0);
  }
  captureGPUInfo() {
    if (this.gpuInfo) return this.gpuInfo;
    const e = this.gl, n = { renderer: "", vendor: "" };
    if (!e) return n;
    const r = e.getExtension("WEBGL_debug_renderer_info");
    if (r) {
      const o = e.getParameter(r.UNMASKED_RENDERER_WEBGL), s = e.getParameter(r.UNMASKED_VENDOR_WEBGL);
      o && (n.renderer = o.toLowerCase()), s && (n.vendor = s.toLowerCase());
    }
    return this.gpuInfo = n, n;
  }
}
let mh;
function oA() {
  const { WebGLProbe: i } = Sr();
  return i.queryWebGL(ro()), kt.enableGLFiltering && i.isSupported(kt.textureSize) ? new b1({ tileSize: kt.textureSize }) : new rA();
}
function gh() {
  return !mh && (!(arguments.length > 0 && arguments[0] !== void 0) || arguments[0]) && (mh = oA()), mh;
}
const sA = ["filters", "resizeFilter", "src", "crossOrigin", "type"], w1 = ["cropX", "cropY"];
class Zn extends An {
  static getDefaults() {
    return K(K({}, super.getDefaults()), Zn.ownDefaults);
  }
  constructor(e, n) {
    super(), Y(this, "_lastScaleX", 1), Y(this, "_lastScaleY", 1), Y(this, "_filterScalingX", 1), Y(this, "_filterScalingY", 1), this.filters = [], Object.assign(this, Zn.ownDefaults), this.setOptions(n), this.cacheKey = "texture".concat(No()), this.setElement(typeof e == "string" ? (this.canvas && Fi(this.canvas.getElement()) || Ca()).getElementById(e) : e, n);
  }
  getElement() {
    return this._element;
  }
  setElement(e) {
    var n;
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._element = e, this._originalElement = e, this._setWidthHeight(r), (n = e.classList) === null || n === void 0 || n.add(Zn.CSS_CANVAS), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters();
  }
  removeTexture(e) {
    const n = gh(!1);
    n instanceof b1 && n.evictCachesForKey(e);
  }
  dispose() {
    super.dispose(), this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._cacheContext = null, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((e) => {
      const n = this[e];
      n && Sr().dispose(n), this[e] = void 0;
    });
  }
  getCrossOrigin() {
    return this._originalElement && (this._originalElement.crossOrigin || null);
  }
  getOriginalSize() {
    const e = this.getElement();
    return e ? { width: e.naturalWidth || e.width, height: e.naturalHeight || e.height } : { width: 0, height: 0 };
  }
  _stroke(e) {
    if (!this.stroke || this.strokeWidth === 0) return;
    const n = this.width / 2, r = this.height / 2;
    e.beginPath(), e.moveTo(-n, -r), e.lineTo(n, -r), e.lineTo(n, r), e.lineTo(-n, r), e.lineTo(-n, -r), e.closePath();
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = [];
    return this.filters.forEach((r) => {
      r && n.push(r.toObject());
    }), K(K({}, super.toObject([...w1, ...e])), {}, { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: n }, this.resizeFilter ? { resizeFilter: this.resizeFilter.toObject() } : {});
  }
  hasCrop() {
    return !!this.cropX || !!this.cropY || this.width < this._element.width || this.height < this._element.height;
  }
  _toSVG() {
    const e = [], n = this._element, r = -this.width / 2, o = -this.height / 2;
    let s = [], a = [], l = "", u = "";
    if (!n) return [];
    if (this.hasCrop()) {
      const c = No();
      s.push('<clipPath id="imageCrop_' + c + `">
`, '	<rect x="' + r + '" y="' + o + '" width="' + this.width + '" height="' + this.height + `" />
`, `</clipPath>
`), l = ' clip-path="url(#imageCrop_' + c + ')" ';
    }
    if (this.imageSmoothing || (u = ' image-rendering="optimizeSpeed"'), e.push("	<image ", "COMMON_PARTS", 'xlink:href="'.concat(this.getSvgSrc(!0), '" x="').concat(r - this.cropX, '" y="').concat(o - this.cropY, '" width="').concat(n.width || n.naturalWidth, '" height="').concat(n.height || n.naturalHeight, '"').concat(u).concat(l, `></image>
`)), this.stroke || this.strokeDashArray) {
      const c = this.fill;
      this.fill = null, a = ['	<rect x="'.concat(r, '" y="').concat(o, '" width="').concat(this.width, '" height="').concat(this.height, '" style="').concat(this.getSvgStyles(), `" />
`)], this.fill = c;
    }
    return s = this.paintFirst !== yn ? s.concat(a, e) : s.concat(e, a), s;
  }
  getSrc(e) {
    const n = e ? this._element : this._originalElement;
    return n ? n.toDataURL ? n.toDataURL() : this.srcFromAttribute ? n.getAttribute("src") || "" : n.src : this.src || "";
  }
  getSvgSrc(e) {
    return this.getSrc(e);
  }
  setSrc(e) {
    let { crossOrigin: n, signal: r } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return vc(e, { crossOrigin: n, signal: r }).then((o) => {
      n !== void 0 && this.set({ crossOrigin: n }), this.setElement(o);
    });
  }
  toString() {
    return '#<Image: { src: "'.concat(this.getSrc(), '" }>');
  }
  applyResizeFilters() {
    const e = this.resizeFilter, n = this.minimumScaleTrigger, r = this.getTotalObjectScaling(), o = r.x, s = r.y, a = this._filteredEl || this._originalElement;
    if (this.group && this.set("dirty", !0), !e || o > n && s > n) return this._element = a, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = o, void (this._lastScaleY = s);
    const l = Ci(a), { width: u, height: c } = a;
    this._element = l, this._lastScaleX = e.scaleX = o, this._lastScaleY = e.scaleY = s, gh().applyFilters([e], a, u, c, this._element), this._filterScalingX = l.width / this._originalElement.width, this._filterScalingY = l.height / this._originalElement.height;
  }
  applyFilters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.filters || [];
    if (e = e.filter((s) => s && !s.isNeutralState()), this.set("dirty", !0), this.removeTexture("".concat(this.cacheKey, "_filtered")), e.length === 0) return this._element = this._originalElement, this._filteredEl = void 0, this._filterScalingX = 1, void (this._filterScalingY = 1);
    const n = this._originalElement, r = n.naturalWidth || n.width, o = n.naturalHeight || n.height;
    if (this._element === this._originalElement) {
      const s = Ci({ width: r, height: o });
      this._element = s, this._filteredEl = s;
    } else this._filteredEl && (this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, r, o), this._lastScaleX = 1, this._lastScaleY = 1);
    gh().applyFilters(e, this._originalElement, r, o, this._element, this.cacheKey), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height);
  }
  _render(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(e), this._renderPaintInOrder(e);
  }
  drawCacheOnCanvas(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, super.drawCacheOnCanvas(e);
  }
  shouldCache() {
    return this.needsItsOwnCache();
  }
  _renderFill(e) {
    const n = this._element;
    if (!n) return;
    const r = this._filterScalingX, o = this._filterScalingY, s = this.width, a = this.height, l = Math.max(this.cropX, 0), u = Math.max(this.cropY, 0), c = n.naturalWidth || n.width, d = n.naturalHeight || n.height, h = l * r, p = u * o, m = Math.min(s * r, c - h), v = Math.min(a * o, d - p), y = -s / 2, w = -a / 2, g = Math.min(s, c / r - l), k = Math.min(a, d / o - u);
    n && e.drawImage(n, h, p, m, v, y, w, g, k);
  }
  _needsResize() {
    const e = this.getTotalObjectScaling();
    return e.x !== this._lastScaleX || e.y !== this._lastScaleY;
  }
  _resetWidthHeight() {
    this.set(this.getOriginalSize());
  }
  _setWidthHeight() {
    let { width: e, height: n } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const r = this.getOriginalSize();
    this.width = e || r.width, this.height = n || r.height;
  }
  parsePreserveAspectRatioAttribute() {
    const e = J3(this.preserveAspectRatio || ""), n = this.width, r = this.height, o = { width: n, height: r };
    let s, a = this._element.width, l = this._element.height, u = 1, c = 1, d = 0, h = 0, p = 0, m = 0;
    return !e || e.alignX === ei && e.alignY === ei ? (u = n / a, c = r / l) : (e.meetOrSlice === "meet" && (u = c = pL(this._element, o), s = (n - a * u) / 2, e.alignX === "Min" && (d = -s), e.alignX === "Max" && (d = s), s = (r - l * c) / 2, e.alignY === "Min" && (h = -s), e.alignY === "Max" && (h = s)), e.meetOrSlice === "slice" && (u = c = mL(this._element, o), s = a - n / u, e.alignX === "Mid" && (p = s / 2), e.alignX === "Max" && (p = s), s = l - r / c, e.alignY === "Mid" && (m = s / 2), e.alignY === "Max" && (m = s), a = n / u, l = r / c)), { width: a, height: l, scaleX: u, scaleY: c, offsetLeft: d, offsetTop: h, cropX: p, cropY: m };
  }
  static fromObject(e, n) {
    let { filters: r, resizeFilter: o, src: s, crossOrigin: a, type: l } = e, u = zt(e, sA);
    return Promise.all([vc(s, K(K({}, n), {}, { crossOrigin: a })), r && Ml(r, n), o && Ml([o], n), vd(u, n)]).then((c) => {
      let [d, h = [], [p] = [], m = {}] = c;
      return new this(d, K(K({}, u), {}, { src: s, filters: h, resizeFilter: p }, m));
    });
  }
  static fromURL(e) {
    let { crossOrigin: n = null, signal: r } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = arguments.length > 2 ? arguments[2] : void 0;
    return vc(e, { crossOrigin: n, signal: r }).then((s) => new this(s, o));
  }
  static async fromElement(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 ? arguments[2] : void 0;
    const o = uo(e, this.ATTRIBUTE_NAMES, r);
    return this.fromURL(o["xlink:href"] || o.href, n, o).catch((s) => (Ro("log", "Unable to parse Image", s), null));
  }
}
Y(Zn, "type", "Image"), Y(Zn, "cacheProperties", [...lo, ...w1]), Y(Zn, "ownDefaults", { strokeWidth: 0, srcFromAttribute: !1, minimumScaleTrigger: 0.5, cropX: 0, cropY: 0, imageSmoothing: !0 }), Y(Zn, "CSS_CANVAS", "canvas-img"), Y(Zn, "ATTRIBUTE_NAMES", [...Bo, "x", "y", "width", "height", "preserveAspectRatio", "xlink:href", "href", "crossOrigin", "image-rendering"]), Ne.setClass(Zn), Ne.setSVGClass(Zn);
bd(["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"]);
const Sd = (i) => i.webgl !== void 0, xp = "precision highp float", aA = `
    `.concat(xp, `;
    varying vec2 vTexCoord;
    uniform sampler2D uTexture;
    void main() {
      gl_FragColor = texture2D(uTexture, vTexCoord);
    }`), lA = ["type"], uA = ["type"], cA = new RegExp(xp, "g");
class bn {
  get type() {
    return this.constructor.type;
  }
  constructor() {
    let e = zt(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, lA);
    Object.assign(this, this.constructor.defaults, e);
  }
  getFragmentSource() {
    return aA;
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aPosition;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }`;
  }
  createProgram(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getFragmentSource(), r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getVertexSource();
    const { WebGLProbe: { GLPrecision: o = "highp" } } = Sr();
    o !== "highp" && (n = n.replace(cA, xp.replace("highp", o)));
    const s = e.createShader(e.VERTEX_SHADER), a = e.createShader(e.FRAGMENT_SHADER), l = e.createProgram();
    if (!s || !a || !l) throw new yr("Vertex, fragment shader or program creation error");
    if (e.shaderSource(s, r), e.compileShader(s), !e.getShaderParameter(s, e.COMPILE_STATUS)) throw new yr("Vertex shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(s)));
    if (e.shaderSource(a, n), e.compileShader(a), !e.getShaderParameter(a, e.COMPILE_STATUS)) throw new yr("Fragment shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(a)));
    if (e.attachShader(l, s), e.attachShader(l, a), e.linkProgram(l), !e.getProgramParameter(l, e.LINK_STATUS)) throw new yr('Shader link error for "'.concat(this.type, '" ').concat(e.getProgramInfoLog(l)));
    const u = this.getUniformLocations(e, l) || {};
    return u.uStepW = e.getUniformLocation(l, "uStepW"), u.uStepH = e.getUniformLocation(l, "uStepH"), { program: l, attributeLocations: this.getAttributeLocations(e, l), uniformLocations: u };
  }
  getAttributeLocations(e, n) {
    return { aPosition: e.getAttribLocation(n, "aPosition") };
  }
  getUniformLocations(e, n) {
    const r = this.constructor.uniformLocations, o = {};
    for (let s = 0; s < r.length; s++) o[r[s]] = e.getUniformLocation(n, r[s]);
    return o;
  }
  sendAttributeData(e, n, r) {
    const o = n.aPosition, s = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, s), e.enableVertexAttribArray(o), e.vertexAttribPointer(o, 2, e.FLOAT, !1, 0, 0), e.bufferData(e.ARRAY_BUFFER, r, e.STATIC_DRAW);
  }
  _setupFrameBuffer(e) {
    const n = e.context;
    if (e.passes > 1) {
      const r = e.destinationWidth, o = e.destinationHeight;
      e.sourceWidth === r && e.sourceHeight === o || (n.deleteTexture(e.targetTexture), e.targetTexture = e.filterBackend.createTexture(n, r, o)), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e.targetTexture, 0);
    } else n.bindFramebuffer(n.FRAMEBUFFER, null), n.finish();
  }
  _swapTextures(e) {
    e.passes--, e.pass++;
    const n = e.targetTexture;
    e.targetTexture = e.sourceTexture, e.sourceTexture = n;
  }
  isNeutralState(e) {
    return !1;
  }
  applyTo(e) {
    Sd(e) ? (this._setupFrameBuffer(e), this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
  }
  getCacheKey() {
    return this.type;
  }
  retrieveShader(e) {
    const n = this.getCacheKey();
    return e.programCache[n] || (e.programCache[n] = this.createProgram(e.context)), e.programCache[n];
  }
  applyToWebGL(e) {
    const n = e.context, r = this.retrieveShader(e);
    e.pass === 0 && e.originalTexture ? n.bindTexture(n.TEXTURE_2D, e.originalTexture) : n.bindTexture(n.TEXTURE_2D, e.sourceTexture), n.useProgram(r.program), this.sendAttributeData(n, r.attributeLocations, e.aPosition), n.uniform1f(r.uniformLocations.uStepW, 1 / e.sourceWidth), n.uniform1f(r.uniformLocations.uStepH, 1 / e.sourceHeight), this.sendUniformData(n, r.uniformLocations), n.viewport(0, 0, e.destinationWidth, e.destinationHeight), n.drawArrays(n.TRIANGLE_STRIP, 0, 4);
  }
  bindAdditionalTexture(e, n, r) {
    e.activeTexture(r), e.bindTexture(e.TEXTURE_2D, n), e.activeTexture(e.TEXTURE0);
  }
  unbindAdditionalTexture(e, n) {
    e.activeTexture(n), e.bindTexture(e.TEXTURE_2D, null), e.activeTexture(e.TEXTURE0);
  }
  sendUniformData(e, n) {
  }
  createHelpLayer(e) {
    if (!e.helpLayer) {
      const { sourceWidth: n, sourceHeight: r } = e, o = Ci({ width: n, height: r });
      e.helpLayer = o;
    }
  }
  toObject() {
    const e = Object.keys(this.constructor.defaults || {});
    return K({ type: this.type }, e.reduce((n, r) => (n[r] = this[r], n), {}));
  }
  toJSON() {
    return this.toObject();
  }
  static async fromObject(e, n) {
    return new this(zt(e, uA));
  }
}
Y(bn, "type", "BaseFilter"), Y(bn, "uniformLocations", []);
const dA = { multiply: `gl_FragColor.rgb *= uColor.rgb;
`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`, add: `gl_FragColor.rgb += uColor.rgb;
`, difference: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`, subtract: `gl_FragColor.rgb -= uColor.rgb;
`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`, overlay: `
    if (uColor.r < 0.5) {
      gl_FragColor.r *= 2.0 * uColor.r;
    } else {
      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
    }
    if (uColor.g < 0.5) {
      gl_FragColor.g *= 2.0 * uColor.g;
    } else {
      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
    }
    if (uColor.b < 0.5) {
      gl_FragColor.b *= 2.0 * uColor.b;
    } else {
      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
    }
    `, tint: `
    gl_FragColor.rgb *= (1.0 - uColor.a);
    gl_FragColor.rgb += uColor.rgb;
    ` };
class Bu extends bn {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec4 uColor;
      varying vec2 vTexCoord;
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        gl_FragColor = color;
        if (color.a > 0.0) {
          `.concat(dA[this.mode], `
        }
      }
      `);
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const r = new $t(this.color).getSource(), o = this.alpha, s = r[0] * o, a = r[1] * o, l = r[2] * o, u = 1 - o;
    for (let c = 0; c < n.length; c += 4) {
      const d = n[c], h = n[c + 1], p = n[c + 2];
      let m, v, y;
      switch (this.mode) {
        case "multiply":
          m = d * s / 255, v = h * a / 255, y = p * l / 255;
          break;
        case "screen":
          m = 255 - (255 - d) * (255 - s) / 255, v = 255 - (255 - h) * (255 - a) / 255, y = 255 - (255 - p) * (255 - l) / 255;
          break;
        case "add":
          m = d + s, v = h + a, y = p + l;
          break;
        case "difference":
          m = Math.abs(d - s), v = Math.abs(h - a), y = Math.abs(p - l);
          break;
        case "subtract":
          m = d - s, v = h - a, y = p - l;
          break;
        case "darken":
          m = Math.min(d, s), v = Math.min(h, a), y = Math.min(p, l);
          break;
        case "lighten":
          m = Math.max(d, s), v = Math.max(h, a), y = Math.max(p, l);
          break;
        case "overlay":
          m = s < 128 ? 2 * d * s / 255 : 255 - 2 * (255 - d) * (255 - s) / 255, v = a < 128 ? 2 * h * a / 255 : 255 - 2 * (255 - h) * (255 - a) / 255, y = l < 128 ? 2 * p * l / 255 : 255 - 2 * (255 - p) * (255 - l) / 255;
          break;
        case "exclusion":
          m = s + d - 2 * s * d / 255, v = a + h - 2 * a * h / 255, y = l + p - 2 * l * p / 255;
          break;
        case "tint":
          m = s + d * u, v = a + h * u, y = l + p * u;
      }
      n[c] = m, n[c + 1] = v, n[c + 2] = y;
    }
  }
  sendUniformData(e, n) {
    const r = new $t(this.color).getSource();
    r[0] = this.alpha * r[0] / 255, r[1] = this.alpha * r[1] / 255, r[2] = this.alpha * r[2] / 255, r[3] = this.alpha, e.uniform4fv(n.uColor, r);
  }
}
Y(Bu, "defaults", { color: "#F95C63", mode: "multiply", alpha: 1 }), Y(Bu, "type", "BlendColor"), Y(Bu, "uniformLocations", ["uColor"]), Ne.setClass(Bu);
const hA = { multiply: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.rgba *= color2.rgba;
      gl_FragColor = color;
    }
    `, mask: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.a = color2.a;
      gl_FragColor = color;
    }
    ` }, fA = ["type", "image"];
class Hu extends bn {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return hA[this.mode];
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    uniform mat3 uTransformMatrix;
    void main() {
      vTexCoord = aPosition;
      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }
    `;
  }
  applyToWebGL(e) {
    const n = e.context, r = this.createTexture(e.filterBackend, this.image);
    this.bindAdditionalTexture(n, r, n.TEXTURE1), super.applyToWebGL(e), this.unbindAdditionalTexture(n, n.TEXTURE1);
  }
  createTexture(e, n) {
    return e.getCachedTexture(n.cacheKey, n.getElement());
  }
  calculateMatrix() {
    const e = this.image, { width: n, height: r } = e.getElement();
    return [1 / e.scaleX, 0, 0, 0, 1 / e.scaleY, 0, -e.left / n, -e.top / r, 1];
  }
  applyTo2d(e) {
    let { imageData: { data: n, width: r, height: o }, filterBackend: { resources: s } } = e;
    const a = this.image;
    s.blendImage || (s.blendImage = ro());
    const l = s.blendImage, u = l.getContext("2d");
    l.width !== r || l.height !== o ? (l.width = r, l.height = o) : u.clearRect(0, 0, r, o), u.setTransform(a.scaleX, 0, 0, a.scaleY, a.left, a.top), u.drawImage(a.getElement(), 0, 0, r, o);
    const c = u.getImageData(0, 0, r, o).data;
    for (let d = 0; d < n.length; d += 4) {
      const h = n[d], p = n[d + 1], m = n[d + 2], v = n[d + 3], y = c[d], w = c[d + 1], g = c[d + 2], k = c[d + 3];
      switch (this.mode) {
        case "multiply":
          n[d] = h * y / 255, n[d + 1] = p * w / 255, n[d + 2] = m * g / 255, n[d + 3] = v * k / 255;
          break;
        case "mask":
          n[d + 3] = k;
      }
    }
  }
  sendUniformData(e, n) {
    const r = this.calculateMatrix();
    e.uniform1i(n.uImage, 1), e.uniformMatrix3fv(n.uTransformMatrix, !1, r);
  }
  toObject() {
    return K(K({}, super.toObject()), {}, { image: this.image && this.image.toObject() });
  }
  static async fromObject(e, n) {
    let { type: r, image: o } = e, s = zt(e, fA);
    return Zn.fromObject(o, n).then((a) => new this(K(K({}, s), {}, { image: a })));
  }
}
Y(Hu, "type", "BlendImage"), Y(Hu, "defaults", { mode: "multiply", alpha: 1 }), Y(Hu, "uniformLocations", ["uTransformMatrix", "uImage"]), Ne.setClass(Hu);
class Uu extends bn {
  getFragmentSource() {
    return `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDelta;
    varying vec2 vTexCoord;
    const float nSamples = 15.0;
    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
    float random(vec3 scale) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
    }
    void main() {
      vec4 color = vec4(0.0);
      float totalC = 0.0;
      float totalA = 0.0;
      float offset = random(v3offset);
      for (float t = -nSamples; t <= nSamples; t++) {
        float percent = (t + offset - 0.5) / nSamples;
        vec4 sample = texture2D(uTexture, vTexCoord + uDelta * percent);
        float weight = 1.0 - abs(percent);
        float alpha = weight * sample.a;
        color.rgb += sample.rgb * alpha;
        color.a += alpha;
        totalA += weight;
        totalC += alpha;
      }
      gl_FragColor.rgb = color.rgb / totalC;
      gl_FragColor.a = color.a / totalA;
    }
  `;
  }
  applyTo(e) {
    Sd(e) ? (this.aspectRatio = e.sourceWidth / e.sourceHeight, e.passes++, this._setupFrameBuffer(e), this.horizontal = !0, this.applyToWebGL(e), this._swapTextures(e), this._setupFrameBuffer(e), this.horizontal = !1, this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
    let { imageData: { data: n, width: r, height: o } } = e;
    this.aspectRatio = r / o, this.horizontal = !0;
    let s = this.getBlurValue() * r;
    const a = new Uint8ClampedArray(n), l = 15, u = 4 * r;
    for (let c = 0; c < n.length; c += 4) {
      let d = 0, h = 0, p = 0, m = 0, v = 0;
      const y = c - c % u, w = y + u;
      for (let g = -14; g < l; g++) {
        const k = g / l, _ = 4 * Math.floor(s * k), S = 1 - Math.abs(k);
        let b = c + _;
        b < y ? b = y : b > w && (b = w);
        const C = n[b + 3] * S;
        d += n[b] * C, h += n[b + 1] * C, p += n[b + 2] * C, m += C, v += S;
      }
      a[c] = d / m, a[c + 1] = h / m, a[c + 2] = p / m, a[c + 3] = m / v;
    }
    this.horizontal = !1, s = this.getBlurValue() * o;
    for (let c = 0; c < a.length; c += 4) {
      let d = 0, h = 0, p = 0, m = 0, v = 0;
      const y = c % u, w = a.length - u + y;
      for (let g = -14; g < l; g++) {
        const k = g / l, _ = Math.floor(s * k) * u, S = 1 - Math.abs(k);
        let b = c + _;
        b < y ? b = y : b > w && (b = w);
        const C = a[b + 3] * S;
        d += a[b] * C, h += a[b + 1] * C, p += a[b + 2] * C, m += C, v += S;
      }
      n[c] = d / m, n[c + 1] = h / m, n[c + 2] = p / m, n[c + 3] = m / v;
    }
  }
  sendUniformData(e, n) {
    const r = this.chooseRightDelta();
    e.uniform2fv(n.uDelta, r);
  }
  isNeutralState() {
    return this.blur === 0;
  }
  getBlurValue() {
    let e = 1;
    const { horizontal: n, aspectRatio: r } = this;
    return n ? r > 1 && (e = 1 / r) : r < 1 && (e = r), e * this.blur * 0.12;
  }
  chooseRightDelta() {
    const e = this.getBlurValue();
    return this.horizontal ? [e, 0] : [0, e];
  }
}
Y(Uu, "type", "Blur"), Y(Uu, "defaults", { blur: 0 }), Y(Uu, "uniformLocations", ["uDelta"]), Ne.setClass(Uu);
class Wu extends bn {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBrightness;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += uBrightness;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const r = Math.round(255 * this.brightness);
    for (let o = 0; o < n.length; o += 4) n[o] += r, n[o + 1] += r, n[o + 2] += r;
  }
  isNeutralState() {
    return this.brightness === 0;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uBrightness, this.brightness);
  }
}
Y(Wu, "type", "Brightness"), Y(Wu, "defaults", { brightness: 0 }), Y(Wu, "uniformLocations", ["uBrightness"]), Ne.setClass(Wu);
const _1 = { matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], colorsOnly: !0 };
class oa extends bn {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  varying vec2 vTexCoord;
  uniform mat4 uColorMatrix;
  uniform vec4 uConstants;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color *= uColorMatrix;
    color += uConstants;
    gl_FragColor = color;
  }`;
  }
  applyTo2d(e) {
    const n = e.imageData.data, r = this.matrix, o = this.colorsOnly;
    for (let s = 0; s < n.length; s += 4) {
      const a = n[s], l = n[s + 1], u = n[s + 2];
      if (n[s] = a * r[0] + l * r[1] + u * r[2] + 255 * r[4], n[s + 1] = a * r[5] + l * r[6] + u * r[7] + 255 * r[9], n[s + 2] = a * r[10] + l * r[11] + u * r[12] + 255 * r[14], !o) {
        const c = n[s + 3];
        n[s] += c * r[3], n[s + 1] += c * r[8], n[s + 2] += c * r[13], n[s + 3] = a * r[15] + l * r[16] + u * r[17] + c * r[18] + 255 * r[19];
      }
    }
  }
  sendUniformData(e, n) {
    const r = this.matrix, o = [r[0], r[1], r[2], r[3], r[5], r[6], r[7], r[8], r[10], r[11], r[12], r[13], r[15], r[16], r[17], r[18]], s = [r[4], r[9], r[14], r[19]];
    e.uniformMatrix4fv(n.uColorMatrix, !1, o), e.uniform4fv(n.uConstants, s);
  }
  toObject() {
    return K(K({}, super.toObject()), {}, { matrix: [...this.matrix] });
  }
}
function Ls(i, e) {
  var n;
  const r = (Y(n = class extends oa {
    toObject() {
      return { type: this.type, colorsOnly: this.colorsOnly };
    }
  }, "type", i), Y(n, "defaults", { colorsOnly: !1, matrix: e }), n);
  return Ne.setClass(r, i), r;
}
Y(oa, "type", "ColorMatrix"), Y(oa, "defaults", _1), Y(oa, "uniformLocations", ["uColorMatrix", "uConstants"]), Ne.setClass(oa);
Ls("Brownie", [0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0, -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0]);
Ls("Vintage", [0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259, 0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0]);
Ls("Kodachrome", [1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352, -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0, 0, 1, 0]);
Ls("Technicolor", [1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589, -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0, 0, 1, 0]);
Ls("Polaroid", [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0]);
Ls("Sepia", [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0]);
Ls("BlackWhite", [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]);
class wv extends bn {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.subFilters = e.subFilters || [];
  }
  applyTo(e) {
    Sd(e) && (e.passes += this.subFilters.length - 1), this.subFilters.forEach((n) => {
      n.applyTo(e);
    });
  }
  toObject() {
    return { type: this.type, subFilters: this.subFilters.map((e) => e.toObject()) };
  }
  isNeutralState() {
    return !this.subFilters.some((e) => !e.isNeutralState());
  }
  static fromObject(e, n) {
    return Promise.all((e.subFilters || []).map((r) => Ne.getClass(r.type).fromObject(r, n))).then((r) => new this({ subFilters: r }));
  }
}
Y(wv, "type", "Composed"), Ne.setClass(wv);
class Gu extends bn {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uContrast;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
    gl_FragColor = color;
  }`;
  }
  isNeutralState() {
    return this.contrast === 0;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const r = Math.floor(255 * this.contrast), o = 259 * (r + 255) / (255 * (259 - r));
    for (let s = 0; s < n.length; s += 4) n[s] = o * (n[s] - 128) + 128, n[s + 1] = o * (n[s + 1] - 128) + 128, n[s + 2] = o * (n[s + 2] - 128) + 128;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uContrast, this.contrast);
  }
}
Y(Gu, "type", "Contrast"), Y(Gu, "defaults", { contrast: 0 }), Y(Gu, "uniformLocations", ["uContrast"]), Ne.setClass(Gu);
const pA = { Convolute_3_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_3_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_5_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_5_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_7_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_7_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_9_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_9_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    ` };
class Xu extends bn {
  getCacheKey() {
    return "".concat(this.type, "_").concat(Math.sqrt(this.matrix.length), "_").concat(this.opaque ? 1 : 0);
  }
  getFragmentSource() {
    return pA[this.getCacheKey()];
  }
  applyTo2d(e) {
    const n = e.imageData, r = n.data, o = this.matrix, s = Math.round(Math.sqrt(o.length)), a = Math.floor(s / 2), l = n.width, u = n.height, c = e.ctx.createImageData(l, u), d = c.data, h = this.opaque ? 1 : 0;
    let p, m, v, y, w, g, k, _, S, b, C, x, I;
    for (C = 0; C < u; C++) for (b = 0; b < l; b++) {
      for (w = 4 * (C * l + b), p = 0, m = 0, v = 0, y = 0, I = 0; I < s; I++) for (x = 0; x < s; x++) k = C + I - a, g = b + x - a, k < 0 || k >= u || g < 0 || g >= l || (_ = 4 * (k * l + g), S = o[I * s + x], p += r[_] * S, m += r[_ + 1] * S, v += r[_ + 2] * S, h || (y += r[_ + 3] * S));
      d[w] = p, d[w + 1] = m, d[w + 2] = v, d[w + 3] = h ? r[w + 3] : y;
    }
    e.imageData = c;
  }
  sendUniformData(e, n) {
    e.uniform1fv(n.uMatrix, this.matrix);
  }
  toObject() {
    return K(K({}, super.toObject()), {}, { opaque: this.opaque, matrix: [...this.matrix] });
  }
}
Y(Xu, "type", "Convolute"), Y(Xu, "defaults", { opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0] }), Y(Xu, "uniformLocations", ["uMatrix", "uOpaque", "uHalfSize", "uSize"]), Ne.setClass(Xu);
const x1 = "Gamma";
class Yu extends bn {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform vec3 uGamma;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec3 correction = (1.0 / uGamma);
    color.r = pow(color.r, correction.r);
    color.g = pow(color.g, correction.g);
    color.b = pow(color.b, correction.b);
    gl_FragColor = color;
    gl_FragColor.rgb *= color.a;
  }
`;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.gamma = e.gamma || this.constructor.defaults.gamma.concat();
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const r = this.gamma, o = 1 / r[0], s = 1 / r[1], a = 1 / r[2];
    this.rgbValues || (this.rgbValues = { r: new Uint8Array(256), g: new Uint8Array(256), b: new Uint8Array(256) });
    const l = this.rgbValues;
    for (let u = 0; u < 256; u++) l.r[u] = 255 * Math.pow(u / 255, o), l.g[u] = 255 * Math.pow(u / 255, s), l.b[u] = 255 * Math.pow(u / 255, a);
    for (let u = 0; u < n.length; u += 4) n[u] = l.r[n[u]], n[u + 1] = l.g[n[u + 1]], n[u + 2] = l.b[n[u + 2]];
  }
  sendUniformData(e, n) {
    e.uniform3fv(n.uGamma, this.gamma);
  }
  isNeutralState() {
    const { gamma: e } = this;
    return e[0] === 1 && e[1] === 1 && e[2] === 1;
  }
  toObject() {
    return { type: x1, gamma: this.gamma.concat() };
  }
}
Y(Yu, "type", x1), Y(Yu, "defaults", { gamma: [1, 1, 1] }), Y(Yu, "uniformLocations", ["uGamma"]), Ne.setClass(Yu);
const mA = { average: `
    precision highp float;
    uniform sampler2D uTexture;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      float average = (color.r + color.b + color.g) / 3.0;
      gl_FragColor = vec4(average, average, average, color.a);
    }
    `, lightness: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    `, luminosity: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    ` };
class Ku extends bn {
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    for (let r, o = 0; o < n.length; o += 4) {
      const s = n[o], a = n[o + 1], l = n[o + 2];
      switch (this.mode) {
        case "average":
          r = (s + a + l) / 3;
          break;
        case "lightness":
          r = (Math.min(s, a, l) + Math.max(s, a, l)) / 2;
          break;
        case "luminosity":
          r = 0.21 * s + 0.72 * a + 0.07 * l;
      }
      n[o + 2] = n[o + 1] = n[o] = r;
    }
  }
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return mA[this.mode];
  }
  sendUniformData(e, n) {
    e.uniform1i(n.uMode, 1);
  }
  isNeutralState() {
    return !1;
  }
}
Y(Ku, "type", "Grayscale"), Y(Ku, "defaults", { mode: "average" }), Y(Ku, "uniformLocations", ["uMode"]), Ne.setClass(Ku);
const gA = K(K({}, _1), {}, { rotation: 0 });
class vh extends oa {
  calculateMatrix() {
    const e = this.rotation * Math.PI, n = no(e), r = io(e), o = 1 / 3, s = Math.sqrt(o) * r, a = 1 - n;
    this.matrix = [n + a / 3, o * a - s, o * a + s, 0, 0, o * a + s, n + o * a, o * a - s, 0, 0, o * a - s, o * a + s, n + o * a, 0, 0, 0, 0, 0, 1, 0];
  }
  isNeutralState() {
    return this.rotation === 0;
  }
  applyTo(e) {
    this.calculateMatrix(), super.applyTo(e);
  }
  toObject() {
    return { type: this.type, rotation: this.rotation };
  }
}
Y(vh, "type", "HueRotation"), Y(vh, "defaults", gA), Ne.setClass(vh);
class qu extends bn {
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    for (let r = 0; r < n.length; r += 4) n[r] = 255 - n[r], n[r + 1] = 255 - n[r + 1], n[r + 2] = 255 - n[r + 2], this.alpha && (n[r + 3] = 255 - n[r + 3]);
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform int uInvert;
  uniform int uAlpha;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    if (uInvert == 1) {
      if (uAlpha == 1) {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);
      } else {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
      }
    } else {
      gl_FragColor = color;
    }
  }
`;
  }
  isNeutralState() {
    return !this.invert;
  }
  sendUniformData(e, n) {
    e.uniform1i(n.uInvert, Number(this.invert)), e.uniform1i(n.uAlpha, Number(this.alpha));
  }
}
Y(qu, "type", "Invert"), Y(qu, "defaults", { alpha: !1, invert: !0 }), Y(qu, "uniformLocations", ["uInvert", "uAlpha"]), Ne.setClass(qu);
class Zu extends bn {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uStepH;
  uniform float uNoise;
  uniform float uSeed;
  varying vec2 vTexCoord;
  float rand(vec2 co, float seed, float vScale) {
    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
  }
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const r = this.noise;
    for (let o = 0; o < n.length; o += 4) {
      const s = (0.5 - Math.random()) * r;
      n[o] += s, n[o + 1] += s, n[o + 2] += s;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uNoise, this.noise / 255), e.uniform1f(n.uSeed, Math.random());
  }
  isNeutralState() {
    return this.noise === 0;
  }
}
Y(Zu, "type", "Noise"), Y(Zu, "defaults", { noise: 0 }), Y(Zu, "uniformLocations", ["uNoise", "uSeed"]), Ne.setClass(Zu);
class Ju extends bn {
  applyTo2d(e) {
    let { imageData: { data: n, width: r, height: o } } = e;
    for (let s = 0; s < o; s += this.blocksize) for (let a = 0; a < r; a += this.blocksize) {
      const l = 4 * s * r + 4 * a, u = n[l], c = n[l + 1], d = n[l + 2], h = n[l + 3];
      for (let p = s; p < Math.min(s + this.blocksize, o); p++) for (let m = a; m < Math.min(a + this.blocksize, r); m++) {
        const v = 4 * p * r + 4 * m;
        n[v] = u, n[v + 1] = c, n[v + 2] = d, n[v + 3] = h;
      }
    }
  }
  isNeutralState() {
    return this.blocksize === 1;
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBlocksize;
  uniform float uStepW;
  uniform float uStepH;
  varying vec2 vTexCoord;
  void main() {
    float blockW = uBlocksize * uStepW;
    float blockH = uBlocksize * uStepH;
    int posX = int(vTexCoord.x / blockW);
    int posY = int(vTexCoord.y / blockH);
    float fposX = float(posX);
    float fposY = float(posY);
    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
    vec4 color = texture2D(uTexture, squareCoords);
    gl_FragColor = color;
  }
`;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uBlocksize, this.blocksize);
  }
}
Y(Ju, "type", "Pixelate"), Y(Ju, "defaults", { blocksize: 4 }), Y(Ju, "uniformLocations", ["uBlocksize"]), Ne.setClass(Ju);
class Qu extends bn {
  getFragmentSource() {
    return `
precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
  gl_FragColor = texture2D(uTexture, vTexCoord);
  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
    gl_FragColor.a = 0.0;
  }
}
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const r = 255 * this.distance, o = new $t(this.color).getSource(), s = [o[0] - r, o[1] - r, o[2] - r], a = [o[0] + r, o[1] + r, o[2] + r];
    for (let l = 0; l < n.length; l += 4) {
      const u = n[l], c = n[l + 1], d = n[l + 2];
      u > s[0] && c > s[1] && d > s[2] && u < a[0] && c < a[1] && d < a[2] && (n[l + 3] = 0);
    }
  }
  sendUniformData(e, n) {
    const r = new $t(this.color).getSource(), o = this.distance, s = [0 + r[0] / 255 - o, 0 + r[1] / 255 - o, 0 + r[2] / 255 - o, 1], a = [r[0] / 255 + o, r[1] / 255 + o, r[2] / 255 + o, 1];
    e.uniform4fv(n.uLow, s), e.uniform4fv(n.uHigh, a);
  }
}
Y(Qu, "type", "RemoveColor"), Y(Qu, "defaults", { color: "#FFFFFF", distance: 0.02, useAlpha: !1 }), Y(Qu, "uniformLocations", ["uLow", "uHigh"]), Ne.setClass(Qu);
class ec extends bn {
  sendUniformData(e, n) {
    e.uniform2fv(n.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), e.uniform1fv(n.uTaps, this.taps);
  }
  getFilterWindow() {
    const e = this.tempScale;
    return Math.ceil(this.lanczosLobes / e);
  }
  getCacheKey() {
    const e = this.getFilterWindow();
    return "".concat(this.type, "_").concat(e);
  }
  getFragmentSource() {
    const e = this.getFilterWindow();
    return this.generateShader(e);
  }
  getTaps() {
    const e = this.lanczosCreate(this.lanczosLobes), n = this.tempScale, r = this.getFilterWindow(), o = new Array(r);
    for (let s = 1; s <= r; s++) o[s - 1] = e(s * n);
    return o;
  }
  generateShader(e) {
    const n = new Array(e);
    for (let r = 1; r <= e; r++) n[r - 1] = "".concat(r, ".0 * uDelta");
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec2 uDelta;
      varying vec2 vTexCoord;
      uniform float uTaps[`.concat(e, `];
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        float sum = 1.0;
        `).concat(n.map((r, o) => `
              color += texture2D(uTexture, vTexCoord + `.concat(r, ") * uTaps[").concat(o, "] + texture2D(uTexture, vTexCoord - ").concat(r, ") * uTaps[").concat(o, `];
              sum += 2.0 * uTaps[`).concat(o, `];
            `)).join(`
`), `
        gl_FragColor = color / sum;
      }
    `);
  }
  applyToForWebgl(e) {
    e.passes++, this.width = e.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = e.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), e.destinationWidth = this.dW, super.applyTo(e), e.sourceWidth = e.destinationWidth, this.height = e.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), e.destinationHeight = this.dH, super.applyTo(e), e.sourceHeight = e.destinationHeight;
  }
  applyTo(e) {
    Sd(e) ? this.applyToForWebgl(e) : this.applyTo2d(e);
  }
  isNeutralState() {
    return this.scaleX === 1 && this.scaleY === 1;
  }
  lanczosCreate(e) {
    return (n) => {
      if (n >= e || n <= -e) return 0;
      if (n < 11920929e-14 && n > -11920929e-14) return 1;
      const r = (n *= Math.PI) / e;
      return Math.sin(n) / n * Math.sin(r) / r;
    };
  }
  applyTo2d(e) {
    const n = e.imageData, r = this.scaleX, o = this.scaleY;
    this.rcpScaleX = 1 / r, this.rcpScaleY = 1 / o;
    const s = n.width, a = n.height, l = Math.round(s * r), u = Math.round(a * o);
    let c;
    c = this.resizeType === "sliceHack" ? this.sliceByTwo(e, s, a, l, u) : this.resizeType === "hermite" ? this.hermiteFastResize(e, s, a, l, u) : this.resizeType === "bilinear" ? this.bilinearFiltering(e, s, a, l, u) : this.resizeType === "lanczos" ? this.lanczosResize(e, s, a, l, u) : new ImageData(l, u), e.imageData = c;
  }
  sliceByTwo(e, n, r, o, s) {
    const a = e.imageData, l = 0.5;
    let u = !1, c = !1, d = n * l, h = r * l;
    const p = e.filterBackend.resources;
    let m = 0, v = 0;
    const y = n;
    let w = 0;
    p.sliceByTwo || (p.sliceByTwo = ro());
    const g = p.sliceByTwo;
    (g.width < 1.5 * n || g.height < r) && (g.width = 1.5 * n, g.height = r);
    const k = g.getContext("2d");
    for (k.clearRect(0, 0, 1.5 * n, r), k.putImageData(a, 0, 0), o = Math.floor(o), s = Math.floor(s); !u || !c; ) n = d, r = h, o < Math.floor(d * l) ? d = Math.floor(d * l) : (d = o, u = !0), s < Math.floor(h * l) ? h = Math.floor(h * l) : (h = s, c = !0), k.drawImage(g, m, v, n, r, y, w, d, h), m = y, v = w, w += h;
    return k.getImageData(m, v, o, s);
  }
  lanczosResize(e, n, r, o, s) {
    const a = e.imageData.data, l = e.ctx.createImageData(o, s), u = l.data, c = this.lanczosCreate(this.lanczosLobes), d = this.rcpScaleX, h = this.rcpScaleY, p = 2 / this.rcpScaleX, m = 2 / this.rcpScaleY, v = Math.ceil(d * this.lanczosLobes / 2), y = Math.ceil(h * this.lanczosLobes / 2), w = {}, g = { x: 0, y: 0 }, k = { x: 0, y: 0 };
    return function _(S) {
      let b, C, x, I, F, B, X, j, ee, ie, M;
      for (g.x = (S + 0.5) * d, k.x = Math.floor(g.x), b = 0; b < s; b++) {
        for (g.y = (b + 0.5) * h, k.y = Math.floor(g.y), F = 0, B = 0, X = 0, j = 0, ee = 0, C = k.x - v; C <= k.x + v; C++) if (!(C < 0 || C >= n)) {
          ie = Math.floor(1e3 * Math.abs(C - g.x)), w[ie] || (w[ie] = {});
          for (let W = k.y - y; W <= k.y + y; W++) W < 0 || W >= r || (M = Math.floor(1e3 * Math.abs(W - g.y)), w[ie][M] || (w[ie][M] = c(Math.sqrt(Math.pow(ie * p, 2) + Math.pow(M * m, 2)) / 1e3)), x = w[ie][M], x > 0 && (I = 4 * (W * n + C), F += x, B += x * a[I], X += x * a[I + 1], j += x * a[I + 2], ee += x * a[I + 3]));
        }
        I = 4 * (b * o + S), u[I] = B / F, u[I + 1] = X / F, u[I + 2] = j / F, u[I + 3] = ee / F;
      }
      return ++S < o ? _(S) : l;
    }(0);
  }
  bilinearFiltering(e, n, r, o, s) {
    let a, l, u, c, d, h, p, m, v, y, w, g, k, _ = 0;
    const S = this.rcpScaleX, b = this.rcpScaleY, C = 4 * (n - 1), x = e.imageData.data, I = e.ctx.createImageData(o, s), F = I.data;
    for (p = 0; p < s; p++) for (m = 0; m < o; m++) for (d = Math.floor(S * m), h = Math.floor(b * p), v = S * m - d, y = b * p - h, k = 4 * (h * n + d), w = 0; w < 4; w++) a = x[k + w], l = x[k + 4 + w], u = x[k + C + w], c = x[k + C + 4 + w], g = a * (1 - v) * (1 - y) + l * v * (1 - y) + u * y * (1 - v) + c * v * y, F[_++] = g;
    return I;
  }
  hermiteFastResize(e, n, r, o, s) {
    const a = this.rcpScaleX, l = this.rcpScaleY, u = Math.ceil(a / 2), c = Math.ceil(l / 2), d = e.imageData.data, h = e.ctx.createImageData(o, s), p = h.data;
    for (let m = 0; m < s; m++) for (let v = 0; v < o; v++) {
      const y = 4 * (v + m * o);
      let w = 0, g = 0, k = 0, _ = 0, S = 0, b = 0, C = 0;
      const x = (m + 0.5) * l;
      for (let I = Math.floor(m * l); I < (m + 1) * l; I++) {
        const F = Math.abs(x - (I + 0.5)) / c, B = (v + 0.5) * a, X = F * F;
        for (let j = Math.floor(v * a); j < (v + 1) * a; j++) {
          let ee = Math.abs(B - (j + 0.5)) / u;
          const ie = Math.sqrt(X + ee * ee);
          ie > 1 && ie < -1 || (w = 2 * ie * ie * ie - 3 * ie * ie + 1, w > 0 && (ee = 4 * (j + I * n), C += w * d[ee + 3], k += w, d[ee + 3] < 255 && (w = w * d[ee + 3] / 250), _ += w * d[ee], S += w * d[ee + 1], b += w * d[ee + 2], g += w));
        }
      }
      p[y] = _ / g, p[y + 1] = S / g, p[y + 2] = b / g, p[y + 3] = C / k;
    }
    return h;
  }
}
Y(ec, "type", "Resize"), Y(ec, "defaults", { resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3 }), Y(ec, "uniformLocations", ["uDelta", "uTaps"]), Ne.setClass(ec);
class tc extends bn {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uSaturation;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float rgMax = max(color.r, color.g);
    float rgbMax = max(rgMax, color.b);
    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const r = -this.saturation;
    for (let o = 0; o < n.length; o += 4) {
      const s = n[o], a = n[o + 1], l = n[o + 2], u = Math.max(s, a, l);
      n[o] += u !== s ? (u - s) * r : 0, n[o + 1] += u !== a ? (u - a) * r : 0, n[o + 2] += u !== l ? (u - l) * r : 0;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uSaturation, -this.saturation);
  }
  isNeutralState() {
    return this.saturation === 0;
  }
}
Y(tc, "type", "Saturation"), Y(tc, "defaults", { saturation: 0 }), Y(tc, "uniformLocations", ["uSaturation"]), Ne.setClass(tc);
class nc extends bn {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uVibrance;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float max = max(color.r, max(color.g, color.b));
    float avg = (color.r + color.g + color.b) / 3.0;
    float amt = (abs(max - avg) * 2.0) * uVibrance;
    color.r += max != color.r ? (max - color.r) * amt : 0.00;
    color.g += max != color.g ? (max - color.g) * amt : 0.00;
    color.b += max != color.b ? (max - color.b) * amt : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const r = -this.vibrance;
    for (let o = 0; o < n.length; o += 4) {
      const s = n[o], a = n[o + 1], l = n[o + 2], u = Math.max(s, a, l), c = (s + a + l) / 3, d = 2 * Math.abs(u - c) / 255 * r;
      n[o] += u !== s ? (u - s) * d : 0, n[o + 1] += u !== a ? (u - a) * d : 0, n[o + 2] += u !== l ? (u - l) * d : 0;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uVibrance, -this.vibrance);
  }
  isNeutralState() {
    return this.vibrance === 0;
  }
}
Y(nc, "type", "Vibrance"), Y(nc, "defaults", { vibrance: 0 }), Y(nc, "uniformLocations", ["uVibrance"]), Ne.setClass(nc);
const _v = vA(), xv = yA();
function vA() {
  const i = new Uint8Array(1024);
  for (let e = 0; e < 256; e++) {
    const n = e / 255, r = Math.round(255 * pa(0.267004 + n * (4874e-6 + n * (-0.259027 + n * (2.066795 + n * (-2.131557 + n * 0.736987)))))), o = Math.round(255 * pa(4874e-6 + n * (1.404613 + n * (-0.598103 + n * (-0.229949 + n * (0.659864 + n * -0.238132)))))), s = Math.round(255 * pa(0.329415 + n * (1.384613 + n * (-1.860504 + n * (1.592785 + n * (-0.730173 + n * 0.13561))))));
    i[e * 4] = r, i[e * 4 + 1] = o, i[e * 4 + 2] = s, i[e * 4 + 3] = 255;
  }
  return i;
}
function yA() {
  const i = new Uint8Array(1024);
  for (let e = 0; e < 256; e++) {
    const n = e / 255, r = Math.round(255 * pa(0.050383 + n * (2.689401 + n * (-1.802775 + n * (-0.391194 + n * (0.706557 + n * -0.218185)))))), o = Math.round(255 * pa(0.029803 + n * (-0.177105 + n * (0.96833 + n * (0.419198 + n * (-0.991163 + n * 0.517737)))))), s = Math.round(255 * pa(0.527975 + n * (1.546816 + n * (-4.246533 + n * (6.585146 + n * (-4.621553 + n * 1.205227))))));
    i[e * 4] = r, i[e * 4 + 1] = o, i[e * 4 + 2] = s, i[e * 4 + 3] = 255;
  }
  return i;
}
function pa(i) {
  return Math.max(0, Math.min(1, i));
}
const hs = class hs extends Zn {
  constructor(e, n = {}) {
    super(e, {
      ...hs.ownDefaults,
      ...n
    }), this.colormap = n.colormap || "viridis", this._colorizedCanvas = null, this._webglContext = null, this._webglProgram = null, this._sourceImageData = null, this._initializeColorization();
  }
  /**
   * Initialize the colorization system (WebGL or Canvas2D fallback)
   */
  _initializeColorization() {
    const e = this.getElement();
    e && (this._colorizedCanvas = document.createElement("canvas"), this._colorizedCanvas.width = e.width || e.naturalWidth, this._colorizedCanvas.height = e.height || e.naturalHeight, this._initWebGL() ? this._applyColormapWebGL() : this._applyColormapCanvas2D());
  }
  /**
   * Initialize WebGL context and shader program
   */
  _initWebGL() {
    if (!this._colorizedCanvas) return !1;
    try {
      const e = this._colorizedCanvas.getContext("webgl", {
        preserveDrawingBuffer: !0,
        alpha: !0
      });
      if (!e) return !1;
      this._webglContext = e;
      const n = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_texCoord;
        }
      `, r = `
        precision mediump float;
        uniform sampler2D u_image;
        uniform sampler2D u_colormap;
        varying vec2 v_texCoord;
        void main() {
          vec4 depth = texture2D(u_image, v_texCoord);
          float gray = dot(depth.rgb, vec3(0.299, 0.587, 0.114));
          vec4 color = texture2D(u_colormap, vec2(gray, 0.5));
          gl_FragColor = vec4(color.rgb, depth.a);
        }
      `, o = this._compileShader(e, e.VERTEX_SHADER, n), s = this._compileShader(e, e.FRAGMENT_SHADER, r);
      if (!o || !s) return !1;
      const a = e.createProgram();
      return a ? (e.attachShader(a, o), e.attachShader(a, s), e.linkProgram(a), e.getProgramParameter(a, e.LINK_STATUS) ? (this._webglProgram = a, !0) : (console.error("[DepthMapImage] Program link error:", e.getProgramInfoLog(a)), !1)) : !1;
    } catch (e) {
      return console.warn("[DepthMapImage] WebGL init failed:", e), !1;
    }
  }
  _compileShader(e, n, r) {
    const o = e.createShader(n);
    return o ? (e.shaderSource(o, r), e.compileShader(o), e.getShaderParameter(o, e.COMPILE_STATUS) ? o : (console.error("[DepthMapImage] Shader compile error:", e.getShaderInfoLog(o)), e.deleteShader(o), null)) : null;
  }
  /**
   * Apply colormap using WebGL
   */
  _applyColormapWebGL() {
    const e = this._webglContext, n = this._webglProgram;
    if (!e || !n || !this._colorizedCanvas) return;
    e.useProgram(n);
    const r = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, r), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1,
      1
    ]), e.STATIC_DRAW);
    const o = e.getAttribLocation(n, "a_position");
    e.enableVertexAttribArray(o), e.vertexAttribPointer(o, 2, e.FLOAT, !1, 0, 0);
    const s = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, s), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      0,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0
    ]), e.STATIC_DRAW);
    const a = e.getAttribLocation(n, "a_texCoord");
    e.enableVertexAttribArray(a), e.vertexAttribPointer(a, 2, e.FLOAT, !1, 0, 0);
    const l = e.createTexture();
    e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, l), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, this.getElement());
    const u = e.createTexture();
    e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, u), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR);
    const c = this.colormap === "plasma" ? xv : _v;
    e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 256, 1, 0, e.RGBA, e.UNSIGNED_BYTE, c), e.uniform1i(e.getUniformLocation(n, "u_image"), 0), e.uniform1i(e.getUniformLocation(n, "u_colormap"), 1), e.viewport(0, 0, this._colorizedCanvas.width, this._colorizedCanvas.height), e.drawArrays(e.TRIANGLES, 0, 6);
  }
  /**
   * Apply colormap using Canvas2D (fallback)
   */
  _applyColormapCanvas2D() {
    if (!this._colorizedCanvas) return;
    const e = this._colorizedCanvas.getContext("2d");
    if (!e) return;
    const n = this.getElement(), r = this._colorizedCanvas.width, o = this._colorizedCanvas.height;
    e.drawImage(n, 0, 0, r, o);
    const s = e.getImageData(0, 0, r, o), a = s.data, l = this.colormap === "plasma" ? xv : this.colormap === "viridis" ? _v : null;
    if (l) {
      for (let u = 0; u < a.length; u += 4) {
        const c = Math.round(
          a[u] * 0.299 + a[u + 1] * 0.587 + a[u + 2] * 0.114
        );
        a[u] = l[c * 4], a[u + 1] = l[c * 4 + 1], a[u + 2] = l[c * 4 + 2];
      }
      e.putImageData(s, 0, 0);
    }
  }
  /**
   * Set the colormap and re-apply
   */
  setColormap(e) {
    var n;
    this.colormap = e, this._webglContext && this._webglProgram ? this._applyColormapWebGL() : this._applyColormapCanvas2D(), this.dirty = !0, (n = this.canvas) == null || n.requestRenderAll();
  }
  /**
   * Override render to use colorized canvas
   */
  render(e) {
    if (this._colorizedCanvas && this.colormap !== "grayscale") {
      const n = this.getElement();
      this.setElement(this._colorizedCanvas), super.render(e), this.setElement(n);
    } else
      super.render(e);
  }
  /**
   * Get serializable properties including colormap
   */
  getSerializableData() {
    return {
      colormap: this.colormap
    };
  }
  /**
   * Deserialization from JSON
   */
  static fromObject(e) {
    return new Promise((n, r) => {
      if (!e.src) {
        r(new Error("DepthMapImage requires a src property"));
        return;
      }
      const o = new Image();
      o.crossOrigin = "anonymous", o.onload = () => {
        n(new hs(o, {
          colormap: e.colormap,
          ...e
        }));
      }, o.onerror = r, o.src = e.src;
    });
  }
  /**
   * Create from base64 data
   */
  static fromBase64(e, n = {}) {
    return new Promise((r, o) => {
      const s = new Image();
      s.crossOrigin = "anonymous", s.onload = () => {
        r(new hs(s, n));
      }, s.onerror = o, s.src = e.startsWith("data:") ? e : `data:image/png;base64,${e}`;
    });
  }
};
Xe(hs, "type", "DepthMapImage"), Xe(hs, "ownDefaults", {
  colormap: "viridis",
  opacity: 0.5,
  visible: !0
});
let ed = hs;
Ne.setClass(ed);
const sa = class sa extends $o {
  constructor(e, n = {}) {
    super(e, {
      ...sa.ownDefaults,
      ...n
    }), this.controlPoints = n.controlPoints || [], this._animationKeyframes = [];
  }
  /**
   * Update path data from control points
   */
  updatePathFromControlPoints() {
    if (this.controlPoints.length < 2) {
      this.set("path", []);
      return;
    }
    const e = [], n = this.controlPoints;
    e.push(["M", n[0].x, n[0].y]);
    for (let r = 0; r < n.length - 1; r++) {
      const o = n[r], s = n[r + 1], a = o.handleOut || { x: o.x, y: o.y }, l = s.handleIn || { x: s.x, y: s.y };
      e.push([
        "C",
        a.x,
        a.y,
        l.x,
        l.y,
        s.x,
        s.y
      ]);
    }
    this.set("path", e), this.setCoords();
  }
  /**
   * Add a new control point at position
   */
  addControlPoint(e, n, r) {
    const o = {
      id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      x: e,
      y: n,
      depth: r,
      handleIn: null,
      handleOut: null,
      type: "corner"
    };
    return this.controlPoints.push(o), this.updatePathFromControlPoints(), o;
  }
  /**
   * Move a control point
   */
  moveControlPoint(e, n, r) {
    const o = this.controlPoints.find((l) => l.id === e);
    if (!o) return;
    const s = n - o.x, a = r - o.y;
    o.x = n, o.y = r, o.handleIn && (o.handleIn.x += s, o.handleIn.y += a), o.handleOut && (o.handleOut.x += s, o.handleOut.y += a), this.updatePathFromControlPoints();
  }
  /**
   * Set handle position for a control point
   */
  setHandle(e, n, r, o, s = !1) {
    const a = this.controlPoints.find((l) => l.id === e);
    if (a) {
      if (n === "in" ? a.handleIn = { x: r, y: o } : a.handleOut = { x: r, y: o }, !s && a.type === "smooth") {
        const l = n === "in" ? a.handleIn : a.handleOut, u = n === "in" ? "handleOut" : "handleIn";
        if (l) {
          const c = l.x - a.x, d = l.y - a.y;
          a[u] = {
            x: a.x - c,
            y: a.y - d
          };
        }
      }
      this.updatePathFromControlPoints();
    }
  }
  /**
   * Delete a control point
   */
  deleteControlPoint(e) {
    const n = this.controlPoints.findIndex((r) => r.id === e);
    n !== -1 && (this.controlPoints.splice(n, 1), this.updatePathFromControlPoints());
  }
  /**
   * Get spline data for serialization
   */
  getSplineData() {
    var e;
    return {
      pathData: ((e = this.path) == null ? void 0 : e.map((n) => n.join(" ")).join(" ")) || "",
      controlPoints: this.controlPoints,
      closed: !1,
      stroke: this.stroke,
      strokeWidth: this.strokeWidth,
      fill: this.fill
    };
  }
  /**
   * Get serializable properties
   */
  getSerializableData() {
    return {
      controlPoints: this.controlPoints,
      _animationKeyframes: this._animationKeyframes
    };
  }
  /**
   * Deserialization from JSON
   */
  static fromObject(e) {
    var r;
    const n = ((r = e.path) == null ? void 0 : r.map((o) => o.join(" ")).join(" ")) || "";
    return Promise.resolve(new sa(n, {
      ...e,
      controlPoints: e.controlPoints || []
    }));
  }
};
// Type identifier for serialization
Xe(sa, "type", "SplinePath"), // Default values
Xe(sa, "ownDefaults", {
  stroke: "#00ff00",
  strokeWidth: 2,
  fill: "",
  selectable: !0,
  controlPoints: []
});
let td = sa;
Ne.setClass(td);
const bA = { class: "spline-editor" }, wA = ["viewBox"], _A = ["x1", "y1", "x2", "y2"], xA = ["x1", "y1", "x2", "y2"], SA = ["cx", "cy", "onMousedown"], CA = ["cx", "cy", "onMousedown"], kA = ["cx", "cy", "onMousedown"], OA = ["cx", "cy"], EA = /* @__PURE__ */ tn({
  __name: "SplineEditor",
  props: {
    layerId: {},
    canvasWidth: {},
    canvasHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated"],
  setup(i, { expose: e, emit: n }) {
    const r = i, o = n, s = Gn(), a = re(null), l = re(null), u = re(null), c = Ee(() => {
      if (!r.layerId) return [];
      const k = s.layers.find((S) => S.id === r.layerId);
      return !k || k.type !== "spline" || !k.data ? [] : k.data.controlPoints || [];
    });
    function d(k, _) {
      const S = r.viewportTransform, b = (k - S[4]) / S[0], C = (_ - S[5]) / S[3];
      return { x: b, y: C };
    }
    function h(k) {
      const S = k.currentTarget.getBoundingClientRect(), b = k.clientX - S.left, C = k.clientY - S.top;
      return d(b, C);
    }
    function p(k) {
      if (!r.isPenMode) return;
      const _ = h(k);
      if (r.layerId) {
        const S = s.layers.find((b) => b.id === r.layerId);
        if (S && S.type === "spline") {
          const b = S.data, C = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: _.x,
            y: _.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          b.controlPoints || (b.controlPoints = []), b.controlPoints.push(C), a.value = C.id, u.value = {
            type: "handleOut",
            pointId: C.id,
            startX: _.x,
            startY: _.y
          }, o("pointAdded", C), o("pathUpdated");
        }
      }
    }
    function m(k) {
      var S;
      const _ = h(k);
      if (r.isPenMode && (l.value = _), u.value) {
        const b = s.layers.find((I) => I.id === r.layerId);
        if (!b || b.type !== "spline") return;
        const x = (S = b.data.controlPoints) == null ? void 0 : S.find((I) => I.id === u.value.pointId);
        if (!x) return;
        if (u.value.type === "point") {
          const I = _.x - x.x, F = _.y - x.y;
          x.x = _.x, x.y = _.y, x.handleIn && (x.handleIn.x += I, x.handleIn.y += F), x.handleOut && (x.handleOut.x += I, x.handleOut.y += F), o("pointMoved", x.id, _.x, _.y);
        } else if (u.value.type === "handleIn") {
          if (x.handleIn = { x: _.x, y: _.y }, x.type === "smooth") {
            const I = _.x - x.x, F = _.y - x.y;
            x.handleOut = { x: x.x - I, y: x.y - F };
          }
          o("handleMoved", x.id, "in", _.x, _.y);
        } else if (u.value.type === "handleOut") {
          if (x.handleOut = { x: _.x, y: _.y }, x.type === "smooth") {
            const I = _.x - x.x, F = _.y - x.y;
            x.handleIn = { x: x.x - I, y: x.y - F };
          }
          o("handleMoved", x.id, "out", _.x, _.y);
        }
        o("pathUpdated");
      }
    }
    function v() {
      var k;
      if (u.value) {
        const _ = s.layers.find((S) => S.id === r.layerId);
        if (_ && _.type === "spline") {
          const b = (k = _.data.controlPoints) == null ? void 0 : k.find((C) => C.id === u.value.pointId);
          if (b && b.handleOut) {
            const C = b.handleOut.x - b.x, x = b.handleOut.y - b.y;
            Math.sqrt(C * C + x * x) > 5 ? (b.type = "smooth", b.handleIn = { x: b.x - C, y: b.y - x }) : b.handleOut = null;
          }
        }
        u.value = null, o("pathUpdated");
      }
    }
    function y(k, _) {
      if (a.value = k, !r.isPenMode) {
        const S = h(_);
        u.value = {
          type: "point",
          pointId: k,
          startX: S.x,
          startY: S.y
        };
      }
    }
    function w(k, _, S) {
      const b = h(S);
      u.value = {
        type: _ === "in" ? "handleIn" : "handleOut",
        pointId: k,
        startX: b.x,
        startY: b.y
      };
    }
    function g(k) {
      var _, S;
      if ((k.key === "Delete" || k.key === "Backspace") && a.value && r.layerId) {
        const b = s.layers.find((C) => C.id === r.layerId);
        if (b && b.type === "spline") {
          const C = b.data, x = (_ = C.controlPoints) == null ? void 0 : _.findIndex((I) => I.id === a.value);
          x !== void 0 && x >= 0 && ((S = C.controlPoints) == null || S.splice(x, 1), o("pointDeleted", a.value), o("pathUpdated"), a.value = null);
        }
      }
    }
    return Wn(() => {
      window.addEventListener("keydown", g);
    }), Qi(() => {
      window.removeEventListener("keydown", g);
    }), e({
      selectedPointId: a,
      clearSelection: () => {
        a.value = null;
      }
    }), (k, _) => ($(), A("div", bA, [
      ($(), A("svg", {
        class: "control-overlay",
        viewBox: `0 0 ${i.canvasWidth} ${i.canvasHeight}`,
        onMousedown: p,
        onMousemove: m,
        onMouseup: v,
        onMouseleave: v
      }, [
        ($(!0), A(Fe, null, Ke(c.value, (S) => ($(), A(Fe, {
          key: `handles-${S.id}`
        }, [
          S.handleIn && a.value === S.id ? ($(), A("line", {
            key: 0,
            x1: S.x,
            y1: S.y,
            x2: S.handleIn.x,
            y2: S.handleIn.y,
            class: "handle-line"
          }, null, 8, _A)) : ve("", !0),
          S.handleOut && a.value === S.id ? ($(), A("line", {
            key: 1,
            x1: S.x,
            y1: S.y,
            x2: S.handleOut.x,
            y2: S.handleOut.y,
            class: "handle-line"
          }, null, 8, xA)) : ve("", !0)
        ], 64))), 128)),
        ($(!0), A(Fe, null, Ke(c.value, (S) => {
          var b, C;
          return $(), A(Fe, {
            key: `handle-points-${S.id}`
          }, [
            S.handleIn && a.value === S.id ? ($(), A("circle", {
              key: 0,
              cx: S.handleIn.x,
              cy: S.handleIn.y,
              r: "4",
              class: _e(["handle-point", { active: ((b = u.value) == null ? void 0 : b.type) === "handleIn" && u.value.pointId === S.id }]),
              onMousedown: tt((x) => w(S.id, "in", x), ["stop"])
            }, null, 42, SA)) : ve("", !0),
            S.handleOut && a.value === S.id ? ($(), A("circle", {
              key: 1,
              cx: S.handleOut.x,
              cy: S.handleOut.y,
              r: "4",
              class: _e(["handle-point", { active: ((C = u.value) == null ? void 0 : C.type) === "handleOut" && u.value.pointId === S.id }]),
              onMousedown: tt((x) => w(S.id, "out", x), ["stop"])
            }, null, 42, CA)) : ve("", !0)
          ], 64);
        }), 128)),
        ($(!0), A(Fe, null, Ke(c.value, (S) => ($(), A("circle", {
          key: `point-${S.id}`,
          cx: S.x,
          cy: S.y,
          r: "6",
          class: _e(["control-point", {
            selected: a.value === S.id,
            corner: S.type === "corner",
            smooth: S.type === "smooth"
          }]),
          onMousedown: tt((b) => y(S.id, b), ["stop"])
        }, null, 42, kA))), 128)),
        l.value && i.isPenMode ? ($(), A("circle", {
          key: 0,
          cx: l.value.x,
          cy: l.value.y,
          r: "4",
          class: "preview-point"
        }, null, 8, OA)) : ve("", !0)
      ], 40, wA))
    ]));
  }
}), TA = /* @__PURE__ */ cn(EA, [["__scopeId", "data-v-48e73a8b"]]), S1 = /* @__PURE__ */ Math.sqrt(3), DA = 0.5 * (S1 - 1), Na = (3 - S1) / 6, Sv = (i) => Math.floor(i) | 0, Cv = /* @__PURE__ */ new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
function $A(i = Math.random) {
  const e = MA(i), n = new Float64Array(e).map((o) => Cv[o % 12 * 2]), r = new Float64Array(e).map((o) => Cv[o % 12 * 2 + 1]);
  return function(s, a) {
    let l = 0, u = 0, c = 0;
    const d = (s + a) * DA, h = Sv(s + d), p = Sv(a + d), m = (h + p) * Na, v = h - m, y = p - m, w = s - v, g = a - y;
    let k, _;
    w > g ? (k = 1, _ = 0) : (k = 0, _ = 1);
    const S = w - k + Na, b = g - _ + Na, C = w - 1 + 2 * Na, x = g - 1 + 2 * Na, I = h & 255, F = p & 255;
    let B = 0.5 - w * w - g * g;
    if (B >= 0) {
      const ee = I + e[F], ie = n[ee], M = r[ee];
      B *= B, l = B * B * (ie * w + M * g);
    }
    let X = 0.5 - S * S - b * b;
    if (X >= 0) {
      const ee = I + k + e[F + _], ie = n[ee], M = r[ee];
      X *= X, u = X * X * (ie * S + M * b);
    }
    let j = 0.5 - C * C - x * x;
    if (j >= 0) {
      const ee = I + 1 + e[F + 1], ie = n[ee], M = r[ee];
      j *= j, c = j * j * (ie * C + M * x);
    }
    return 70 * (l + u + c);
  };
}
function MA(i) {
  const n = new Uint8Array(512);
  for (let r = 0; r < 512 / 2; r++)
    n[r] = r;
  for (let r = 0; r < 512 / 2 - 1; r++) {
    const o = r + ~~(i() * (256 - r)), s = n[r];
    n[r] = n[o], n[o] = s;
  }
  for (let r = 256; r < 512; r++)
    n[r] = n[r - 256];
  return n;
}
function PA() {
  return {
    enabled: !1,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: !0
  };
}
function IA() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: !1,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: []
  };
}
function kv() {
  return {
    blendMode: "additive",
    renderTrails: !1,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: !1,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: !1,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: PA()
  };
}
class Cd {
  constructor(e = {}) {
    Xe(this, "particles", []);
    Xe(this, "emitters", /* @__PURE__ */ new Map());
    Xe(this, "gravityWells", /* @__PURE__ */ new Map());
    Xe(this, "vortices", /* @__PURE__ */ new Map());
    Xe(this, "modulations", []);
    Xe(this, "config");
    Xe(this, "boundaryMask", null);
    Xe(this, "frameCount", 0);
    Xe(this, "emissionAccumulators", /* @__PURE__ */ new Map());
    Xe(this, "nextParticleId", 0);
    Xe(this, "trailHistory", /* @__PURE__ */ new Map());
    // Audio reactivity state
    Xe(this, "featureOverrides", /* @__PURE__ */ new Map());
    // Turbulence noise generator
    Xe(this, "noise2D");
    Xe(this, "noiseTime", 0);
    // Render options cache for spatial grid
    Xe(this, "renderOptions", kv());
    this.config = { ...IA(), ...e }, this.noise2D = $A();
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    if (this.emitters.set(e.id, { ...e }), this.emissionAccumulators.set(e.id, 0), e.initialBurst > 0 && e.enabled) {
      const n = Math.floor(e.emissionRate * e.initialBurst * 10);
      for (let r = 0; r < n; r++)
        this.spawnParticle(e);
    }
  }
  updateEmitter(e, n) {
    const r = this.emitters.get(e);
    r && Object.assign(r, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.emissionAccumulators.delete(e);
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(e) {
    this.gravityWells.set(e.id, { ...e });
  }
  updateGravityWell(e, n) {
    const r = this.gravityWells.get(e);
    r && Object.assign(r, n);
  }
  removeGravityWell(e) {
    this.gravityWells.delete(e);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(e) {
    this.vortices.set(e.id, { ...e });
  }
  updateVortex(e, n) {
    const r = this.vortices.get(e);
    r && Object.assign(r, n);
  }
  removeVortex(e) {
    this.vortices.delete(e);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(e) {
    this.modulations.push({ ...e });
  }
  removeModulation(e) {
    const n = this.modulations.findIndex((r) => r.id === e);
    n >= 0 && this.modulations.splice(n, 1);
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(e) {
    this.boundaryMask = e;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(e, n, r) {
    const o = r ? `${r}:${e}` : `*:${e}`;
    this.featureOverrides.set(o, n);
  }
  getFeatureValue(e, n) {
    return this.featureOverrides.get(`${n}:${e}`) ?? this.featureOverrides.get(`*:${e}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(e = 1) {
    this.emitters.forEach((c, d) => {
      if (!c.enabled) return;
      const p = (this.getFeatureValue("emissionRate", d) ?? c.emissionRate) * e;
      let m = (this.emissionAccumulators.get(d) || 0) + p;
      for (; m >= 1 && this.particles.length < this.config.maxParticles; )
        this.spawnParticle(c), m -= 1;
      this.emissionAccumulators.set(d, m);
    });
    const n = this.config.windDirection * Math.PI / 180, r = Math.cos(n) * this.config.windStrength * 1e-3, o = Math.sin(n) * this.config.windStrength * 1e-3, s = this.getFeatureValue("gravity", "*") ?? this.config.gravity, a = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength, l = r * (a / Math.max(1, this.config.windStrength)), u = o * (a / Math.max(1, this.config.windStrength));
    for (let c = this.particles.length - 1; c >= 0; c--) {
      const d = this.particles[c];
      if (d.prevX = d.x, d.prevY = d.y, this.trailHistory.has(d.id)) {
        const p = this.trailHistory.get(d.id);
        p.unshift({ x: d.x, y: d.y }), p.length > 20 && p.pop();
      }
      d.vy += s * 1e-3 * e, d.vx += l * e, d.vy += u * e, this.gravityWells.forEach((p) => {
        if (!p.enabled) return;
        const m = p.x - d.x, v = p.y - d.y, y = Math.sqrt(m * m + v * v);
        if (y < p.radius && y > 1e-3) {
          let w = p.strength * 1e-4;
          switch (p.falloff) {
            case "linear":
              w *= 1 - y / p.radius;
              break;
            case "quadratic":
              w *= Math.pow(1 - y / p.radius, 2);
              break;
          }
          const g = m / y, k = v / y;
          d.vx += g * w * e, d.vy += k * w * e;
        }
      }), this.vortices.forEach((p) => {
        if (!p.enabled) return;
        const m = p.x - d.x, v = p.y - d.y, y = Math.sqrt(m * m + v * v);
        if (y < p.radius && y > 1e-3) {
          const w = 1 - y / p.radius, g = p.strength * 1e-4 * w, k = m / y, _ = v / y, S = -_, b = k;
          d.vx += S * g * e, d.vy += b * g * e;
          const C = p.inwardPull * 1e-4 * w;
          d.vx += k * C * e, d.vy += _ * C * e;
        }
      }), this.applyTurbulence(d, e);
      const h = 1 - this.config.friction;
      d.vx *= h, d.vy *= h, d.x += d.vx * e, d.y += d.vy * e, this.boundaryMask && this.config.respectMaskBoundary && this.handleBoundaryCollision(d), this.handleCanvasBoundary(d), this.applyModulations(d), d.age += e, d.age > d.lifetime && (d.isSubParticle || this.triggerSubEmitters(d), this.particles.splice(c, 1), this.trailHistory.delete(d.id));
    }
    this.noiseTime += e, this.frameCount++;
  }
  spawnParticle(e) {
    if (this.particles.length >= this.config.maxParticles) return;
    const n = e.spread * Math.PI / 180, o = e.direction * Math.PI / 180 + (Math.random() - 0.5) * n, a = (e.speed + (Math.random() - 0.5) * 2 * e.speedVariance) * 1e-3, l = Math.max(1, e.size + (Math.random() - 0.5) * 2 * e.sizeVariance), u = Math.max(1, e.particleLifetime + (Math.random() - 0.5) * 2 * e.lifetimeVariance), c = {
      id: this.nextParticleId++,
      x: e.x,
      y: e.y,
      prevX: e.x,
      prevY: e.y,
      vx: Math.cos(o) * a,
      vy: Math.sin(o) * a,
      age: 0,
      lifetime: u,
      size: l,
      baseSize: l,
      color: [...e.color, 255],
      baseColor: [...e.color, 255],
      emitterId: e.id,
      isSubParticle: !1
    };
    this.particles.push(c), this.trailHistory.set(c.id, [{ x: c.x, y: c.y }]);
  }
  handleBoundaryCollision(e) {
    if (!this.boundaryMask) return;
    const n = Math.floor(e.x * this.boundaryMask.width), r = Math.floor(e.y * this.boundaryMask.height);
    if (n < 0 || n >= this.boundaryMask.width || r < 0 || r >= this.boundaryMask.height)
      return;
    const o = (r * this.boundaryMask.width + n) * 4;
    if (this.boundaryMask.data[o] < 128)
      switch (this.config.boundaryBehavior) {
        case "bounce":
          e.vx *= -0.8, e.vy *= -0.8, e.x = e.prevX, e.y = e.prevY;
          break;
        case "kill":
          e.age = e.lifetime + 1;
          break;
        case "wrap":
          e.x = Math.random(), e.y = Math.random();
          break;
      }
  }
  handleCanvasBoundary(e) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        e.x < 0 && (e.x = 0, e.vx *= -0.8), e.x > 1 && (e.x = 1, e.vx *= -0.8), e.y < 0 && (e.y = 0, e.vy *= -0.8), e.y > 1 && (e.y = 1, e.vy *= -0.8);
        break;
      case "kill":
        (e.x < -0.1 || e.x > 1.1 || e.y < -0.1 || e.y > 1.1) && (e.age = e.lifetime + 1);
        break;
      case "wrap":
        e.x < 0 && (e.x += 1), e.x > 1 && (e.x -= 1), e.y < 0 && (e.y += 1), e.y > 1 && (e.y -= 1);
        break;
    }
  }
  applyModulations(e) {
    const n = e.age / e.lifetime;
    for (const r of this.modulations) {
      if (r.emitterId !== "*" && r.emitterId !== e.emitterId) continue;
      const o = r.easing, s = zc[o] || zc.linear, a = Q2(n, s), l = r.startValue + (r.endValue - r.startValue) * a;
      switch (r.property) {
        case "size":
          e.size = e.baseSize * l;
          break;
        case "speed":
          const u = Math.sqrt(e.vx * e.vx + e.vy * e.vy);
          if (u > 1e-4) {
            const c = l / Math.max(1e-4, u * 1e3);
            e.vx *= c, e.vy *= c;
          }
          break;
        case "opacity":
          e.color[3] = Math.max(0, Math.min(255, e.baseColor[3] * l));
          break;
        case "colorR":
          e.color[0] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorG":
          e.color[1] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorB":
          e.color[2] = Math.max(0, Math.min(255, l * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(e, n) {
    const r = this.config.turbulenceFields || [];
    for (const o of r) {
      if (!o.enabled) continue;
      const s = e.x * o.scale * 1e3, a = e.y * o.scale * 1e3, l = this.noiseTime * o.evolutionSpeed, u = this.noise2D(s + l, a + l) * Math.PI * 2, c = o.strength * 1e-5;
      e.vx += Math.cos(u) * c * n, e.vy += Math.sin(u) * c * n;
    }
  }
  addTurbulence(e) {
    this.config.turbulenceFields || (this.config.turbulenceFields = []), this.config.turbulenceFields.push(e);
  }
  updateTurbulence(e, n) {
    var o;
    const r = (o = this.config.turbulenceFields) == null ? void 0 : o.find((s) => s.id === e);
    r && Object.assign(r, n);
  }
  removeTurbulence(e) {
    this.config.turbulenceFields && (this.config.turbulenceFields = this.config.turbulenceFields.filter((n) => n.id !== e));
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  triggerSubEmitters(e) {
    const n = this.config.subEmitters || [];
    for (const r of n)
      if (r.enabled && !(r.parentEmitterId !== "*" && r.parentEmitterId !== e.emitterId))
        for (let o = 0; o < r.spawnCount; o++) {
          const s = (Math.random() - 0.5) * r.spread * Math.PI / 180, l = Math.atan2(e.vy, e.vx) + s, u = Math.sqrt(e.vx ** 2 + e.vy ** 2) * r.inheritVelocity, c = r.speed * 1e-3 + u, d = {
            id: this.nextParticleId++,
            x: e.x,
            y: e.y,
            prevX: e.x,
            prevY: e.y,
            vx: Math.cos(l) * c + e.vx * r.inheritVelocity,
            vy: Math.sin(l) * c + e.vy * r.inheritVelocity,
            age: 0,
            lifetime: r.lifetime * (1 + (Math.random() - 0.5) * 0.2),
            size: r.size * (1 + (Math.random() - 0.5) * r.sizeVariance / r.size),
            baseSize: r.size,
            color: [...r.color, 255],
            baseColor: [...r.color, 255],
            emitterId: r.id,
            isSubParticle: !0
          };
          this.particles.push(d), this.trailHistory.set(d.id, [{ x: d.x, y: d.y }]);
        }
  }
  addSubEmitter(e) {
    this.config.subEmitters || (this.config.subEmitters = []), this.config.subEmitters.push(e);
  }
  updateSubEmitter(e, n) {
    var o;
    const r = (o = this.config.subEmitters) == null ? void 0 : o.find((s) => s.id === e);
    r && Object.assign(r, n);
  }
  removeSubEmitter(e) {
    this.config.subEmitters && (this.config.subEmitters = this.config.subEmitters.filter((n) => n.id !== e));
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(e, n) {
    const r = this.emitters.get(e);
    if (!r || !r.enabled) return;
    const o = n ?? r.burstCount ?? 20;
    for (let s = 0; s < o; s++)
      this.spawnParticle(r);
  }
  triggerAllBursts() {
    for (const e of this.emitters.values())
      e.burstOnBeat && e.enabled && this.triggerBurst(e.id);
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    var r;
    const e = ((r = this.renderOptions.connections) == null ? void 0 : r.maxDistance) || 100, n = /* @__PURE__ */ new Map();
    for (const o of this.particles) {
      const s = Math.floor(o.x * 1e3 / e), a = Math.floor(o.y * 1e3 / e), l = `${s},${a}`;
      n.has(l) || n.set(l, []), n.get(l).push(o);
    }
    return { cellSize: e, cells: n };
  }
  getNeighborParticles(e, n) {
    const r = Math.floor(e.x * 1e3 / n.cellSize), o = Math.floor(e.y * 1e3 / n.cellSize), s = [];
    for (let a = -1; a <= 1; a++)
      for (let l = -1; l <= 1; l++) {
        const u = `${r + a},${o + l}`, c = n.cells.get(u);
        c && s.push(...c);
      }
    return s;
  }
  renderConnections(e, n, r) {
    const o = this.renderOptions.connections;
    if (!(o != null && o.enabled) || this.particles.length < 2) return;
    const s = this.buildSpatialGrid(), a = o.maxDistance / 1e3, l = a * a;
    e.lineWidth = o.lineWidth;
    for (const u of this.particles) {
      const c = this.getNeighborParticles(u, s);
      let d = 0;
      for (const h of c) {
        if (h.id <= u.id) continue;
        if (d >= o.maxConnections) break;
        const p = h.x - u.x, m = h.y - u.y, v = p * p + m * m;
        if (v < l) {
          const y = Math.sqrt(v);
          let w = o.lineOpacity;
          o.fadeByDistance && (w *= 1 - y / a);
          const g = Math.round((u.color[0] + h.color[0]) / 2), k = Math.round((u.color[1] + h.color[1]) / 2), _ = Math.round((u.color[2] + h.color[2]) / 2);
          e.strokeStyle = `rgba(${g},${k},${_},${w})`, e.beginPath(), e.moveTo(u.x * n, u.y * r), e.lineTo(h.x * n, h.y * r), e.stroke(), d++;
        }
      }
    }
  }
  reset() {
    this.particles = [], this.frameCount = 0, this.trailHistory.clear(), this.emissionAccumulators.forEach((e, n) => {
      this.emissionAccumulators.set(n, 0);
    }), this.nextParticleId = 0;
  }
  warmup() {
    for (let e = 0; e < this.config.warmupPeriod; e++)
      this.step(1);
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(e) {
    Object.assign(this.config, e);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(e, n, r, o = kv()) {
    switch (this.renderOptions = o, e.save(), o.blendMode) {
      case "additive":
        e.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        e.globalCompositeOperation = "multiply";
        break;
      case "screen":
        e.globalCompositeOperation = "screen";
        break;
      default:
        e.globalCompositeOperation = "source-over";
    }
    this.renderConnections(e, n, r);
    for (const s of this.particles) {
      const a = s.x * n, l = s.y * r, u = s.size;
      if (o.renderTrails) {
        const c = this.trailHistory.get(s.id);
        if (c && c.length > 1) {
          e.beginPath(), e.moveTo(a, l);
          const d = Math.min(c.length, o.trailLength);
          for (let h = 0; h < d; h++) {
            const p = c[h], m = s.color[3] * Math.pow(o.trailOpacityFalloff, h + 1);
            e.strokeStyle = `rgba(${s.color[0]}, ${s.color[1]}, ${s.color[2]}, ${m / 255})`, e.lineWidth = u * Math.pow(o.trailOpacityFalloff, h), e.lineTo(p.x * n, p.y * r);
          }
          e.stroke();
        }
      }
      o.glowEnabled ? (e.shadowBlur = o.glowRadius, e.shadowColor = `rgba(${s.color[0]}, ${s.color[1]}, ${s.color[2]}, ${o.glowIntensity})`) : e.shadowBlur = 0, o.motionBlur && (s.vx !== 0 || s.vy !== 0) ? this.renderParticleWithMotionBlur(e, s, a, l, u, n, r, o) : this.renderParticleShape(e, a, l, u, s.color, o.particleShape);
    }
    e.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(e, n, r, o, s, a, l, u) {
    const c = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
    if (c < 1e-4) {
      this.renderParticleShape(e, r, o, s, n.color, u.particleShape);
      return;
    }
    const d = u.motionBlurStrength * c * 500, h = Math.min(u.motionBlurSamples, 16), p = n.vx / c, m = n.vy / c, v = Math.min(d * s, s * 10);
    for (let y = 0; y < h; y++) {
      const w = y / (h - 1), g = (1 - w * 0.8) / h, k = r - p * v * w, _ = o - m * v * w, S = s * (1 - w * 0.3), b = n.color[3] / 255 * g * h;
      e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${Math.min(1, b)})`, this.renderParticleShape(e, k, _, S, null, u.particleShape);
    }
    e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${n.color[3] / 255})`, this.renderParticleShape(e, r, o, s, n.color, u.particleShape);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(e, n, r, o, s, a) {
    switch (s && (e.fillStyle = `rgba(${s[0]}, ${s[1]}, ${s[2]}, ${s[3] / 255})`), a) {
      case "circle":
        e.beginPath(), e.arc(n, r, o / 2, 0, Math.PI * 2), e.fill();
        break;
      case "square":
        e.fillRect(n - o / 2, r - o / 2, o, o);
        break;
      case "triangle":
        e.beginPath(), e.moveTo(n, r - o / 2), e.lineTo(n - o / 2, r + o / 2), e.lineTo(n + o / 2, r + o / 2), e.closePath(), e.fill();
        break;
      case "star":
        this.drawStar(e, n, r, 5, o / 2, o / 4), e.fill();
        break;
    }
  }
  drawStar(e, n, r, o, s, a) {
    e.beginPath();
    let l = -Math.PI / 2;
    for (let u = 0; u < o; u++) {
      const c = n + Math.cos(l) * s, d = r + Math.sin(l) * s;
      u === 0 ? e.moveTo(c, d) : e.lineTo(c, d), l += Math.PI / o;
      const h = n + Math.cos(l) * a, p = r + Math.sin(l) * a;
      e.lineTo(h, p), l += Math.PI / o;
    }
    e.closePath();
  }
  renderToMask(e, n) {
    const o = new OffscreenCanvas(e, n).getContext("2d");
    o.fillStyle = "#FFFFFF", o.fillRect(0, 0, e, n);
    const s = this.renderOptions.connections;
    s != null && s.enabled && this.particles.length >= 2 && (o.strokeStyle = "#000000", o.lineWidth = s.lineWidth * 2, this.renderConnections(o, e, n)), o.fillStyle = "#000000";
    for (const a of this.particles) {
      const l = a.x * e, u = a.y * n, c = a.size * 1.5;
      o.beginPath(), o.arc(l, u, c / 2, 0, Math.PI * 2), o.fill();
    }
    return o.getImageData(0, 0, e, n);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(e) {
    const n = new Cd(e.config);
    if (e.emitters)
      for (const r of e.emitters)
        n.addEmitter(r);
    if (e.gravityWells)
      for (const r of e.gravityWells)
        n.addGravityWell(r);
    if (e.vortices)
      for (const r of e.vortices)
        n.addVortex(r);
    if (e.modulations)
      for (const r of e.modulations)
        n.addModulation(r);
    return n;
  }
}
function LA() {
  return {
    preset: "static",
    zoom: 1,
    offsetX: 0,
    offsetY: 0,
    rotation: 0,
    depthScale: 1,
    focusDepth: 0.5,
    dollyZoom: 0,
    orbitRadius: 0.1,
    orbitSpeed: 2,
    swingAmplitude: 0.1,
    swingFrequency: 0.5,
    edgeDilation: 5,
    inpaintEdges: !0
  };
}
const AA = `#version 300 es
in vec2 a_position;
in vec2 a_texCoord;
out vec2 v_texCoord;

void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
  v_texCoord = a_texCoord;
}
`, VA = `#version 300 es
precision highp float;

in vec2 v_texCoord;
out vec4 outColor;

uniform sampler2D u_source;
uniform sampler2D u_depth;
uniform float u_zoom;
uniform vec2 u_offset;
uniform float u_rotation;
uniform float u_depthScale;
uniform float u_focusDepth;
uniform float u_edgeDilation;
uniform vec2 u_resolution;

vec2 rotate2D(vec2 p, float angle) {
  float c = cos(angle);
  float s = sin(angle);
  return vec2(p.x * c - p.y * s, p.x * s + p.y * c);
}

void main() {
  // Get depth at current pixel
  float depth = texture(u_depth, v_texCoord).r;

  // Calculate parallax offset based on depth
  // Objects closer than focus depth move more, objects further move less
  float depthDiff = (depth - u_focusDepth) * u_depthScale;

  // Transform texture coordinates
  vec2 center = vec2(0.5, 0.5);
  vec2 coord = v_texCoord - center;

  // Apply rotation
  float rotRad = u_rotation * 3.14159265 / 180.0;
  coord = rotate2D(coord, rotRad);

  // Apply zoom
  coord /= u_zoom;

  // Apply parallax offset based on depth
  vec2 parallaxOffset = u_offset * depthDiff;
  coord += parallaxOffset;

  // Apply camera offset
  coord -= u_offset * 0.5;

  coord += center;

  // Edge handling with dilation
  float dilatePixels = u_edgeDilation / u_resolution.x;

  // Clamp coordinates
  vec2 clampedCoord = clamp(coord, vec2(dilatePixels), vec2(1.0 - dilatePixels));

  // Check if we're sampling outside bounds
  float outOfBounds = step(0.0, coord.x) * step(coord.x, 1.0) *
                      step(0.0, coord.y) * step(coord.y, 1.0);

  // Sample source texture
  vec4 color = texture(u_source, clampedCoord);

  // Fade edges if out of bounds
  if (outOfBounds < 0.5) {
    // Sample from clamped position with reduced alpha
    color = texture(u_source, clampedCoord);
    color.a *= 0.3;
  }

  outColor = color;
}
`;
class FA {
  constructor() {
    Xe(this, "sourceCanvas");
    Xe(this, "depthCanvas");
    Xe(this, "outputCanvas");
    Xe(this, "gl", null);
    Xe(this, "program", null);
    Xe(this, "useWebGL", !1);
    // WebGL resources
    Xe(this, "sourceTexture", null);
    Xe(this, "depthTexture", null);
    Xe(this, "positionBuffer", null);
    Xe(this, "texCoordBuffer", null);
    // Uniform locations
    Xe(this, "uniforms", {});
    // Current config
    Xe(this, "config", LA());
    // Source dimensions
    Xe(this, "width", 0);
    Xe(this, "height", 0);
    this.sourceCanvas = document.createElement("canvas"), this.depthCanvas = document.createElement("canvas"), this.outputCanvas = document.createElement("canvas"), this.initWebGL();
  }
  initWebGL() {
    const e = this.outputCanvas.getContext("webgl2", {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0
    });
    if (!e) {
      console.warn("[Depthflow] WebGL2 not available, using Canvas2D fallback"), this.useWebGL = !1;
      return;
    }
    this.gl = e, this.useWebGL = !0;
    const n = this.compileShader(e, e.VERTEX_SHADER, AA), r = this.compileShader(e, e.FRAGMENT_SHADER, VA);
    if (!n || !r) {
      this.useWebGL = !1;
      return;
    }
    const o = e.createProgram();
    if (e.attachShader(o, n), e.attachShader(o, r), e.linkProgram(o), !e.getProgramParameter(o, e.LINK_STATUS)) {
      console.error("[Depthflow] Program link error:", e.getProgramInfoLog(o)), this.useWebGL = !1;
      return;
    }
    this.program = o, this.uniforms = {
      u_source: e.getUniformLocation(o, "u_source"),
      u_depth: e.getUniformLocation(o, "u_depth"),
      u_zoom: e.getUniformLocation(o, "u_zoom"),
      u_offset: e.getUniformLocation(o, "u_offset"),
      u_rotation: e.getUniformLocation(o, "u_rotation"),
      u_depthScale: e.getUniformLocation(o, "u_depthScale"),
      u_focusDepth: e.getUniformLocation(o, "u_focusDepth"),
      u_edgeDilation: e.getUniformLocation(o, "u_edgeDilation"),
      u_resolution: e.getUniformLocation(o, "u_resolution")
    }, this.positionBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.positionBuffer), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1,
      1
    ]), e.STATIC_DRAW), this.texCoordBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.texCoordBuffer), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      0,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0
    ]), e.STATIC_DRAW);
  }
  compileShader(e, n, r) {
    const o = e.createShader(n);
    return e.shaderSource(o, r), e.compileShader(o), e.getShaderParameter(o, e.COMPILE_STATUS) ? o : (console.error("[Depthflow] Shader compile error:", e.getShaderInfoLog(o)), e.deleteShader(o), null);
  }
  setSource(e) {
    e instanceof ImageData ? (this.sourceCanvas.width = e.width, this.sourceCanvas.height = e.height, this.sourceCanvas.getContext("2d").putImageData(e, 0, 0)) : (this.sourceCanvas.width = e.width, this.sourceCanvas.height = e.height, this.sourceCanvas.getContext("2d").drawImage(e, 0, 0)), this.width = this.sourceCanvas.width, this.height = this.sourceCanvas.height, this.outputCanvas.width = this.width, this.outputCanvas.height = this.height, this.useWebGL && this.gl && this.updateTexture("source");
  }
  setDepthMap(e) {
    e instanceof ImageData ? (this.depthCanvas.width = e.width, this.depthCanvas.height = e.height, this.depthCanvas.getContext("2d").putImageData(e, 0, 0)) : (this.depthCanvas.width = e.width, this.depthCanvas.height = e.height, this.depthCanvas.getContext("2d").drawImage(e, 0, 0)), this.useWebGL && this.gl && this.updateTexture("depth");
  }
  updateTexture(e) {
    const n = this.gl, r = e === "source" ? this.sourceCanvas : this.depthCanvas;
    e === "source" ? (this.sourceTexture && n.deleteTexture(this.sourceTexture), this.sourceTexture = n.createTexture(), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, this.sourceTexture)) : (this.depthTexture && n.deleteTexture(this.depthTexture), this.depthTexture = n.createTexture(), n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, this.depthTexture)), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, r);
  }
  setConfig(e) {
    this.config = { ...this.config, ...e };
  }
  getConfig() {
    return { ...this.config };
  }
  /**
   * Get animated camera parameters for a specific frame based on preset
   */
  getAnimatedParams(e, n) {
    const r = n > 1 ? e / (n - 1) : 0, { preset: o, orbitRadius: s, orbitSpeed: a, swingAmplitude: l, swingFrequency: u } = this.config;
    let c = this.config.zoom, d = this.config.offsetX, h = this.config.offsetY, p = this.config.rotation, m = this.config.depthScale;
    switch (o) {
      case "static":
        break;
      case "zoom_in":
        c = 1 + r * 0.3;
        break;
      case "zoom_out":
        c = 1 - r * 0.3;
        break;
      case "dolly_zoom_in":
        c = 1 + r * 0.4, m = this.config.depthScale * (1 - r * 0.5);
        break;
      case "dolly_zoom_out":
        c = 1 - r * 0.3, m = this.config.depthScale * (1 + r * 0.5);
        break;
      case "pan_left":
        d = -r * 0.3;
        break;
      case "pan_right":
        d = r * 0.3;
        break;
      case "pan_up":
        h = -r * 0.3;
        break;
      case "pan_down":
        h = r * 0.3;
        break;
      case "circle_cw": {
        const v = r * Math.PI * 2 * (a / 360);
        d = Math.cos(v) * s, h = Math.sin(v) * s;
        break;
      }
      case "circle_ccw": {
        const v = -r * Math.PI * 2 * (a / 360);
        d = Math.cos(v) * s, h = Math.sin(v) * s;
        break;
      }
      case "horizontal_swing":
        d = Math.sin(r * Math.PI * 2 * u) * l;
        break;
      case "vertical_swing":
        h = Math.sin(r * Math.PI * 2 * u) * l;
        break;
    }
    return { zoom: c, offsetX: d, offsetY: h, rotation: p, depthScale: m };
  }
  renderFrame(e, n) {
    const r = this.getAnimatedParams(e, n);
    return this.useWebGL && this.gl && this.program ? this.renderWebGL(r) : this.renderCanvas2D(r);
  }
  renderWebGL(e) {
    const n = this.gl;
    n.viewport(0, 0, this.width, this.height), n.useProgram(this.program), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, this.sourceTexture), n.uniform1i(this.uniforms.u_source, 0), n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, this.depthTexture), n.uniform1i(this.uniforms.u_depth, 1), n.uniform1f(this.uniforms.u_zoom, e.zoom), n.uniform2f(this.uniforms.u_offset, e.offsetX, e.offsetY), n.uniform1f(this.uniforms.u_rotation, e.rotation), n.uniform1f(this.uniforms.u_depthScale, e.depthScale), n.uniform1f(this.uniforms.u_focusDepth, this.config.focusDepth), n.uniform1f(this.uniforms.u_edgeDilation, this.config.edgeDilation), n.uniform2f(this.uniforms.u_resolution, this.width, this.height);
    const r = n.getAttribLocation(this.program, "a_position");
    n.bindBuffer(n.ARRAY_BUFFER, this.positionBuffer), n.enableVertexAttribArray(r), n.vertexAttribPointer(r, 2, n.FLOAT, !1, 0, 0);
    const o = n.getAttribLocation(this.program, "a_texCoord");
    n.bindBuffer(n.ARRAY_BUFFER, this.texCoordBuffer), n.enableVertexAttribArray(o), n.vertexAttribPointer(o, 2, n.FLOAT, !1, 0, 0), n.drawArrays(n.TRIANGLES, 0, 6);
    const s = new Uint8ClampedArray(this.width * this.height * 4);
    n.readPixels(0, 0, this.width, this.height, n.RGBA, n.UNSIGNED_BYTE, s);
    const a = new Uint8ClampedArray(s.length);
    for (let l = 0; l < this.height; l++) {
      const u = (this.height - 1 - l) * this.width * 4, c = l * this.width * 4;
      a.set(s.subarray(u, u + this.width * 4), c);
    }
    return new ImageData(a, this.width, this.height);
  }
  renderCanvas2D(e) {
    const n = this.outputCanvas.getContext("2d"), r = this.sourceCanvas.getContext("2d"), o = this.depthCanvas.getContext("2d"), s = r.getImageData(0, 0, this.width, this.height), a = o.getImageData(0, 0, this.width, this.height), l = n.createImageData(this.width, this.height), { zoom: u, offsetX: c, offsetY: d, rotation: h, depthScale: p } = e, { focusDepth: m } = this.config, v = h * Math.PI / 180, y = Math.cos(v), w = Math.sin(v);
    for (let g = 0; g < this.height; g++)
      for (let k = 0; k < this.width; k++) {
        const _ = (g * this.width + k) * 4, b = (a.data[_] / 255 - m) * p;
        let C = k / this.width - 0.5, x = g / this.height - 0.5;
        const I = C * y - x * w, F = C * w + x * y;
        C = I, x = F, C /= u, x /= u, C += c * b, x += d * b, C -= c * 0.5, x -= d * 0.5, C = (C + 0.5) * this.width, x = (x + 0.5) * this.height;
        const B = Math.floor(C), X = Math.floor(x), j = B + 1, ee = X + 1, ie = C - B, M = x - X, W = Math.max(0, Math.min(this.width - 1, B)), R = Math.max(0, Math.min(this.height - 1, X)), V = Math.max(0, Math.min(this.width - 1, j)), ae = Math.max(0, Math.min(this.height - 1, ee)), $e = (R * this.width + W) * 4, N = (R * this.width + V) * 4, me = (ae * this.width + W) * 4, we = (ae * this.width + V) * 4;
        for (let fe = 0; fe < 4; fe++) {
          const te = s.data[$e + fe], Me = s.data[N + fe], Re = s.data[me + fe], Ce = s.data[we + fe], le = te * (1 - ie) + Me * ie, T = Re * (1 - ie) + Ce * ie;
          l.data[_ + fe] = Math.round(le * (1 - M) + T * M);
        }
        (C < 0 || C >= this.width || x < 0 || x >= this.height) && (l.data[_ + 3] = Math.round(l.data[_ + 3] * 0.3));
      }
    return n.putImageData(l, 0, 0), l;
  }
  renderSequence(e, n) {
    const r = [];
    for (let o = 0; o < e; o++)
      r.push(this.renderFrame(o, e)), n && n(o);
    return r;
  }
  /**
   * Get preset configuration with optional intensity modifier
   */
  getPresetConfig(e, n = 1) {
    const r = { preset: e };
    switch (e) {
      case "zoom_in":
      case "zoom_out":
        return { ...r, depthScale: 1 * n };
      case "dolly_zoom_in":
      case "dolly_zoom_out":
        return { ...r, depthScale: 1.5 * n, dollyZoom: 0.5 * n };
      case "pan_left":
      case "pan_right":
      case "pan_up":
      case "pan_down":
        return { ...r, depthScale: 0.8 * n };
      case "circle_cw":
      case "circle_ccw":
        return { ...r, orbitRadius: 0.1 * n, orbitSpeed: 360 };
      case "horizontal_swing":
      case "vertical_swing":
        return { ...r, swingAmplitude: 0.1 * n, swingFrequency: 1 };
      default:
        return r;
    }
  }
  getOutputCanvas() {
    return this.outputCanvas;
  }
  dispose() {
    this.gl && (this.sourceTexture && this.gl.deleteTexture(this.sourceTexture), this.depthTexture && this.gl.deleteTexture(this.depthTexture), this.positionBuffer && this.gl.deleteBuffer(this.positionBuffer), this.texCoordBuffer && this.gl.deleteBuffer(this.texCoordBuffer), this.program && this.gl.deleteProgram(this.program)), this.sourceTexture = null, this.depthTexture = null, this.positionBuffer = null, this.texCoordBuffer = null, this.program = null, this.gl = null;
  }
}
const jA = { class: "zoom-controls" }, RA = { class: "zoom-level" }, NA = {
  key: 1,
  class: "overlay-controls"
}, zA = {
  key: 2,
  class: "loading-overlay"
}, BA = /* @__PURE__ */ tn({
  __name: "CompositionCanvas",
  setup(i, { expose: e }) {
    const n = Gn(), r = re(null), o = re(null), s = re(null), a = re(null), l = re(null), u = re(null), c = re(/* @__PURE__ */ new Map()), d = re(!1), h = re(1), p = re(!0), m = re("viridis"), v = re(50), y = re(800), w = re(600), g = re(/* @__PURE__ */ new Map()), k = re(/* @__PURE__ */ new Map()), _ = re(null), S = re(null), b = re(null), C = re(/* @__PURE__ */ new Map()), x = Ee(() => n.depthMap !== null), I = Ee(() => n.currentTool === "pen"), F = Ee(() => {
      const E = n.selectedLayer;
      if ((E == null ? void 0 : E.type) === "spline")
        return E.id;
      if (I.value && n.layers.filter((L) => L.type === "spline").length === 0)
        return null;
      if (I.value) {
        const L = n.layers.filter((D) => D.type === "spline");
        return L.length > 0 ? L[L.length - 1].id : null;
      }
      return null;
    }), B = Ee(() => {
      var L;
      const E = (L = a.value) == null ? void 0 : L.viewportTransform;
      return E ? Array.from(E) : [1, 0, 0, 1, 0, 0];
    });
    Wn(() => {
      if (!o.value || !r.value) return;
      const E = r.value, L = E.getBoundingClientRect();
      y.value = L.width, w.value = L.height, a.value = new of(o.value, {
        width: L.width,
        height: L.height,
        backgroundColor: "#1a1a1a",
        selection: !0,
        preserveObjectStacking: !0
      }), X(), new ResizeObserver(j).observe(E), Lt(() => n.sourceImage, ee, { immediate: !0 }), Lt(() => n.depthMap, ie, { immediate: !0 }), Lt(() => n.layers, M, { deep: !0, immediate: !0 }), Lt(() => n.layers, me, { deep: !0, immediate: !0 }), Lt(() => n.layers, we, { deep: !0, immediate: !0 }), _.value = document.createElement("canvas"), S.value = _.value.getContext("2d"), fe();
    }), Qi(() => {
      var E;
      b.value !== null && cancelAnimationFrame(b.value), g.value.forEach((L) => {
        L.reset();
      }), g.value.clear(), k.value.forEach((L) => {
        L.dispose();
      }), k.value.clear(), (E = a.value) == null || E.dispose();
    });
    function X() {
      const E = a.value;
      if (!E) return;
      E.on("mouse:wheel", (G) => {
        const ne = G.e.deltaY;
        let se = E.getZoom() * (ne > 0 ? 0.9 : 1.1);
        se = Math.min(Math.max(se, 0.1), 10);
        const ge = new ce(G.e.offsetX, G.e.offsetY);
        E.zoomToPoint(ge, se), h.value = se, G.e.preventDefault(), G.e.stopPropagation();
      });
      let L = !1, D = 0, P = 0;
      E.on("mouse:down", (G) => {
        const ne = G.e;
        (ne.button === 1 || ne.button === 0 && ne.altKey) && (L = !0, D = ne.clientX, P = ne.clientY, E.selection = !1);
      }), E.on("mouse:move", (G) => {
        if (L) {
          const ne = G.e, se = E.viewportTransform;
          se && (se[4] += ne.clientX - D, se[5] += ne.clientY - P, E.requestRenderAll()), D = ne.clientX, P = ne.clientY;
        }
      }), E.on("mouse:up", () => {
        L && (L = !1, E.selection = !0);
      }), E.on("selection:created", (G) => {
        var se;
        const ne = (se = G.selected) == null ? void 0 : se[0];
        ne && ne.layerId && n.selectLayer(ne.layerId);
      });
    }
    function j(E) {
      const L = a.value;
      if (L)
        for (const D of E) {
          const { width: P, height: G } = D.contentRect;
          L.setDimensions({ width: P, height: G }), y.value = P, w.value = G, L.requestRenderAll();
        }
    }
    async function ee(E) {
      const L = a.value;
      if (!(!L || !E)) {
        d.value = !0;
        try {
          l.value && L.remove(l.value);
          const D = await V(E);
          l.value = new Zn(D, {
            selectable: !1,
            evented: !1,
            left: 0,
            top: 0
          }), L.add(l.value), L.sendObjectToBack(l.value), N();
        } catch (D) {
          console.error("[CompositionCanvas] Failed to load source image:", D);
        } finally {
          d.value = !1;
        }
      }
    }
    async function ie(E) {
      const L = a.value;
      if (!(!L || !E))
        try {
          if (u.value && L.remove(u.value), u.value = await ed.fromBase64(E, {
            colormap: m.value,
            opacity: v.value / 100,
            visible: p.value
          }), u.value.set({
            selectable: !1,
            evented: !1,
            left: 0,
            top: 0
          }), L.add(u.value), l.value) {
            const D = L.getObjects().indexOf(l.value);
            L.moveObjectTo(u.value, D + 1);
          }
          L.requestRenderAll();
        } catch (D) {
          console.error("[CompositionCanvas] Failed to load depth map:", D);
        }
    }
    function M() {
      const E = a.value;
      if (!E) return;
      const L = n.layers.filter((P) => P.type === "spline");
      for (const P of L) {
        const G = P.data;
        if (!G) continue;
        let ne = c.value.get(P.id);
        ne ? (ne.controlPoints = G.controlPoints || [], ne.set({
          stroke: G.stroke,
          strokeWidth: G.strokeWidth,
          fill: G.fill,
          selectable: !P.locked,
          visible: P.visible
        })) : (ne = new td("", {
          stroke: G.stroke || "#00ff00",
          strokeWidth: G.strokeWidth || 2,
          fill: G.fill || "",
          controlPoints: G.controlPoints || [],
          selectable: !P.locked
        }), ne.layerId = P.id, c.value.set(P.id, ne), E.add(ne)), ne.updatePathFromControlPoints();
      }
      const D = new Set(L.map((P) => P.id));
      for (const [P, G] of c.value)
        D.has(P) || (E.remove(G), c.value.delete(P));
      E.requestRenderAll();
    }
    function W(E) {
      if (!F.value) {
        const L = n.createLayer("spline");
        n.selectLayer(L.id);
      }
    }
    function R() {
      M();
    }
    Lt(p, (E) => {
      var L;
      u.value && (u.value.set("visible", E), (L = a.value) == null || L.requestRenderAll());
    }), Lt(m, (E) => {
      u.value && u.value.setColormap(E);
    }), Lt(v, (E) => {
      var L;
      u.value && (u.value.set("opacity", E / 100), (L = a.value) == null || L.requestRenderAll());
    });
    function V(E) {
      return new Promise((L, D) => {
        const P = new Image();
        P.crossOrigin = "anonymous", P.onload = () => L(P), P.onerror = D, P.src = E.startsWith("data:") ? E : `data:image/png;base64,${E}`;
      });
    }
    function ae() {
      const E = a.value;
      if (!E) return;
      const L = Math.min(E.getZoom() * 1.2, 10);
      E.setZoom(L), h.value = L;
    }
    function $e() {
      const E = a.value;
      if (!E) return;
      const L = Math.max(E.getZoom() * 0.8, 0.1);
      E.setZoom(L), h.value = L;
    }
    function N() {
      const E = a.value, L = r.value;
      if (!E || !L || !l.value) return;
      const D = L.getBoundingClientRect(), P = l.value.width || 1, G = l.value.height || 1, ne = 40, se = (D.width - ne * 2) / P, ge = (D.height - ne * 2) / G, Se = Math.min(se, ge, 1), be = E.viewportTransform;
      be && (be[0] = Se, be[3] = Se, be[4] = (D.width - P * Se) / 2, be[5] = (D.height - G * Se) / 2), h.value = Se, E.requestRenderAll();
    }
    function me() {
      var D;
      const E = n.layers.filter((P) => P.type === "particles"), L = new Set(E.map((P) => P.id));
      for (const P of E)
        if (g.value.has(P.id)) {
          const G = g.value.get(P.id), ne = P.data;
          if (ne) {
            G.setConfig(ne.systemConfig);
            const se = G.getEmitters();
            for (const ge of ne.emitters)
              se.find((be) => be.id === ge.id) ? G.updateEmitter(ge.id, ge) : G.addEmitter(ge);
          }
        } else {
          const G = P.data;
          if (G) {
            const ne = new Cd(G.systemConfig);
            for (const se of G.emitters)
              ne.addEmitter(se);
            for (const se of G.gravityWells)
              ne.addGravityWell(se);
            for (const se of G.vortices)
              ne.addVortex(se);
            for (const se of G.modulations)
              ne.addModulation(se);
            g.value.set(P.id, ne);
          }
        }
      for (const [P] of g.value)
        L.has(P) || ((D = g.value.get(P)) == null || D.reset(), g.value.delete(P));
    }
    function we() {
      var D;
      const E = n.layers.filter((P) => P.type === "depthflow"), L = new Set(E.map((P) => P.id));
      for (const P of E)
        if (k.value.has(P.id)) {
          const G = k.value.get(P.id), ne = P.data;
          ne && G.setConfig(ne.config);
        } else {
          const G = P.data;
          if (G) {
            const ne = new FA();
            ne.setConfig(G.config), k.value.set(P.id, ne);
          }
        }
      for (const [P] of k.value)
        L.has(P) || ((D = k.value.get(P)) == null || D.dispose(), k.value.delete(P));
    }
    function fe() {
      const E = () => {
        (n.isPlaying || n.audioAnalysis) && Ce(), n.isPlaying && te(), Me(), le(), b.value = requestAnimationFrame(E);
      };
      b.value = requestAnimationFrame(E);
    }
    function te() {
      var L;
      const E = ((L = n.audioAnalysis) == null ? void 0 : L.onsets.includes(n.currentFrame)) ?? !1;
      g.value.forEach((D, P) => {
        const G = n.getActiveMappingsForLayer(P);
        for (const ne of G) {
          const ge = n.getAudioFeatureAtFrame(ne.feature) * ne.sensitivity, Se = ne.target.split("."), be = Se.length > 1 ? Se[1] : ne.target;
          D.setFeatureValue(be, ge, ne.targetEmitterId);
        }
        E && D.triggerAllBursts(), D.step(1);
      });
    }
    function Me() {
      const E = a.value;
      if (!E || !_.value || !S.value) return;
      const L = n.layers.filter((G) => G.type === "particles" && G.visible);
      if (L.length === 0) return;
      (_.value.width !== E.width || _.value.height !== E.height) && (_.value.width = E.width || 800, _.value.height = E.height || 600);
      const D = S.value;
      D.clearRect(0, 0, _.value.width, _.value.height);
      for (const G of L) {
        const ne = g.value.get(G.id), se = G.data;
        if (ne && se) {
          D.save();
          const ge = E.viewportTransform;
          ge && D.transform(ge[0], ge[1], ge[2], ge[3], ge[4], ge[5]), ne.renderToCanvas(
            D,
            n.width,
            n.height,
            se.renderOptions
          ), D.restore();
        }
      }
      const P = E.getContext();
      P && L.length > 0 && P.drawImage(_.value, 0, 0);
    }
    function Re(E) {
      const L = g.value.get(E);
      return (L == null ? void 0 : L.getParticleCount()) ?? 0;
    }
    function Ce() {
      n.updatePathAnimators();
      for (const E of n.layers) {
        const L = n.getPathAnimator(E.id);
        if (L) {
          const D = L.getState();
          C.value.set(E.id, D);
        }
      }
    }
    function le() {
      const E = a.value;
      if (!E || !_.value || !S.value) return;
      const L = n.layers.filter((P) => P.type === "text" && P.visible);
      if (L.length === 0) return;
      const D = S.value;
      for (const P of L) {
        const G = P.data;
        if (!(G != null && G.pathLayerId)) continue;
        const ne = n.getPathAnimator(P.id);
        if (!ne) continue;
        const se = C.value.get(P.id);
        if (!se) continue;
        const ge = n.layers.find((J) => J.id === G.pathLayerId);
        if (!ge) continue;
        const Se = ge.data;
        if (!(Se != null && Se.pathData)) continue;
        D.save();
        const be = E.viewportTransform;
        be && D.transform(be[0], be[1], be[2], be[3], be[4], be[5]);
        const xe = ne.getConfig(), q = Math.abs(se.position - se.previousPosition);
        if (xe.motionBlur && q > 1e-3) {
          const J = ne.getMotionBlurTrail(8);
          D.lineCap = "round", D.lineJoin = "round";
          for (let ue = 0; ue < J.length - 1; ue++) {
            const Ae = J[ue], je = J[ue + 1], Ge = Ae.opacity * xe.motionBlurStrength * 0.5;
            D.strokeStyle = `rgba(255, 255, 255, ${Ge})`, D.lineWidth = Math.max(2, (G.fontSize || 48) * 0.1 * (1 - ue / J.length)), D.beginPath(), D.moveTo(Ae.x, Ae.y), D.lineTo(je.x, je.y), D.stroke();
          }
        }
        D.restore();
      }
    }
    function T(E) {
      const L = n.getPathAnimator(E);
      if (!L) return null;
      const D = C.value.get(E);
      if (!D) return null;
      const P = L.getPositionOnPath(D.position);
      return {
        x: P.x,
        y: P.y,
        angle: P.angle
      };
    }
    return e({
      fabricCanvas: a,
      fitToView: N,
      zoom: h,
      particleSystems: g,
      depthflowRenderers: k,
      getParticleCount: Re,
      getTextPathPosition: T,
      pathAnimationStates: C
    }), (E, L) => ($(), A("div", {
      class: "composition-canvas",
      ref_key: "containerRef",
      ref: r
    }, [
      f("canvas", {
        ref_key: "canvasRef",
        ref: o
      }, null, 512),
      F.value || I.value ? ($(), st(TA, {
        key: 0,
        layerId: F.value,
        canvasWidth: y.value,
        canvasHeight: w.value,
        zoom: h.value,
        viewportTransform: B.value,
        isPenMode: I.value,
        onPointAdded: W,
        onPathUpdated: R,
        ref_key: "splineEditorRef",
        ref: s
      }, null, 8, ["layerId", "canvasWidth", "canvasHeight", "zoom", "viewportTransform", "isPenMode"])) : ve("", !0),
      f("div", jA, [
        f("button", {
          onClick: ae,
          title: "Zoom In"
        }, "+"),
        f("span", RA, Q(Math.round(h.value * 100)) + "%", 1),
        f("button", {
          onClick: $e,
          title: "Zoom Out"
        }, "-"),
        f("button", {
          onClick: N,
          title: "Fit to View"
        }, "Fit")
      ]),
      x.value ? ($(), A("div", NA, [
        f("label", null, [
          ot(f("input", {
            type: "checkbox",
            "onUpdate:modelValue": L[0] || (L[0] = (D) => p.value = D)
          }, null, 512), [
            [vS, p.value]
          ]),
          L[3] || (L[3] = vt(" Depth Overlay ", -1))
        ]),
        ot(f("select", {
          "onUpdate:modelValue": L[1] || (L[1] = (D) => m.value = D),
          class: "colormap-select"
        }, [...L[4] || (L[4] = [
          f("option", { value: "viridis" }, "Viridis", -1),
          f("option", { value: "plasma" }, "Plasma", -1),
          f("option", { value: "grayscale" }, "Grayscale", -1)
        ])], 512), [
          [Zr, m.value]
        ]),
        ot(f("input", {
          type: "range",
          min: "0",
          max: "100",
          "onUpdate:modelValue": L[2] || (L[2] = (D) => v.value = D),
          class: "opacity-slider"
        }, null, 512), [
          [
            Qt,
            v.value,
            void 0,
            { number: !0 }
          ]
        ])
      ])) : ve("", !0),
      d.value ? ($(), A("div", zA, [...L[5] || (L[5] = [
        f("div", { class: "loading-spinner" }, null, -1),
        f("span", null, "Loading...", -1)
      ])])) : ve("", !0)
    ], 512));
  }
}), HA = /* @__PURE__ */ cn(BA, [["__scopeId", "data-v-6b736d12"]]), UA = { class: "layer-info" }, WA = ["onClick"], GA = { class: "av-switches" }, XA = ["title"], YA = { class: "icon" }, KA = ["title"], qA = { class: "icon" }, ZA = { class: "layer-name-container" }, JA = ["title"], QA = ["title"], e6 = { class: "parent-picker" }, t6 = ["value", "disabled"], n6 = ["value"], i6 = {
  key: 0,
  class: "layer-switches"
}, r6 = {
  key: 0,
  class: "effect-indicator",
  title: "Has Effects"
}, o6 = ["title", "onClick", "onDblclick"], s6 = /* @__PURE__ */ tn({
  __name: "EnhancedLayerTrack",
  props: {
    layer: {},
    frameCount: {},
    allLayers: {},
    soloedLayerIds: {},
    showSwitches: { type: Boolean }
  },
  emits: ["select", "updateLayer", "selectKeyframe", "setParent", "toggleSolo"],
  setup(i, { emit: e }) {
    const n = i, r = e, o = Gn(), s = re(null), a = re(null), l = re(!1), u = re(!1), c = re(""), d = [
      "#ff6b6b",
      "#ffc107",
      "#4ecdc4",
      "#45b7d1",
      "#96ceb4",
      "#7c9cff",
      "#bb8fce",
      "#ff8a65",
      "#a1887f",
      "#90a4ae",
      "#e0e0e0",
      "#333333"
    ], h = Ee(() => o.selectedLayerIds.includes(n.layer.id)), p = Ee(() => o.selectedKeyframeIds), m = Ee(() => n.soloedLayerIds.includes(n.layer.id)), v = Ee(
      () => n.soloedLayerIds.length > 0 && !m.value
    ), y = Ee(
      () => n.layer.type === "audio" || n.layer.type === "video"
    ), w = Ee(() => n.allLayers.filter((T) => {
      if (T.id === n.layer.id) return !1;
      let E = T;
      for (; E.parentId; ) {
        if (E.parentId === n.layer.id) return !1;
        if (E = n.allLayers.find((L) => L.id === E.parentId) || E, !E.parentId) break;
      }
      return !0;
    })), g = Ee(() => {
      const T = n.layer.inPoint / n.frameCount * 100, L = (n.layer.outPoint + 1) / n.frameCount * 100 - T;
      return {
        left: `${T}%`,
        width: `${L}%`
      };
    }), k = Ee(() => {
      const T = [];
      return n.layer.opacity.animated && n.layer.opacity.keyframes.forEach((E) => {
        T.push({ ...E, propertyName: "Opacity" });
      }), ["position", "scale", "rotation"].forEach((E) => {
        const L = n.layer.transform[E];
        L != null && L.animated && L.keyframes.forEach((D) => {
          T.push({ ...D, propertyName: E.charAt(0).toUpperCase() + E.slice(1) });
        });
      }), n.layer.properties.forEach((E) => {
        E.animated && E.keyframes.forEach((L) => {
          T.push({ ...L, propertyName: E.name });
        });
      }), T;
    }), _ = Ee(() => k.value.length > 0), S = Ee(() => {
      const T = [];
      return n.layer.properties.forEach((E) => {
        E.expression && T.push({
          propertyId: E.id,
          startFrame: n.layer.inPoint
        });
      }), T;
    });
    function b(T) {
      return T / n.frameCount * 100;
    }
    function C(T) {
      return {
        spline: "~",
        text: "T",
        solid: "[]",
        null: "N",
        camera: "C",
        light: "*",
        audio: "A",
        video: "V",
        image: "I",
        shape: "S",
        adjustment: "Ad"
      }[T] || "?";
    }
    function x() {
      r("select", n.layer.id);
    }
    function I() {
      r("updateLayer", n.layer.id, { visible: !n.layer.visible });
    }
    function F() {
      r("updateLayer", n.layer.id, { audioEnabled: !n.layer.audioEnabled });
    }
    function B() {
      r("updateLayer", n.layer.id, { locked: !n.layer.locked });
    }
    function X() {
      r("toggleSolo", n.layer.id);
    }
    function j(T) {
      r("updateLayer", n.layer.id, { [T]: !n.layer[T] });
    }
    function ee() {
      const T = n.layer.quality === "best" ? "draft" : "best";
      r("updateLayer", n.layer.id, { quality: T });
    }
    function ie(T) {
      r("updateLayer", n.layer.id, { labelColor: T }), l.value = !1;
    }
    function M(T) {
      const L = T.target.value || null;
      r("setParent", n.layer.id, L);
    }
    function W(T) {
      r("selectKeyframe", T);
    }
    function R(T) {
      o.setFrame(T);
    }
    function V() {
      n.layer.locked || (u.value = !0, c.value = n.layer.name, Es(() => {
        var T, E;
        (T = a.value) == null || T.focus(), (E = a.value) == null || E.select();
      }));
    }
    function ae() {
      c.value.trim() && r("updateLayer", n.layer.id, { name: c.value.trim() }), u.value = !1;
    }
    function $e() {
      u.value = !1;
    }
    let N = null, me = 0, we = 0, fe = 0;
    function te(T) {
      n.layer.locked || (N = "move", me = T.clientX, we = n.layer.inPoint, fe = n.layer.outPoint, document.addEventListener("mousemove", Ce), document.addEventListener("mouseup", le));
    }
    function Me(T) {
      n.layer.locked || (N = "trimIn", document.addEventListener("mousemove", Ce), document.addEventListener("mouseup", le));
    }
    function Re(T) {
      n.layer.locked || (N = "trimOut", document.addEventListener("mousemove", Ce), document.addEventListener("mouseup", le));
    }
    function Ce(T) {
      if (!s.value || !N) return;
      const E = s.value.getBoundingClientRect(), L = T.clientX - E.left, D = Math.round(L / E.width * n.frameCount);
      if (N === "trimIn") {
        const P = Math.min(D, n.layer.outPoint - 1);
        r("updateLayer", n.layer.id, { inPoint: Math.max(0, P) });
      } else if (N === "trimOut") {
        const P = Math.max(D, n.layer.inPoint + 1);
        r("updateLayer", n.layer.id, { outPoint: Math.min(n.frameCount - 1, P) });
      } else if (N === "move") {
        const P = T.clientX - me, G = Math.round(P / E.width * n.frameCount);
        let ne = we + G, se = fe + G;
        ne < 0 && (se -= ne, ne = 0), se > n.frameCount - 1 && (ne -= se - (n.frameCount - 1), se = n.frameCount - 1), r("updateLayer", n.layer.id, { inPoint: ne, outPoint: se });
      }
    }
    function le() {
      N = null, document.removeEventListener("mousemove", Ce), document.removeEventListener("mouseup", le);
    }
    return (T, E) => ($(), A("div", {
      class: _e(["enhanced-layer-track", {
        selected: h.value,
        locked: i.layer.locked,
        hidden: !i.layer.visible,
        soloed: m.value,
        "dimmed-by-solo": v.value
      }]),
      onClick: x,
      style: Pt({ "--label-color": i.layer.labelColor || "#7c9cff" })
    }, [
      f("div", UA, [
        f("div", {
          class: "label-color",
          onClick: E[1] || (E[1] = tt((L) => l.value = !l.value, ["stop"]))
        }, [
          l.value ? ($(), A("div", {
            key: 0,
            class: "label-picker",
            onClick: E[0] || (E[0] = tt(() => {
            }, ["stop"]))
          }, [
            ($(), A(Fe, null, Ke(d, (L) => f("button", {
              key: L,
              style: Pt({ background: L }),
              onClick: (D) => ie(L)
            }, null, 12, WA)), 64))
          ])) : ve("", !0)
        ]),
        f("div", GA, [
          f("button", {
            class: _e(["icon-btn", { active: i.layer.visible }]),
            onClick: tt(I, ["stop"]),
            title: i.layer.visible ? "Hide (V)" : "Show (V)"
          }, [
            f("span", YA, Q(i.layer.visible ? "V" : "-"), 1)
          ], 10, XA),
          y.value ? ($(), A("button", {
            key: 0,
            class: _e(["icon-btn", { active: i.layer.audioEnabled }]),
            onClick: tt(F, ["stop"]),
            title: "Toggle Audio"
          }, [...E[7] || (E[7] = [
            f("span", { class: "icon" }, "A", -1)
          ])], 2)) : ve("", !0)
        ]),
        f("button", {
          class: _e(["icon-btn solo-btn", { active: m.value }]),
          onClick: tt(X, ["stop"]),
          title: "Solo (S)"
        }, [...E[8] || (E[8] = [
          f("span", { class: "icon" }, "S", -1)
        ])], 2),
        f("button", {
          class: _e(["icon-btn lock-btn", { active: i.layer.locked }]),
          onClick: tt(B, ["stop"]),
          title: i.layer.locked ? "Unlock (L)" : "Lock (L)"
        }, [
          f("span", qA, Q(i.layer.locked ? "L" : "u"), 1)
        ], 10, KA),
        f("div", ZA, [
          f("span", {
            class: "layer-type-icon",
            title: i.layer.type
          }, Q(C(i.layer.type)), 9, JA),
          f("span", {
            class: "layer-name",
            title: i.layer.name,
            onDblclick: tt(V, ["stop"])
          }, [
            u.value ? ot(($(), A("input", {
              key: 0,
              "onUpdate:modelValue": E[2] || (E[2] = (L) => c.value = L),
              onBlur: ae,
              onKeyup: [
                Ah(ae, ["enter"]),
                Ah($e, ["escape"])
              ],
              class: "rename-input",
              ref_key: "renameInput",
              ref: a
            }, null, 544)), [
              [Qt, c.value]
            ]) : ($(), A(Fe, { key: 1 }, [
              vt(Q(i.layer.name), 1)
            ], 64))
          ], 40, QA)
        ]),
        f("div", e6, [
          f("select", {
            value: i.layer.parentId || "",
            onChange: M,
            disabled: i.layer.locked,
            class: "parent-select",
            title: "Parent & Link"
          }, [
            E[9] || (E[9] = f("option", { value: "" }, "None", -1)),
            ($(!0), A(Fe, null, Ke(w.value, (L) => ($(), A("option", {
              key: L.id,
              value: L.id
            }, Q(L.name), 9, n6))), 128))
          ], 40, t6)
        ]),
        i.showSwitches ? ($(), A("div", i6, [
          f("button", {
            class: _e(["switch-btn", { active: i.layer.shy }]),
            onClick: E[3] || (E[3] = tt((L) => j("shy"), ["stop"])),
            title: "Shy"
          }, " Sh ", 2),
          f("button", {
            class: _e(["switch-btn", { active: i.layer.collapse }]),
            onClick: E[4] || (E[4] = tt((L) => j("collapse"), ["stop"])),
            title: "Collapse Transformations"
          }, " Ct ", 2),
          f("button", {
            class: _e(["switch-btn", { active: i.layer.quality === "best" }]),
            onClick: tt(ee, ["stop"]),
            title: "Quality"
          }, Q(i.layer.quality === "best" ? "B" : "D"), 3),
          f("button", {
            class: _e(["switch-btn", { active: i.layer.is3D }]),
            onClick: E[5] || (E[5] = tt((L) => j("is3D"), ["stop"])),
            title: "3D Layer"
          }, " 3D ", 2),
          f("button", {
            class: _e(["switch-btn", { active: i.layer.motionBlur }]),
            onClick: E[6] || (E[6] = tt((L) => j("motionBlur"), ["stop"])),
            title: "Motion Blur"
          }, " MB ", 2)
        ])) : ve("", !0)
      ]),
      f("div", {
        class: "track-area",
        ref_key: "trackAreaRef",
        ref: s
      }, [
        f("div", {
          class: _e(["duration-bar", { "has-keyframes": _.value }]),
          style: Pt(g.value),
          onMousedown: te
        }, [
          f("div", {
            class: "trim-handle trim-in",
            onMousedown: tt(Me, ["stop"])
          }, null, 32),
          f("div", {
            class: "trim-handle trim-out",
            onMousedown: tt(Re, ["stop"])
          }, null, 32),
          i.layer.effects && i.layer.effects.length > 0 ? ($(), A("div", r6, " fx ")) : ve("", !0)
        ], 38),
        ($(!0), A(Fe, null, Ke(k.value, (L) => ($(), A("div", {
          key: L.id,
          class: _e(["keyframe-diamond", {
            selected: p.value.includes(L.id),
            [L.interpolation]: !0
          }]),
          style: Pt({ left: `${b(L.frame)}%` }),
          title: `${L.propertyName} @ Frame ${L.frame}`,
          onClick: tt((D) => W(L.id), ["stop"]),
          onDblclick: tt((D) => R(L.frame), ["stop"])
        }, null, 46, o6))), 128)),
        ($(!0), A(Fe, null, Ke(S.value, (L) => ($(), A("div", {
          key: L.propertyId,
          class: "expression-indicator",
          style: Pt({ left: `${b(L.startFrame)}%` }),
          title: "Expression"
        }, " = ", 4))), 128))
      ], 512)
    ], 6));
  }
}), a6 = /* @__PURE__ */ cn(s6, [["__scopeId", "data-v-2d2067d2"]]), l6 = { class: "timeline-panel" }, u6 = { class: "timeline-header" }, c6 = { class: "header-left" }, d6 = { class: "timeline-info" }, h6 = { class: "header-center" }, f6 = { class: "playback-controls" }, p6 = { class: "icon" }, m6 = ["title"], g6 = { class: "icon" }, v6 = { class: "header-right" }, y6 = {
  key: 0,
  class: "add-layer-menu"
}, b6 = { class: "time-ruler" }, w6 = ["onClick", "onDblclick", "title"], _6 = {
  key: 0,
  class: "mark-label"
}, x6 = {
  key: 0,
  class: "empty-state"
}, S6 = { key: 0 }, C6 = { class: "timeline-scrubber" }, k6 = { class: "scrubber-sidebar" }, O6 = { class: "frame-label" }, E6 = { class: "frame-input" }, T6 = ["value", "max"], D6 = { class: "frame-total" }, $6 = { class: "marker-dialog-content" }, M6 = { class: "form-row" }, P6 = { class: "form-row" }, I6 = { class: "form-row" }, L6 = { class: "form-row" }, A6 = { class: "dialog-actions" }, V6 = 220, F6 = /* @__PURE__ */ tn({
  __name: "TimelinePanel",
  setup(i) {
    const e = Gn(), n = re(null), r = re(null), o = re(null), s = re(!1), a = re(600), l = re(""), u = re(!0), c = re(!1), d = re("loop");
    let h = null, p = 1;
    const m = zo({
      start: 0,
      end: e.frameCount - 1
    }), v = re([]), y = re(null), w = re(null), g = re([]), k = Ee(() => {
      if (!l.value) return e.layers;
      const q = l.value.toLowerCase();
      return e.layers.filter(
        (J) => J.name.toLowerCase().includes(q)
      );
    }), _ = Ee(() => e.currentFrame / e.frameCount * a.value), S = Ee(() => e.currentFrame / (e.frameCount - 1) * 100), b = Ee(() => {
      const q = m.start / e.frameCount * 100, J = (m.end + 1) / e.frameCount * 100;
      return {
        left: `${q}%`,
        width: `${J - q}%`
      };
    }), C = Ee(() => b.value), x = Ee(() => {
      const q = [], J = e.frameCount, ue = Math.max(1, Math.floor(J / 20)), Ae = ue * 2;
      for (let je = 0; je <= J; je += ue)
        q.push({
          frame: je,
          position: je / J * 100,
          major: je % Ae === 0
        });
      return q;
    });
    function I(q) {
      const J = e.fps, ue = q / J, Ae = Math.floor(ue / 60), je = Math.floor(ue % 60), Ge = q % J;
      return `${Ae.toString().padStart(2, "0")}:${je.toString().padStart(2, "0")}:${Ge.toString().padStart(2, "0")}`;
    }
    function F() {
      r.value && (a.value = r.value.offsetWidth);
    }
    function B() {
      c.value = !c.value, c.value ? (p = 1, h = window.setInterval(() => {
        let q = e.currentFrame + p;
        if (q > m.end)
          if (d.value === "loop")
            q = m.start;
          else if (d.value === "pingpong")
            p = -1, q = e.currentFrame - 1;
          else {
            X();
            return;
          }
        else q < m.start && d.value === "pingpong" && (p = 1, q = e.currentFrame + 1);
        e.setFrame(Math.max(m.start, Math.min(m.end, q)));
      }, 1e3 / e.fps)) : X();
    }
    function X() {
      c.value = !1, h && (clearInterval(h), h = null);
    }
    function j() {
      e.setFrame(m.start);
    }
    function ee() {
      e.setFrame(m.end);
    }
    function ie() {
      e.setFrame(Math.min(e.currentFrame + 1, m.end));
    }
    function M() {
      e.setFrame(Math.max(e.currentFrame - 1, m.start));
    }
    function W() {
      const q = ["none", "loop", "pingpong"], J = q.indexOf(d.value);
      d.value = q[(J + 1) % q.length];
    }
    function R(q) {
      e.selectLayer(q);
    }
    function V(q, J) {
      e.updateLayer(q, J);
    }
    function ae(q) {
      const J = e.selectedKeyframeIds.indexOf(q);
      J >= 0 ? e.selectedKeyframeIds.splice(J, 1) : e.selectedKeyframeIds.push(q);
    }
    function $e(q) {
      e.createLayer(q), s.value = !1;
    }
    function N(q, J) {
      e.updateLayer(q, { parentId: J });
    }
    function me(q) {
      const J = g.value.indexOf(q);
      J >= 0 ? g.value.splice(J, 1) : g.value.push(q);
    }
    let we = null, fe = 0;
    function te(q) {
      we = "move", fe = q.clientX, document.addEventListener("mousemove", Re), document.addEventListener("mouseup", Ce);
    }
    function Me(q, J) {
      we = q, document.addEventListener("mousemove", Re), document.addEventListener("mouseup", Ce);
    }
    function Re(q) {
      if (!r.value || !we) return;
      const J = r.value.getBoundingClientRect(), ue = q.clientX - J.left, Ae = Math.round(ue / J.width * e.frameCount);
      if (we === "start")
        m.start = Math.max(0, Math.min(Ae, m.end - 1));
      else if (we === "end")
        m.end = Math.min(e.frameCount - 1, Math.max(Ae, m.start + 1));
      else if (we === "move") {
        const je = q.clientX - fe, Ge = Math.round(je / J.width * e.frameCount), ft = m.start + Ge, at = m.end + Ge;
        ft >= 0 && at <= e.frameCount - 1 && (m.start = ft, m.end = at), fe = q.clientX;
      }
    }
    function Ce() {
      we = null, document.removeEventListener("mousemove", Re), document.removeEventListener("mouseup", Ce);
    }
    function le(q) {
      if (!r.value) return;
      const J = r.value.getBoundingClientRect(), ue = q.clientX - J.left, Ae = Math.round(ue / J.width * e.frameCount), je = {
        id: `marker-${Date.now()}`,
        frame: Ae,
        label: `Marker ${v.value.length + 1}`,
        color: "#ffc107",
        comment: ""
      };
      v.value.push(je), w.value = { ...je };
    }
    function T(q) {
      y.value = y.value === q ? null : q;
    }
    function E(q) {
      const J = v.value.find((ue) => ue.id === q);
      J && (w.value = { ...J });
    }
    function L() {
      if (!w.value) return;
      const q = v.value.findIndex((J) => J.id === w.value.id);
      q >= 0 && (v.value[q] = { ...w.value }), w.value = null;
    }
    function D(q) {
      v.value = v.value.filter((J) => J.id !== q), y.value === q && (y.value = null), w.value = null;
    }
    let P = !1;
    function G(q) {
      P = !0, ne(q), document.addEventListener("mousemove", se), document.addEventListener("mouseup", ge);
    }
    function ne(q) {
      const ue = q.currentTarget.getBoundingClientRect(), Ae = q.clientX - ue.left, je = Math.max(0, Math.min(1, Ae / ue.width)), Ge = Math.round(je * (e.frameCount - 1));
      e.setFrame(Ge);
    }
    function se(q) {
      if (!P) return;
      const J = document.querySelector(".scrubber-track");
      if (!J) return;
      const ue = J.getBoundingClientRect(), Ae = q.clientX - ue.left, je = Math.max(0, Math.min(1, Ae / ue.width)), Ge = Math.round(je * (e.frameCount - 1));
      e.setFrame(Ge);
    }
    function ge() {
      P = !1, document.removeEventListener("mousemove", se), document.removeEventListener("mouseup", ge);
    }
    function Se(q) {
      const J = q.target, ue = parseInt(J.value, 10);
      isNaN(ue) || e.setFrame(ue);
    }
    function be(q) {
      if (!(q.target.tagName === "INPUT" || q.target.tagName === "TEXTAREA"))
        switch (q.key) {
          case " ":
            q.preventDefault(), B();
            break;
          case "Home":
            j();
            break;
          case "End":
            ee();
            break;
          case "PageUp":
            M();
            break;
          case "PageDown":
            ie();
            break;
          case "b":
          case "B":
            m.start = e.currentFrame;
            break;
          case "n":
          case "N":
            m.end = e.currentFrame;
            break;
        }
    }
    function xe(q) {
      const J = q.target;
      !J.closest(".add-layer-btn") && !J.closest(".add-layer-menu") && (s.value = !1);
    }
    return Wn(() => {
      F(), window.addEventListener("resize", F), document.addEventListener("click", xe), document.addEventListener("keydown", be), m.end = e.frameCount - 1;
    }), Qi(() => {
      X(), window.removeEventListener("resize", F), document.removeEventListener("click", xe), document.removeEventListener("keydown", be);
    }), Lt(() => e.frameCount, (q) => {
      m.end >= q && (m.end = q - 1);
    }), (q, J) => ($(), A("div", l6, [
      f("div", u6, [
        f("div", c6, [
          J[18] || (J[18] = f("span", { class: "timeline-title" }, "Timeline", -1)),
          f("span", d6, Q(ze(e).frameCount) + " frames @ " + Q(ze(e).fps) + "fps ", 1)
        ]),
        f("div", h6, [
          f("div", f6, [
            f("button", {
              onClick: j,
              title: "Go to Start (Home)"
            }, [...J[19] || (J[19] = [
              f("span", { class: "icon" }, "|<", -1)
            ])]),
            f("button", {
              onClick: M,
              title: "Previous Frame (Page Up)"
            }, [...J[20] || (J[20] = [
              f("span", { class: "icon" }, "<", -1)
            ])]),
            f("button", {
              onClick: B,
              class: _e({ active: c.value }),
              title: "Play/Pause (Space)"
            }, [
              f("span", p6, Q(c.value ? "||" : ">"), 1)
            ], 2),
            f("button", {
              onClick: ie,
              title: "Next Frame (Page Down)"
            }, [...J[21] || (J[21] = [
              f("span", { class: "icon" }, ">", -1)
            ])]),
            f("button", {
              onClick: ee,
              title: "Go to End (End)"
            }, [...J[22] || (J[22] = [
              f("span", { class: "icon" }, ">|", -1)
            ])])
          ]),
          f("button", {
            class: _e(["loop-btn", { active: d.value !== "none" }]),
            onClick: W,
            title: `Loop: ${d.value}`
          }, [
            f("span", g6, Q(d.value === "none" ? "L-" : d.value === "loop" ? "LP" : "PP"), 1)
          ], 10, m6)
        ]),
        f("div", v6, [
          ot(f("input", {
            type: "text",
            "onUpdate:modelValue": J[0] || (J[0] = (ue) => l.value = ue),
            placeholder: "Search layers...",
            class: "search-input"
          }, null, 512), [
            [Qt, l.value]
          ]),
          f("button", {
            class: "add-layer-btn",
            onClick: J[1] || (J[1] = (ue) => s.value = !s.value)
          }, [...J[23] || (J[23] = [
            f("span", { class: "icon" }, "+", -1),
            vt(" Add Layer ", -1)
          ])]),
          s.value ? ($(), A("div", y6, [
            f("button", {
              onClick: J[2] || (J[2] = (ue) => $e("spline"))
            }, "Spline Path"),
            f("button", {
              onClick: J[3] || (J[3] = (ue) => $e("text"))
            }, "Text"),
            f("button", {
              onClick: J[4] || (J[4] = (ue) => $e("solid"))
            }, "Solid"),
            f("button", {
              onClick: J[5] || (J[5] = (ue) => $e("null"))
            }, "Null Object"),
            f("button", {
              onClick: J[6] || (J[6] = (ue) => $e("camera"))
            }, "Camera"),
            f("button", {
              onClick: J[7] || (J[7] = (ue) => $e("light"))
            }, "Light")
          ])) : ve("", !0)
        ])
      ]),
      J[33] || (J[33] = va('<div class="column-headers" data-v-f3b9bc96><div class="layer-columns-header" data-v-f3b9bc96><span class="col-header col-label" title="Label Color" data-v-f3b9bc96>L</span><span class="col-header col-av" title="Audio/Video" data-v-f3b9bc96>AV</span><span class="col-header col-solo" title="Solo" data-v-f3b9bc96>S</span><span class="col-header col-lock" title="Lock" data-v-f3b9bc96>Lk</span><span class="col-header col-name" data-v-f3b9bc96>Layer Name</span><span class="col-header col-parent" title="Parent &amp; Link" data-v-f3b9bc96>Par</span><span class="col-header col-switches" title="Layer Switches" data-v-f3b9bc96>Switches</span></div><div class="track-header" data-v-f3b9bc96></div></div>', 1)),
      f("div", {
        class: "timeline-content",
        ref_key: "timelineContentRef",
        ref: n
      }, [
        f("div", b6, [
          J[24] || (J[24] = f("div", { class: "ruler-sidebar" }, null, -1)),
          f("div", {
            class: "ruler-track",
            ref_key: "rulerTrackRef",
            ref: r,
            onDblclick: le
          }, [
            f("div", {
              class: "work-area",
              style: Pt(b.value),
              onMousedown: te
            }, [
              f("div", {
                class: "work-area-handle start",
                onMousedown: J[8] || (J[8] = tt((ue) => Me("start"), ["stop"]))
              }, null, 32),
              f("div", {
                class: "work-area-handle end",
                onMousedown: J[9] || (J[9] = tt((ue) => Me("end"), ["stop"]))
              }, null, 32)
            ], 36),
            ($(!0), A(Fe, null, Ke(v.value, (ue) => ($(), A("div", {
              key: ue.id,
              class: _e(["marker", { selected: y.value === ue.id }]),
              style: Pt({ left: `${ue.frame / ze(e).frameCount * 100}%` }),
              onClick: tt((Ae) => T(ue.id), ["stop"]),
              onDblclick: tt((Ae) => E(ue.id), ["stop"]),
              title: `${ue.label} (Frame ${ue.frame})`
            }, [
              f("div", {
                class: "marker-flag",
                style: Pt({ background: ue.color })
              }, null, 4)
            ], 46, w6))), 128)),
            ($(!0), A(Fe, null, Ke(x.value, (ue) => ($(), A("div", {
              key: ue.frame,
              class: _e(["ruler-mark", { major: ue.major }]),
              style: Pt({ left: `${ue.position}%` })
            }, [
              ue.major ? ($(), A("span", _6, Q(I(ue.frame)), 1)) : ve("", !0)
            ], 6))), 128))
          ], 544)
        ]),
        f("div", {
          class: "layer-tracks",
          ref_key: "layerTracksRef",
          ref: o
        }, [
          ($(!0), A(Fe, null, Ke(k.value, (ue) => ($(), st(a6, {
            key: ue.id,
            layer: ue,
            frameCount: ze(e).frameCount,
            allLayers: ze(e).layers,
            soloedLayerIds: g.value,
            showSwitches: u.value,
            onSelect: R,
            onUpdateLayer: V,
            onSelectKeyframe: ae,
            onSetParent: N,
            onToggleSolo: me
          }, null, 8, ["layer", "frameCount", "allLayers", "soloedLayerIds", "showSwitches"]))), 128)),
          k.value.length === 0 ? ($(), A("div", x6, [
            l.value ? ($(), A("p", S6, 'No layers match "' + Q(l.value) + '"', 1)) : ($(), A(Fe, { key: 1 }, [
              J[25] || (J[25] = f("p", null, "No layers yet", -1)),
              J[26] || (J[26] = f("p", { class: "hint" }, 'Click "Add Layer" to create a layer', -1))
            ], 64))
          ])) : ve("", !0)
        ], 512),
        f("div", {
          class: "playhead",
          style: Pt({ left: `${V6 + _.value}px` })
        }, [...J[27] || (J[27] = [
          f("div", { class: "playhead-head" }, null, -1),
          f("div", { class: "playhead-line" }, null, -1)
        ])], 4)
      ], 512),
      f("div", C6, [
        f("div", k6, [
          f("button", {
            class: _e(["toggle-switches-btn", { active: u.value }]),
            onClick: J[10] || (J[10] = (ue) => u.value = !u.value),
            title: "Toggle Layer Switches"
          }, " Sw ", 2),
          f("span", O6, Q(I(ze(e).currentFrame)), 1)
        ]),
        f("div", {
          class: "scrubber-track",
          onMousedown: G,
          onClick: ne
        }, [
          f("div", {
            class: "scrubber-work-area",
            style: Pt(C.value)
          }, null, 4),
          f("div", {
            class: "scrubber-progress",
            style: Pt({ width: `${S.value}%` })
          }, null, 4)
        ], 32),
        f("div", E6, [
          f("input", {
            type: "number",
            value: ze(e).currentFrame,
            min: 0,
            max: ze(e).frameCount - 1,
            onChange: Se
          }, null, 40, T6),
          f("span", D6, "/ " + Q(ze(e).frameCount - 1), 1)
        ])
      ]),
      w.value ? ($(), A("div", {
        key: 0,
        class: "marker-dialog",
        onClick: J[17] || (J[17] = tt((ue) => w.value = null, ["self"]))
      }, [
        f("div", $6, [
          J[32] || (J[32] = f("h3", null, "Edit Marker", -1)),
          f("div", M6, [
            J[28] || (J[28] = f("label", null, "Label:", -1)),
            ot(f("input", {
              type: "text",
              "onUpdate:modelValue": J[11] || (J[11] = (ue) => w.value.label = ue)
            }, null, 512), [
              [Qt, w.value.label]
            ])
          ]),
          f("div", P6, [
            J[29] || (J[29] = f("label", null, "Frame:", -1)),
            ot(f("input", {
              type: "number",
              "onUpdate:modelValue": J[12] || (J[12] = (ue) => w.value.frame = ue)
            }, null, 512), [
              [
                Qt,
                w.value.frame,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          f("div", I6, [
            J[30] || (J[30] = f("label", null, "Color:", -1)),
            ot(f("input", {
              type: "color",
              "onUpdate:modelValue": J[13] || (J[13] = (ue) => w.value.color = ue)
            }, null, 512), [
              [Qt, w.value.color]
            ])
          ]),
          f("div", L6, [
            J[31] || (J[31] = f("label", null, "Comment:", -1)),
            ot(f("textarea", {
              "onUpdate:modelValue": J[14] || (J[14] = (ue) => w.value.comment = ue),
              rows: "3"
            }, null, 512), [
              [Qt, w.value.comment]
            ])
          ]),
          f("div", A6, [
            f("button", {
              onClick: J[15] || (J[15] = (ue) => D(w.value.id))
            }, "Delete"),
            f("button", {
              onClick: J[16] || (J[16] = (ue) => w.value = null)
            }, "Cancel"),
            f("button", {
              class: "primary",
              onClick: L
            }, "Save")
          ])
        ])
      ])) : ve("", !0)
    ]));
  }
}), j6 = /* @__PURE__ */ cn(F6, [["__scopeId", "data-v-f3b9bc96"]]), R6 = { class: "graph-editor" }, N6 = { class: "graph-header" }, z6 = { class: "mode-toggle" }, B6 = { class: "preset-buttons" }, H6 = ["onClick", "title"], U6 = { class: "toolbar" }, W6 = { class: "graph-content" }, G6 = { class: "property-list" }, X6 = { class: "property-list-header" }, Y6 = ["title"], K6 = ["onClick"], q6 = ["onClick"], Z6 = { class: "property-name" }, J6 = {
  key: 0,
  class: "keyframe-count"
}, Q6 = {
  key: 0,
  class: "dimension-toggles"
}, e8 = ["onClick"], t8 = {
  key: 0,
  class: "no-properties"
}, n8 = { class: "graph-main" }, i8 = ["viewBox"], r8 = ["onMousedown"], o8 = ["x", "y", "fill", "transform"], s8 = {
  key: 1,
  class: "bezier-handles"
}, a8 = {
  key: 0,
  class: "handle out-handle"
}, l8 = ["x1", "y1", "x2", "y2"], u8 = ["cx", "cy", "onMousedown"], c8 = {
  key: 1,
  class: "handle in-handle"
}, d8 = ["x1", "y1", "x2", "y2"], h8 = ["cx", "cy", "onMousedown"], f8 = ["x1", "x2", "y2"], p8 = {
  key: 0,
  class: "keyframe-info-panel"
}, m8 = { class: "info-row" }, g8 = ["value"], v8 = { class: "info-row" }, y8 = ["value"], b8 = { class: "info-row" }, w8 = ["value"], _8 = ["disabled"], x8 = ["disabled"], S8 = ["disabled"], C8 = /* @__PURE__ */ tn({
  __name: "GraphEditor",
  emits: ["close"],
  setup(i, { emit: e }) {
    const n = e, r = Gn(), o = re(null), s = re(null), a = re(null), l = re(null), u = re(null), c = re(null), d = re(400), h = re(200), p = re("value"), m = zo({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    }), v = re([]), y = re([]), w = re({}), g = re([]), k = re(null), _ = re(null), S = re(null), b = re(null), C = re(null), x = re(!1), I = re(!0), F = { top: 10, right: 10, bottom: 10, left: 10 }, B = {
      Position: "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      Scale: "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      Rotation: "#bb8fce",
      Opacity: "#f8b739",
      default: "#7c9cff"
    }, X = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ], j = Ee(() => {
      const H = r.selectedLayer;
      if (!H) return [];
      const U = [];
      return U.push(H.transform.position), U.push(H.transform.scale), U.push(H.transform.rotation), U.push(H.opacity), U.push(...H.properties), U;
    }), ee = Ee(() => j.value.filter(
      (H) => y.value.includes(H.id) && H.animated
    )), ie = Ee(() => j.value.every((H) => y.value.includes(H.id))), M = Ee(() => W(r.currentFrame));
    function W(H) {
      const U = d.value - F.left - F.right, oe = (H - m.frameStart) / (m.frameEnd - m.frameStart);
      return F.left + oe * U;
    }
    function R(H) {
      const U = d.value - F.left - F.right, oe = (H - F.left) / U;
      return m.frameStart + oe * (m.frameEnd - m.frameStart);
    }
    function V(H) {
      const U = h.value - F.top - F.bottom, oe = (H - m.valueMin) / (m.valueMax - m.valueMin);
      return h.value - F.bottom - oe * U;
    }
    function ae(H) {
      const U = h.value - F.top - F.bottom, oe = (h.value - F.bottom - H) / U;
      return m.valueMin + oe * (m.valueMax - m.valueMin);
    }
    function $e(H) {
      return W(H.frame);
    }
    function N(H, U) {
      const oe = typeof U.value == "number" ? U.value : typeof U.value == "object" ? U.value.x ?? U.value : 0;
      return V(oe);
    }
    function me(H) {
      if (!H) return 0;
      const U = H.keyframe.value;
      return typeof U == "number" ? U : typeof U == "object" ? U.x ?? 0 : 0;
    }
    function we(H, U) {
      const oe = H.keyframes[U], Pe = H.keyframes[U + 1];
      if (!oe || !Pe) return 0;
      const he = Pe.frame - oe.frame, Le = oe.frame + oe.outHandle.x * he;
      return W(Le);
    }
    function fe(H, U) {
      const oe = H.keyframes[U], Pe = H.keyframes[U + 1];
      if (!oe || !Pe) return 0;
      const he = Re(Pe.value) - Re(oe.value), Le = Re(oe.value) + oe.outHandle.y * he;
      return V(Le);
    }
    function te(H, U) {
      const oe = H.keyframes[U], Pe = H.keyframes[U - 1];
      if (!oe || !Pe) return 0;
      const he = oe.frame - Pe.frame, Le = oe.frame - oe.inHandle.x * he;
      return W(Le);
    }
    function Me(H, U) {
      const oe = H.keyframes[U], Pe = H.keyframes[U - 1];
      if (!oe || !Pe) return 0;
      const he = Re(oe.value) - Re(Pe.value), Le = Re(oe.value) - oe.inHandle.y * he;
      return V(Le);
    }
    function Re(H) {
      return typeof H == "number" ? H : typeof H == "object" ? H.x ?? H.y ?? H.z ?? 0 : 0;
    }
    function Ce(H) {
      const U = j.value.find((oe) => oe.id === H);
      return U ? B[U.name] ?? B.default : B.default;
    }
    function le(H) {
      return H.frame >= m.frameStart && H.frame <= m.frameEnd;
    }
    function T(H, U) {
      return g.value.some((oe) => oe.propId === H && oe.index === U);
    }
    function E(H, U) {
      if (!H.animated || H.keyframes.length === 0) return !1;
      const oe = H.keyframes[0].value;
      return typeof oe == "object" && U in oe;
    }
    function L(H) {
      const U = v.value.indexOf(H);
      U === -1 ? v.value.push(H) : v.value.splice(U, 1);
    }
    function D(H) {
      const U = y.value.indexOf(H);
      U === -1 ? y.value.push(H) : y.value.splice(U, 1), se();
    }
    function P() {
      ie.value ? y.value = [] : y.value = j.value.map((H) => H.id), se();
    }
    function G(H, U) {
      w.value[H] || (w.value[H] = []);
      const oe = w.value[H], Pe = oe.indexOf(U);
      Pe === -1 ? oe.push(U) : oe.splice(Pe, 1);
    }
    function ne() {
      const H = ee.value;
      if (H.length === 0) return;
      let U = 1 / 0, oe = -1 / 0, Pe = 1 / 0, he = -1 / 0;
      for (const ht of H)
        for (const Qe of ht.keyframes) {
          U = Math.min(U, Qe.frame), oe = Math.max(oe, Qe.frame);
          const Ye = Re(Qe.value);
          Pe = Math.min(Pe, Ye), he = Math.max(he, Ye);
        }
      const Le = (oe - U) * 0.1 || 10, He = (he - Pe) * 0.1 || 10;
      m.frameStart = U - Le, m.frameEnd = oe + Le, m.valueMin = Pe - He, m.valueMax = he + He;
    }
    function se() {
      ne();
    }
    function ge() {
      I.value = !I.value;
    }
    function Se(H) {
      if (g.value.length === 0) return !1;
      const U = zc[H];
      return U ? g.value.every((oe) => {
        const Pe = Math.abs(oe.keyframe.outHandle.x - U.outHandle.x) < 0.01 && Math.abs(oe.keyframe.outHandle.y - U.outHandle.y) < 0.01, he = Math.abs(oe.keyframe.inHandle.x - U.inHandle.x) < 0.01 && Math.abs(oe.keyframe.inHandle.y - U.inHandle.y) < 0.01;
        return Pe && he;
      }) : !1;
    }
    function be(H) {
      const U = zc[H];
      if (U) {
        for (const oe of g.value)
          oe.keyframe.outHandle = { ...U.outHandle }, oe.keyframe.inHandle = { ...U.inHandle }, oe.keyframe.interpolation = H === "linear" ? "linear" : "bezier";
        qt();
      }
    }
    function xe(H) {
      var he;
      const U = (he = o.value) == null ? void 0 : he.getBoundingClientRect();
      if (!U) return;
      const oe = H.clientX - U.left, Pe = H.clientY - U.top;
      H.button === 1 || H.button === 0 && H.altKey ? _.value = { type: "pan", startX: oe, startY: Pe } : H.button === 0 && (H.shiftKey || (g.value = []), S.value = { x: oe, y: Pe, width: 0, height: 0 }, _.value = { type: "select", startX: oe, startY: Pe });
    }
    function q(H) {
      var he;
      const U = (he = o.value) == null ? void 0 : he.getBoundingClientRect();
      if (!U) return;
      const oe = H.clientX - U.left, Pe = H.clientY - U.top;
      if (Ae(oe, Pe), !!_.value)
        if (_.value.type === "pan") {
          const Le = oe - (_.value.startX ?? 0), He = Pe - (_.value.startY ?? 0), ht = d.value - F.left - F.right, Qe = h.value - F.top - F.bottom, Ye = -Le / ht * (m.frameEnd - m.frameStart), Xt = He / Qe * (m.valueMax - m.valueMin);
          m.frameStart += Ye, m.frameEnd += Ye, m.valueMin += Xt, m.valueMax += Xt, _.value.startX = oe, _.value.startY = Pe, qt();
        } else if (_.value.type === "select" && S.value) {
          const Le = _.value.startX ?? 0, He = _.value.startY ?? 0;
          S.value = {
            x: Math.min(oe, Le),
            y: Math.min(Pe, He),
            width: Math.abs(oe - Le),
            height: Math.abs(Pe - He)
          };
        } else _.value.type === "keyframe" ? ft(oe, Pe) : (_.value.type === "outHandle" || _.value.type === "inHandle") && Gt(oe, Pe);
    }
    function J() {
      var H;
      ((H = _.value) == null ? void 0 : H.type) === "select" && S.value && Ge(), _.value = null, S.value = null;
    }
    function ue(H) {
      var ht;
      H.preventDefault();
      const U = (ht = o.value) == null ? void 0 : ht.getBoundingClientRect();
      if (!U) return;
      const oe = H.clientX - U.left, Pe = H.deltaY > 0 ? 1.1 : 0.9, he = R(oe), Le = he - (he - m.frameStart) * Pe, He = he + (m.frameEnd - he) * Pe;
      if (H.shiftKey)
        m.frameStart = Le, m.frameEnd = He;
      else {
        m.frameStart = Le, m.frameEnd = He;
        const Qe = H.clientY - U.top, Ye = ae(Qe);
        m.valueMin = Ye - (Ye - m.valueMin) * Pe, m.valueMax = Ye + (m.valueMax - Ye) * Pe;
      }
      qt();
    }
    function Ae(H, U) {
      k.value = null;
      for (const oe of ee.value)
        for (let Pe = 0; Pe < oe.keyframes.length; Pe++) {
          const he = oe.keyframes[Pe], Le = $e(he), He = N(oe, he);
          if (Math.sqrt((H - Le) ** 2 + (U - He) ** 2) < 10) {
            k.value = { propId: oe.id, index: Pe };
            return;
          }
        }
    }
    function je(H, U, oe) {
      const Pe = j.value.find((Le) => Le.id === H);
      if (!Pe) return;
      const he = Pe.keyframes[U];
      oe.shiftKey || (g.value = []), T(H, U) || g.value.push({ propId: H, index: U, keyframe: he }), _.value = { type: "keyframe", propId: H, index: U };
    }
    function Ge() {
      if (!S.value) return;
      const H = S.value;
      for (const U of ee.value)
        for (let oe = 0; oe < U.keyframes.length; oe++) {
          const Pe = U.keyframes[oe], he = $e(Pe), Le = N(U, Pe);
          he >= H.x && he <= H.x + H.width && Le >= H.y && Le <= H.y + H.height && (T(U.id, oe) || g.value.push({ propId: U.id, index: oe, keyframe: Pe }));
        }
    }
    function ft(H, U) {
      const oe = Math.round(R(H)), Pe = ae(U);
      if (g.value.length > 0) {
        const he = g.value[0];
        he.keyframe.frame = x.value ? Math.round(oe / 5) * 5 : oe, typeof he.keyframe.value == "number" && (he.keyframe.value = Pe);
      }
      qt();
    }
    function at(H, U, oe, Pe) {
      _.value = { type: H, propId: U, index: oe }, document.addEventListener("mousemove", nn), document.addEventListener("mouseup", wn);
    }
    function nn(H) {
      var he;
      const U = (he = o.value) == null ? void 0 : he.getBoundingClientRect();
      if (!U || !_.value) return;
      const oe = H.clientX - U.left, Pe = H.clientY - U.top;
      Gt(oe, Pe);
    }
    function Gt(H, U) {
      if (!_.value || !_.value.propId) return;
      const oe = j.value.find((Le) => Le.id === _.value.propId);
      if (!oe) return;
      const Pe = _.value.index, he = oe.keyframes[Pe];
      if (he) {
        if (_.value.type === "outHandle") {
          const Le = oe.keyframes[Pe + 1];
          if (!Le) return;
          const He = Le.frame - he.frame, ht = Re(Le.value) - Re(he.value), Qe = R(H), Ye = ae(U);
          he.outHandle = {
            x: Math.max(0, Math.min(1, (Qe - he.frame) / He)),
            y: ht !== 0 ? (Ye - Re(he.value)) / ht : 0
          }, he.interpolation = "bezier";
        } else if (_.value.type === "inHandle") {
          const Le = oe.keyframes[Pe - 1];
          if (!Le) return;
          const He = he.frame - Le.frame, ht = Re(he.value) - Re(Le.value), Qe = R(H), Ye = ae(U);
          he.inHandle = {
            x: Math.max(0, Math.min(1, (he.frame - Qe) / He)),
            y: ht !== 0 ? (Re(he.value) - Ye) / ht : 0
          };
        }
        qt();
      }
    }
    function wn() {
      _.value = null, document.removeEventListener("mousemove", nn), document.removeEventListener("mouseup", wn);
    }
    function _n(H) {
      b.value = { x: H.offsetX, y: H.offsetY };
    }
    function kn() {
      if (!b.value) return;
      const H = Math.round(R(b.value.x)), U = ae(b.value.y);
      if (ee.value.length > 0) {
        const oe = ee.value[0], Pe = {
          id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          frame: H,
          value: typeof oe.value == "number" ? U : { x: U, y: U },
          interpolation: "bezier",
          inHandle: { x: 0.33, y: 0 },
          outHandle: { x: 0.33, y: 0 },
          handlesBroken: !1
        }, he = oe.keyframes.findIndex((Le) => Le.frame > H);
        he === -1 ? oe.keyframes.push(Pe) : oe.keyframes.splice(he, 0, Pe), oe.animated = !0, qt();
      }
      b.value = null;
    }
    function rn() {
      for (const H of g.value) {
        const U = j.value.find((oe) => oe.id === H.propId);
        if (U) {
          const oe = U.keyframes.indexOf(H.keyframe);
          oe !== -1 && U.keyframes.splice(oe, 1), U.keyframes.length === 0 && (U.animated = !1);
        }
      }
      g.value = [], qt();
    }
    function It() {
      C.value = g.value.map((H) => ({ ...H.keyframe }));
    }
    function mn() {
      if (!C.value || ee.value.length === 0) return;
      const H = ee.value[0], U = r.currentFrame - C.value[0].frame;
      for (const oe of C.value) {
        const Pe = {
          ...oe,
          frame: oe.frame + U
        }, he = H.keyframes.findIndex((Le) => Le.frame > Pe.frame);
        he === -1 ? H.keyframes.push(Pe) : H.keyframes.splice(he, 0, Pe);
      }
      H.animated = !0, qt();
    }
    function Vn() {
      g.value = [];
      for (const H of ee.value)
        for (let U = 0; U < H.keyframes.length; U++)
          g.value.push({ propId: H.id, index: U, keyframe: H.keyframes[U] });
    }
    function Or() {
      const H = [];
      for (const U of ee.value)
        for (let oe = 0; oe < U.keyframes.length; oe++)
          T(U.id, oe) || H.push({ propId: U.id, index: oe, keyframe: U.keyframes[oe] });
      g.value = H;
    }
    function co(H) {
      const U = parseInt(H.target.value);
      g.value.length > 0 && !isNaN(U) && (g.value[0].keyframe.frame = U, qt());
    }
    function tr(H) {
      const U = parseFloat(H.target.value);
      if (g.value.length > 0 && !isNaN(U)) {
        const oe = g.value[0].keyframe;
        typeof oe.value == "number" ? oe.value = U : typeof oe.value == "object" && (oe.value.x = U), qt();
      }
    }
    function ho(H) {
      const U = H.target.value;
      g.value.length > 0 && (g.value[0].keyframe.interpolation = U, qt());
    }
    function Er(H) {
      var he;
      const U = (he = l.value) == null ? void 0 : he.getBoundingClientRect();
      if (!U) return;
      const oe = H.clientX - U.left, Pe = Math.round(R(oe));
      r.setFrame(Pe);
    }
    function qt() {
      Ma(), nr(), Dr();
    }
    function Ma() {
      const H = o.value;
      if (!H) return;
      const U = H.getContext("2d");
      if (U) {
        H.width = d.value, H.height = h.value, U.fillStyle = "#1a1a1a", U.fillRect(0, 0, d.value, h.value), As(U);
        for (const oe of ee.value)
          fo(U, oe);
      }
    }
    function As(H) {
      const U = d.value - F.left - F.right, oe = h.value - F.top - F.bottom;
      H.strokeStyle = "#2a2a2a", H.lineWidth = 1;
      const Pe = m.frameEnd - m.frameStart, he = Tr(Pe, U, 50), Le = m.valueMax - m.valueMin, He = Tr(Le, oe, 30), ht = Math.ceil(m.frameStart / he) * he;
      for (let Ye = ht; Ye <= m.frameEnd; Ye += he) {
        const Xt = W(Ye);
        H.beginPath(), H.moveTo(Xt, F.top), H.lineTo(Xt, h.value - F.bottom), H.stroke();
      }
      const Qe = Math.ceil(m.valueMin / He) * He;
      for (let Ye = Qe; Ye <= m.valueMax; Ye += He) {
        const Xt = V(Ye);
        H.beginPath(), H.moveTo(F.left, Xt), H.lineTo(d.value - F.right, Xt), H.stroke();
      }
      if (H.strokeStyle = "#3a3a3a", H.lineWidth = 1, m.frameStart <= 0 && m.frameEnd >= 0) {
        const Ye = W(0);
        H.beginPath(), H.moveTo(Ye, F.top), H.lineTo(Ye, h.value - F.bottom), H.stroke();
      }
      if (m.valueMin <= 0 && m.valueMax >= 0) {
        const Ye = V(0);
        H.beginPath(), H.moveTo(F.left, Ye), H.lineTo(d.value - F.right, Ye), H.stroke();
      }
    }
    function Tr(H, U, oe) {
      const Pe = H * oe / U, he = Math.pow(10, Math.floor(Math.log10(Pe))), Le = Pe / he;
      return Le <= 1 ? he : Le <= 2 ? 2 * he : Le <= 5 ? 5 * he : 10 * he;
    }
    function fo(H, U) {
      if (U.keyframes.length < 2) return;
      const oe = Ce(U.id);
      H.strokeStyle = oe, H.lineWidth = 2, H.beginPath();
      let Pe = !1;
      for (let he = 0; he < U.keyframes.length - 1; he++) {
        const Le = U.keyframes[he], He = U.keyframes[he + 1];
        if (He.frame < m.frameStart || Le.frame > m.frameEnd) continue;
        const ht = $e(Le), Qe = N(U, Le), Ye = $e(He), Xt = N(U, He);
        if (Pe || (H.moveTo(ht, Qe), Pe = !0), Le.interpolation === "hold")
          H.lineTo(Ye, Qe), H.lineTo(Ye, Xt);
        else if (Le.interpolation === "linear")
          H.lineTo(Ye, Xt);
        else {
          const po = ht + (Ye - ht) * Le.outHandle.x, Z = Qe + (Xt - Qe) * Le.outHandle.y, pe = Ye - (Ye - ht) * He.inHandle.x, Te = Xt - (Xt - Qe) * He.inHandle.y;
          H.bezierCurveTo(po, Z, pe, Te, Ye, Xt);
        }
      }
      H.stroke();
    }
    function nr() {
      var ht;
      const H = l.value;
      if (!H) return;
      const U = (ht = a.value) == null ? void 0 : ht.getBoundingClientRect();
      if (!U) return;
      H.width = U.width, H.height = 24;
      const oe = H.getContext("2d");
      if (!oe) return;
      oe.fillStyle = "#252525", oe.fillRect(0, 0, H.width, H.height);
      const Pe = m.frameEnd - m.frameStart, he = Tr(Pe, H.width, 60);
      oe.fillStyle = "#888", oe.font = "10px system-ui", oe.textAlign = "center";
      const Le = Math.ceil(m.frameStart / he) * he;
      for (let Qe = Le; Qe <= m.frameEnd; Qe += he) {
        const Ye = W(Qe);
        oe.fillText(Qe.toString(), Ye, 16), oe.strokeStyle = "#444", oe.beginPath(), oe.moveTo(Ye, 20), oe.lineTo(Ye, 24), oe.stroke();
      }
      const He = W(r.currentFrame);
      oe.fillStyle = "#ff4444", oe.beginPath(), oe.moveTo(He - 5, 0), oe.lineTo(He + 5, 0), oe.lineTo(He, 8), oe.closePath(), oe.fill();
    }
    function Dr() {
      var He;
      const H = c.value;
      if (!H) return;
      const U = (He = u.value) == null ? void 0 : He.getBoundingClientRect();
      if (!U) return;
      H.width = 40, H.height = U.height;
      const oe = H.getContext("2d");
      if (!oe) return;
      oe.fillStyle = "#252525", oe.fillRect(0, 0, H.width, H.height);
      const Pe = m.valueMax - m.valueMin, he = Tr(Pe, H.height, 30);
      oe.fillStyle = "#888", oe.font = "10px system-ui", oe.textAlign = "right";
      const Le = Math.ceil(m.valueMin / he) * he;
      for (let ht = Le; ht <= m.valueMax; ht += he) {
        const Qe = V(ht);
        oe.fillText(ht.toFixed(0), 36, Qe + 4);
      }
    }
    let xn = null;
    return Wn(() => {
      s.value && (xn = new ResizeObserver((H) => {
        for (const U of H)
          d.value = U.contentRect.width, h.value = U.contentRect.height, qt();
      }), xn.observe(s.value)), y.value = j.value.filter((H) => H.animated).map((H) => H.id), ne(), qt();
    }), Qi(() => {
      xn == null || xn.disconnect();
    }), Lt([() => r.currentFrame, y, p], () => {
      qt();
    }), Lt(j, () => {
      ne(), qt();
    }, { deep: !0 }), (H, U) => {
      var oe, Pe;
      return $(), A("div", R6, [
        f("div", N6, [
          U[9] || (U[9] = f("span", { class: "graph-title" }, "Graph Editor", -1)),
          f("div", z6, [
            f("button", {
              class: _e({ active: p.value === "value" }),
              onClick: U[0] || (U[0] = (he) => p.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            f("button", {
              class: _e({ active: p.value === "speed" }),
              onClick: U[1] || (U[1] = (he) => p.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          f("div", B6, [
            ($(), A(Fe, null, Ke(X, (he) => f("button", {
              key: he.key,
              class: _e(["preset-btn", { active: Se(he.key) }]),
              onClick: (Le) => be(he.key),
              title: he.label
            }, Q(he.shortLabel), 11, H6)), 64))
          ]),
          f("div", U6, [
            f("button", {
              onClick: ne,
              title: "Fit to View"
            }, [...U[5] || (U[5] = [
              f("span", { class: "icon" }, "[ ]", -1)
            ])]),
            f("button", {
              onClick: ge,
              class: _e({ active: I.value }),
              title: "Auto-select Nearby Keyframes"
            }, [...U[6] || (U[6] = [
              f("span", { class: "icon" }, "A", -1)
            ])], 2),
            f("button", {
              onClick: U[2] || (U[2] = (he) => x.value = !x.value),
              class: _e({ active: x.value }),
              title: "Snap to Grid"
            }, [...U[7] || (U[7] = [
              f("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          f("button", {
            class: "close-btn",
            onClick: U[3] || (U[3] = (he) => n("close"))
          }, [...U[8] || (U[8] = [
            f("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        f("div", W6, [
          f("div", G6, [
            f("div", X6, [
              U[10] || (U[10] = vt(" Properties ", -1)),
              f("button", {
                class: "toggle-all-btn",
                onClick: P,
                title: ie.value ? "Hide All" : "Show All"
              }, Q(ie.value ? "Hide" : "Show"), 9, Y6)
            ]),
            ($(!0), A(Fe, null, Ke(j.value, (he) => ($(), A("div", {
              key: he.id,
              class: _e(["property-item", {
                selected: v.value.includes(he.id),
                animated: he.animated
              }])
            }, [
              f("div", {
                class: "property-row",
                onClick: (Le) => L(he.id)
              }, [
                f("span", {
                  class: _e(["visibility-toggle", { visible: y.value.includes(he.id) }]),
                  onClick: tt((Le) => D(he.id), ["stop"])
                }, null, 10, q6),
                f("span", {
                  class: "property-color",
                  style: Pt({ background: Ce(he.id) })
                }, null, 4),
                f("span", Z6, Q(he.name), 1),
                he.animated ? ($(), A("span", J6, Q(he.keyframes.length), 1)) : ve("", !0)
              ], 8, K6),
              he.name === "Position" || he.name === "Scale" ? ($(), A("div", Q6, [
                ($(), A(Fe, null, Ke(["x", "y", "z"], (Le) => {
                  var He;
                  return f("button", {
                    key: Le,
                    class: _e({
                      active: (He = w.value[he.id]) == null ? void 0 : He.includes(Le),
                      hasValue: E(he, Le)
                    }),
                    onClick: (ht) => G(he.id, Le)
                  }, Q(Le.toUpperCase()), 11, e8);
                }), 64))
              ])) : ve("", !0)
            ], 2))), 128)),
            j.value.length === 0 ? ($(), A("div", t8, " No animated properties ")) : ve("", !0)
          ]),
          f("div", n8, [
            f("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: a
            }, [
              f("canvas", {
                ref_key: "timeRulerCanvas",
                ref: l,
                onClick: Er
              }, null, 512)
            ], 512),
            f("div", {
              class: "graph-canvas-container",
              ref_key: "canvasContainerRef",
              ref: s
            }, [
              f("canvas", {
                ref_key: "canvasRef",
                ref: o,
                onMousedown: xe,
                onMousemove: q,
                onMouseup: J,
                onMouseleave: J,
                onWheel: ue,
                onContextmenu: tt(_n, ["prevent"])
              }, null, 544),
              S.value ? ($(), A("div", {
                key: 0,
                class: "selection-box",
                style: Pt({
                  left: S.value.x + "px",
                  top: S.value.y + "px",
                  width: S.value.width + "px",
                  height: S.value.height + "px"
                })
              }, null, 4)) : ve("", !0),
              ($(), A("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${d.value} ${h.value}`
              }, [
                ($(!0), A(Fe, null, Ke(ee.value, (he) => ($(), A("g", {
                  key: he.id,
                  class: "property-handles"
                }, [
                  ($(!0), A(Fe, null, Ke(he.keyframes, (Le, He) => {
                    var ht, Qe, Ye, Xt, po, Z, pe, Te;
                    return $(), A(Fe, { key: He }, [
                      le(Le) ? ($(), A("g", {
                        key: 0,
                        class: _e(["keyframe-marker", {
                          selected: T(he.id, He),
                          hovered: ((ht = k.value) == null ? void 0 : ht.propId) === he.id && ((Qe = k.value) == null ? void 0 : Qe.index) === He
                        }]),
                        onMousedown: tt((Be) => je(he.id, He, Be), ["stop"])
                      }, [
                        f("rect", {
                          x: $e(Le) - 5,
                          y: N(he, Le) - 5,
                          width: "10",
                          height: "10",
                          fill: Ce(he.id),
                          "transform-origin": "center",
                          transform: `rotate(45, ${$e(Le)}, ${N(he, Le)})`
                        }, null, 8, o8)
                      ], 42, r8)) : ve("", !0),
                      T(he.id, He) && Le.interpolation === "bezier" ? ($(), A("g", s8, [
                        he.keyframes[He + 1] ? ($(), A("g", a8, [
                          f("line", {
                            x1: $e(Le),
                            y1: N(he, Le),
                            x2: we(he, He),
                            y2: fe(he, He),
                            class: "handle-line"
                          }, null, 8, l8),
                          f("circle", {
                            cx: we(he, He),
                            cy: fe(he, He),
                            r: "5",
                            class: _e(["handle-point", { dragging: ((Ye = _.value) == null ? void 0 : Ye.type) === "outHandle" && ((Xt = _.value) == null ? void 0 : Xt.propId) === he.id && ((po = _.value) == null ? void 0 : po.index) === He }]),
                            onMousedown: tt((Be) => at("outHandle", he.id, He), ["stop"])
                          }, null, 42, u8)
                        ])) : ve("", !0),
                        He > 0 ? ($(), A("g", c8, [
                          f("line", {
                            x1: $e(Le),
                            y1: N(he, Le),
                            x2: te(he, He),
                            y2: Me(he, He),
                            class: "handle-line"
                          }, null, 8, d8),
                          f("circle", {
                            cx: te(he, He),
                            cy: Me(he, He),
                            r: "5",
                            class: _e(["handle-point", { dragging: ((Z = _.value) == null ? void 0 : Z.type) === "inHandle" && ((pe = _.value) == null ? void 0 : pe.propId) === he.id && ((Te = _.value) == null ? void 0 : Te.index) === He }]),
                            onMousedown: tt((Be) => at("inHandle", he.id, He), ["stop"])
                          }, null, 42, h8)
                        ])) : ve("", !0)
                      ])) : ve("", !0)
                    ], 64);
                  }), 128))
                ]))), 128)),
                f("line", {
                  x1: M.value,
                  y1: 0,
                  x2: M.value,
                  y2: h.value,
                  class: "current-time-line"
                }, null, 8, f8)
              ], 8, i8))
            ], 512),
            f("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: u
            }, [
              f("canvas", {
                ref_key: "valueAxisCanvas",
                ref: c
              }, null, 512)
            ], 512)
          ])
        ]),
        g.value.length > 0 ? ($(), A("div", p8, [
          f("div", m8, [
            U[11] || (U[11] = f("span", { class: "info-label" }, "Frame:", -1)),
            f("input", {
              type: "number",
              value: (oe = g.value[0]) == null ? void 0 : oe.keyframe.frame,
              onChange: co,
              class: "info-input"
            }, null, 40, g8)
          ]),
          f("div", v8, [
            U[12] || (U[12] = f("span", { class: "info-label" }, "Value:", -1)),
            f("input", {
              type: "number",
              value: me(g.value[0]),
              onChange: tr,
              class: "info-input",
              step: "0.1"
            }, null, 40, y8)
          ]),
          f("div", b8, [
            U[14] || (U[14] = f("span", { class: "info-label" }, "Interpolation:", -1)),
            f("select", {
              value: (Pe = g.value[0]) == null ? void 0 : Pe.keyframe.interpolation,
              onChange: ho,
              class: "info-select"
            }, [...U[13] || (U[13] = [
              f("option", { value: "linear" }, "Linear", -1),
              f("option", { value: "bezier" }, "Bezier", -1),
              f("option", { value: "hold" }, "Hold", -1)
            ])], 40, w8)
          ])
        ])) : ve("", !0),
        b.value ? ($(), A("div", {
          key: 1,
          class: "context-menu",
          style: Pt({ left: b.value.x + "px", top: b.value.y + "px" }),
          onClick: U[4] || (U[4] = (he) => b.value = null)
        }, [
          f("button", { onClick: kn }, "Add Keyframe"),
          f("button", {
            onClick: rn,
            disabled: g.value.length === 0
          }, "Delete Keyframe(s)", 8, _8),
          U[15] || (U[15] = f("hr", null, null, -1)),
          f("button", {
            onClick: It,
            disabled: g.value.length === 0
          }, "Copy", 8, x8),
          f("button", {
            onClick: mn,
            disabled: !C.value
          }, "Paste", 8, S8),
          U[16] || (U[16] = f("hr", null, null, -1)),
          f("button", { onClick: Vn }, "Select All"),
          f("button", { onClick: Or }, "Invert Selection")
        ], 4)) : ve("", !0)
      ]);
    };
  }
}), k8 = /* @__PURE__ */ cn(C8, [["__scopeId", "data-v-300cb1cd"]]), { abs: za, cos: Vr, sin: Ys, acos: O8, atan2: Ba, sqrt: xo, pow: yi } = Math;
function Ha(i) {
  return i < 0 ? -yi(-i, 1 / 3) : yi(i, 1 / 3);
}
const C1 = Math.PI, ic = 2 * C1, So = C1 / 2, E8 = 1e-6, yh = Number.MAX_SAFE_INTEGER || 9007199254740991, bh = Number.MIN_SAFE_INTEGER || -9007199254740991, T8 = { x: 0, y: 0, z: 0 }, De = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(i, e) {
    const n = e(i);
    let r = n.x * n.x + n.y * n.y;
    return typeof n.z < "u" && (r += n.z * n.z), xo(r);
  },
  compute: function(i, e, n) {
    if (i === 0)
      return e[0].t = 0, e[0];
    const r = e.length - 1;
    if (i === 1)
      return e[r].t = 1, e[r];
    const o = 1 - i;
    let s = e;
    if (r === 0)
      return e[0].t = i, e[0];
    if (r === 1) {
      const l = {
        x: o * s[0].x + i * s[1].x,
        y: o * s[0].y + i * s[1].y,
        t: i
      };
      return n && (l.z = o * s[0].z + i * s[1].z), l;
    }
    if (r < 4) {
      let l = o * o, u = i * i, c, d, h, p = 0;
      r === 2 ? (s = [s[0], s[1], s[2], T8], c = l, d = o * i * 2, h = u) : r === 3 && (c = l * o, d = l * i * 3, h = o * u * 3, p = i * u);
      const m = {
        x: c * s[0].x + d * s[1].x + h * s[2].x + p * s[3].x,
        y: c * s[0].y + d * s[1].y + h * s[2].y + p * s[3].y,
        t: i
      };
      return n && (m.z = c * s[0].z + d * s[1].z + h * s[2].z + p * s[3].z), m;
    }
    const a = JSON.parse(JSON.stringify(e));
    for (; a.length > 1; ) {
      for (let l = 0; l < a.length - 1; l++)
        a[l] = {
          x: a[l].x + (a[l + 1].x - a[l].x) * i,
          y: a[l].y + (a[l + 1].y - a[l].y) * i
        }, typeof a[l].z < "u" && (a[l].z = a[l].z + (a[l + 1].z - a[l].z) * i);
      a.splice(a.length - 1, 1);
    }
    return a[0].t = i, a[0];
  },
  computeWithRatios: function(i, e, n, r) {
    const o = 1 - i, s = n, a = e;
    let l = s[0], u = s[1], c = s[2], d = s[3], h;
    if (l *= o, u *= i, a.length === 2)
      return h = l + u, {
        x: (l * a[0].x + u * a[1].x) / h,
        y: (l * a[0].y + u * a[1].y) / h,
        z: r ? (l * a[0].z + u * a[1].z) / h : !1,
        t: i
      };
    if (l *= o, u *= 2 * o, c *= i * i, a.length === 3)
      return h = l + u + c, {
        x: (l * a[0].x + u * a[1].x + c * a[2].x) / h,
        y: (l * a[0].y + u * a[1].y + c * a[2].y) / h,
        z: r ? (l * a[0].z + u * a[1].z + c * a[2].z) / h : !1,
        t: i
      };
    if (l *= o, u *= 1.5 * o, c *= 3 * o, d *= i * i * i, a.length === 4)
      return h = l + u + c + d, {
        x: (l * a[0].x + u * a[1].x + c * a[2].x + d * a[3].x) / h,
        y: (l * a[0].y + u * a[1].y + c * a[2].y + d * a[3].y) / h,
        z: r ? (l * a[0].z + u * a[1].z + c * a[2].z + d * a[3].z) / h : !1,
        t: i
      };
  },
  derive: function(i, e) {
    const n = [];
    for (let r = i, o = r.length, s = o - 1; o > 1; o--, s--) {
      const a = [];
      for (let l = 0, u; l < s; l++)
        u = {
          x: s * (r[l + 1].x - r[l].x),
          y: s * (r[l + 1].y - r[l].y)
        }, e && (u.z = s * (r[l + 1].z - r[l].z)), a.push(u);
      n.push(a), r = a;
    }
    return n;
  },
  between: function(i, e, n) {
    return e <= i && i <= n || De.approximately(i, e) || De.approximately(i, n);
  },
  approximately: function(i, e, n) {
    return za(i - e) <= (n || E8);
  },
  length: function(i) {
    const n = De.Tvalues.length;
    let r = 0;
    for (let o = 0, s; o < n; o++)
      s = 0.5 * De.Tvalues[o] + 0.5, r += De.Cvalues[o] * De.arcfn(s, i);
    return 0.5 * r;
  },
  map: function(i, e, n, r, o) {
    const s = n - e, a = o - r, l = i - e, u = l / s;
    return r + a * u;
  },
  lerp: function(i, e, n) {
    const r = {
      x: e.x + i * (n.x - e.x),
      y: e.y + i * (n.y - e.y)
    };
    return e.z !== void 0 && n.z !== void 0 && (r.z = e.z + i * (n.z - e.z)), r;
  },
  pointToString: function(i) {
    let e = i.x + "/" + i.y;
    return typeof i.z < "u" && (e += "/" + i.z), e;
  },
  pointsToString: function(i) {
    return "[" + i.map(De.pointToString).join(", ") + "]";
  },
  copy: function(i) {
    return JSON.parse(JSON.stringify(i));
  },
  angle: function(i, e, n) {
    const r = e.x - i.x, o = e.y - i.y, s = n.x - i.x, a = n.y - i.y, l = r * a - o * s, u = r * s + o * a;
    return Ba(l, u);
  },
  // round as string, to avoid rounding errors
  round: function(i, e) {
    const n = "" + i, r = n.indexOf(".");
    return parseFloat(n.substring(0, r + 1 + e));
  },
  dist: function(i, e) {
    const n = i.x - e.x, r = i.y - e.y;
    return xo(n * n + r * r);
  },
  closest: function(i, e) {
    let n = yi(2, 63), r, o;
    return i.forEach(function(s, a) {
      o = De.dist(e, s), o < n && (n = o, r = a);
    }), { mdist: n, mpos: r };
  },
  abcratio: function(i, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof i > "u")
      i = 0.5;
    else if (i === 0 || i === 1)
      return i;
    const n = yi(i, e) + yi(1 - i, e), r = n - 1;
    return za(r / n);
  },
  projectionratio: function(i, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof i > "u")
      i = 0.5;
    else if (i === 0 || i === 1)
      return i;
    const n = yi(1 - i, e), r = yi(i, e) + n;
    return n / r;
  },
  lli8: function(i, e, n, r, o, s, a, l) {
    const u = (i * r - e * n) * (o - a) - (i - n) * (o * l - s * a), c = (i * r - e * n) * (s - l) - (e - r) * (o * l - s * a), d = (i - n) * (s - l) - (e - r) * (o - a);
    return d == 0 ? !1 : { x: u / d, y: c / d };
  },
  lli4: function(i, e, n, r) {
    const o = i.x, s = i.y, a = e.x, l = e.y, u = n.x, c = n.y, d = r.x, h = r.y;
    return De.lli8(o, s, a, l, u, c, d, h);
  },
  lli: function(i, e) {
    return De.lli4(i, i.c, e, e.c);
  },
  makeline: function(i, e) {
    return new k1(
      i.x,
      i.y,
      (i.x + e.x) / 2,
      (i.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(i) {
    let e = yh, n = yh, r = bh, o = bh;
    return i.forEach(function(s) {
      const a = s.bbox();
      e > a.x.min && (e = a.x.min), n > a.y.min && (n = a.y.min), r < a.x.max && (r = a.x.max), o < a.y.max && (o = a.y.max);
    }), {
      x: { min: e, mid: (e + r) / 2, max: r, size: r - e },
      y: { min: n, mid: (n + o) / 2, max: o, size: o - n }
    };
  },
  shapeintersections: function(i, e, n, r, o) {
    if (!De.bboxoverlap(e, r)) return [];
    const s = [], a = [i.startcap, i.forward, i.back, i.endcap], l = [n.startcap, n.forward, n.back, n.endcap];
    return a.forEach(function(u) {
      u.virtual || l.forEach(function(c) {
        if (c.virtual) return;
        const d = u.intersects(c, o);
        d.length > 0 && (d.c1 = u, d.c2 = c, d.s1 = i, d.s2 = n, s.push(d));
      });
    }), s;
  },
  makeshape: function(i, e, n) {
    const r = e.points.length, o = i.points.length, s = De.makeline(e.points[r - 1], i.points[0]), a = De.makeline(i.points[o - 1], e.points[0]), l = {
      startcap: s,
      forward: i,
      back: e,
      endcap: a,
      bbox: De.findbbox([s, i, e, a])
    };
    return l.intersections = function(u) {
      return De.shapeintersections(
        l,
        l.bbox,
        u,
        u.bbox,
        n
      );
    }, l;
  },
  getminmax: function(i, e, n) {
    if (!n) return { min: 0, max: 0 };
    let r = yh, o = bh, s, a;
    n.indexOf(0) === -1 && (n = [0].concat(n)), n.indexOf(1) === -1 && n.push(1);
    for (let l = 0, u = n.length; l < u; l++)
      s = n[l], a = i.get(s), a[e] < r && (r = a[e]), a[e] > o && (o = a[e]);
    return { min: r, mid: (r + o) / 2, max: o, size: o - r };
  },
  align: function(i, e) {
    const n = e.p1.x, r = e.p1.y, o = -Ba(e.p2.y - r, e.p2.x - n), s = function(a) {
      return {
        x: (a.x - n) * Vr(o) - (a.y - r) * Ys(o),
        y: (a.x - n) * Ys(o) + (a.y - r) * Vr(o)
      };
    };
    return i.map(s);
  },
  roots: function(i, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const n = i.length - 1, r = De.align(i, e), o = function(x) {
      return 0 <= x && x <= 1;
    };
    if (n === 2) {
      const x = r[0].y, I = r[1].y, F = r[2].y, B = x - 2 * I + F;
      if (B !== 0) {
        const X = -xo(I * I - x * F), j = -x + I, ee = -(X + j) / B, ie = -(-X + j) / B;
        return [ee, ie].filter(o);
      } else if (I !== F && B === 0)
        return [(2 * I - F) / (2 * I - 2 * F)].filter(o);
      return [];
    }
    const s = r[0].y, a = r[1].y, l = r[2].y, u = r[3].y;
    let c = -s + 3 * a - 3 * l + u, d = 3 * s - 6 * a + 3 * l, h = -3 * s + 3 * a, p = s;
    if (De.approximately(c, 0)) {
      if (De.approximately(d, 0))
        return De.approximately(h, 0) ? [] : [-p / h].filter(o);
      const x = xo(h * h - 4 * d * p), I = 2 * d;
      return [(x - h) / I, (-h - x) / I].filter(o);
    }
    d /= c, h /= c, p /= c;
    const m = (3 * h - d * d) / 3, v = m / 3, y = (2 * d * d * d - 9 * d * h + 27 * p) / 27, w = y / 2, g = w * w + v * v * v;
    let k, _, S, b, C;
    if (g < 0) {
      const x = -m / 3, I = x * x * x, F = xo(I), B = -y / (2 * F), X = B < -1 ? -1 : B > 1 ? 1 : B, j = O8(X), ee = Ha(F), ie = 2 * ee;
      return S = ie * Vr(j / 3) - d / 3, b = ie * Vr((j + ic) / 3) - d / 3, C = ie * Vr((j + 2 * ic) / 3) - d / 3, [S, b, C].filter(o);
    } else {
      if (g === 0)
        return k = w < 0 ? Ha(-w) : -Ha(w), S = 2 * k - d / 3, b = -k - d / 3, [S, b].filter(o);
      {
        const x = xo(g);
        return k = Ha(-w + x), _ = Ha(w + x), [k - _ - d / 3].filter(o);
      }
    }
  },
  droots: function(i) {
    if (i.length === 3) {
      const e = i[0], n = i[1], r = i[2], o = e - 2 * n + r;
      if (o !== 0) {
        const s = -xo(n * n - e * r), a = -e + n, l = -(s + a) / o, u = -(-s + a) / o;
        return [l, u];
      } else if (n !== r && o === 0)
        return [(2 * n - r) / (2 * (n - r))];
      return [];
    }
    if (i.length === 2) {
      const e = i[0], n = i[1];
      return e !== n ? [e / (e - n)] : [];
    }
    return [];
  },
  curvature: function(i, e, n, r, o) {
    let s, a, l, u, c = 0, d = 0;
    const h = De.compute(i, e), p = De.compute(i, n), m = h.x * h.x + h.y * h.y;
    if (r ? (s = xo(
      yi(h.y * p.z - p.y * h.z, 2) + yi(h.z * p.x - p.z * h.x, 2) + yi(h.x * p.y - p.x * h.y, 2)
    ), a = yi(m + h.z * h.z, 3 / 2)) : (s = h.x * p.y - h.y * p.x, a = yi(m, 3 / 2)), s === 0 || a === 0)
      return { k: 0, r: 0 };
    if (c = s / a, d = a / s, !o) {
      const v = De.curvature(i - 1e-3, e, n, r, !0).k, y = De.curvature(i + 1e-3, e, n, r, !0).k;
      u = (y - c + (c - v)) / 2, l = (za(y - c) + za(c - v)) / 2;
    }
    return { k: c, r: d, dk: u, adk: l };
  },
  inflections: function(i) {
    if (i.length < 4) return [];
    const e = De.align(i, { p1: i[0], p2: i.slice(-1)[0] }), n = e[2].x * e[1].y, r = e[3].x * e[1].y, o = e[1].x * e[2].y, s = e[3].x * e[2].y, a = 18 * (-3 * n + 2 * r + 3 * o - s), l = 18 * (3 * n - r - 3 * o), u = 18 * (o - n);
    if (De.approximately(a, 0)) {
      if (!De.approximately(l, 0)) {
        let p = -u / l;
        if (0 <= p && p <= 1) return [p];
      }
      return [];
    }
    const c = 2 * a;
    if (De.approximately(c, 0)) return [];
    const d = l * l - 4 * a * u;
    if (d < 0) return [];
    const h = Math.sqrt(d);
    return [(h - l) / c, -(l + h) / c].filter(function(p) {
      return 0 <= p && p <= 1;
    });
  },
  bboxoverlap: function(i, e) {
    const n = ["x", "y"], r = n.length;
    for (let o = 0, s, a, l, u; o < r; o++)
      if (s = n[o], a = i[s].mid, l = e[s].mid, u = (i[s].size + e[s].size) / 2, za(a - l) >= u) return !1;
    return !0;
  },
  expandbox: function(i, e) {
    e.x.min < i.x.min && (i.x.min = e.x.min), e.y.min < i.y.min && (i.y.min = e.y.min), e.z && e.z.min < i.z.min && (i.z.min = e.z.min), e.x.max > i.x.max && (i.x.max = e.x.max), e.y.max > i.y.max && (i.y.max = e.y.max), e.z && e.z.max > i.z.max && (i.z.max = e.z.max), i.x.mid = (i.x.min + i.x.max) / 2, i.y.mid = (i.y.min + i.y.max) / 2, i.z && (i.z.mid = (i.z.min + i.z.max) / 2), i.x.size = i.x.max - i.x.min, i.y.size = i.y.max - i.y.min, i.z && (i.z.size = i.z.max - i.z.min);
  },
  pairiteration: function(i, e, n) {
    const r = i.bbox(), o = e.bbox(), s = 1e5, a = n || 0.5;
    if (r.x.size + r.y.size < a && o.x.size + o.y.size < a)
      return [
        (s * (i._t1 + i._t2) / 2 | 0) / s + "/" + (s * (e._t1 + e._t2) / 2 | 0) / s
      ];
    let l = i.split(0.5), u = e.split(0.5), c = [
      { left: l.left, right: u.left },
      { left: l.left, right: u.right },
      { left: l.right, right: u.right },
      { left: l.right, right: u.left }
    ];
    c = c.filter(function(h) {
      return De.bboxoverlap(h.left.bbox(), h.right.bbox());
    });
    let d = [];
    return c.length === 0 || (c.forEach(function(h) {
      d = d.concat(
        De.pairiteration(h.left, h.right, a)
      );
    }), d = d.filter(function(h, p) {
      return d.indexOf(h) === p;
    })), d;
  },
  getccenter: function(i, e, n) {
    const r = e.x - i.x, o = e.y - i.y, s = n.x - e.x, a = n.y - e.y, l = r * Vr(So) - o * Ys(So), u = r * Ys(So) + o * Vr(So), c = s * Vr(So) - a * Ys(So), d = s * Ys(So) + a * Vr(So), h = (i.x + e.x) / 2, p = (i.y + e.y) / 2, m = (e.x + n.x) / 2, v = (e.y + n.y) / 2, y = h + l, w = p + u, g = m + c, k = v + d, _ = De.lli8(h, p, y, w, m, v, g, k), S = De.dist(_, i);
    let b = Ba(i.y - _.y, i.x - _.x), C = Ba(e.y - _.y, e.x - _.x), x = Ba(n.y - _.y, n.x - _.x), I;
    return b < x ? ((b > C || C > x) && (b += ic), b > x && (I = x, x = b, b = I)) : x < C && C < b ? (I = x, x = b, b = I) : x += ic, _.s = b, _.e = x, _.r = S, _;
  },
  numberSort: function(i, e) {
    return i - e;
  }
};
class gl {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return De.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, n) {
      return e + n;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var n = e[0].bbox(), r = 1; r < e.length; r++)
      De.expandbox(n, e[r].bbox());
    return n;
  }
  offset(e) {
    const n = [];
    return this.curves.forEach(function(r) {
      n.push(...r.offset(e));
    }), new gl(n);
  }
}
const { abs: Ua, min: Ov, max: Ev, cos: D8, sin: $8, acos: M8, sqrt: Wa } = Math, P8 = Math.PI;
let k1 = class Jt {
  constructor(e) {
    let n = e && e.forEach ? e : Array.from(arguments).slice(), r = !1;
    if (typeof n[0] == "object") {
      r = n.length;
      const m = [];
      n.forEach(function(v) {
        ["x", "y", "z"].forEach(function(y) {
          typeof v[y] < "u" && m.push(v[y]);
        });
      }), n = m;
    }
    let o = !1;
    const s = n.length;
    if (r) {
      if (r > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        o = !0;
      }
    } else if (s !== 6 && s !== 8 && s !== 9 && s !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const a = this._3d = !o && (s === 9 || s === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let m = 0, v = a ? 3 : 2; m < s; m += v) {
      var u = {
        x: n[m],
        y: n[m + 1]
      };
      a && (u.z = n[m + 2]), l.push(u);
    }
    const c = this.order = l.length - 1, d = this.dims = ["x", "y"];
    a && d.push("z"), this.dimlen = d.length;
    const h = De.align(l, { p1: l[0], p2: l[c] }), p = De.dist(l[0], l[c]);
    this._linear = h.reduce((m, v) => m + Ua(v.y), 0) < p / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, n, r, o) {
    if (typeof o > "u" && (o = 0.5), o === 0)
      return new Jt(n, n, r);
    if (o === 1)
      return new Jt(e, n, n);
    const s = Jt.getABC(2, e, n, r, o);
    return new Jt(e, s.A, r);
  }
  static cubicFromPoints(e, n, r, o, s) {
    typeof o > "u" && (o = 0.5);
    const a = Jt.getABC(3, e, n, r, o);
    typeof s > "u" && (s = De.dist(n, a.C));
    const l = s * (1 - o) / o, u = De.dist(e, r), c = (r.x - e.x) / u, d = (r.y - e.y) / u, h = s * c, p = s * d, m = l * c, v = l * d, y = { x: n.x - h, y: n.y - p }, w = { x: n.x + m, y: n.y + v }, g = a.A, k = { x: g.x + (y.x - g.x) / (1 - o), y: g.y + (y.y - g.y) / (1 - o) }, _ = { x: g.x + (w.x - g.x) / o, y: g.y + (w.y - g.y) / o }, S = { x: e.x + (k.x - e.x) / o, y: e.y + (k.y - e.y) / o }, b = {
      x: r.x + (_.x - r.x) / (1 - o),
      y: r.y + (_.y - r.y) / (1 - o)
    };
    return new Jt(e, S, b, r);
  }
  static getUtils() {
    return De;
  }
  getUtils() {
    return Jt.getUtils();
  }
  static get PolyBezier() {
    return gl;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return De.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, n = e[0].x, r = e[0].y, o = ["M", n, r, this.order === 2 ? "Q" : "C"];
    for (let s = 1, a = e.length; s < a; s++)
      o.push(e[s].x), o.push(e[s].y);
    return o.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, n) {
      return "" + n + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = De.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, n = De.angle(e[0], e[this.order], e[1]);
    this.clockwise = n > 0;
  }
  length() {
    return De.length(this.derivative.bind(this));
  }
  static getABC(e = 2, n, r, o, s = 0.5) {
    const a = De.projectionratio(s, e), l = 1 - a, u = {
      x: a * n.x + l * o.x,
      y: a * n.y + l * o.y
    }, c = De.abcratio(s, e);
    return { A: {
      x: r.x + (r.x - u.x) / c,
      y: r.y + (r.y - u.y) / c
    }, B: r, C: u, S: n, E: o };
  }
  getABC(e, n) {
    n = n || this.get(e);
    let r = this.points[0], o = this.points[this.order];
    return Jt.getABC(this.order, r, n, o, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let n = 0, r, o; n < e; n++)
      o = n / (e - 1), r = this.compute(o), r.t = o, this._lut.push(r);
    return this._lut;
  }
  on(e, n) {
    n = n || 5;
    const r = this.getLUT(), o = [];
    for (let s = 0, a, l = 0; s < r.length; s++)
      a = r[s], De.dist(a, e) < n && (o.push(a), l += s / r.length);
    return o.length ? t /= o.length : !1;
  }
  project(e) {
    const n = this.getLUT(), r = n.length - 1, o = De.closest(n, e), s = o.mpos, a = (s - 1) / r, l = (s + 1) / r, u = 0.1 / r;
    let c = o.mdist, d = a, h = d, p;
    c += 1;
    for (let m; d < l + u; d += u)
      p = this.compute(d), m = De.dist(e, p), m < c && (c = m, h = d);
    return h = h < 0 ? 0 : h > 1 ? 1 : h, p = this.compute(h), p.t = h, p.d = c, p;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? De.computeWithRatios(e, this.points, this.ratios, this._3d) : De.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, n = [e[0]], r = e.length;
    for (let o = 1, s, a; o < r; o++)
      s = e[o], a = e[o - 1], n[o] = {
        x: (r - o) / r * s.x + o / r * a.x,
        y: (r - o) / r * s.y + o / r * a.y
      };
    return n[r] = e[r - 1], new Jt(n);
  }
  derivative(e) {
    return De.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return De.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new Jt(De.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return De.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return De.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const n = this.derivative(e), r = Wa(n.x * n.x + n.y * n.y);
    return { t: e, x: -n.y / r, y: n.x / r };
  }
  __normal3(e) {
    const n = this.derivative(e), r = this.derivative(e + 0.01), o = Wa(n.x * n.x + n.y * n.y + n.z * n.z), s = Wa(r.x * r.x + r.y * r.y + r.z * r.z);
    n.x /= o, n.y /= o, n.z /= o, r.x /= s, r.y /= s, r.z /= s;
    const a = {
      x: r.y * n.z - r.z * n.y,
      y: r.z * n.x - r.x * n.z,
      z: r.x * n.y - r.y * n.x
    }, l = Wa(a.x * a.x + a.y * a.y + a.z * a.z);
    a.x /= l, a.y /= l, a.z /= l;
    const u = [
      a.x * a.x,
      a.x * a.y - a.z,
      a.x * a.z + a.y,
      a.x * a.y + a.z,
      a.y * a.y,
      a.y * a.z - a.x,
      a.x * a.z - a.y,
      a.y * a.z + a.x,
      a.z * a.z
    ];
    return {
      t: e,
      x: u[0] * n.x + u[1] * n.y + u[2] * n.z,
      y: u[3] * n.x + u[4] * n.y + u[5] * n.z,
      z: u[6] * n.x + u[7] * n.y + u[8] * n.z
    };
  }
  hull(e) {
    let n = this.points, r = [], o = [], s = 0;
    for (o[s++] = n[0], o[s++] = n[1], o[s++] = n[2], this.order === 3 && (o[s++] = n[3]); n.length > 1; ) {
      r = [];
      for (let a = 0, l, u = n.length - 1; a < u; a++)
        l = De.lerp(e, n[a], n[a + 1]), o[s++] = l, r.push(l);
      n = r;
    }
    return o;
  }
  split(e, n) {
    if (e === 0 && n)
      return this.split(n).left;
    if (n === 1)
      return this.split(e).right;
    const r = this.hull(e), o = {
      left: this.order === 2 ? new Jt([r[0], r[3], r[5]]) : new Jt([r[0], r[4], r[7], r[9]]),
      right: this.order === 2 ? new Jt([r[5], r[4], r[2]]) : new Jt([r[9], r[8], r[6], r[3]]),
      span: r
    };
    return o.left._t1 = De.map(0, 0, 1, this._t1, this._t2), o.left._t2 = De.map(e, 0, 1, this._t1, this._t2), o.right._t1 = De.map(e, 0, 1, this._t1, this._t2), o.right._t2 = De.map(1, 0, 1, this._t1, this._t2), n ? (n = De.map(n, e, 1, 0, 1), o.right.split(n).left) : o;
  }
  extrema() {
    const e = {};
    let n = [];
    return this.dims.forEach(
      (function(r) {
        let o = function(a) {
          return a[r];
        }, s = this.dpoints[0].map(o);
        e[r] = De.droots(s), this.order === 3 && (s = this.dpoints[1].map(o), e[r] = e[r].concat(De.droots(s))), e[r] = e[r].filter(function(a) {
          return a >= 0 && a <= 1;
        }), n = n.concat(e[r].sort(De.numberSort));
      }).bind(this)
    ), e.values = n.sort(De.numberSort).filter(function(r, o) {
      return n.indexOf(r) === o;
    }), e;
  }
  bbox() {
    const e = this.extrema(), n = {};
    return this.dims.forEach(
      (function(r) {
        n[r] = De.getminmax(this, r, e[r]);
      }).bind(this)
    ), n;
  }
  overlaps(e) {
    const n = this.bbox(), r = e.bbox();
    return De.bboxoverlap(n, r);
  }
  offset(e, n) {
    if (typeof n < "u") {
      const r = this.get(e), o = this.normal(e), s = {
        c: r,
        n: o,
        x: r.x + o.x * n,
        y: r.y + o.y * n
      };
      return this._3d && (s.z = r.z + o.z * n), s;
    }
    if (this._linear) {
      const r = this.normal(0), o = this.points.map(function(s) {
        const a = {
          x: s.x + e * r.x,
          y: s.y + e * r.y
        };
        return s.z && r.z && (a.z = s.z + e * r.z), a;
      });
      return [new Jt(o)];
    }
    return this.reduce().map(function(r) {
      return r._linear ? r.offset(e)[0] : r.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const o = De.angle(this.points[0], this.points[3], this.points[1]), s = De.angle(this.points[0], this.points[3], this.points[2]);
      if (o > 0 && s < 0 || o < 0 && s > 0) return !1;
    }
    const e = this.normal(0), n = this.normal(1);
    let r = e.x * n.x + e.y * n.y;
    return this._3d && (r += e.z * n.z), Ua(M8(r)) < P8 / 3;
  }
  reduce() {
    let e, n = 0, r = 0, o = 0.01, s, a = [], l = [], u = this.extrema().values;
    for (u.indexOf(0) === -1 && (u = [0].concat(u)), u.indexOf(1) === -1 && u.push(1), n = u[0], e = 1; e < u.length; e++)
      r = u[e], s = this.split(n, r), s._t1 = n, s._t2 = r, a.push(s), n = r;
    return a.forEach(function(c) {
      for (n = 0, r = 0; r <= 1; )
        for (r = n + o; r <= 1 + o; r += o)
          if (s = c.split(n, r), !s.simple()) {
            if (r -= o, Ua(n - r) < o)
              return [];
            s = c.split(n, r), s._t1 = De.map(n, 0, 1, c._t1, c._t2), s._t2 = De.map(r, 0, 1, c._t1, c._t2), l.push(s), n = r;
            break;
          }
      n < 1 && (s = c.split(n, 1), s._t1 = De.map(n, 0, 1, c._t1, c._t2), s._t2 = c._t2, l.push(s));
    }), l;
  }
  translate(e, n, r) {
    r = typeof r == "number" ? r : n;
    const o = this.order;
    let s = this.points.map((a, l) => (1 - l / o) * n + l / o * r);
    return new Jt(
      this.points.map((a, l) => ({
        x: a.x + e.x * s[l],
        y: a.y + e.y * s[l]
      }))
    );
  }
  scale(e) {
    const n = this.order;
    let r = !1;
    if (typeof e == "function" && (r = e), r && n === 2)
      return this.raise().scale(r);
    const o = this.clockwise, s = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        r ? r(0) : e,
        r ? r(1) : e
      );
    const a = r ? r(0) : e, l = r ? r(1) : e, u = [this.offset(0, 10), this.offset(1, 10)], c = [], d = De.lli4(u[0], u[0].c, u[1], u[1].c);
    if (!d)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(h) {
      const p = c[h * n] = De.copy(s[h * n]);
      p.x += (h ? l : a) * u[h].n.x, p.y += (h ? l : a) * u[h].n.y;
    }), r ? ([0, 1].forEach(function(h) {
      if (!(n === 2 && h)) {
        var p = s[h + 1], m = {
          x: p.x - d.x,
          y: p.y - d.y
        }, v = r ? r((h + 1) / n) : e;
        r && !o && (v = -v);
        var y = Wa(m.x * m.x + m.y * m.y);
        m.x /= y, m.y /= y, c[h + 1] = {
          x: p.x + v * m.x,
          y: p.y + v * m.y
        };
      }
    }), new Jt(c)) : ([0, 1].forEach((h) => {
      if (n === 2 && h) return;
      const p = c[h * n], m = this.derivative(h), v = { x: p.x + m.x, y: p.y + m.y };
      c[h + 1] = De.lli4(p, v, d, s[h + 1]);
    }), new Jt(c));
  }
  outline(e, n, r, o) {
    if (n = n === void 0 ? e : n, this._linear) {
      const b = this.normal(0), C = this.points[0], x = this.points[this.points.length - 1];
      let I, F, B;
      r === void 0 && (r = e, o = n), I = { x: C.x + b.x * e, y: C.y + b.y * e }, B = { x: x.x + b.x * r, y: x.y + b.y * r }, F = { x: (I.x + B.x) / 2, y: (I.y + B.y) / 2 };
      const X = [I, F, B];
      I = { x: C.x - b.x * n, y: C.y - b.y * n }, B = { x: x.x - b.x * o, y: x.y - b.y * o }, F = { x: (I.x + B.x) / 2, y: (I.y + B.y) / 2 };
      const j = [B, F, I], ee = De.makeline(j[2], X[0]), ie = De.makeline(X[2], j[0]), M = [ee, new Jt(X), ie, new Jt(j)];
      return new gl(M);
    }
    const s = this.reduce(), a = s.length, l = [];
    let u = [], c, d = 0, h = this.length();
    const p = typeof r < "u" && typeof o < "u";
    function m(b, C, x, I, F) {
      return function(B) {
        const X = I / x, j = (I + F) / x, ee = C - b;
        return De.map(B, 0, 1, b + X * ee, b + j * ee);
      };
    }
    s.forEach(function(b) {
      const C = b.length();
      p ? (l.push(
        b.scale(m(e, r, h, d, C))
      ), u.push(
        b.scale(m(-n, -o, h, d, C))
      )) : (l.push(b.scale(e)), u.push(b.scale(-n))), d += C;
    }), u = u.map(function(b) {
      return c = b.points, c[3] ? b.points = [c[3], c[2], c[1], c[0]] : b.points = [c[2], c[1], c[0]], b;
    }).reverse();
    const v = l[0].points[0], y = l[a - 1].points[l[a - 1].points.length - 1], w = u[a - 1].points[u[a - 1].points.length - 1], g = u[0].points[0], k = De.makeline(w, v), _ = De.makeline(y, g), S = [k].concat(l).concat([_]).concat(u);
    return new gl(S);
  }
  outlineshapes(e, n, r) {
    n = n || e;
    const o = this.outline(e, n).curves, s = [];
    for (let a = 1, l = o.length; a < l / 2; a++) {
      const u = De.makeshape(
        o[a],
        o[l - a],
        r
      );
      u.startcap.virtual = a > 1, u.endcap.virtual = a < l / 2 - 1, s.push(u);
    }
    return s;
  }
  intersects(e, n) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof Jt && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      n
    )) : this.selfintersects(n);
  }
  lineIntersects(e) {
    const n = Ov(e.p1.x, e.p2.x), r = Ov(e.p1.y, e.p2.y), o = Ev(e.p1.x, e.p2.x), s = Ev(e.p1.y, e.p2.y);
    return De.roots(this.points, e).filter((a) => {
      var l = this.get(a);
      return De.between(l.x, n, o) && De.between(l.y, r, s);
    });
  }
  selfintersects(e) {
    const n = this.reduce(), r = n.length - 2, o = [];
    for (let s = 0, a, l, u; s < r; s++)
      l = n.slice(s, s + 1), u = n.slice(s + 2), a = this.curveintersects(l, u, e), o.push(...a);
    return o;
  }
  curveintersects(e, n, r) {
    const o = [];
    e.forEach(function(a) {
      n.forEach(function(l) {
        a.overlaps(l) && o.push({ left: a, right: l });
      });
    });
    let s = [];
    return o.forEach(function(a) {
      const l = De.pairiteration(
        a.left,
        a.right,
        r
      );
      l.length > 0 && (s = s.concat(l));
    }), s;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, n, r, o) {
    const s = (o - r) / 4, a = this.get(r + s), l = this.get(o - s), u = De.dist(e, n), c = De.dist(e, a), d = De.dist(e, l);
    return Ua(c - u) + Ua(d - u);
  }
  _iterate(e, n) {
    let r = 0, o = 1, s;
    do {
      s = 0, o = 1;
      let a = this.get(r), l, u, c, d, h = !1, p = !1, m, v = o, y = 1;
      do
        if (p = h, d = c, v = (r + o) / 2, l = this.get(v), u = this.get(o), c = De.getccenter(a, l, u), c.interval = {
          start: r,
          end: o
        }, h = this._error(c, a, r, o) <= e, m = p && !h, m || (y = o), h) {
          if (o >= 1) {
            if (c.interval.end = y = 1, d = c, o > 1) {
              let g = {
                x: c.x + c.r * D8(c.e),
                y: c.y + c.r * $8(c.e)
              };
              c.e += De.angle({ x: c.x, y: c.y }, g, this.get(1));
            }
            break;
          }
          o = o + (o - r) / 2;
        } else
          o = v;
      while (!m && s++ < 100);
      if (s >= 100)
        break;
      d = d || c, n.push(d), r = y;
    } while (o < 1);
    return n;
  }
};
const I8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bezier: k1
}, Symbol.toStringTag, { value: "Module" })), Tv = I8;
class L8 {
  /**
   * @param curve - Bezier.js curve instance
   * @param resolution - Number of samples for LUT (higher = more accurate)
   */
  constructor(e, n = 1e3) {
    Xe(this, "curve");
    Xe(this, "lut");
    Xe(this, "totalLength");
    this.curve = e, this.lut = [], this.totalLength = 0, this.buildLUT(n);
  }
  /**
   * Build the arc length lookup table
   */
  buildLUT(e) {
    let n = 0, r = this.curve.get(0);
    for (let o = 0; o <= e; o++) {
      const s = o / e, a = this.curve.get(s);
      if (o > 0) {
        const l = a.x - r.x, u = a.y - r.y;
        n += Math.sqrt(l * l + u * u);
      }
      this.lut.push({
        t: s,
        length: n
      }), r = a;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, r = this.lut.length - 1;
    for (; n < r; ) {
      const l = Math.floor((n + r) / 2);
      this.lut[l].length < e ? n = l + 1 : r = l;
    }
    const o = this.lut[n], s = this.lut[Math.max(0, n - 1)];
    if (o.length === s.length)
      return o.t;
    const a = (e - s.length) / (o.length - s.length);
    return s.t + a * (o.t - s.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e);
    return {
      point: this.curve.get(n),
      tangent: this.curve.derivative(n),
      t: n
    };
  }
  /**
   * Get evenly spaced points along the curve
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(e) {
    const n = [], r = this.totalLength / (e - 1);
    for (let o = 0; o < e; o++) {
      const s = o * r;
      n.push(this.getPointAtDistance(s));
    }
    return n;
  }
}
function A8(i) {
  if (!i || i.length < 2)
    return null;
  let e = null;
  for (const n of i) {
    const [r, ...o] = n;
    if (r === "M")
      e = { x: o[0], y: o[1] };
    else {
      if (r === "C" && e)
        return new Tv(
          e.x,
          e.y,
          o[0],
          o[1],
          // control point 1
          o[2],
          o[3],
          // control point 2
          o[4],
          o[5]
          // end point
        );
      if (r === "Q" && e)
        return new Tv(
          e.x,
          e.y,
          o[0],
          o[1],
          // control point
          o[2],
          o[3]
          // end point
        );
    }
  }
  return null;
}
class V8 {
  constructor() {
    Xe(this, "offscreenCanvas", null);
    Xe(this, "ctx", null);
    Xe(this, "particleSystems", /* @__PURE__ */ new Map());
  }
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(e, n) {
    const r = Math.round(e / 8) * 8, o = Math.round(n / 8) * 8, s = Math.max(256, r), a = Math.max(256, o), l = e === s && n === a;
    return {
      valid: l,
      correctedWidth: s,
      correctedHeight: a,
      message: l ? void 0 : `Adjusted to ${s}x${a} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(e, n, r) {
    const { frameCount: o } = e.composition, { width: s, height: a } = n;
    this.offscreenCanvas = new OffscreenCanvas(s, a), this.ctx = this.offscreenCanvas.getContext("2d"), this.initializeParticleSystems(e);
    const l = [];
    for (let u = 0; u < o; u++) {
      r && r({
        frame: u,
        total: o,
        percent: Math.round(u / o * 100)
      }), this.stepParticleSystemsToFrame(e, u);
      const c = await this.generateFrame(e, u, n);
      l.push(c);
    }
    return this.particleSystems.clear(), r && r({
      frame: o,
      total: o,
      percent: 100
    }), l;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(e, n, r) {
    const o = this.ctx, { width: s, height: a } = r;
    if (o.fillStyle = "#FFFFFF", o.fillRect(0, 0, s, a), r.matteMode === "include_all")
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    o.fillStyle = "#000000";
    const l = s / e.composition.width, u = a / e.composition.height, c = e.layers.filter(
      (h) => h.type === "text" && h.visible && n >= h.inPoint && n <= h.outPoint
    );
    for (const h of c)
      await this.renderTextLayerToMatte(o, h, e, n, l, u);
    const d = e.layers.filter(
      (h) => h.type === "particles" && h.visible && n >= h.inPoint && n <= h.outPoint
    );
    for (const h of d)
      this.renderParticleLayerToMatte(o, h, s, a);
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(e, n, r) {
    (!this.offscreenCanvas || this.offscreenCanvas.width !== r.width || this.offscreenCanvas.height !== r.height) && (this.offscreenCanvas = new OffscreenCanvas(r.width, r.height), this.ctx = this.offscreenCanvas.getContext("2d"));
    const o = await this.generateFrame(e, n, r);
    return URL.createObjectURL(o);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(e, n, r, o, s, a) {
    const l = n.data;
    if (!l) return;
    const u = n.properties.find((h) => h.name === "fontSize"), d = (u ? Qs(u, o) : l.fontSize) * Math.min(s, a);
    e.font = `${l.fontWeight} ${d}px "${l.fontFamily}"`, l.pathLayerId ? await this.renderTextOnPathToMatte(e, n, l, r, o, d, s, a) : this.renderTextBlockToMatte(e, n, l, o, d, s, a);
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(e, n, r, o, s, a, l, u) {
    const c = o.layers.find((_) => _.id === r.pathLayerId);
    if (!c || c.type !== "spline") return;
    const d = c.data;
    if (!(d != null && d.controlPoints) || d.controlPoints.length < 2) return;
    const h = this.buildPathCommands(d);
    if (!h || h.length < 2) return;
    const p = A8(h);
    if (!p) return;
    const m = new L8(p), v = n.properties.find((_) => _.name === "pathOffset"), y = v ? Qs(v, s) : r.pathOffset, w = m.totalLength;
    let g = y * w;
    const k = 4 * Math.min(l, u);
    for (const _ of r.text) {
      if (_ === " ") {
        const X = e.measureText(" ").width;
        g += X + r.letterSpacing;
        continue;
      }
      const S = e.measureText(_).width, b = Math.max(0, Math.min(g, w)), { point: C, tangent: x } = m.getPointAtDistance(b), I = Math.atan2(x.y, x.x), F = C.x * l, B = C.y * u;
      e.save(), e.translate(F, B), e.rotate(I), e.fillRect(
        -k,
        -a - k,
        S + k * 2,
        a + k * 2
      ), e.restore(), g += S + r.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(e) {
    const n = e.controlPoints;
    if (!n || n.length < 2) return null;
    const r = [];
    r.push(["M", n[0].x, n[0].y]);
    for (let o = 0; o < n.length - 1; o++) {
      const s = n[o], a = n[o + 1], l = s.handleOut || { x: s.x, y: s.y }, u = a.handleIn || { x: a.x, y: a.y };
      r.push([
        "C",
        l.x,
        l.y,
        u.x,
        u.y,
        a.x,
        a.y
      ]);
    }
    return r;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(e, n, r, o, s, a, l) {
    const u = n.transform.position, c = Qs(u, o), d = n.transform.rotation, h = Qs(d, o), p = n.transform.scale, m = Qs(p, o);
    e.save(), e.translate(c.x * a, c.y * l), e.rotate(h * Math.PI / 180), e.scale(m.x, m.y);
    const y = e.measureText(r.text).width, w = s, g = 4;
    e.fillRect(
      -g,
      -w - g,
      y + g * 2,
      w + g * 2
    ), e.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(e, n = "matte_sequence", r) {
    const o = (await import("./weyl-jszip.min.js").then((c) => c.j)).default, s = new o();
    e.forEach((c, d) => {
      const h = `${n}_${String(d).padStart(4, "0")}.png`;
      s.file(h, c);
    });
    const a = await s.generateAsync(
      { type: "blob" },
      (c) => {
        r && r(Math.round(c.percent));
      }
    ), l = URL.createObjectURL(a), u = document.createElement("a");
    u.href = l, u.download = `${n}.zip`, document.body.appendChild(u), u.click(), document.body.removeChild(u), URL.revokeObjectURL(l);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(e) {
    this.particleSystems.clear();
    const n = e.layers.filter(
      (r) => r.type === "particles"
    );
    for (const r of n) {
      const o = r.data;
      if (!o) continue;
      const s = new Cd(o.systemConfig);
      for (const l of o.emitters)
        s.addEmitter(l);
      for (const l of o.gravityWells)
        s.addGravityWell(l);
      for (const l of o.vortices)
        s.addVortex(l);
      for (const l of o.modulations)
        s.addModulation(l);
      const a = o.systemConfig.warmupPeriod || 0;
      for (let l = 0; l < a; l++)
        s.step();
      this.particleSystems.set(r.id, s);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(e, n) {
    if (n !== 0)
      for (const r of e.layers) {
        if (r.type !== "particles") continue;
        const o = this.particleSystems.get(r.id);
        o && r.visible && n >= r.inPoint && n <= r.outPoint && o.step();
      }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(e, n, r, o) {
    const s = this.particleSystems.get(n.id);
    if (!s) return;
    const a = s.renderToMask(r, o), l = new OffscreenCanvas(r, o);
    l.getContext("2d").putImageData(a, 0, 0), e.globalCompositeOperation = "multiply", e.drawImage(l, 0, 0), e.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null, this.ctx = null, this.particleSystems.clear();
  }
}
const ns = new V8(), F8 = { class: "export-dialog" }, j8 = { class: "dialog-header" }, R8 = { class: "dialog-content" }, N8 = { class: "form-group" }, z8 = { class: "resolution-presets" }, B8 = ["onClick"], H8 = { class: "custom-resolution" }, U8 = { class: "dimension-input" }, W8 = { class: "dimension-input" }, G8 = {
  key: 0,
  class: "dimension-warning"
}, X8 = { class: "form-group" }, Y8 = { class: "matte-mode-options" }, K8 = { class: "form-group" }, q8 = { class: "preview-container" }, Z8 = ["src"], J8 = {
  key: 1,
  class: "preview-placeholder"
}, Q8 = {
  key: 0,
  class: "progress-section"
}, eV = { class: "progress-bar" }, tV = { class: "progress-text" }, nV = { class: "dialog-footer" }, iV = { class: "export-info" }, rV = ["disabled"], oV = ["disabled"], sV = /* @__PURE__ */ tn({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(i, { emit: e }) {
    const n = e, r = Gn(), o = ns.getResolutionPresets(), s = re("720p (1280x720)"), a = re(1280), l = re(720), u = re(), c = re("exclude_text"), d = re(null), h = re(!1), p = re(0), m = re(""), v = Ee(() => a.value), y = Ee(() => l.value);
    function w(S) {
      s.value = S.label, a.value = S.width, l.value = S.height, u.value = void 0;
    }
    function g() {
      const S = ns.validateDimensions(a.value, l.value);
      if (!S.valid)
        a.value = S.correctedWidth, l.value = S.correctedHeight, u.value = S.message, s.value = "";
      else {
        u.value = void 0;
        const b = o.find(
          (C) => C.width === a.value && C.height === l.value
        );
        s.value = (b == null ? void 0 : b.label) || "";
      }
    }
    async function k() {
      if (!r.hasProject) return;
      d.value && (URL.revokeObjectURL(d.value), d.value = null);
      const S = {
        width: v.value,
        height: y.value,
        matteMode: c.value
      };
      d.value = await ns.generatePreviewFrame(
        r.project,
        0,
        S
      );
    }
    async function _() {
      if (h.value || !r.hasProject) return;
      h.value = !0, p.value = 0, m.value = "Generating frames...";
      const S = {
        width: v.value,
        height: y.value,
        matteMode: c.value
      };
      try {
        const b = await ns.generateMatteSequence(
          r.project,
          S,
          (C) => {
            p.value = C.percent, m.value = `Generating frame ${C.frame + 1} of ${C.total}...`;
          }
        );
        m.value = "Creating ZIP archive...", await ns.downloadAsZip(
          b,
          `matte_${Date.now()}`,
          (C) => {
            m.value = `Compressing... ${C}%`;
          }
        ), m.value = "Export complete!", n("exported"), setTimeout(() => {
          n("close");
        }, 1e3);
      } catch (b) {
        console.error("[ExportDialog] Export failed:", b), m.value = `Export failed: ${b instanceof Error ? b.message : "Unknown error"}`;
      } finally {
        h.value = !1;
      }
    }
    return Lt(
      [v, y, c],
      () => {
        k();
      },
      { immediate: !1 }
    ), Wn(() => {
      if (r.hasProject) {
        const S = ns.validateDimensions(r.width, r.height);
        a.value = S.correctedWidth, l.value = S.correctedHeight;
        const b = o.find(
          (C) => C.width === a.value && C.height === l.value
        );
        s.value = (b == null ? void 0 : b.label) || "", S.valid || (u.value = S.message);
      }
      k();
    }), Qi(() => {
      d.value && URL.revokeObjectURL(d.value), ns.dispose();
    }), (S, b) => ($(), A("div", {
      class: "export-dialog-overlay",
      onClick: b[6] || (b[6] = tt((C) => n("close"), ["self"]))
    }, [
      f("div", F8, [
        f("div", j8, [
          b[8] || (b[8] = f("h3", null, "Export Matte Sequence", -1)),
          f("button", {
            class: "close-btn",
            onClick: b[0] || (b[0] = (C) => n("close"))
          }, [...b[7] || (b[7] = [
            f("i", { class: "pi pi-times" }, null, -1)
          ])])
        ]),
        f("div", R8, [
          f("div", N8, [
            b[13] || (b[13] = f("label", null, "Resolution", -1)),
            f("div", z8, [
              ($(!0), A(Fe, null, Ke(ze(o), (C) => ($(), A("button", {
                key: C.label,
                class: _e(["preset-btn", { active: s.value === C.label }]),
                onClick: (x) => w(C)
              }, Q(C.label), 11, B8))), 128))
            ]),
            f("div", H8, [
              f("div", U8, [
                b[9] || (b[9] = f("label", null, "Width", -1)),
                ot(f("input", {
                  "onUpdate:modelValue": b[1] || (b[1] = (C) => a.value = C),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: g
                }, null, 544), [
                  [
                    Qt,
                    a.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ]),
              b[11] || (b[11] = f("span", { class: "dimension-x" }, "", -1)),
              f("div", W8, [
                b[10] || (b[10] = f("label", null, "Height", -1)),
                ot(f("input", {
                  "onUpdate:modelValue": b[2] || (b[2] = (C) => l.value = C),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: g
                }, null, 544), [
                  [
                    Qt,
                    l.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ])
            ]),
            u.value ? ($(), A("p", G8, [
              b[12] || (b[12] = f("i", { class: "pi pi-info-circle" }, null, -1)),
              vt(" " + Q(u.value), 1)
            ])) : ve("", !0)
          ]),
          f("div", X8, [
            b[16] || (b[16] = f("label", null, "Matte Mode", -1)),
            f("div", Y8, [
              f("button", {
                class: _e(["mode-btn", { active: c.value === "exclude_text" }]),
                onClick: b[3] || (b[3] = (C) => c.value = "exclude_text")
              }, [...b[14] || (b[14] = [
                f("i", { class: "pi pi-ban" }, null, -1),
                f("span", null, "Exclude Text", -1),
                f("small", null, "Text regions are BLACK (excluded from generation)", -1)
              ])], 2),
              f("button", {
                class: _e(["mode-btn", { active: c.value === "include_all" }]),
                onClick: b[4] || (b[4] = (C) => c.value = "include_all")
              }, [...b[15] || (b[15] = [
                f("i", { class: "pi pi-check-circle" }, null, -1),
                f("span", null, "Include All", -1),
                f("small", null, "Entire frame is WHITE (generate everything)", -1)
              ])], 2)
            ])
          ]),
          f("div", K8, [
            b[18] || (b[18] = f("label", null, "Preview (Frame 0)", -1)),
            f("div", q8, [
              d.value ? ($(), A("img", {
                key: 0,
                src: d.value,
                alt: "Matte preview",
                class: "preview-image"
              }, null, 8, Z8)) : ($(), A("div", J8, [...b[17] || (b[17] = [
                f("i", { class: "pi pi-image" }, null, -1),
                f("span", null, "Generating preview...", -1)
              ])]))
            ]),
            b[19] || (b[19] = f("p", { class: "preview-info" }, [
              vt(" White = Keep original / generate content"),
              f("br"),
              vt(" Black = Exclude from generation ")
            ], -1))
          ]),
          h.value ? ($(), A("div", Q8, [
            f("div", eV, [
              f("div", {
                class: "progress-fill",
                style: Pt({ width: `${p.value}%` })
              }, null, 4)
            ]),
            f("p", tV, Q(m.value), 1)
          ])) : ve("", !0)
        ]),
        f("div", nV, [
          f("div", iV, [
            f("span", null, Q(ze(r).frameCount) + " frames @ " + Q(v.value) + "" + Q(y.value), 1)
          ]),
          f("button", {
            class: "cancel-btn",
            onClick: b[5] || (b[5] = (C) => n("close")),
            disabled: h.value
          }, " Cancel ", 8, rV),
          f("button", {
            class: "export-btn",
            onClick: _,
            disabled: h.value || !ze(r).hasProject
          }, [
            b[20] || (b[20] = f("i", { class: "pi pi-download" }, null, -1)),
            vt(" " + Q(h.value ? "Exporting..." : "Export ZIP"), 1)
          ], 8, oV)
        ])
      ])
    ]));
  }
}), aV = /* @__PURE__ */ cn(sV, [["__scopeId", "data-v-34eee532"]]), lV = { class: "workspace-layout" }, uV = { class: "toolbar" }, cV = { class: "tool-group" }, dV = { class: "tool-group" }, hV = ["title"], fV = { class: "icon" }, pV = { class: "timecode-display" }, mV = { class: "tool-group" }, gV = { class: "tool-group" }, vV = ["disabled"], yV = ["disabled"], bV = { class: "workspace-content" }, wV = { class: "panel left-panel" }, _V = { class: "panel-tabs" }, xV = { class: "panel-content" }, SV = { class: "panel viewport-panel" }, CV = { class: "viewport-header" }, kV = { class: "viewport-tabs" }, OV = { class: "viewport-controls" }, EV = { class: "viewport-content" }, TV = { class: "panel timeline-panel" }, DV = { class: "panel graph-editor-panel" }, $V = { class: "panel right-panel" }, MV = { class: "panel-tabs" }, PV = { class: "panel-content" }, IV = { class: "status-bar" }, LV = { class: "status-left" }, AV = { class: "status-item" }, VV = { class: "status-item" }, FV = { class: "status-center" }, jV = {
  key: 0,
  class: "render-progress"
}, RV = { class: "status-right" }, NV = { class: "status-item" }, zV = { class: "status-item" }, BV = /* @__PURE__ */ tn({
  __name: "WorkspaceLayout",
  setup(i) {
    const e = Gn(), n = re("select"), r = re("standard"), o = re("project"), s = re("properties"), a = re("composition"), l = re("fit"), u = re(!1), c = re(!0), d = re(!1), h = re(!1), p = re(!1), m = re("cpu"), v = re(null), y = re(sk()), w = re(ak()), g = re({
      showGrid: !0,
      showAxes: !0,
      showCameraFrustum: !0,
      showCompositionBounds: !0,
      showFocalPlane: !1,
      showLayerOutlines: !0,
      gridSize: 100,
      gridDivisions: 10
    }), k = Ee(() => {
      var fe, te;
      return ((te = (fe = e.project) == null ? void 0 : fe.composition) == null ? void 0 : te.width) || 1920;
    }), _ = Ee(() => {
      var fe, te;
      return ((te = (fe = e.project) == null ? void 0 : fe.composition) == null ? void 0 : te.height) || 1080;
    }), S = re(60), b = re("0 MB"), C = re(0), x = Ee(() => {
      var T, E;
      const fe = e.currentFrame, te = ((E = (T = e.project) == null ? void 0 : T.composition) == null ? void 0 : E.fps) || 30, Me = fe / te, Re = Math.floor(Me / 60), Ce = Math.floor(Me % 60), le = fe % te;
      return `${String(Re).padStart(2, "0")}:${String(Ce).padStart(2, "0")}:${String(le).padStart(2, "0")}`;
    }), I = Ee(() => {
      var fe, te;
      return ((te = (fe = e.project) == null ? void 0 : fe.meta) == null ? void 0 : te.name) || "Untitled Project";
    }), F = Ee(() => {
      var te;
      const fe = (te = e.project) == null ? void 0 : te.composition;
      return fe ? `${fe.width}${fe.height} @ ${fe.fps}fps` : "No Composition";
    }), B = Ee(() => e.canUndo), X = Ee(() => e.canRedo);
    function j() {
      p.value = !p.value, p.value ? e.play() : e.pause();
    }
    function ee() {
      e.goToStart();
    }
    function ie() {
      e.goToEnd();
    }
    function M() {
      e.setFrame(e.currentFrame + 1);
    }
    function W() {
      e.setFrame(Math.max(0, e.currentFrame - 1));
    }
    function R() {
      e.undo();
    }
    function V() {
      e.redo();
    }
    function ae(fe) {
      y.value = fe;
    }
    function $e() {
      console.log("[Weyl] Export completed");
    }
    function N(fe) {
      var te, Me;
      if (!(((te = document.activeElement) == null ? void 0 : te.tagName) === "INPUT" || ((Me = document.activeElement) == null ? void 0 : Me.tagName) === "TEXTAREA"))
        switch (fe.key.toLowerCase()) {
          case " ":
            fe.preventDefault(), j();
            break;
          case "v":
            n.value = "select";
            break;
          case "p":
            n.value = "pen";
            break;
          case "t":
            n.value = "text";
            break;
          case "h":
            n.value = "hand";
            break;
          case "z":
            fe.ctrlKey || fe.metaKey ? (fe.preventDefault(), fe.shiftKey ? V() : R()) : n.value = "zoom";
            break;
          case "home":
            fe.preventDefault(), ee();
            break;
          case "end":
            fe.preventDefault(), ie();
            break;
          case "arrowleft":
            fe.preventDefault(), W();
            break;
          case "arrowright":
            fe.preventDefault(), M();
            break;
          case "g":
            fe.shiftKey && (d.value = !d.value);
            break;
        }
    }
    let me;
    function we() {
      if ("memory" in performance) {
        const fe = performance.memory, te = Math.round(fe.usedJSHeapSize / 1024 / 1024);
        b.value = `${te} MB`;
      }
    }
    return Wn(async () => {
      const fe = await rk();
      m.value = fe.tier, window.addEventListener("keydown", N), me = window.setInterval(we, 1e3);
    }), Qi(() => {
      window.removeEventListener("keydown", N), clearInterval(me);
    }), (fe, te) => ($(), A("div", lV, [
      f("div", uV, [
        f("div", cV, [
          f("button", {
            class: _e({ active: n.value === "select" }),
            onClick: te[0] || (te[0] = (Me) => n.value = "select"),
            title: "Select (V)"
          }, [...te[20] || (te[20] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: _e({ active: n.value === "pen" }),
            onClick: te[1] || (te[1] = (Me) => n.value = "pen"),
            title: "Pen Tool (P)"
          }, [...te[21] || (te[21] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: _e({ active: n.value === "text" }),
            onClick: te[2] || (te[2] = (Me) => n.value = "text"),
            title: "Text Tool (T)"
          }, [...te[22] || (te[22] = [
            f("span", { class: "icon" }, "T", -1)
          ])], 2),
          f("button", {
            class: _e({ active: n.value === "hand" }),
            onClick: te[3] || (te[3] = (Me) => n.value = "hand"),
            title: "Hand Tool (H)"
          }, [...te[23] || (te[23] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: _e({ active: n.value === "zoom" }),
            onClick: te[4] || (te[4] = (Me) => n.value = "zoom"),
            title: "Zoom Tool (Z)"
          }, [...te[24] || (te[24] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2)
        ]),
        te[33] || (te[33] = f("div", { class: "divider" }, null, -1)),
        f("div", dV, [
          f("button", {
            onClick: ee,
            title: "Go to Start (Home)"
          }, [...te[25] || (te[25] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: W,
            title: "Step Backward"
          }, [...te[26] || (te[26] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: j,
            title: p.value ? "Pause (Space)" : "Play (Space)"
          }, [
            f("span", fV, Q(p.value ? "" : ""), 1)
          ], 8, hV),
          f("button", {
            onClick: M,
            title: "Step Forward"
          }, [...te[27] || (te[27] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: ie,
            title: "Go to End (End)"
          }, [...te[28] || (te[28] = [
            f("span", { class: "icon" }, "", -1)
          ])])
        ]),
        f("div", pV, Q(x.value), 1),
        te[34] || (te[34] = f("div", { class: "divider" }, null, -1)),
        f("div", mV, [
          ot(f("select", {
            "onUpdate:modelValue": te[5] || (te[5] = (Me) => r.value = Me),
            class: "workspace-selector"
          }, [...te[29] || (te[29] = [
            f("option", { value: "standard" }, "Standard", -1),
            f("option", { value: "animation" }, "Animation", -1),
            f("option", { value: "effects" }, "Effects", -1),
            f("option", { value: "minimal" }, "Minimal", -1)
          ])], 512), [
            [Zr, r.value]
          ])
        ]),
        te[35] || (te[35] = f("div", { class: "spacer" }, null, -1)),
        f("div", gV, [
          f("span", {
            class: _e(["gpu-badge", m.value])
          }, Q(m.value.toUpperCase()), 3),
          f("button", {
            onClick: R,
            disabled: !B.value,
            title: "Undo (Ctrl+Z)"
          }, [...te[30] || (te[30] = [
            f("span", { class: "icon" }, "", -1)
          ])], 8, vV),
          f("button", {
            onClick: V,
            disabled: !X.value,
            title: "Redo (Ctrl+Shift+Z)"
          }, [...te[31] || (te[31] = [
            f("span", { class: "icon" }, "", -1)
          ])], 8, yV),
          f("button", {
            onClick: te[6] || (te[6] = (Me) => h.value = !0),
            title: "Export"
          }, [...te[32] || (te[32] = [
            f("span", { class: "icon" }, "", -1),
            vt(" Export ", -1)
          ])])
        ])
      ]),
      f("div", bV, [
        Ve(ze(sr), {
          defaultSizes: [15, 60, 25],
          class: "horizontal-split"
        }, {
          default: Wt(() => [
            Ve(ze(sr).Pane, {
              minSize: 150,
              maxSize: 400
            }, {
              default: Wt(() => [
                f("div", wV, [
                  f("div", _V, [
                    f("button", {
                      class: _e({ active: o.value === "project" }),
                      onClick: te[7] || (te[7] = (Me) => o.value = "project")
                    }, " Project ", 2),
                    f("button", {
                      class: _e({ active: o.value === "effects" }),
                      onClick: te[8] || (te[8] = (Me) => o.value = "effects")
                    }, " Effects ", 2)
                  ]),
                  f("div", xV, [
                    o.value === "project" ? ($(), st(Ik, { key: 0 })) : o.value === "effects" ? ($(), st(pO, { key: 1 })) : ve("", !0)
                  ])
                ])
              ]),
              _: 1
            }),
            Ve(ze(sr).Pane, { minSize: 400 }, {
              default: Wt(() => [
                Ve(ze(sr), {
                  vertical: "",
                  defaultSizes: [65, 35]
                }, {
                  default: Wt(() => [
                    Ve(ze(sr).Pane, { minSize: 200 }, {
                      default: Wt(() => [
                        f("div", SV, [
                          f("div", CV, [
                            f("div", kV, [
                              f("button", {
                                class: _e({ active: a.value === "composition" }),
                                onClick: te[9] || (te[9] = (Me) => a.value = "composition")
                              }, " Composition ", 2),
                              f("button", {
                                class: _e({ active: a.value === "layer" }),
                                onClick: te[10] || (te[10] = (Me) => a.value = "layer")
                              }, " Layer ", 2),
                              f("button", {
                                class: _e({ active: a.value === "footage" }),
                                onClick: te[11] || (te[11] = (Me) => a.value = "footage")
                              }, " Footage ", 2)
                            ]),
                            f("div", OV, [
                              ot(f("select", {
                                "onUpdate:modelValue": te[12] || (te[12] = (Me) => l.value = Me),
                                class: "zoom-select"
                              }, [...te[36] || (te[36] = [
                                f("option", { value: "fit" }, "Fit", -1),
                                f("option", { value: "25" }, "25%", -1),
                                f("option", { value: "50" }, "50%", -1),
                                f("option", { value: "100" }, "100%", -1),
                                f("option", { value: "200" }, "200%", -1)
                              ])], 512), [
                                [Zr, l.value]
                              ]),
                              f("button", {
                                class: _e({ active: u.value }),
                                onClick: te[13] || (te[13] = (Me) => u.value = !u.value),
                                title: "Toggle Guides"
                              }, [...te[37] || (te[37] = [
                                f("span", { class: "icon" }, "", -1)
                              ])], 2),
                              f("button", {
                                class: _e({ active: c.value }),
                                onClick: te[14] || (te[14] = (Me) => c.value = !c.value),
                                title: "Toggle Grid"
                              }, [...te[38] || (te[38] = [
                                f("span", { class: "icon" }, "", -1)
                              ])], 2)
                            ])
                          ]),
                          f("div", EV, [
                            a.value === "composition" ? ($(), st(T3, {
                              key: 0,
                              camera: y.value,
                              viewportState: w.value,
                              viewOptions: g.value,
                              compWidth: k.value,
                              compHeight: _.value
                            }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"])) : ($(), st(HA, {
                              key: 1,
                              ref_key: "canvasRef",
                              ref: v
                            }, null, 512))
                          ])
                        ])
                      ]),
                      _: 1
                    }),
                    Ve(ze(sr).Pane, { minSize: 150 }, {
                      default: Wt(() => [
                        Ve(ze(sr), {
                          vertical: "",
                          defaultSizes: d.value ? [50, 50] : [100, 0]
                        }, {
                          default: Wt(() => [
                            Ve(ze(sr).Pane, { minSize: 100 }, {
                              default: Wt(() => [
                                f("div", TV, [
                                  Ve(j6)
                                ])
                              ]),
                              _: 1
                            }),
                            d.value ? ($(), st(ze(sr).Pane, {
                              key: 0,
                              minSize: 100
                            }, {
                              default: Wt(() => [
                                f("div", DV, [
                                  Ve(k8, {
                                    onClose: te[15] || (te[15] = (Me) => d.value = !1)
                                  })
                                ])
                              ]),
                              _: 1
                            })) : ve("", !0)
                          ]),
                          _: 1
                        }, 8, ["defaultSizes"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            Ve(ze(sr).Pane, {
              minSize: 200,
              maxSize: 450
            }, {
              default: Wt(() => [
                f("div", $V, [
                  f("div", MV, [
                    f("button", {
                      class: _e({ active: s.value === "properties" }),
                      onClick: te[16] || (te[16] = (Me) => s.value = "properties")
                    }, " Properties ", 2),
                    f("button", {
                      class: _e({ active: s.value === "camera" }),
                      onClick: te[17] || (te[17] = (Me) => s.value = "camera")
                    }, " Camera ", 2),
                    f("button", {
                      class: _e({ active: s.value === "audio" }),
                      onClick: te[18] || (te[18] = (Me) => s.value = "audio")
                    }, " Audio ", 2)
                  ]),
                  f("div", PV, [
                    s.value === "properties" ? ($(), st(iI, { key: 0 })) : s.value === "camera" ? ($(), st(w5, {
                      key: 1,
                      camera: y.value,
                      "onUpdate:camera": ae
                    }, null, 8, ["camera"])) : s.value === "audio" ? ($(), st(s3, { key: 2 })) : ve("", !0)
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      f("div", IV, [
        f("div", LV, [
          f("span", AV, Q(I.value), 1),
          te[39] || (te[39] = f("span", { class: "status-divider" }, "|", -1)),
          f("span", VV, Q(F.value), 1)
        ]),
        f("div", FV, [
          C.value > 0 ? ($(), A("span", jV, " Rendering: " + Q(Math.round(C.value * 100)) + "% ", 1)) : ve("", !0)
        ]),
        f("div", RV, [
          f("span", NV, Q(b.value), 1),
          te[40] || (te[40] = f("span", { class: "status-divider" }, "|", -1)),
          f("span", zV, Q(S.value) + " fps", 1)
        ])
      ]),
      h.value ? ($(), st(aV, {
        key: 0,
        onClose: te[19] || (te[19] = (Me) => h.value = !1),
        onExported: $e
      })) : ve("", !0)
    ]));
  }
}), HV = /* @__PURE__ */ cn(BV, [["__scopeId", "data-v-1f442a6a"]]), UV = /* @__PURE__ */ tn({
  __name: "App",
  setup(i) {
    return (e, n) => ($(), st(HV));
  }
});
var Mo = {
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  getLoadedStyleNames: function() {
    return this._loadedStyleNames;
  },
  isStyleNameLoaded: function(e) {
    return this._loadedStyleNames.has(e);
  },
  setLoadedStyleName: function(e) {
    this._loadedStyleNames.add(e);
  },
  deleteLoadedStyleName: function(e) {
    this._loadedStyleNames.delete(e);
  },
  clearLoadedStyleNames: function() {
    this._loadedStyleNames.clear();
  }
};
function WV() {
  var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "pc", e = D_();
  return "".concat(i).concat(e.replace("v-", "").replaceAll("-", "_"));
}
var Dv = bt.extend({
  name: "common"
});
function Vl(i) {
  "@babel/helpers - typeof";
  return Vl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Vl(i);
}
function GV(i) {
  return T1(i) || XV(i) || E1(i) || O1();
}
function XV(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function Ga(i, e) {
  return T1(i) || YV(i, e) || E1(i, e) || O1();
}
function O1() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function E1(i, e) {
  if (i) {
    if (typeof i == "string") return af(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? af(i, e) : void 0;
  }
}
function af(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function YV(i, e) {
  var n = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (n != null) {
    var r, o, s, a, l = [], u = !0, c = !1;
    try {
      if (s = (n = n.call(i)).next, e === 0) {
        if (Object(n) !== n) return;
        u = !1;
      } else for (; !(u = (r = s.call(n)).done) && (l.push(r.value), l.length !== e); u = !0) ;
    } catch (d) {
      c = !0, o = d;
    } finally {
      try {
        if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return;
      } finally {
        if (c) throw o;
      }
    }
    return l;
  }
}
function T1(i) {
  if (Array.isArray(i)) return i;
}
function $v(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pt(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? $v(Object(n), !0).forEach(function(r) {
      el(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : $v(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function el(i, e, n) {
  return (e = KV(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function KV(i) {
  var e = qV(i, "string");
  return Vl(e) == "symbol" ? e : e + "";
}
function qV(i, e) {
  if (Vl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Vl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var Ho = {
  name: "BaseComponent",
  props: {
    pt: {
      type: Object,
      default: void 0
    },
    ptOptions: {
      type: Object,
      default: void 0
    },
    unstyled: {
      type: Boolean,
      default: void 0
    },
    dt: {
      type: Object,
      default: void 0
    }
  },
  inject: {
    $parentInstance: {
      default: void 0
    }
  },
  watch: {
    isUnstyled: {
      immediate: !0,
      handler: function(e) {
        Dn.off("theme:change", this._loadCoreStyles), e || (this._loadCoreStyles(), this._themeChangeListener(this._loadCoreStyles));
      }
    },
    dt: {
      immediate: !0,
      handler: function(e, n) {
        var r = this;
        Dn.off("theme:change", this._themeScopedListener), e ? (this._loadScopedThemeStyles(e), this._themeScopedListener = function() {
          return r._loadScopedThemeStyles(e);
        }, this._themeChangeListener(this._themeScopedListener)) : this._unloadScopedThemeStyles();
      }
    }
  },
  scopedStyleEl: void 0,
  rootEl: void 0,
  uid: void 0,
  $attrSelector: void 0,
  beforeCreate: function() {
    var e, n, r, o, s, a, l, u, c, d, h, p = (e = this.pt) === null || e === void 0 ? void 0 : e._usept, m = p ? (n = this.pt) === null || n === void 0 || (n = n.originalValue) === null || n === void 0 ? void 0 : n[this.$.type.name] : void 0, v = p ? (r = this.pt) === null || r === void 0 || (r = r.value) === null || r === void 0 ? void 0 : r[this.$.type.name] : this.pt;
    (o = v || m) === null || o === void 0 || (o = o.hooks) === null || o === void 0 || (s = o.onBeforeCreate) === null || s === void 0 || s.call(o);
    var y = (a = this.$primevueConfig) === null || a === void 0 || (a = a.pt) === null || a === void 0 ? void 0 : a._usept, w = y ? (l = this.$primevue) === null || l === void 0 || (l = l.config) === null || l === void 0 || (l = l.pt) === null || l === void 0 ? void 0 : l.originalValue : void 0, g = y ? (u = this.$primevue) === null || u === void 0 || (u = u.config) === null || u === void 0 || (u = u.pt) === null || u === void 0 ? void 0 : u.value : (c = this.$primevue) === null || c === void 0 || (c = c.config) === null || c === void 0 ? void 0 : c.pt;
    (d = g || w) === null || d === void 0 || (d = d[this.$.type.name]) === null || d === void 0 || (d = d.hooks) === null || d === void 0 || (h = d.onBeforeCreate) === null || h === void 0 || h.call(d), this.$attrSelector = WV(), this.uid = this.$attrs.id || this.$attrSelector.replace("pc", "pv_id_");
  },
  created: function() {
    this._hook("onCreated");
  },
  beforeMount: function() {
    var e;
    this.rootEl = ba(Is(this.$el) ? this.$el : (e = this.$el) === null || e === void 0 ? void 0 : e.parentElement, "[".concat(this.$attrSelector, "]")), this.rootEl && (this.rootEl.$pc = pt({
      name: this.$.type.name,
      attrSelector: this.$attrSelector
    }, this.$params)), this._loadStyles(), this._hook("onBeforeMount");
  },
  mounted: function() {
    this._hook("onMounted");
  },
  beforeUpdate: function() {
    this._hook("onBeforeUpdate");
  },
  updated: function() {
    this._hook("onUpdated");
  },
  beforeUnmount: function() {
    this._hook("onBeforeUnmount");
  },
  unmounted: function() {
    this._removeThemeListeners(), this._unloadScopedThemeStyles(), this._hook("onUnmounted");
  },
  methods: {
    _hook: function(e) {
      if (!this.$options.hostName) {
        var n = this._usePT(this._getPT(this.pt, this.$.type.name), this._getOptionValue, "hooks.".concat(e)), r = this._useDefaultPT(this._getOptionValue, "hooks.".concat(e));
        n == null || n(), r == null || r();
      }
    },
    _mergeProps: function(e) {
      for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
        r[o - 1] = arguments[o];
      return hd(e) ? e.apply(void 0, r) : ke.apply(void 0, r);
    },
    _load: function() {
      Mo.isStyleNameLoaded("base") || (bt.loadCSS(this.$styleOptions), this._loadGlobalStyles(), Mo.setLoadedStyleName("base")), this._loadThemeStyles();
    },
    _loadStyles: function() {
      this._load(), this._themeChangeListener(this._load);
    },
    _loadCoreStyles: function() {
      var e, n;
      !Mo.isStyleNameLoaded((e = this.$style) === null || e === void 0 ? void 0 : e.name) && (n = this.$style) !== null && n !== void 0 && n.name && (Dv.loadCSS(this.$styleOptions), this.$options.style && this.$style.loadCSS(this.$styleOptions), Mo.setLoadedStyleName(this.$style.name));
    },
    _loadGlobalStyles: function() {
      var e = this._useGlobalPT(this._getOptionValue, "global.css", this.$params);
      gt(e) && bt.load(e, pt({
        name: "global"
      }, this.$styleOptions));
    },
    _loadThemeStyles: function() {
      var e, n;
      if (!(this.isUnstyled || this.$theme === "none")) {
        if (!Mt.isStyleNameLoaded("common")) {
          var r, o, s = ((r = this.$style) === null || r === void 0 || (o = r.getCommonTheme) === null || o === void 0 ? void 0 : o.call(r)) || {}, a = s.primitive, l = s.semantic, u = s.global, c = s.style;
          bt.load(a == null ? void 0 : a.css, pt({
            name: "primitive-variables"
          }, this.$styleOptions)), bt.load(l == null ? void 0 : l.css, pt({
            name: "semantic-variables"
          }, this.$styleOptions)), bt.load(u == null ? void 0 : u.css, pt({
            name: "global-variables"
          }, this.$styleOptions)), bt.loadStyle(pt({
            name: "global-style"
          }, this.$styleOptions), c), Mt.setLoadedStyleName("common");
        }
        if (!Mt.isStyleNameLoaded((e = this.$style) === null || e === void 0 ? void 0 : e.name) && (n = this.$style) !== null && n !== void 0 && n.name) {
          var d, h, p, m, v = ((d = this.$style) === null || d === void 0 || (h = d.getComponentTheme) === null || h === void 0 ? void 0 : h.call(d)) || {}, y = v.css, w = v.style;
          (p = this.$style) === null || p === void 0 || p.load(y, pt({
            name: "".concat(this.$style.name, "-variables")
          }, this.$styleOptions)), (m = this.$style) === null || m === void 0 || m.loadStyle(pt({
            name: "".concat(this.$style.name, "-style")
          }, this.$styleOptions), w), Mt.setLoadedStyleName(this.$style.name);
        }
        if (!Mt.isStyleNameLoaded("layer-order")) {
          var g, k, _ = (g = this.$style) === null || g === void 0 || (k = g.getLayerOrderThemeCSS) === null || k === void 0 ? void 0 : k.call(g);
          bt.load(_, pt({
            name: "layer-order",
            first: !0
          }, this.$styleOptions)), Mt.setLoadedStyleName("layer-order");
        }
      }
    },
    _loadScopedThemeStyles: function(e) {
      var n, r, o, s = ((n = this.$style) === null || n === void 0 || (r = n.getPresetTheme) === null || r === void 0 ? void 0 : r.call(n, e, "[".concat(this.$attrSelector, "]"))) || {}, a = s.css, l = (o = this.$style) === null || o === void 0 ? void 0 : o.load(a, pt({
        name: "".concat(this.$attrSelector, "-").concat(this.$style.name)
      }, this.$styleOptions));
      this.scopedStyleEl = l.el;
    },
    _unloadScopedThemeStyles: function() {
      var e;
      (e = this.scopedStyleEl) === null || e === void 0 || (e = e.value) === null || e === void 0 || e.remove();
    },
    _themeChangeListener: function() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
      };
      Mo.clearLoadedStyleNames(), Dn.on("theme:change", e);
    },
    _removeThemeListeners: function() {
      Dn.off("theme:change", this._loadCoreStyles), Dn.off("theme:change", this._load), Dn.off("theme:change", this._themeScopedListener);
    },
    _getHostInstance: function(e) {
      return e ? this.$options.hostName ? e.$.type.name === this.$options.hostName ? e : this._getHostInstance(e.$parentInstance) : e.$parentInstance : void 0;
    },
    _getPropValue: function(e) {
      var n;
      return this[e] || ((n = this._getHostInstance(this)) === null || n === void 0 ? void 0 : n[e]);
    },
    _getOptionValue: function(e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return Xf(e, n, r);
    },
    _getPTValue: function() {
      var e, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, a = /./g.test(r) && !!o[r.split(".")[0]], l = this._getPropValue("ptOptions") || ((e = this.$primevueConfig) === null || e === void 0 ? void 0 : e.ptOptions) || {}, u = l.mergeSections, c = u === void 0 ? !0 : u, d = l.mergeProps, h = d === void 0 ? !1 : d, p = s ? a ? this._useGlobalPT(this._getPTClassValue, r, o) : this._useDefaultPT(this._getPTClassValue, r, o) : void 0, m = a ? void 0 : this._getPTSelf(n, this._getPTClassValue, r, pt(pt({}, o), {}, {
        global: p || {}
      })), v = this._getPTDatasets(r);
      return c || !c && m ? h ? this._mergeProps(h, p, m, v) : pt(pt(pt({}, p), m), v) : pt(pt({}, m), v);
    },
    _getPTSelf: function() {
      for (var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
        r[o - 1] = arguments[o];
      return ke(
        this._usePT.apply(this, [this._getPT(e, this.$name)].concat(r)),
        // Exp; <component :pt="{}"
        this._usePT.apply(this, [this.$_attrsPT].concat(r))
        // Exp; <component :pt:[passthrough_key]:[attribute]="{value}" or <component :pt:[passthrough_key]="() =>{value}"
      );
    },
    _getPTDatasets: function() {
      var e, n, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", o = "data-pc-", s = r === "root" && gt((e = this.pt) === null || e === void 0 ? void 0 : e["data-pc-section"]);
      return r !== "transition" && pt(pt({}, r === "root" && pt(pt(el({}, "".concat(o, "name"), pr(s ? (n = this.pt) === null || n === void 0 ? void 0 : n["data-pc-section"] : this.$.type.name)), s && el({}, "".concat(o, "extend"), pr(this.$.type.name))), {}, el({}, "".concat(this.$attrSelector), ""))), {}, el({}, "".concat(o, "section"), pr(r)));
    },
    _getPTClassValue: function() {
      var e = this._getOptionValue.apply(this, arguments);
      return Jn(e) || H0(e) ? {
        class: e
      } : e;
    },
    _getPT: function(e) {
      var n = this, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", o = arguments.length > 2 ? arguments[2] : void 0, s = function(l) {
        var u, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, d = o ? o(l) : l, h = pr(r), p = pr(n.$name);
        return (u = c ? h !== p ? d == null ? void 0 : d[h] : void 0 : d == null ? void 0 : d[h]) !== null && u !== void 0 ? u : d;
      };
      return e != null && e.hasOwnProperty("_usept") ? {
        _usept: e._usept,
        originalValue: s(e.originalValue),
        value: s(e.value)
      } : s(e, !0);
    },
    _usePT: function(e, n, r, o) {
      var s = function(y) {
        return n(y, r, o);
      };
      if (e != null && e.hasOwnProperty("_usept")) {
        var a, l = e._usept || ((a = this.$primevueConfig) === null || a === void 0 ? void 0 : a.ptOptions) || {}, u = l.mergeSections, c = u === void 0 ? !0 : u, d = l.mergeProps, h = d === void 0 ? !1 : d, p = s(e.originalValue), m = s(e.value);
        return p === void 0 && m === void 0 ? void 0 : Jn(m) ? m : Jn(p) ? p : c || !c && m ? h ? this._mergeProps(h, p, m) : pt(pt({}, p), m) : m;
      }
      return s(e);
    },
    _useGlobalPT: function(e, n, r) {
      return this._usePT(this.globalPT, e, n, r);
    },
    _useDefaultPT: function(e, n, r) {
      return this._usePT(this.defaultPT, e, n, r);
    },
    ptm: function() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this._getPTValue(this.pt, e, pt(pt({}, this.$params), n));
    },
    ptmi: function() {
      var e, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = ke(this.$_attrsWithoutPT, this.ptm(n, r));
      return o != null && o.hasOwnProperty("id") && ((e = o.id) !== null && e !== void 0 || (o.id = this.$id)), o;
    },
    ptmo: function() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this._getPTValue(e, n, pt({
        instance: this
      }, r), !1);
    },
    cx: function() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this.isUnstyled ? void 0 : this._getOptionValue(this.$style.classes, e, pt(pt({}, this.$params), n));
    },
    sx: function() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (n) {
        var o = this._getOptionValue(this.$style.inlineStyles, e, pt(pt({}, this.$params), r)), s = this._getOptionValue(Dv.inlineStyles, e, pt(pt({}, this.$params), r));
        return [s, o];
      }
    }
  },
  computed: {
    globalPT: function() {
      var e, n = this;
      return this._getPT((e = this.$primevueConfig) === null || e === void 0 ? void 0 : e.pt, void 0, function(r) {
        return li(r, {
          instance: n
        });
      });
    },
    defaultPT: function() {
      var e, n = this;
      return this._getPT((e = this.$primevueConfig) === null || e === void 0 ? void 0 : e.pt, void 0, function(r) {
        return n._getOptionValue(r, n.$name, pt({}, n.$params)) || li(r, pt({}, n.$params));
      });
    },
    isUnstyled: function() {
      var e;
      return this.unstyled !== void 0 ? this.unstyled : (e = this.$primevueConfig) === null || e === void 0 ? void 0 : e.unstyled;
    },
    $id: function() {
      return this.$attrs.id || this.uid;
    },
    $inProps: function() {
      var e, n = Object.keys(((e = this.$.vnode) === null || e === void 0 ? void 0 : e.props) || {});
      return Object.fromEntries(Object.entries(this.$props).filter(function(r) {
        var o = Ga(r, 1), s = o[0];
        return n == null ? void 0 : n.includes(s);
      }));
    },
    $theme: function() {
      var e;
      return (e = this.$primevueConfig) === null || e === void 0 ? void 0 : e.theme;
    },
    $style: function() {
      return pt(pt({
        classes: void 0,
        inlineStyles: void 0,
        load: function() {
        },
        loadCSS: function() {
        },
        loadStyle: function() {
        }
      }, (this._getHostInstance(this) || {}).$style), this.$options.style);
    },
    $styleOptions: function() {
      var e;
      return {
        nonce: (e = this.$primevueConfig) === null || e === void 0 || (e = e.csp) === null || e === void 0 ? void 0 : e.nonce
      };
    },
    $primevueConfig: function() {
      var e;
      return (e = this.$primevue) === null || e === void 0 ? void 0 : e.config;
    },
    $name: function() {
      return this.$options.hostName || this.$.type.name;
    },
    $params: function() {
      var e = this._getHostInstance(this) || this.$parent;
      return {
        instance: this,
        props: this.$props,
        state: this.$data,
        attrs: this.$attrs,
        parent: {
          instance: e,
          props: e == null ? void 0 : e.$props,
          state: e == null ? void 0 : e.$data,
          attrs: e == null ? void 0 : e.$attrs
        }
      };
    },
    $_attrsPT: function() {
      return Object.entries(this.$attrs || {}).filter(function(e) {
        var n = Ga(e, 1), r = n[0];
        return r == null ? void 0 : r.startsWith("pt:");
      }).reduce(function(e, n) {
        var r = Ga(n, 2), o = r[0], s = r[1], a = o.split(":"), l = GV(a), u = af(l).slice(1);
        return u == null || u.reduce(function(c, d, h, p) {
          return !c[d] && (c[d] = h === p.length - 1 ? s : {}), c[d];
        }, e), e;
      }, {});
    },
    $_attrsWithoutPT: function() {
      return Object.entries(this.$attrs || {}).filter(function(e) {
        var n = Ga(e, 1), r = n[0];
        return !(r != null && r.startsWith("pt:"));
      }).reduce(function(e, n) {
        var r = Ga(n, 2), o = r[0], s = r[1];
        return e[o] = s, e;
      }, {});
    }
  }
}, ZV = `
.p-icon {
    display: inline-block;
    vertical-align: baseline;
    flex-shrink: 0;
}

.p-icon-spin {
    -webkit-animation: p-icon-spin 2s infinite linear;
    animation: p-icon-spin 2s infinite linear;
}

@-webkit-keyframes p-icon-spin {
    0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
    }
    100% {
        -webkit-transform: rotate(359deg);
        transform: rotate(359deg);
    }
}

@keyframes p-icon-spin {
    0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
    }
    100% {
        -webkit-transform: rotate(359deg);
        transform: rotate(359deg);
    }
}
`, JV = bt.extend({
  name: "baseicon",
  css: ZV
});
function Fl(i) {
  "@babel/helpers - typeof";
  return Fl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Fl(i);
}
function Mv(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pv(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Mv(Object(n), !0).forEach(function(r) {
      QV(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : Mv(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function QV(i, e, n) {
  return (e = eF(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function eF(i) {
  var e = tF(i, "string");
  return Fl(e) == "symbol" ? e : e + "";
}
function tF(i, e) {
  if (Fl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Fl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var kr = {
  name: "BaseIcon",
  extends: Ho,
  props: {
    label: {
      type: String,
      default: void 0
    },
    spin: {
      type: Boolean,
      default: !1
    }
  },
  style: JV,
  provide: function() {
    return {
      $pcIcon: this,
      $parentInstance: this
    };
  },
  methods: {
    pti: function() {
      var e = Ji(this.label);
      return Pv(Pv({}, !this.isUnstyled && {
        class: ["p-icon", {
          "p-icon-spin": this.spin
        }]
      }), {}, {
        role: e ? void 0 : "img",
        "aria-label": e ? void 0 : this.label,
        "aria-hidden": e
      });
    }
  }
}, kd = {
  name: "SpinnerIcon",
  extends: kr
};
function nF(i) {
  return sF(i) || oF(i) || rF(i) || iF();
}
function iF() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function rF(i, e) {
  if (i) {
    if (typeof i == "string") return lf(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? lf(i, e) : void 0;
  }
}
function oF(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function sF(i) {
  if (Array.isArray(i)) return lf(i);
}
function lf(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function aF(i, e, n, r, o, s) {
  return $(), A("svg", ke({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i.pti()), nF(e[0] || (e[0] = [f("path", {
    d: "M6.99701 14C5.85441 13.999 4.72939 13.7186 3.72012 13.1832C2.71084 12.6478 1.84795 11.8737 1.20673 10.9284C0.565504 9.98305 0.165424 8.89526 0.041387 7.75989C-0.0826496 6.62453 0.073125 5.47607 0.495122 4.4147C0.917119 3.35333 1.59252 2.4113 2.46241 1.67077C3.33229 0.930247 4.37024 0.413729 5.4857 0.166275C6.60117 -0.0811796 7.76026 -0.0520535 8.86188 0.251112C9.9635 0.554278 10.9742 1.12227 11.8057 1.90555C11.915 2.01493 11.9764 2.16319 11.9764 2.31778C11.9764 2.47236 11.915 2.62062 11.8057 2.73C11.7521 2.78503 11.688 2.82877 11.6171 2.85864C11.5463 2.8885 11.4702 2.90389 11.3933 2.90389C11.3165 2.90389 11.2404 2.8885 11.1695 2.85864C11.0987 2.82877 11.0346 2.78503 10.9809 2.73C9.9998 1.81273 8.73246 1.26138 7.39226 1.16876C6.05206 1.07615 4.72086 1.44794 3.62279 2.22152C2.52471 2.99511 1.72683 4.12325 1.36345 5.41602C1.00008 6.70879 1.09342 8.08723 1.62775 9.31926C2.16209 10.5513 3.10478 11.5617 4.29713 12.1803C5.48947 12.7989 6.85865 12.988 8.17414 12.7157C9.48963 12.4435 10.6711 11.7264 11.5196 10.6854C12.3681 9.64432 12.8319 8.34282 12.8328 7C12.8328 6.84529 12.8943 6.69692 13.0038 6.58752C13.1132 6.47812 13.2616 6.41667 13.4164 6.41667C13.5712 6.41667 13.7196 6.47812 13.8291 6.58752C13.9385 6.69692 14 6.84529 14 7C14 8.85651 13.2622 10.637 11.9489 11.9497C10.6356 13.2625 8.85432 14 6.99701 14Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
kd.render = aF;
var lF = `
    .p-badge {
        display: inline-flex;
        border-radius: dt('badge.border.radius');
        align-items: center;
        justify-content: center;
        padding: dt('badge.padding');
        background: dt('badge.primary.background');
        color: dt('badge.primary.color');
        font-size: dt('badge.font.size');
        font-weight: dt('badge.font.weight');
        min-width: dt('badge.min.width');
        height: dt('badge.height');
    }

    .p-badge-dot {
        width: dt('badge.dot.size');
        min-width: dt('badge.dot.size');
        height: dt('badge.dot.size');
        border-radius: 50%;
        padding: 0;
    }

    .p-badge-circle {
        padding: 0;
        border-radius: 50%;
    }

    .p-badge-secondary {
        background: dt('badge.secondary.background');
        color: dt('badge.secondary.color');
    }

    .p-badge-success {
        background: dt('badge.success.background');
        color: dt('badge.success.color');
    }

    .p-badge-info {
        background: dt('badge.info.background');
        color: dt('badge.info.color');
    }

    .p-badge-warn {
        background: dt('badge.warn.background');
        color: dt('badge.warn.color');
    }

    .p-badge-danger {
        background: dt('badge.danger.background');
        color: dt('badge.danger.color');
    }

    .p-badge-contrast {
        background: dt('badge.contrast.background');
        color: dt('badge.contrast.color');
    }

    .p-badge-sm {
        font-size: dt('badge.sm.font.size');
        min-width: dt('badge.sm.min.width');
        height: dt('badge.sm.height');
    }

    .p-badge-lg {
        font-size: dt('badge.lg.font.size');
        min-width: dt('badge.lg.min.width');
        height: dt('badge.lg.height');
    }

    .p-badge-xl {
        font-size: dt('badge.xl.font.size');
        min-width: dt('badge.xl.min.width');
        height: dt('badge.xl.height');
    }
`, uF = {
  root: function(e) {
    var n = e.props, r = e.instance;
    return ["p-badge p-component", {
      "p-badge-circle": gt(n.value) && String(n.value).length === 1,
      "p-badge-dot": Ji(n.value) && !r.$slots.default,
      "p-badge-sm": n.size === "small",
      "p-badge-lg": n.size === "large",
      "p-badge-xl": n.size === "xlarge",
      "p-badge-info": n.severity === "info",
      "p-badge-success": n.severity === "success",
      "p-badge-warn": n.severity === "warn",
      "p-badge-danger": n.severity === "danger",
      "p-badge-secondary": n.severity === "secondary",
      "p-badge-contrast": n.severity === "contrast"
    }];
  }
}, cF = bt.extend({
  name: "badge",
  style: lF,
  classes: uF
}), dF = {
  name: "BaseBadge",
  extends: Ho,
  props: {
    value: {
      type: [String, Number],
      default: null
    },
    severity: {
      type: String,
      default: null
    },
    size: {
      type: String,
      default: null
    }
  },
  style: cF,
  provide: function() {
    return {
      $pcBadge: this,
      $parentInstance: this
    };
  }
};
function jl(i) {
  "@babel/helpers - typeof";
  return jl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, jl(i);
}
function Iv(i, e, n) {
  return (e = hF(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function hF(i) {
  var e = fF(i, "string");
  return jl(e) == "symbol" ? e : e + "";
}
function fF(i, e) {
  if (jl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (jl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var D1 = {
  name: "Badge",
  extends: dF,
  inheritAttrs: !1,
  computed: {
    dataP: function() {
      return ui(Iv(Iv({
        circle: this.value != null && String(this.value).length === 1,
        empty: this.value == null && !this.$slots.default
      }, this.severity, this.severity), this.size, this.size));
    }
  }
}, pF = ["data-p"];
function mF(i, e, n, r, o, s) {
  return $(), A("span", ke({
    class: i.cx("root"),
    "data-p": s.dataP
  }, i.ptmi("root")), [it(i.$slots, "default", {}, function() {
    return [vt(Q(i.value), 1)];
  })], 16, pF);
}
D1.render = mF;
function Rl(i) {
  "@babel/helpers - typeof";
  return Rl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Rl(i);
}
function Lv(i, e) {
  return bF(i) || yF(i, e) || vF(i, e) || gF();
}
function gF() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function vF(i, e) {
  if (i) {
    if (typeof i == "string") return Av(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Av(i, e) : void 0;
  }
}
function Av(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function yF(i, e) {
  var n = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (n != null) {
    var r, o, s, a, l = [], u = !0, c = !1;
    try {
      if (s = (n = n.call(i)).next, e !== 0) for (; !(u = (r = s.call(n)).done) && (l.push(r.value), l.length !== e); u = !0) ;
    } catch (d) {
      c = !0, o = d;
    } finally {
      try {
        if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return;
      } finally {
        if (c) throw o;
      }
    }
    return l;
  }
}
function bF(i) {
  if (Array.isArray(i)) return i;
}
function Vv(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ct(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Vv(Object(n), !0).forEach(function(r) {
      uf(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : Vv(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function uf(i, e, n) {
  return (e = wF(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function wF(i) {
  var e = _F(i, "string");
  return Rl(e) == "symbol" ? e : e + "";
}
function _F(i, e) {
  if (Rl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Rl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var rt = {
  _getMeta: function() {
    return [_r(arguments.length <= 0 ? void 0 : arguments[0]) || arguments.length <= 0 ? void 0 : arguments[0], li(_r(arguments.length <= 0 ? void 0 : arguments[0]) ? arguments.length <= 0 ? void 0 : arguments[0] : arguments.length <= 1 ? void 0 : arguments[1])];
  },
  _getConfig: function(e, n) {
    var r, o, s;
    return (r = (e == null || (o = e.instance) === null || o === void 0 ? void 0 : o.$primevue) || (n == null || (s = n.ctx) === null || s === void 0 || (s = s.appContext) === null || s === void 0 || (s = s.config) === null || s === void 0 || (s = s.globalProperties) === null || s === void 0 ? void 0 : s.$primevue)) === null || r === void 0 ? void 0 : r.config;
  },
  _getOptionValue: Xf,
  _getPTValue: function() {
    var e, n, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "", a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, u = function() {
      var k = rt._getOptionValue.apply(rt, arguments);
      return Jn(k) || H0(k) ? {
        class: k
      } : k;
    }, c = ((e = r.binding) === null || e === void 0 || (e = e.value) === null || e === void 0 ? void 0 : e.ptOptions) || ((n = r.$primevueConfig) === null || n === void 0 ? void 0 : n.ptOptions) || {}, d = c.mergeSections, h = d === void 0 ? !0 : d, p = c.mergeProps, m = p === void 0 ? !1 : p, v = l ? rt._useDefaultPT(r, r.defaultPT(), u, s, a) : void 0, y = rt._usePT(r, rt._getPT(o, r.$name), u, s, Ct(Ct({}, a), {}, {
      global: v || {}
    })), w = rt._getPTDatasets(r, s);
    return h || !h && y ? m ? rt._mergeProps(r, m, v, y, w) : Ct(Ct(Ct({}, v), y), w) : Ct(Ct({}, y), w);
  },
  _getPTDatasets: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", r = "data-pc-";
    return Ct(Ct({}, n === "root" && uf({}, "".concat(r, "name"), pr(e.$name))), {}, uf({}, "".concat(r, "section"), pr(n)));
  },
  _getPT: function(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", r = arguments.length > 2 ? arguments[2] : void 0, o = function(a) {
      var l, u = r ? r(a) : a, c = pr(n);
      return (l = u == null ? void 0 : u[c]) !== null && l !== void 0 ? l : u;
    };
    return e && Object.hasOwn(e, "_usept") ? {
      _usept: e._usept,
      originalValue: o(e.originalValue),
      value: o(e.value)
    } : o(e);
  },
  _usePT: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 ? arguments[2] : void 0, o = arguments.length > 3 ? arguments[3] : void 0, s = arguments.length > 4 ? arguments[4] : void 0, a = function(w) {
      return r(w, o, s);
    };
    if (n && Object.hasOwn(n, "_usept")) {
      var l, u = n._usept || ((l = e.$primevueConfig) === null || l === void 0 ? void 0 : l.ptOptions) || {}, c = u.mergeSections, d = c === void 0 ? !0 : c, h = u.mergeProps, p = h === void 0 ? !1 : h, m = a(n.originalValue), v = a(n.value);
      return m === void 0 && v === void 0 ? void 0 : Jn(v) ? v : Jn(m) ? m : d || !d && v ? p ? rt._mergeProps(e, p, m, v) : Ct(Ct({}, m), v) : v;
    }
    return a(n);
  },
  _useDefaultPT: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 ? arguments[2] : void 0, o = arguments.length > 3 ? arguments[3] : void 0, s = arguments.length > 4 ? arguments[4] : void 0;
    return rt._usePT(e, n, r, o, s);
  },
  _loadStyles: function() {
    var e, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0, o = arguments.length > 2 ? arguments[2] : void 0, s = rt._getConfig(r, o), a = {
      nonce: s == null || (e = s.csp) === null || e === void 0 ? void 0 : e.nonce
    };
    rt._loadCoreStyles(n, a), rt._loadThemeStyles(n, a), rt._loadScopedThemeStyles(n, a), rt._removeThemeListeners(n), n.$loadStyles = function() {
      return rt._loadThemeStyles(n, a);
    }, rt._themeChangeListener(n.$loadStyles);
  },
  _loadCoreStyles: function() {
    var e, n, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 ? arguments[1] : void 0;
    if (!Mo.isStyleNameLoaded((e = r.$style) === null || e === void 0 ? void 0 : e.name) && (n = r.$style) !== null && n !== void 0 && n.name) {
      var s;
      bt.loadCSS(o), (s = r.$style) === null || s === void 0 || s.loadCSS(o), Mo.setLoadedStyleName(r.$style.name);
    }
  },
  _loadThemeStyles: function() {
    var e, n, r, o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 ? arguments[1] : void 0;
    if (!(o != null && o.isUnstyled() || (o == null || (e = o.theme) === null || e === void 0 ? void 0 : e.call(o)) === "none")) {
      if (!Mt.isStyleNameLoaded("common")) {
        var a, l, u = ((a = o.$style) === null || a === void 0 || (l = a.getCommonTheme) === null || l === void 0 ? void 0 : l.call(a)) || {}, c = u.primitive, d = u.semantic, h = u.global, p = u.style;
        bt.load(c == null ? void 0 : c.css, Ct({
          name: "primitive-variables"
        }, s)), bt.load(d == null ? void 0 : d.css, Ct({
          name: "semantic-variables"
        }, s)), bt.load(h == null ? void 0 : h.css, Ct({
          name: "global-variables"
        }, s)), bt.loadStyle(Ct({
          name: "global-style"
        }, s), p), Mt.setLoadedStyleName("common");
      }
      if (!Mt.isStyleNameLoaded((n = o.$style) === null || n === void 0 ? void 0 : n.name) && (r = o.$style) !== null && r !== void 0 && r.name) {
        var m, v, y, w, g = ((m = o.$style) === null || m === void 0 || (v = m.getDirectiveTheme) === null || v === void 0 ? void 0 : v.call(m)) || {}, k = g.css, _ = g.style;
        (y = o.$style) === null || y === void 0 || y.load(k, Ct({
          name: "".concat(o.$style.name, "-variables")
        }, s)), (w = o.$style) === null || w === void 0 || w.loadStyle(Ct({
          name: "".concat(o.$style.name, "-style")
        }, s), _), Mt.setLoadedStyleName(o.$style.name);
      }
      if (!Mt.isStyleNameLoaded("layer-order")) {
        var S, b, C = (S = o.$style) === null || S === void 0 || (b = S.getLayerOrderThemeCSS) === null || b === void 0 ? void 0 : b.call(S);
        bt.load(C, Ct({
          name: "layer-order",
          first: !0
        }, s)), Mt.setLoadedStyleName("layer-order");
      }
    }
  },
  _loadScopedThemeStyles: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0, r = e.preset();
    if (r && e.$attrSelector) {
      var o, s, a, l = ((o = e.$style) === null || o === void 0 || (s = o.getPresetTheme) === null || s === void 0 ? void 0 : s.call(o, r, "[".concat(e.$attrSelector, "]"))) || {}, u = l.css, c = (a = e.$style) === null || a === void 0 ? void 0 : a.load(u, Ct({
        name: "".concat(e.$attrSelector, "-").concat(e.$style.name)
      }, n));
      e.scopedStyleEl = c.el;
    }
  },
  _themeChangeListener: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
    };
    Mo.clearLoadedStyleNames(), Dn.on("theme:change", e);
  },
  _removeThemeListeners: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Dn.off("theme:change", e.$loadStyles), e.$loadStyles = void 0;
  },
  _hook: function(e, n, r, o, s, a) {
    var l, u, c = "on".concat(fC(n)), d = rt._getConfig(o, s), h = r == null ? void 0 : r.$instance, p = rt._usePT(h, rt._getPT(o == null || (l = o.value) === null || l === void 0 ? void 0 : l.pt, e), rt._getOptionValue, "hooks.".concat(c)), m = rt._useDefaultPT(h, d == null || (u = d.pt) === null || u === void 0 || (u = u.directives) === null || u === void 0 ? void 0 : u[e], rt._getOptionValue, "hooks.".concat(c)), v = {
      el: r,
      binding: o,
      vnode: s,
      prevVnode: a
    };
    p == null || p(h, v), m == null || m(h, v);
  },
  /* eslint-disable-next-line no-unused-vars */
  _mergeProps: function() {
    for (var e = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
      r[o - 2] = arguments[o];
    return hd(e) ? e.apply(void 0, r) : ke.apply(void 0, r);
  },
  _extend: function(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = function(l, u, c, d, h) {
      var p, m, v, y;
      u._$instances = u._$instances || {};
      var w = rt._getConfig(c, d), g = u._$instances[e] || {}, k = Ji(g) ? Ct(Ct({}, n), n == null ? void 0 : n.methods) : {};
      u._$instances[e] = Ct(Ct({}, g), {}, {
        /* new instance variables to pass in directive methods */
        $name: e,
        $host: u,
        $binding: c,
        $modifiers: c == null ? void 0 : c.modifiers,
        $value: c == null ? void 0 : c.value,
        $el: g.$el || u || void 0,
        $style: Ct({
          classes: void 0,
          inlineStyles: void 0,
          load: function() {
          },
          loadCSS: function() {
          },
          loadStyle: function() {
          }
        }, n == null ? void 0 : n.style),
        $primevueConfig: w,
        $attrSelector: (p = u.$pd) === null || p === void 0 || (p = p[e]) === null || p === void 0 ? void 0 : p.attrSelector,
        /* computed instance variables */
        defaultPT: function() {
          return rt._getPT(w == null ? void 0 : w.pt, void 0, function(S) {
            var b;
            return S == null || (b = S.directives) === null || b === void 0 ? void 0 : b[e];
          });
        },
        isUnstyled: function() {
          var S, b;
          return ((S = u._$instances[e]) === null || S === void 0 || (S = S.$binding) === null || S === void 0 || (S = S.value) === null || S === void 0 ? void 0 : S.unstyled) !== void 0 ? (b = u._$instances[e]) === null || b === void 0 || (b = b.$binding) === null || b === void 0 || (b = b.value) === null || b === void 0 ? void 0 : b.unstyled : w == null ? void 0 : w.unstyled;
        },
        theme: function() {
          var S;
          return (S = u._$instances[e]) === null || S === void 0 || (S = S.$primevueConfig) === null || S === void 0 ? void 0 : S.theme;
        },
        preset: function() {
          var S;
          return (S = u._$instances[e]) === null || S === void 0 || (S = S.$binding) === null || S === void 0 || (S = S.value) === null || S === void 0 ? void 0 : S.dt;
        },
        /* instance's methods */
        ptm: function() {
          var S, b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return rt._getPTValue(u._$instances[e], (S = u._$instances[e]) === null || S === void 0 || (S = S.$binding) === null || S === void 0 || (S = S.value) === null || S === void 0 ? void 0 : S.pt, b, Ct({}, C));
        },
        ptmo: function() {
          var S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return rt._getPTValue(u._$instances[e], S, b, C, !1);
        },
        cx: function() {
          var S, b, C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return (S = u._$instances[e]) !== null && S !== void 0 && S.isUnstyled() ? void 0 : rt._getOptionValue((b = u._$instances[e]) === null || b === void 0 || (b = b.$style) === null || b === void 0 ? void 0 : b.classes, C, Ct({}, x));
        },
        sx: function() {
          var S, b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return C ? rt._getOptionValue((S = u._$instances[e]) === null || S === void 0 || (S = S.$style) === null || S === void 0 ? void 0 : S.inlineStyles, b, Ct({}, x)) : void 0;
        }
      }, k), u.$instance = u._$instances[e], (m = (v = u.$instance)[l]) === null || m === void 0 || m.call(v, u, c, d, h), u["$".concat(e)] = u.$instance, rt._hook(e, l, u, c, d, h), u.$pd || (u.$pd = {}), u.$pd[e] = Ct(Ct({}, (y = u.$pd) === null || y === void 0 ? void 0 : y[e]), {}, {
        name: e,
        instance: u._$instances[e]
      });
    }, o = function(l) {
      var u, c, d, h = l._$instances[e], p = h == null ? void 0 : h.watch, m = function(w) {
        var g, k = w.newValue, _ = w.oldValue;
        return p == null || (g = p.config) === null || g === void 0 ? void 0 : g.call(h, k, _);
      }, v = function(w) {
        var g, k = w.newValue, _ = w.oldValue;
        return p == null || (g = p["config.ripple"]) === null || g === void 0 ? void 0 : g.call(h, k, _);
      };
      h.$watchersCallback = {
        config: m,
        "config.ripple": v
      }, p == null || (u = p.config) === null || u === void 0 || u.call(h, h == null ? void 0 : h.$primevueConfig), Lo.on("config:change", m), p == null || (c = p["config.ripple"]) === null || c === void 0 || c.call(h, h == null || (d = h.$primevueConfig) === null || d === void 0 ? void 0 : d.ripple), Lo.on("config:ripple:change", v);
    }, s = function(l) {
      var u = l._$instances[e].$watchersCallback;
      u && (Lo.off("config:change", u.config), Lo.off("config:ripple:change", u["config.ripple"]), l._$instances[e].$watchersCallback = void 0);
    };
    return {
      created: function(l, u, c, d) {
        l.$pd || (l.$pd = {}), l.$pd[e] = {
          name: e,
          attrSelector: Za("pd")
        }, r("created", l, u, c, d);
      },
      beforeMount: function(l, u, c, d) {
        var h;
        rt._loadStyles((h = l.$pd[e]) === null || h === void 0 ? void 0 : h.instance, u, c), r("beforeMount", l, u, c, d), o(l);
      },
      mounted: function(l, u, c, d) {
        var h;
        rt._loadStyles((h = l.$pd[e]) === null || h === void 0 ? void 0 : h.instance, u, c), r("mounted", l, u, c, d);
      },
      beforeUpdate: function(l, u, c, d) {
        r("beforeUpdate", l, u, c, d);
      },
      updated: function(l, u, c, d) {
        var h;
        rt._loadStyles((h = l.$pd[e]) === null || h === void 0 ? void 0 : h.instance, u, c), r("updated", l, u, c, d);
      },
      beforeUnmount: function(l, u, c, d) {
        var h;
        s(l), rt._removeThemeListeners((h = l.$pd[e]) === null || h === void 0 ? void 0 : h.instance), r("beforeUnmount", l, u, c, d);
      },
      unmounted: function(l, u, c, d) {
        var h;
        (h = l.$pd[e]) === null || h === void 0 || (h = h.instance) === null || h === void 0 || (h = h.scopedStyleEl) === null || h === void 0 || (h = h.value) === null || h === void 0 || h.remove(), r("unmounted", l, u, c, d);
      }
    };
  },
  extend: function() {
    var e = rt._getMeta.apply(rt, arguments), n = Lv(e, 2), r = n[0], o = n[1];
    return Ct({
      extend: function() {
        var a = rt._getMeta.apply(rt, arguments), l = Lv(a, 2), u = l[0], c = l[1];
        return rt.extend(u, Ct(Ct(Ct({}, o), o == null ? void 0 : o.methods), c));
      }
    }, rt._extend(r, o));
  }
}, xF = `
    .p-ink {
        display: block;
        position: absolute;
        background: dt('ripple.background');
        border-radius: 100%;
        transform: scale(0);
        pointer-events: none;
    }

    .p-ink-active {
        animation: ripple 0.4s linear;
    }

    @keyframes ripple {
        100% {
            opacity: 0;
            transform: scale(2.5);
        }
    }
`, SF = {
  root: "p-ink"
}, CF = bt.extend({
  name: "ripple-directive",
  style: xF,
  classes: SF
}), kF = rt.extend({
  style: CF
});
function Nl(i) {
  "@babel/helpers - typeof";
  return Nl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Nl(i);
}
function OF(i) {
  return $F(i) || DF(i) || TF(i) || EF();
}
function EF() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function TF(i, e) {
  if (i) {
    if (typeof i == "string") return cf(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? cf(i, e) : void 0;
  }
}
function DF(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function $F(i) {
  if (Array.isArray(i)) return cf(i);
}
function cf(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function Fv(i, e, n) {
  return (e = MF(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function MF(i) {
  var e = PF(i, "string");
  return Nl(e) == "symbol" ? e : e + "";
}
function PF(i, e) {
  if (Nl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Nl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var Sp = kF.extend("ripple", {
  watch: {
    "config.ripple": function(e) {
      e ? (this.createRipple(this.$host), this.bindEvents(this.$host), this.$host.setAttribute("data-pd-ripple", !0), this.$host.style.overflow = "hidden", this.$host.style.position = "relative") : (this.remove(this.$host), this.$host.removeAttribute("data-pd-ripple"));
    }
  },
  unmounted: function(e) {
    this.remove(e);
  },
  timeout: void 0,
  methods: {
    bindEvents: function(e) {
      e.addEventListener("mousedown", this.onMouseDown.bind(this));
    },
    unbindEvents: function(e) {
      e.removeEventListener("mousedown", this.onMouseDown.bind(this));
    },
    createRipple: function(e) {
      var n = this.getInk(e);
      n || (n = cl("span", Fv(Fv({
        role: "presentation",
        "aria-hidden": !0,
        "data-p-ink": !0,
        "data-p-ink-active": !1,
        class: !this.isUnstyled() && this.cx("root"),
        onAnimationEnd: this.onAnimationEnd.bind(this)
      }, this.$attrSelector, ""), "p-bind", this.ptm("root"))), e.appendChild(n), this.$el = n);
    },
    remove: function(e) {
      var n = this.getInk(e);
      n && (this.$host.style.overflow = "", this.$host.style.position = "", this.unbindEvents(e), n.removeEventListener("animationend", this.onAnimationEnd), n.remove());
    },
    onMouseDown: function(e) {
      var n = this, r = e.currentTarget, o = this.getInk(r);
      if (!(!o || getComputedStyle(o, null).display === "none")) {
        if (!this.isUnstyled() && Ss(o, "p-ink-active"), o.setAttribute("data-p-ink-active", "false"), !as(o) && !ls(o)) {
          var s = Math.max(dr(r), Nr(r));
          o.style.height = s + "px", o.style.width = s + "px";
        }
        var a = wC(r), l = e.pageX - a.left + document.body.scrollTop - ls(o) / 2, u = e.pageY - a.top + document.body.scrollLeft - as(o) / 2;
        o.style.top = u + "px", o.style.left = l + "px", !this.isUnstyled() && Ms(o, "p-ink-active"), o.setAttribute("data-p-ink-active", "true"), this.timeout = setTimeout(function() {
          o && (!n.isUnstyled() && Ss(o, "p-ink-active"), o.setAttribute("data-p-ink-active", "false"));
        }, 401);
      }
    },
    onAnimationEnd: function(e) {
      this.timeout && clearTimeout(this.timeout), !this.isUnstyled() && Ss(e.currentTarget, "p-ink-active"), e.currentTarget.setAttribute("data-p-ink-active", "false");
    },
    getInk: function(e) {
      return e && e.children ? OF(e.children).find(function(n) {
        return To(n, "data-pc-name") === "ripple";
      }) : void 0;
    }
  }
}), IF = `
    .p-button {
        display: inline-flex;
        cursor: pointer;
        user-select: none;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        position: relative;
        color: dt('button.primary.color');
        background: dt('button.primary.background');
        border: 1px solid dt('button.primary.border.color');
        padding: dt('button.padding.y') dt('button.padding.x');
        font-size: 1rem;
        font-family: inherit;
        font-feature-settings: inherit;
        transition:
            background dt('button.transition.duration'),
            color dt('button.transition.duration'),
            border-color dt('button.transition.duration'),
            outline-color dt('button.transition.duration'),
            box-shadow dt('button.transition.duration');
        border-radius: dt('button.border.radius');
        outline-color: transparent;
        gap: dt('button.gap');
    }

    .p-button:disabled {
        cursor: default;
    }

    .p-button-icon-right {
        order: 1;
    }

    .p-button-icon-right:dir(rtl) {
        order: -1;
    }

    .p-button:not(.p-button-vertical) .p-button-icon:not(.p-button-icon-right):dir(rtl) {
        order: 1;
    }

    .p-button-icon-bottom {
        order: 2;
    }

    .p-button-icon-only {
        width: dt('button.icon.only.width');
        padding-inline-start: 0;
        padding-inline-end: 0;
        gap: 0;
    }

    .p-button-icon-only.p-button-rounded {
        border-radius: 50%;
        height: dt('button.icon.only.width');
    }

    .p-button-icon-only .p-button-label {
        visibility: hidden;
        width: 0;
    }

    .p-button-icon-only::after {
        content: "\0A0";
        visibility: hidden;
        width: 0;
    }

    .p-button-sm {
        font-size: dt('button.sm.font.size');
        padding: dt('button.sm.padding.y') dt('button.sm.padding.x');
    }

    .p-button-sm .p-button-icon {
        font-size: dt('button.sm.font.size');
    }

    .p-button-sm.p-button-icon-only {
        width: dt('button.sm.icon.only.width');
    }

    .p-button-sm.p-button-icon-only.p-button-rounded {
        height: dt('button.sm.icon.only.width');
    }

    .p-button-lg {
        font-size: dt('button.lg.font.size');
        padding: dt('button.lg.padding.y') dt('button.lg.padding.x');
    }

    .p-button-lg .p-button-icon {
        font-size: dt('button.lg.font.size');
    }

    .p-button-lg.p-button-icon-only {
        width: dt('button.lg.icon.only.width');
    }

    .p-button-lg.p-button-icon-only.p-button-rounded {
        height: dt('button.lg.icon.only.width');
    }

    .p-button-vertical {
        flex-direction: column;
    }

    .p-button-label {
        font-weight: dt('button.label.font.weight');
    }

    .p-button-fluid {
        width: 100%;
    }

    .p-button-fluid.p-button-icon-only {
        width: dt('button.icon.only.width');
    }

    .p-button:not(:disabled):hover {
        background: dt('button.primary.hover.background');
        border: 1px solid dt('button.primary.hover.border.color');
        color: dt('button.primary.hover.color');
    }

    .p-button:not(:disabled):active {
        background: dt('button.primary.active.background');
        border: 1px solid dt('button.primary.active.border.color');
        color: dt('button.primary.active.color');
    }

    .p-button:focus-visible {
        box-shadow: dt('button.primary.focus.ring.shadow');
        outline: dt('button.focus.ring.width') dt('button.focus.ring.style') dt('button.primary.focus.ring.color');
        outline-offset: dt('button.focus.ring.offset');
    }

    .p-button .p-badge {
        min-width: dt('button.badge.size');
        height: dt('button.badge.size');
        line-height: dt('button.badge.size');
    }

    .p-button-raised {
        box-shadow: dt('button.raised.shadow');
    }

    .p-button-rounded {
        border-radius: dt('button.rounded.border.radius');
    }

    .p-button-secondary {
        background: dt('button.secondary.background');
        border: 1px solid dt('button.secondary.border.color');
        color: dt('button.secondary.color');
    }

    .p-button-secondary:not(:disabled):hover {
        background: dt('button.secondary.hover.background');
        border: 1px solid dt('button.secondary.hover.border.color');
        color: dt('button.secondary.hover.color');
    }

    .p-button-secondary:not(:disabled):active {
        background: dt('button.secondary.active.background');
        border: 1px solid dt('button.secondary.active.border.color');
        color: dt('button.secondary.active.color');
    }

    .p-button-secondary:focus-visible {
        outline-color: dt('button.secondary.focus.ring.color');
        box-shadow: dt('button.secondary.focus.ring.shadow');
    }

    .p-button-success {
        background: dt('button.success.background');
        border: 1px solid dt('button.success.border.color');
        color: dt('button.success.color');
    }

    .p-button-success:not(:disabled):hover {
        background: dt('button.success.hover.background');
        border: 1px solid dt('button.success.hover.border.color');
        color: dt('button.success.hover.color');
    }

    .p-button-success:not(:disabled):active {
        background: dt('button.success.active.background');
        border: 1px solid dt('button.success.active.border.color');
        color: dt('button.success.active.color');
    }

    .p-button-success:focus-visible {
        outline-color: dt('button.success.focus.ring.color');
        box-shadow: dt('button.success.focus.ring.shadow');
    }

    .p-button-info {
        background: dt('button.info.background');
        border: 1px solid dt('button.info.border.color');
        color: dt('button.info.color');
    }

    .p-button-info:not(:disabled):hover {
        background: dt('button.info.hover.background');
        border: 1px solid dt('button.info.hover.border.color');
        color: dt('button.info.hover.color');
    }

    .p-button-info:not(:disabled):active {
        background: dt('button.info.active.background');
        border: 1px solid dt('button.info.active.border.color');
        color: dt('button.info.active.color');
    }

    .p-button-info:focus-visible {
        outline-color: dt('button.info.focus.ring.color');
        box-shadow: dt('button.info.focus.ring.shadow');
    }

    .p-button-warn {
        background: dt('button.warn.background');
        border: 1px solid dt('button.warn.border.color');
        color: dt('button.warn.color');
    }

    .p-button-warn:not(:disabled):hover {
        background: dt('button.warn.hover.background');
        border: 1px solid dt('button.warn.hover.border.color');
        color: dt('button.warn.hover.color');
    }

    .p-button-warn:not(:disabled):active {
        background: dt('button.warn.active.background');
        border: 1px solid dt('button.warn.active.border.color');
        color: dt('button.warn.active.color');
    }

    .p-button-warn:focus-visible {
        outline-color: dt('button.warn.focus.ring.color');
        box-shadow: dt('button.warn.focus.ring.shadow');
    }

    .p-button-help {
        background: dt('button.help.background');
        border: 1px solid dt('button.help.border.color');
        color: dt('button.help.color');
    }

    .p-button-help:not(:disabled):hover {
        background: dt('button.help.hover.background');
        border: 1px solid dt('button.help.hover.border.color');
        color: dt('button.help.hover.color');
    }

    .p-button-help:not(:disabled):active {
        background: dt('button.help.active.background');
        border: 1px solid dt('button.help.active.border.color');
        color: dt('button.help.active.color');
    }

    .p-button-help:focus-visible {
        outline-color: dt('button.help.focus.ring.color');
        box-shadow: dt('button.help.focus.ring.shadow');
    }

    .p-button-danger {
        background: dt('button.danger.background');
        border: 1px solid dt('button.danger.border.color');
        color: dt('button.danger.color');
    }

    .p-button-danger:not(:disabled):hover {
        background: dt('button.danger.hover.background');
        border: 1px solid dt('button.danger.hover.border.color');
        color: dt('button.danger.hover.color');
    }

    .p-button-danger:not(:disabled):active {
        background: dt('button.danger.active.background');
        border: 1px solid dt('button.danger.active.border.color');
        color: dt('button.danger.active.color');
    }

    .p-button-danger:focus-visible {
        outline-color: dt('button.danger.focus.ring.color');
        box-shadow: dt('button.danger.focus.ring.shadow');
    }

    .p-button-contrast {
        background: dt('button.contrast.background');
        border: 1px solid dt('button.contrast.border.color');
        color: dt('button.contrast.color');
    }

    .p-button-contrast:not(:disabled):hover {
        background: dt('button.contrast.hover.background');
        border: 1px solid dt('button.contrast.hover.border.color');
        color: dt('button.contrast.hover.color');
    }

    .p-button-contrast:not(:disabled):active {
        background: dt('button.contrast.active.background');
        border: 1px solid dt('button.contrast.active.border.color');
        color: dt('button.contrast.active.color');
    }

    .p-button-contrast:focus-visible {
        outline-color: dt('button.contrast.focus.ring.color');
        box-shadow: dt('button.contrast.focus.ring.shadow');
    }

    .p-button-outlined {
        background: transparent;
        border-color: dt('button.outlined.primary.border.color');
        color: dt('button.outlined.primary.color');
    }

    .p-button-outlined:not(:disabled):hover {
        background: dt('button.outlined.primary.hover.background');
        border-color: dt('button.outlined.primary.border.color');
        color: dt('button.outlined.primary.color');
    }

    .p-button-outlined:not(:disabled):active {
        background: dt('button.outlined.primary.active.background');
        border-color: dt('button.outlined.primary.border.color');
        color: dt('button.outlined.primary.color');
    }

    .p-button-outlined.p-button-secondary {
        border-color: dt('button.outlined.secondary.border.color');
        color: dt('button.outlined.secondary.color');
    }

    .p-button-outlined.p-button-secondary:not(:disabled):hover {
        background: dt('button.outlined.secondary.hover.background');
        border-color: dt('button.outlined.secondary.border.color');
        color: dt('button.outlined.secondary.color');
    }

    .p-button-outlined.p-button-secondary:not(:disabled):active {
        background: dt('button.outlined.secondary.active.background');
        border-color: dt('button.outlined.secondary.border.color');
        color: dt('button.outlined.secondary.color');
    }

    .p-button-outlined.p-button-success {
        border-color: dt('button.outlined.success.border.color');
        color: dt('button.outlined.success.color');
    }

    .p-button-outlined.p-button-success:not(:disabled):hover {
        background: dt('button.outlined.success.hover.background');
        border-color: dt('button.outlined.success.border.color');
        color: dt('button.outlined.success.color');
    }

    .p-button-outlined.p-button-success:not(:disabled):active {
        background: dt('button.outlined.success.active.background');
        border-color: dt('button.outlined.success.border.color');
        color: dt('button.outlined.success.color');
    }

    .p-button-outlined.p-button-info {
        border-color: dt('button.outlined.info.border.color');
        color: dt('button.outlined.info.color');
    }

    .p-button-outlined.p-button-info:not(:disabled):hover {
        background: dt('button.outlined.info.hover.background');
        border-color: dt('button.outlined.info.border.color');
        color: dt('button.outlined.info.color');
    }

    .p-button-outlined.p-button-info:not(:disabled):active {
        background: dt('button.outlined.info.active.background');
        border-color: dt('button.outlined.info.border.color');
        color: dt('button.outlined.info.color');
    }

    .p-button-outlined.p-button-warn {
        border-color: dt('button.outlined.warn.border.color');
        color: dt('button.outlined.warn.color');
    }

    .p-button-outlined.p-button-warn:not(:disabled):hover {
        background: dt('button.outlined.warn.hover.background');
        border-color: dt('button.outlined.warn.border.color');
        color: dt('button.outlined.warn.color');
    }

    .p-button-outlined.p-button-warn:not(:disabled):active {
        background: dt('button.outlined.warn.active.background');
        border-color: dt('button.outlined.warn.border.color');
        color: dt('button.outlined.warn.color');
    }

    .p-button-outlined.p-button-help {
        border-color: dt('button.outlined.help.border.color');
        color: dt('button.outlined.help.color');
    }

    .p-button-outlined.p-button-help:not(:disabled):hover {
        background: dt('button.outlined.help.hover.background');
        border-color: dt('button.outlined.help.border.color');
        color: dt('button.outlined.help.color');
    }

    .p-button-outlined.p-button-help:not(:disabled):active {
        background: dt('button.outlined.help.active.background');
        border-color: dt('button.outlined.help.border.color');
        color: dt('button.outlined.help.color');
    }

    .p-button-outlined.p-button-danger {
        border-color: dt('button.outlined.danger.border.color');
        color: dt('button.outlined.danger.color');
    }

    .p-button-outlined.p-button-danger:not(:disabled):hover {
        background: dt('button.outlined.danger.hover.background');
        border-color: dt('button.outlined.danger.border.color');
        color: dt('button.outlined.danger.color');
    }

    .p-button-outlined.p-button-danger:not(:disabled):active {
        background: dt('button.outlined.danger.active.background');
        border-color: dt('button.outlined.danger.border.color');
        color: dt('button.outlined.danger.color');
    }

    .p-button-outlined.p-button-contrast {
        border-color: dt('button.outlined.contrast.border.color');
        color: dt('button.outlined.contrast.color');
    }

    .p-button-outlined.p-button-contrast:not(:disabled):hover {
        background: dt('button.outlined.contrast.hover.background');
        border-color: dt('button.outlined.contrast.border.color');
        color: dt('button.outlined.contrast.color');
    }

    .p-button-outlined.p-button-contrast:not(:disabled):active {
        background: dt('button.outlined.contrast.active.background');
        border-color: dt('button.outlined.contrast.border.color');
        color: dt('button.outlined.contrast.color');
    }

    .p-button-outlined.p-button-plain {
        border-color: dt('button.outlined.plain.border.color');
        color: dt('button.outlined.plain.color');
    }

    .p-button-outlined.p-button-plain:not(:disabled):hover {
        background: dt('button.outlined.plain.hover.background');
        border-color: dt('button.outlined.plain.border.color');
        color: dt('button.outlined.plain.color');
    }

    .p-button-outlined.p-button-plain:not(:disabled):active {
        background: dt('button.outlined.plain.active.background');
        border-color: dt('button.outlined.plain.border.color');
        color: dt('button.outlined.plain.color');
    }

    .p-button-text {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.primary.color');
    }

    .p-button-text:not(:disabled):hover {
        background: dt('button.text.primary.hover.background');
        border-color: transparent;
        color: dt('button.text.primary.color');
    }

    .p-button-text:not(:disabled):active {
        background: dt('button.text.primary.active.background');
        border-color: transparent;
        color: dt('button.text.primary.color');
    }

    .p-button-text.p-button-secondary {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.secondary.color');
    }

    .p-button-text.p-button-secondary:not(:disabled):hover {
        background: dt('button.text.secondary.hover.background');
        border-color: transparent;
        color: dt('button.text.secondary.color');
    }

    .p-button-text.p-button-secondary:not(:disabled):active {
        background: dt('button.text.secondary.active.background');
        border-color: transparent;
        color: dt('button.text.secondary.color');
    }

    .p-button-text.p-button-success {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.success.color');
    }

    .p-button-text.p-button-success:not(:disabled):hover {
        background: dt('button.text.success.hover.background');
        border-color: transparent;
        color: dt('button.text.success.color');
    }

    .p-button-text.p-button-success:not(:disabled):active {
        background: dt('button.text.success.active.background');
        border-color: transparent;
        color: dt('button.text.success.color');
    }

    .p-button-text.p-button-info {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.info.color');
    }

    .p-button-text.p-button-info:not(:disabled):hover {
        background: dt('button.text.info.hover.background');
        border-color: transparent;
        color: dt('button.text.info.color');
    }

    .p-button-text.p-button-info:not(:disabled):active {
        background: dt('button.text.info.active.background');
        border-color: transparent;
        color: dt('button.text.info.color');
    }

    .p-button-text.p-button-warn {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.warn.color');
    }

    .p-button-text.p-button-warn:not(:disabled):hover {
        background: dt('button.text.warn.hover.background');
        border-color: transparent;
        color: dt('button.text.warn.color');
    }

    .p-button-text.p-button-warn:not(:disabled):active {
        background: dt('button.text.warn.active.background');
        border-color: transparent;
        color: dt('button.text.warn.color');
    }

    .p-button-text.p-button-help {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.help.color');
    }

    .p-button-text.p-button-help:not(:disabled):hover {
        background: dt('button.text.help.hover.background');
        border-color: transparent;
        color: dt('button.text.help.color');
    }

    .p-button-text.p-button-help:not(:disabled):active {
        background: dt('button.text.help.active.background');
        border-color: transparent;
        color: dt('button.text.help.color');
    }

    .p-button-text.p-button-danger {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.danger.color');
    }

    .p-button-text.p-button-danger:not(:disabled):hover {
        background: dt('button.text.danger.hover.background');
        border-color: transparent;
        color: dt('button.text.danger.color');
    }

    .p-button-text.p-button-danger:not(:disabled):active {
        background: dt('button.text.danger.active.background');
        border-color: transparent;
        color: dt('button.text.danger.color');
    }

    .p-button-text.p-button-contrast {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.contrast.color');
    }

    .p-button-text.p-button-contrast:not(:disabled):hover {
        background: dt('button.text.contrast.hover.background');
        border-color: transparent;
        color: dt('button.text.contrast.color');
    }

    .p-button-text.p-button-contrast:not(:disabled):active {
        background: dt('button.text.contrast.active.background');
        border-color: transparent;
        color: dt('button.text.contrast.color');
    }

    .p-button-text.p-button-plain {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.plain.color');
    }

    .p-button-text.p-button-plain:not(:disabled):hover {
        background: dt('button.text.plain.hover.background');
        border-color: transparent;
        color: dt('button.text.plain.color');
    }

    .p-button-text.p-button-plain:not(:disabled):active {
        background: dt('button.text.plain.active.background');
        border-color: transparent;
        color: dt('button.text.plain.color');
    }

    .p-button-link {
        background: transparent;
        border-color: transparent;
        color: dt('button.link.color');
    }

    .p-button-link:not(:disabled):hover {
        background: transparent;
        border-color: transparent;
        color: dt('button.link.hover.color');
    }

    .p-button-link:not(:disabled):hover .p-button-label {
        text-decoration: underline;
    }

    .p-button-link:not(:disabled):active {
        background: transparent;
        border-color: transparent;
        color: dt('button.link.active.color');
    }
`;
function zl(i) {
  "@babel/helpers - typeof";
  return zl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, zl(i);
}
function lr(i, e, n) {
  return (e = LF(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function LF(i) {
  var e = AF(i, "string");
  return zl(e) == "symbol" ? e : e + "";
}
function AF(i, e) {
  if (zl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (zl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var VF = {
  root: function(e) {
    var n = e.instance, r = e.props;
    return ["p-button p-component", lr(lr(lr(lr(lr(lr(lr(lr(lr({
      "p-button-icon-only": n.hasIcon && !r.label && !r.badge,
      "p-button-vertical": (r.iconPos === "top" || r.iconPos === "bottom") && r.label,
      "p-button-loading": r.loading,
      "p-button-link": r.link || r.variant === "link"
    }, "p-button-".concat(r.severity), r.severity), "p-button-raised", r.raised), "p-button-rounded", r.rounded), "p-button-text", r.text || r.variant === "text"), "p-button-outlined", r.outlined || r.variant === "outlined"), "p-button-sm", r.size === "small"), "p-button-lg", r.size === "large"), "p-button-plain", r.plain), "p-button-fluid", n.hasFluid)];
  },
  loadingIcon: "p-button-loading-icon",
  icon: function(e) {
    var n = e.props;
    return ["p-button-icon", lr({}, "p-button-icon-".concat(n.iconPos), n.label)];
  },
  label: "p-button-label"
}, FF = bt.extend({
  name: "button",
  style: IF,
  classes: VF
}), jF = {
  name: "BaseButton",
  extends: Ho,
  props: {
    label: {
      type: String,
      default: null
    },
    icon: {
      type: String,
      default: null
    },
    iconPos: {
      type: String,
      default: "left"
    },
    iconClass: {
      type: [String, Object],
      default: null
    },
    badge: {
      type: String,
      default: null
    },
    badgeClass: {
      type: [String, Object],
      default: null
    },
    badgeSeverity: {
      type: String,
      default: "secondary"
    },
    loading: {
      type: Boolean,
      default: !1
    },
    loadingIcon: {
      type: String,
      default: void 0
    },
    as: {
      type: [String, Object],
      default: "BUTTON"
    },
    asChild: {
      type: Boolean,
      default: !1
    },
    link: {
      type: Boolean,
      default: !1
    },
    severity: {
      type: String,
      default: null
    },
    raised: {
      type: Boolean,
      default: !1
    },
    rounded: {
      type: Boolean,
      default: !1
    },
    text: {
      type: Boolean,
      default: !1
    },
    outlined: {
      type: Boolean,
      default: !1
    },
    size: {
      type: String,
      default: null
    },
    variant: {
      type: String,
      default: null
    },
    plain: {
      type: Boolean,
      default: !1
    },
    fluid: {
      type: Boolean,
      default: null
    }
  },
  style: FF,
  provide: function() {
    return {
      $pcButton: this,
      $parentInstance: this
    };
  }
};
function Bl(i) {
  "@babel/helpers - typeof";
  return Bl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Bl(i);
}
function Xn(i, e, n) {
  return (e = RF(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function RF(i) {
  var e = NF(i, "string");
  return Bl(e) == "symbol" ? e : e + "";
}
function NF(i, e) {
  if (Bl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Bl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var Cp = {
  name: "Button",
  extends: jF,
  inheritAttrs: !1,
  inject: {
    $pcFluid: {
      default: null
    }
  },
  methods: {
    getPTOptions: function(e) {
      var n = e === "root" ? this.ptmi : this.ptm;
      return n(e, {
        context: {
          disabled: this.disabled
        }
      });
    }
  },
  computed: {
    disabled: function() {
      return this.$attrs.disabled || this.$attrs.disabled === "" || this.loading;
    },
    defaultAriaLabel: function() {
      return this.label ? this.label + (this.badge ? " " + this.badge : "") : this.$attrs.ariaLabel;
    },
    hasIcon: function() {
      return this.icon || this.$slots.icon;
    },
    attrs: function() {
      return ke(this.asAttrs, this.a11yAttrs, this.getPTOptions("root"));
    },
    asAttrs: function() {
      return this.as === "BUTTON" ? {
        type: "button",
        disabled: this.disabled
      } : void 0;
    },
    a11yAttrs: function() {
      return {
        "aria-label": this.defaultAriaLabel,
        "data-pc-name": "button",
        "data-p-disabled": this.disabled,
        "data-p-severity": this.severity
      };
    },
    hasFluid: function() {
      return Ji(this.fluid) ? !!this.$pcFluid : this.fluid;
    },
    dataP: function() {
      return ui(Xn(Xn(Xn(Xn(Xn(Xn(Xn(Xn(Xn(Xn({}, this.size, this.size), "icon-only", this.hasIcon && !this.label && !this.badge), "loading", this.loading), "fluid", this.hasFluid), "rounded", this.rounded), "raised", this.raised), "outlined", this.outlined || this.variant === "outlined"), "text", this.text || this.variant === "text"), "link", this.link || this.variant === "link"), "vertical", (this.iconPos === "top" || this.iconPos === "bottom") && this.label));
    },
    dataIconP: function() {
      return ui(Xn(Xn({}, this.iconPos, this.iconPos), this.size, this.size));
    },
    dataLabelP: function() {
      return ui(Xn(Xn({}, this.size, this.size), "icon-only", this.hasIcon && !this.label && !this.badge));
    }
  },
  components: {
    SpinnerIcon: kd,
    Badge: D1
  },
  directives: {
    ripple: Sp
  }
}, zF = ["data-p"], BF = ["data-p"];
function HF(i, e, n, r, o, s) {
  var a = Tn("SpinnerIcon"), l = Tn("Badge"), u = Vf("ripple");
  return i.asChild ? it(i.$slots, "default", {
    key: 1,
    class: _e(i.cx("root")),
    a11yAttrs: s.a11yAttrs
  }) : ot(($(), st(vr(i.as), ke({
    key: 0,
    class: i.cx("root"),
    "data-p": s.dataP
  }, s.attrs), {
    default: Wt(function() {
      return [it(i.$slots, "default", {}, function() {
        return [i.loading ? it(i.$slots, "loadingicon", ke({
          key: 0,
          class: [i.cx("loadingIcon"), i.cx("icon")]
        }, i.ptm("loadingIcon")), function() {
          return [i.loadingIcon ? ($(), A("span", ke({
            key: 0,
            class: [i.cx("loadingIcon"), i.cx("icon"), i.loadingIcon]
          }, i.ptm("loadingIcon")), null, 16)) : ($(), st(a, ke({
            key: 1,
            class: [i.cx("loadingIcon"), i.cx("icon")],
            spin: ""
          }, i.ptm("loadingIcon")), null, 16, ["class"]))];
        }) : it(i.$slots, "icon", ke({
          key: 1,
          class: [i.cx("icon")]
        }, i.ptm("icon")), function() {
          return [i.icon ? ($(), A("span", ke({
            key: 0,
            class: [i.cx("icon"), i.icon, i.iconClass],
            "data-p": s.dataIconP
          }, i.ptm("icon")), null, 16, zF)) : ve("", !0)];
        }), i.label ? ($(), A("span", ke({
          key: 2,
          class: i.cx("label")
        }, i.ptm("label"), {
          "data-p": s.dataLabelP
        }), Q(i.label), 17, BF)) : ve("", !0), i.badge ? ($(), st(l, {
          key: 3,
          value: i.badge,
          class: _e(i.badgeClass),
          severity: i.badgeSeverity,
          unstyled: i.unstyled,
          pt: i.ptm("pcBadge")
        }, null, 8, ["value", "class", "severity", "unstyled", "pt"])) : ve("", !0)];
      })];
    }),
    _: 3
  }, 16, ["class", "data-p"])), [[u]]);
}
Cp.render = HF;
var kp = {
  name: "BaseEditableHolder",
  extends: Ho,
  emits: ["update:modelValue", "value-change"],
  props: {
    modelValue: {
      type: null,
      default: void 0
    },
    defaultValue: {
      type: null,
      default: void 0
    },
    name: {
      type: String,
      default: void 0
    },
    invalid: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    formControl: {
      type: Object,
      default: void 0
    }
  },
  inject: {
    $parentInstance: {
      default: void 0
    },
    $pcForm: {
      default: void 0
    },
    $pcFormField: {
      default: void 0
    }
  },
  data: function() {
    return {
      d_value: this.defaultValue !== void 0 ? this.defaultValue : this.modelValue
    };
  },
  watch: {
    modelValue: {
      deep: !0,
      handler: function(e) {
        this.d_value = e;
      }
    },
    defaultValue: function(e) {
      this.d_value = e;
    },
    $formName: {
      immediate: !0,
      handler: function(e) {
        var n, r;
        this.formField = ((n = this.$pcForm) === null || n === void 0 || (r = n.register) === null || r === void 0 ? void 0 : r.call(n, e, this.$formControl)) || {};
      }
    },
    $formControl: {
      immediate: !0,
      handler: function(e) {
        var n, r;
        this.formField = ((n = this.$pcForm) === null || n === void 0 || (r = n.register) === null || r === void 0 ? void 0 : r.call(n, this.$formName, e)) || {};
      }
    },
    $formDefaultValue: {
      immediate: !0,
      handler: function(e) {
        this.d_value !== e && (this.d_value = e);
      }
    },
    $formValue: {
      immediate: !1,
      handler: function(e) {
        var n;
        (n = this.$pcForm) !== null && n !== void 0 && n.getFieldState(this.$formName) && e !== this.d_value && (this.d_value = e);
      }
    }
  },
  formField: {},
  methods: {
    writeValue: function(e, n) {
      var r, o;
      this.controlled && (this.d_value = e, this.$emit("update:modelValue", e)), this.$emit("value-change", e), (r = (o = this.formField).onChange) === null || r === void 0 || r.call(o, {
        originalEvent: n,
        value: e
      });
    },
    // @todo move to @primeuix/utils
    findNonEmpty: function() {
      for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
        n[r] = arguments[r];
      return n.find(gt);
    }
  },
  computed: {
    $filled: function() {
      return gt(this.d_value);
    },
    $invalid: function() {
      var e, n;
      return !this.$formNovalidate && this.findNonEmpty(this.invalid, (e = this.$pcFormField) === null || e === void 0 || (e = e.$field) === null || e === void 0 ? void 0 : e.invalid, (n = this.$pcForm) === null || n === void 0 || (n = n.getFieldState(this.$formName)) === null || n === void 0 ? void 0 : n.invalid);
    },
    $formName: function() {
      var e;
      return this.$formNovalidate ? void 0 : this.name || ((e = this.$formControl) === null || e === void 0 ? void 0 : e.name);
    },
    $formControl: function() {
      var e;
      return this.formControl || ((e = this.$pcFormField) === null || e === void 0 ? void 0 : e.formControl);
    },
    $formNovalidate: function() {
      var e;
      return (e = this.$formControl) === null || e === void 0 ? void 0 : e.novalidate;
    },
    $formDefaultValue: function() {
      var e, n;
      return this.findNonEmpty(this.d_value, (e = this.$pcFormField) === null || e === void 0 ? void 0 : e.initialValue, (n = this.$pcForm) === null || n === void 0 || (n = n.initialValues) === null || n === void 0 ? void 0 : n[this.$formName]);
    },
    $formValue: function() {
      var e, n;
      return this.findNonEmpty((e = this.$pcFormField) === null || e === void 0 || (e = e.$field) === null || e === void 0 ? void 0 : e.value, (n = this.$pcForm) === null || n === void 0 || (n = n.getFieldState(this.$formName)) === null || n === void 0 ? void 0 : n.value);
    },
    controlled: function() {
      return this.$inProps.hasOwnProperty("modelValue") || !this.$inProps.hasOwnProperty("modelValue") && !this.$inProps.hasOwnProperty("defaultValue");
    },
    // @deprecated use $filled instead
    filled: function() {
      return this.$filled;
    }
  }
}, UF = `
    .p-slider {
        display: block;
        position: relative;
        background: dt('slider.track.background');
        border-radius: dt('slider.track.border.radius');
    }

    .p-slider-handle {
        cursor: grab;
        touch-action: none;
        user-select: none;
        display: flex;
        justify-content: center;
        align-items: center;
        height: dt('slider.handle.height');
        width: dt('slider.handle.width');
        background: dt('slider.handle.background');
        border-radius: dt('slider.handle.border.radius');
        transition:
            background dt('slider.transition.duration'),
            color dt('slider.transition.duration'),
            border-color dt('slider.transition.duration'),
            box-shadow dt('slider.transition.duration'),
            outline-color dt('slider.transition.duration');
        outline-color: transparent;
    }

    .p-slider-handle::before {
        content: '';
        width: dt('slider.handle.content.width');
        height: dt('slider.handle.content.height');
        display: block;
        background: dt('slider.handle.content.background');
        border-radius: dt('slider.handle.content.border.radius');
        box-shadow: dt('slider.handle.content.shadow');
        transition: background dt('slider.transition.duration');
    }

    .p-slider:not(.p-disabled) .p-slider-handle:hover {
        background: dt('slider.handle.hover.background');
    }

    .p-slider:not(.p-disabled) .p-slider-handle:hover::before {
        background: dt('slider.handle.content.hover.background');
    }

    .p-slider-handle:focus-visible {
        box-shadow: dt('slider.handle.focus.ring.shadow');
        outline: dt('slider.handle.focus.ring.width') dt('slider.handle.focus.ring.style') dt('slider.handle.focus.ring.color');
        outline-offset: dt('slider.handle.focus.ring.offset');
    }

    .p-slider-range {
        display: block;
        background: dt('slider.range.background');
        border-radius: dt('slider.track.border.radius');
    }

    .p-slider.p-slider-horizontal {
        height: dt('slider.track.size');
    }

    .p-slider-horizontal .p-slider-range {
        inset-block-start: 0;
        inset-inline-start: 0;
        height: 100%;
    }

    .p-slider-horizontal .p-slider-handle {
        inset-block-start: 50%;
        margin-block-start: calc(-1 * calc(dt('slider.handle.height') / 2));
        margin-inline-start: calc(-1 * calc(dt('slider.handle.width') / 2));
    }

    .p-slider-vertical {
        min-height: 100px;
        width: dt('slider.track.size');
    }

    .p-slider-vertical .p-slider-handle {
        inset-inline-start: 50%;
        margin-inline-start: calc(-1 * calc(dt('slider.handle.width') / 2));
        margin-block-end: calc(-1 * calc(dt('slider.handle.height') / 2));
    }

    .p-slider-vertical .p-slider-range {
        inset-block-end: 0;
        inset-inline-start: 0;
        width: 100%;
    }
`, WF = {
  handle: {
    position: "absolute"
  },
  range: {
    position: "absolute"
  }
}, GF = {
  root: function(e) {
    var n = e.instance, r = e.props;
    return ["p-slider p-component", {
      "p-disabled": r.disabled,
      "p-invalid": n.$invalid,
      "p-slider-horizontal": r.orientation === "horizontal",
      "p-slider-vertical": r.orientation === "vertical"
    }];
  },
  range: "p-slider-range",
  handle: "p-slider-handle"
}, XF = bt.extend({
  name: "slider",
  style: UF,
  classes: GF,
  inlineStyles: WF
}), YF = {
  name: "BaseSlider",
  extends: kp,
  props: {
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    orientation: {
      type: String,
      default: "horizontal"
    },
    step: {
      type: Number,
      default: null
    },
    range: {
      type: Boolean,
      default: !1
    },
    tabindex: {
      type: Number,
      default: 0
    },
    ariaLabelledby: {
      type: String,
      default: null
    },
    ariaLabel: {
      type: String,
      default: null
    }
  },
  style: XF,
  provide: function() {
    return {
      $pcSlider: this,
      $parentInstance: this
    };
  }
};
function Hl(i) {
  "@babel/helpers - typeof";
  return Hl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Hl(i);
}
function KF(i, e, n) {
  return (e = qF(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function qF(i) {
  var e = ZF(i, "string");
  return Hl(e) == "symbol" ? e : e + "";
}
function ZF(i, e) {
  if (Hl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Hl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
function JF(i) {
  return nj(i) || tj(i) || ej(i) || QF();
}
function QF() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ej(i, e) {
  if (i) {
    if (typeof i == "string") return df(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? df(i, e) : void 0;
  }
}
function tj(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function nj(i) {
  if (Array.isArray(i)) return df(i);
}
function df(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
var $1 = {
  name: "Slider",
  extends: YF,
  inheritAttrs: !1,
  emits: ["change", "slideend"],
  dragging: !1,
  handleIndex: null,
  initX: null,
  initY: null,
  barWidth: null,
  barHeight: null,
  dragListener: null,
  dragEndListener: null,
  beforeUnmount: function() {
    this.unbindDragListeners();
  },
  methods: {
    updateDomData: function() {
      var e = this.$el.getBoundingClientRect();
      this.initX = e.left + Kf(), this.initY = e.top + qf(), this.barWidth = this.$el.offsetWidth, this.barHeight = this.$el.offsetHeight;
    },
    setValue: function(e) {
      var n, r = e.touches ? e.touches[0].pageX : e.pageX, o = e.touches ? e.touches[0].pageY : e.pageY;
      this.orientation === "horizontal" ? X0(this.$el) ? n = (this.initX + this.barWidth - r) * 100 / this.barWidth : n = (r - this.initX) * 100 / this.barWidth : n = (this.initY + this.barHeight - o) * 100 / this.barHeight;
      var s = (this.max - this.min) * (n / 100) + this.min;
      if (this.step) {
        var a = this.range ? this.value[this.handleIndex] : this.value, l = s - a;
        l < 0 ? s = a + Math.ceil(s / this.step - a / this.step) * this.step : l > 0 && (s = a + Math.floor(s / this.step - a / this.step) * this.step);
      } else
        s = Math.floor(s);
      this.updateModel(e, s);
    },
    updateModel: function(e, n) {
      var r = Math.round(n * 100) / 100, o;
      this.range ? (o = this.value ? JF(this.value) : [], this.handleIndex == 0 ? (r < this.min ? r = this.min : r >= this.max && (r = this.max), o[0] = r) : (r > this.max ? r = this.max : r <= this.min && (r = this.min), o[1] = r)) : (r < this.min ? r = this.min : r > this.max && (r = this.max), o = r), this.writeValue(o, e), this.$emit("change", o);
    },
    onDragStart: function(e, n) {
      this.disabled || (this.$el.setAttribute("data-p-sliding", !0), this.dragging = !0, this.updateDomData(), this.range && this.value[0] === this.max ? this.handleIndex = 0 : this.handleIndex = n, e.currentTarget.focus());
    },
    onDrag: function(e) {
      this.dragging && this.setValue(e);
    },
    onDragEnd: function(e) {
      this.dragging && (this.dragging = !1, this.$el.setAttribute("data-p-sliding", !1), this.$emit("slideend", {
        originalEvent: e,
        value: this.value
      }));
    },
    onBarClick: function(e) {
      this.disabled || To(e.target, "data-pc-section") !== "handle" && (this.updateDomData(), this.setValue(e));
    },
    onMouseDown: function(e, n) {
      this.bindDragListeners(), this.onDragStart(e, n);
    },
    onKeyDown: function(e, n) {
      switch (this.handleIndex = n, e.code) {
        case "ArrowDown":
        case "ArrowLeft":
          this.decrementValue(e, n), e.preventDefault();
          break;
        case "ArrowUp":
        case "ArrowRight":
          this.incrementValue(e, n), e.preventDefault();
          break;
        case "PageDown":
          this.decrementValue(e, n, !0), e.preventDefault();
          break;
        case "PageUp":
          this.incrementValue(e, n, !0), e.preventDefault();
          break;
        case "Home":
          this.updateModel(e, this.min), e.preventDefault();
          break;
        case "End":
          this.updateModel(e, this.max), e.preventDefault();
          break;
      }
    },
    onBlur: function(e, n) {
      var r, o;
      (r = (o = this.formField).onBlur) === null || r === void 0 || r.call(o, e);
    },
    decrementValue: function(e, n) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, o;
      this.range ? this.step ? o = this.value[n] - this.step : o = this.value[n] - 1 : this.step ? o = this.value - this.step : !this.step && r ? o = this.value - 10 : o = this.value - 1, this.updateModel(e, o), e.preventDefault();
    },
    incrementValue: function(e, n) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, o;
      this.range ? this.step ? o = this.value[n] + this.step : o = this.value[n] + 1 : this.step ? o = this.value + this.step : !this.step && r ? o = this.value + 10 : o = this.value + 1, this.updateModel(e, o), e.preventDefault();
    },
    bindDragListeners: function() {
      this.dragListener || (this.dragListener = this.onDrag.bind(this), document.addEventListener("mousemove", this.dragListener)), this.dragEndListener || (this.dragEndListener = this.onDragEnd.bind(this), document.addEventListener("mouseup", this.dragEndListener));
    },
    unbindDragListeners: function() {
      this.dragListener && (document.removeEventListener("mousemove", this.dragListener), this.dragListener = null), this.dragEndListener && (document.removeEventListener("mouseup", this.dragEndListener), this.dragEndListener = null);
    },
    rangeStyle: function() {
      if (this.range) {
        var e = this.rangeEndPosition > this.rangeStartPosition ? this.rangeEndPosition - this.rangeStartPosition : this.rangeStartPosition - this.rangeEndPosition, n = this.rangeEndPosition > this.rangeStartPosition ? this.rangeStartPosition : this.rangeEndPosition;
        return this.horizontal ? {
          "inset-inline-start": n + "%",
          width: e + "%"
        } : {
          bottom: n + "%",
          height: e + "%"
        };
      } else
        return this.horizontal ? {
          width: this.handlePosition + "%"
        } : {
          height: this.handlePosition + "%"
        };
    },
    handleStyle: function() {
      return this.horizontal ? {
        "inset-inline-start": this.handlePosition + "%"
      } : {
        bottom: this.handlePosition + "%"
      };
    },
    rangeStartHandleStyle: function() {
      return this.horizontal ? {
        "inset-inline-start": this.rangeStartPosition + "%"
      } : {
        bottom: this.rangeStartPosition + "%"
      };
    },
    rangeEndHandleStyle: function() {
      return this.horizontal ? {
        "inset-inline-start": this.rangeEndPosition + "%"
      } : {
        bottom: this.rangeEndPosition + "%"
      };
    }
  },
  computed: {
    value: function() {
      var e;
      if (this.range) {
        var n, r, o, s;
        return [(n = (r = this.d_value) === null || r === void 0 ? void 0 : r[0]) !== null && n !== void 0 ? n : this.min, (o = (s = this.d_value) === null || s === void 0 ? void 0 : s[1]) !== null && o !== void 0 ? o : this.max];
      }
      return (e = this.d_value) !== null && e !== void 0 ? e : this.min;
    },
    horizontal: function() {
      return this.orientation === "horizontal";
    },
    vertical: function() {
      return this.orientation === "vertical";
    },
    handlePosition: function() {
      return this.value < this.min ? 0 : this.value > this.max ? 100 : (this.value - this.min) * 100 / (this.max - this.min);
    },
    rangeStartPosition: function() {
      return this.value && this.value[0] !== void 0 ? this.value[0] < this.min ? 0 : (this.value[0] - this.min) * 100 / (this.max - this.min) : 0;
    },
    rangeEndPosition: function() {
      return this.value && this.value.length === 2 && this.value[1] !== void 0 ? this.value[1] > this.max ? 100 : (this.value[1] - this.min) * 100 / (this.max - this.min) : 100;
    },
    dataP: function() {
      return ui(KF({}, this.orientation, this.orientation));
    }
  }
}, ij = ["data-p"], rj = ["data-p"], oj = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation", "data-p"], sj = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation", "data-p"], aj = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation", "data-p"];
function lj(i, e, n, r, o, s) {
  return $(), A("div", ke({
    class: i.cx("root"),
    onClick: e[18] || (e[18] = function() {
      return s.onBarClick && s.onBarClick.apply(s, arguments);
    })
  }, i.ptmi("root"), {
    "data-p-sliding": !1,
    "data-p": s.dataP
  }), [f("span", ke({
    class: i.cx("range"),
    style: [i.sx("range"), s.rangeStyle()]
  }, i.ptm("range"), {
    "data-p": s.dataP
  }), null, 16, rj), i.range ? ve("", !0) : ($(), A("span", ke({
    key: 0,
    class: i.cx("handle"),
    style: [i.sx("handle"), s.handleStyle()],
    onTouchstartPassive: e[0] || (e[0] = function(a) {
      return s.onDragStart(a);
    }),
    onTouchmovePassive: e[1] || (e[1] = function(a) {
      return s.onDrag(a);
    }),
    onTouchend: e[2] || (e[2] = function(a) {
      return s.onDragEnd(a);
    }),
    onMousedown: e[3] || (e[3] = function(a) {
      return s.onMouseDown(a);
    }),
    onKeydown: e[4] || (e[4] = function(a) {
      return s.onKeyDown(a);
    }),
    onBlur: e[5] || (e[5] = function(a) {
      return s.onBlur(a);
    }),
    tabindex: i.tabindex,
    role: "slider",
    "aria-valuemin": i.min,
    "aria-valuenow": i.d_value,
    "aria-valuemax": i.max,
    "aria-labelledby": i.ariaLabelledby,
    "aria-label": i.ariaLabel,
    "aria-orientation": i.orientation
  }, i.ptm("handle"), {
    "data-p": s.dataP
  }), null, 16, oj)), i.range ? ($(), A("span", ke({
    key: 1,
    class: i.cx("handle"),
    style: [i.sx("handle"), s.rangeStartHandleStyle()],
    onTouchstartPassive: e[6] || (e[6] = function(a) {
      return s.onDragStart(a, 0);
    }),
    onTouchmovePassive: e[7] || (e[7] = function(a) {
      return s.onDrag(a);
    }),
    onTouchend: e[8] || (e[8] = function(a) {
      return s.onDragEnd(a);
    }),
    onMousedown: e[9] || (e[9] = function(a) {
      return s.onMouseDown(a, 0);
    }),
    onKeydown: e[10] || (e[10] = function(a) {
      return s.onKeyDown(a, 0);
    }),
    onBlur: e[11] || (e[11] = function(a) {
      return s.onBlur(a, 0);
    }),
    tabindex: i.tabindex,
    role: "slider",
    "aria-valuemin": i.min,
    "aria-valuenow": i.d_value ? i.d_value[0] : null,
    "aria-valuemax": i.max,
    "aria-labelledby": i.ariaLabelledby,
    "aria-label": i.ariaLabel,
    "aria-orientation": i.orientation
  }, i.ptm("startHandler"), {
    "data-p": s.dataP
  }), null, 16, sj)) : ve("", !0), i.range ? ($(), A("span", ke({
    key: 2,
    class: i.cx("handle"),
    style: [i.sx("handle"), s.rangeEndHandleStyle()],
    onTouchstartPassive: e[12] || (e[12] = function(a) {
      return s.onDragStart(a, 1);
    }),
    onTouchmovePassive: e[13] || (e[13] = function(a) {
      return s.onDrag(a);
    }),
    onTouchend: e[14] || (e[14] = function(a) {
      return s.onDragEnd(a);
    }),
    onMousedown: e[15] || (e[15] = function(a) {
      return s.onMouseDown(a, 1);
    }),
    onKeydown: e[16] || (e[16] = function(a) {
      return s.onKeyDown(a, 1);
    }),
    onBlur: e[17] || (e[17] = function(a) {
      return s.onBlur(a, 1);
    }),
    tabindex: i.tabindex,
    role: "slider",
    "aria-valuemin": i.min,
    "aria-valuenow": i.d_value ? i.d_value[1] : null,
    "aria-valuemax": i.max,
    "aria-labelledby": i.ariaLabelledby,
    "aria-label": i.ariaLabel,
    "aria-orientation": i.orientation
  }, i.ptm("endHandler"), {
    "data-p": s.dataP
  }), null, 16, aj)) : ve("", !0)], 16, ij);
}
$1.render = lj;
function Ul(i) {
  "@babel/helpers - typeof";
  return Ul = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Ul(i);
}
function uj(i, e) {
  if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function cj(i, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, hj(r.key), r);
  }
}
function dj(i, e, n) {
  return e && cj(i.prototype, e), Object.defineProperty(i, "prototype", { writable: !1 }), i;
}
function hj(i) {
  var e = fj(i, "string");
  return Ul(e) == "symbol" ? e : e + "";
}
function fj(i, e) {
  if (Ul(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Ul(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(i);
}
var Op = /* @__PURE__ */ function() {
  function i(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
    };
    uj(this, i), this.element = e, this.listener = n;
  }
  return dj(i, [{
    key: "bindScrollListener",
    value: function() {
      this.scrollableParents = _C(this.element);
      for (var n = 0; n < this.scrollableParents.length; n++)
        this.scrollableParents[n].addEventListener("scroll", this.listener);
    }
  }, {
    key: "unbindScrollListener",
    value: function() {
      if (this.scrollableParents)
        for (var n = 0; n < this.scrollableParents.length; n++)
          this.scrollableParents[n].removeEventListener("scroll", this.listener);
    }
  }, {
    key: "destroy",
    value: function() {
      this.unbindScrollListener(), this.element = null, this.listener = null, this.scrollableParents = null;
    }
  }]);
}(), M1 = {
  name: "BlankIcon",
  extends: kr
};
function pj(i) {
  return yj(i) || vj(i) || gj(i) || mj();
}
function mj() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function gj(i, e) {
  if (i) {
    if (typeof i == "string") return hf(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? hf(i, e) : void 0;
  }
}
function vj(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function yj(i) {
  if (Array.isArray(i)) return hf(i);
}
function hf(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function bj(i, e, n, r, o, s) {
  return $(), A("svg", ke({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i.pti()), pj(e[0] || (e[0] = [f("rect", {
    width: "1",
    height: "1",
    fill: "currentColor",
    "fill-opacity": "0"
  }, null, -1)])), 16);
}
M1.render = bj;
var P1 = {
  name: "CheckIcon",
  extends: kr
};
function wj(i) {
  return Cj(i) || Sj(i) || xj(i) || _j();
}
function _j() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function xj(i, e) {
  if (i) {
    if (typeof i == "string") return ff(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ff(i, e) : void 0;
  }
}
function Sj(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function Cj(i) {
  if (Array.isArray(i)) return ff(i);
}
function ff(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function kj(i, e, n, r, o, s) {
  return $(), A("svg", ke({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i.pti()), wj(e[0] || (e[0] = [f("path", {
    d: "M4.86199 11.5948C4.78717 11.5923 4.71366 11.5745 4.64596 11.5426C4.57826 11.5107 4.51779 11.4652 4.46827 11.4091L0.753985 7.69483C0.683167 7.64891 0.623706 7.58751 0.580092 7.51525C0.536478 7.44299 0.509851 7.36177 0.502221 7.27771C0.49459 7.19366 0.506156 7.10897 0.536046 7.03004C0.565935 6.95111 0.613367 6.88 0.674759 6.82208C0.736151 6.76416 0.8099 6.72095 0.890436 6.69571C0.970973 6.67046 1.05619 6.66385 1.13966 6.67635C1.22313 6.68886 1.30266 6.72017 1.37226 6.76792C1.44186 6.81567 1.4997 6.8786 1.54141 6.95197L4.86199 10.2503L12.6397 2.49483C12.7444 2.42694 12.8689 2.39617 12.9932 2.40745C13.1174 2.41873 13.2343 2.47141 13.3251 2.55705C13.4159 2.64268 13.4753 2.75632 13.4938 2.87973C13.5123 3.00315 13.4888 3.1292 13.4271 3.23768L5.2557 11.4091C5.20618 11.4652 5.14571 11.5107 5.07801 11.5426C5.01031 11.5745 4.9368 11.5923 4.86199 11.5948Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
P1.render = kj;
var I1 = {
  name: "ChevronDownIcon",
  extends: kr
};
function Oj(i) {
  return $j(i) || Dj(i) || Tj(i) || Ej();
}
function Ej() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Tj(i, e) {
  if (i) {
    if (typeof i == "string") return pf(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? pf(i, e) : void 0;
  }
}
function Dj(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function $j(i) {
  if (Array.isArray(i)) return pf(i);
}
function pf(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function Mj(i, e, n, r, o, s) {
  return $(), A("svg", ke({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i.pti()), Oj(e[0] || (e[0] = [f("path", {
    d: "M7.01744 10.398C6.91269 10.3985 6.8089 10.378 6.71215 10.3379C6.61541 10.2977 6.52766 10.2386 6.45405 10.1641L1.13907 4.84913C1.03306 4.69404 0.985221 4.5065 1.00399 4.31958C1.02276 4.13266 1.10693 3.95838 1.24166 3.82747C1.37639 3.69655 1.55301 3.61742 1.74039 3.60402C1.92777 3.59062 2.11386 3.64382 2.26584 3.75424L7.01744 8.47394L11.769 3.75424C11.9189 3.65709 12.097 3.61306 12.2748 3.62921C12.4527 3.64535 12.6199 3.72073 12.7498 3.84328C12.8797 3.96582 12.9647 4.12842 12.9912 4.30502C13.0177 4.48162 12.9841 4.662 12.8958 4.81724L7.58083 10.1322C7.50996 10.2125 7.42344 10.2775 7.32656 10.3232C7.22968 10.3689 7.12449 10.3944 7.01744 10.398Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
I1.render = Mj;
var L1 = {
  name: "SearchIcon",
  extends: kr
};
function Pj(i) {
  return Vj(i) || Aj(i) || Lj(i) || Ij();
}
function Ij() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Lj(i, e) {
  if (i) {
    if (typeof i == "string") return mf(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? mf(i, e) : void 0;
  }
}
function Aj(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function Vj(i) {
  if (Array.isArray(i)) return mf(i);
}
function mf(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function Fj(i, e, n, r, o, s) {
  return $(), A("svg", ke({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i.pti()), Pj(e[0] || (e[0] = [f("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M2.67602 11.0265C3.6661 11.688 4.83011 12.0411 6.02086 12.0411C6.81149 12.0411 7.59438 11.8854 8.32483 11.5828C8.87005 11.357 9.37808 11.0526 9.83317 10.6803L12.9769 13.8241C13.0323 13.8801 13.0983 13.9245 13.171 13.9548C13.2438 13.985 13.3219 14.0003 13.4007 14C13.4795 14.0003 13.5575 13.985 13.6303 13.9548C13.7031 13.9245 13.7691 13.8801 13.8244 13.8241C13.9367 13.7116 13.9998 13.5592 13.9998 13.4003C13.9998 13.2414 13.9367 13.089 13.8244 12.9765L10.6807 9.8328C11.053 9.37773 11.3573 8.86972 11.5831 8.32452C11.8857 7.59408 12.0414 6.81119 12.0414 6.02056C12.0414 4.8298 11.6883 3.66579 11.0268 2.67572C10.3652 1.68564 9.42494 0.913972 8.32483 0.45829C7.22472 0.00260857 6.01418 -0.116618 4.84631 0.115686C3.67844 0.34799 2.60568 0.921393 1.76369 1.76338C0.921698 2.60537 0.348296 3.67813 0.115991 4.84601C-0.116313 6.01388 0.00291375 7.22441 0.458595 8.32452C0.914277 9.42464 1.68595 10.3649 2.67602 11.0265ZM3.35565 2.0158C4.14456 1.48867 5.07206 1.20731 6.02086 1.20731C7.29317 1.20731 8.51338 1.71274 9.41304 2.6124C10.3127 3.51206 10.8181 4.73226 10.8181 6.00457C10.8181 6.95337 10.5368 7.88088 10.0096 8.66978C9.48251 9.45868 8.73328 10.0736 7.85669 10.4367C6.98011 10.7997 6.01554 10.8947 5.08496 10.7096C4.15439 10.5245 3.2996 10.0676 2.62869 9.39674C1.95778 8.72583 1.50089 7.87104 1.31579 6.94046C1.13068 6.00989 1.22568 5.04532 1.58878 4.16874C1.95187 3.29215 2.56675 2.54292 3.35565 2.0158Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
L1.render = Fj;
var Od = {
  name: "TimesIcon",
  extends: kr
};
function jj(i) {
  return Bj(i) || zj(i) || Nj(i) || Rj();
}
function Rj() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Nj(i, e) {
  if (i) {
    if (typeof i == "string") return gf(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? gf(i, e) : void 0;
  }
}
function zj(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function Bj(i) {
  if (Array.isArray(i)) return gf(i);
}
function gf(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function Hj(i, e, n, r, o, s) {
  return $(), A("svg", ke({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i.pti()), jj(e[0] || (e[0] = [f("path", {
    d: "M8.01186 7.00933L12.27 2.75116C12.341 2.68501 12.398 2.60524 12.4375 2.51661C12.4769 2.42798 12.4982 2.3323 12.4999 2.23529C12.5016 2.13827 12.4838 2.0419 12.4474 1.95194C12.4111 1.86197 12.357 1.78024 12.2884 1.71163C12.2198 1.64302 12.138 1.58893 12.0481 1.55259C11.9581 1.51625 11.8617 1.4984 11.7647 1.50011C11.6677 1.50182 11.572 1.52306 11.4834 1.56255C11.3948 1.60204 11.315 1.65898 11.2488 1.72997L6.99067 5.98814L2.7325 1.72997C2.59553 1.60234 2.41437 1.53286 2.22718 1.53616C2.03999 1.53946 1.8614 1.61529 1.72901 1.74767C1.59663 1.88006 1.5208 2.05865 1.5175 2.24584C1.5142 2.43303 1.58368 2.61419 1.71131 2.75116L5.96948 7.00933L1.71131 11.2675C1.576 11.403 1.5 11.5866 1.5 11.7781C1.5 11.9696 1.576 12.1532 1.71131 12.2887C1.84679 12.424 2.03043 12.5 2.2219 12.5C2.41338 12.5 2.59702 12.424 2.7325 12.2887L6.99067 8.03052L11.2488 12.2887C11.3843 12.424 11.568 12.5 11.7594 12.5C11.9509 12.5 12.1346 12.424 12.27 12.2887C12.4053 12.1532 12.4813 11.9696 12.4813 11.7781C12.4813 11.5866 12.4053 11.403 12.27 11.2675L8.01186 7.00933Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
Od.render = Hj;
var Uj = `
    .p-iconfield {
        position: relative;
        display: block;
    }

    .p-inputicon {
        position: absolute;
        top: 50%;
        margin-top: calc(-1 * (dt('icon.size') / 2));
        color: dt('iconfield.icon.color');
        line-height: 1;
        z-index: 1;
    }

    .p-iconfield .p-inputicon:first-child {
        inset-inline-start: dt('form.field.padding.x');
    }

    .p-iconfield .p-inputicon:last-child {
        inset-inline-end: dt('form.field.padding.x');
    }

    .p-iconfield .p-inputtext:not(:first-child),
    .p-iconfield .p-inputwrapper:not(:first-child) .p-inputtext {
        padding-inline-start: calc((dt('form.field.padding.x') * 2) + dt('icon.size'));
    }

    .p-iconfield .p-inputtext:not(:last-child) {
        padding-inline-end: calc((dt('form.field.padding.x') * 2) + dt('icon.size'));
    }

    .p-iconfield:has(.p-inputfield-sm) .p-inputicon {
        font-size: dt('form.field.sm.font.size');
        width: dt('form.field.sm.font.size');
        height: dt('form.field.sm.font.size');
        margin-top: calc(-1 * (dt('form.field.sm.font.size') / 2));
    }

    .p-iconfield:has(.p-inputfield-lg) .p-inputicon {
        font-size: dt('form.field.lg.font.size');
        width: dt('form.field.lg.font.size');
        height: dt('form.field.lg.font.size');
        margin-top: calc(-1 * (dt('form.field.lg.font.size') / 2));
    }
`, Wj = {
  root: "p-iconfield"
}, Gj = bt.extend({
  name: "iconfield",
  style: Uj,
  classes: Wj
}), Xj = {
  name: "BaseIconField",
  extends: Ho,
  style: Gj,
  provide: function() {
    return {
      $pcIconField: this,
      $parentInstance: this
    };
  }
}, A1 = {
  name: "IconField",
  extends: Xj,
  inheritAttrs: !1
};
function Yj(i, e, n, r, o, s) {
  return $(), A("div", ke({
    class: i.cx("root")
  }, i.ptmi("root")), [it(i.$slots, "default")], 16);
}
A1.render = Yj;
var Kj = {
  root: "p-inputicon"
}, qj = bt.extend({
  name: "inputicon",
  classes: Kj
}), Zj = {
  name: "BaseInputIcon",
  extends: Ho,
  style: qj,
  props: {
    class: null
  },
  provide: function() {
    return {
      $pcInputIcon: this,
      $parentInstance: this
    };
  }
}, V1 = {
  name: "InputIcon",
  extends: Zj,
  inheritAttrs: !1,
  computed: {
    containerClass: function() {
      return [this.cx("root"), this.class];
    }
  }
};
function Jj(i, e, n, r, o, s) {
  return $(), A("span", ke({
    class: s.containerClass
  }, i.ptmi("root"), {
    "aria-hidden": "true"
  }), [it(i.$slots, "default")], 16);
}
V1.render = Jj;
var Ep = {
  name: "BaseInput",
  extends: kp,
  props: {
    size: {
      type: String,
      default: null
    },
    fluid: {
      type: Boolean,
      default: null
    },
    variant: {
      type: String,
      default: null
    }
  },
  inject: {
    $parentInstance: {
      default: void 0
    },
    $pcFluid: {
      default: void 0
    }
  },
  computed: {
    $variant: function() {
      var e;
      return (e = this.variant) !== null && e !== void 0 ? e : this.$primevue.config.inputStyle || this.$primevue.config.inputVariant;
    },
    $fluid: function() {
      var e;
      return (e = this.fluid) !== null && e !== void 0 ? e : !!this.$pcFluid;
    },
    // @deprecated use $fluid instead
    hasFluid: function() {
      return this.$fluid;
    }
  }
}, Qj = `
    .p-inputtext {
        font-family: inherit;
        font-feature-settings: inherit;
        font-size: 1rem;
        color: dt('inputtext.color');
        background: dt('inputtext.background');
        padding-block: dt('inputtext.padding.y');
        padding-inline: dt('inputtext.padding.x');
        border: 1px solid dt('inputtext.border.color');
        transition:
            background dt('inputtext.transition.duration'),
            color dt('inputtext.transition.duration'),
            border-color dt('inputtext.transition.duration'),
            outline-color dt('inputtext.transition.duration'),
            box-shadow dt('inputtext.transition.duration');
        appearance: none;
        border-radius: dt('inputtext.border.radius');
        outline-color: transparent;
        box-shadow: dt('inputtext.shadow');
    }

    .p-inputtext:enabled:hover {
        border-color: dt('inputtext.hover.border.color');
    }

    .p-inputtext:enabled:focus {
        border-color: dt('inputtext.focus.border.color');
        box-shadow: dt('inputtext.focus.ring.shadow');
        outline: dt('inputtext.focus.ring.width') dt('inputtext.focus.ring.style') dt('inputtext.focus.ring.color');
        outline-offset: dt('inputtext.focus.ring.offset');
    }

    .p-inputtext.p-invalid {
        border-color: dt('inputtext.invalid.border.color');
    }

    .p-inputtext.p-variant-filled {
        background: dt('inputtext.filled.background');
    }

    .p-inputtext.p-variant-filled:enabled:hover {
        background: dt('inputtext.filled.hover.background');
    }

    .p-inputtext.p-variant-filled:enabled:focus {
        background: dt('inputtext.filled.focus.background');
    }

    .p-inputtext:disabled {
        opacity: 1;
        background: dt('inputtext.disabled.background');
        color: dt('inputtext.disabled.color');
    }

    .p-inputtext::placeholder {
        color: dt('inputtext.placeholder.color');
    }

    .p-inputtext.p-invalid::placeholder {
        color: dt('inputtext.invalid.placeholder.color');
    }

    .p-inputtext-sm {
        font-size: dt('inputtext.sm.font.size');
        padding-block: dt('inputtext.sm.padding.y');
        padding-inline: dt('inputtext.sm.padding.x');
    }

    .p-inputtext-lg {
        font-size: dt('inputtext.lg.font.size');
        padding-block: dt('inputtext.lg.padding.y');
        padding-inline: dt('inputtext.lg.padding.x');
    }

    .p-inputtext-fluid {
        width: 100%;
    }
`, eR = {
  root: function(e) {
    var n = e.instance, r = e.props;
    return ["p-inputtext p-component", {
      "p-filled": n.$filled,
      "p-inputtext-sm p-inputfield-sm": r.size === "small",
      "p-inputtext-lg p-inputfield-lg": r.size === "large",
      "p-invalid": n.$invalid,
      "p-variant-filled": n.$variant === "filled",
      "p-inputtext-fluid": n.$fluid
    }];
  }
}, tR = bt.extend({
  name: "inputtext",
  style: Qj,
  classes: eR
}), nR = {
  name: "BaseInputText",
  extends: Ep,
  style: tR,
  provide: function() {
    return {
      $pcInputText: this,
      $parentInstance: this
    };
  }
};
function Wl(i) {
  "@babel/helpers - typeof";
  return Wl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Wl(i);
}
function iR(i, e, n) {
  return (e = rR(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function rR(i) {
  var e = oR(i, "string");
  return Wl(e) == "symbol" ? e : e + "";
}
function oR(i, e) {
  if (Wl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Wl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var Ed = {
  name: "InputText",
  extends: nR,
  inheritAttrs: !1,
  methods: {
    onInput: function(e) {
      this.writeValue(e.target.value, e);
    }
  },
  computed: {
    attrs: function() {
      return ke(this.ptmi("root", {
        context: {
          filled: this.$filled,
          disabled: this.disabled
        }
      }), this.formField);
    },
    dataP: function() {
      return ui(iR({
        invalid: this.$invalid,
        fluid: this.$fluid,
        filled: this.$variant === "filled"
      }, this.size, this.size));
    }
  }
}, sR = ["value", "name", "disabled", "aria-invalid", "data-p"];
function aR(i, e, n, r, o, s) {
  return $(), A("input", ke({
    type: "text",
    class: i.cx("root"),
    value: i.d_value,
    name: i.name,
    disabled: i.disabled,
    "aria-invalid": i.$invalid || void 0,
    "data-p": s.dataP,
    onInput: e[0] || (e[0] = function() {
      return s.onInput && s.onInput.apply(s, arguments);
    })
  }, s.attrs), null, 16, sR);
}
Ed.render = aR;
var F1 = Yf(), Td = {
  name: "Portal",
  props: {
    appendTo: {
      type: [String, Object],
      default: "body"
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  data: function() {
    return {
      mounted: !1
    };
  },
  mounted: function() {
    this.mounted = tb();
  },
  computed: {
    inline: function() {
      return this.disabled || this.appendTo === "self";
    }
  }
};
function lR(i, e, n, r, o, s) {
  return s.inline ? it(i.$slots, "default", {
    key: 0
  }) : o.mounted ? ($(), st(k_, {
    key: 1,
    to: n.appendTo
  }, [it(i.$slots, "default")], 8, ["to"])) : ve("", !0);
}
Td.render = lR;
var uR = `
    .p-virtualscroller-loader {
        background: dt('virtualscroller.loader.mask.background');
        color: dt('virtualscroller.loader.mask.color');
    }

    .p-virtualscroller-loading-icon {
        font-size: dt('virtualscroller.loader.icon.size');
        width: dt('virtualscroller.loader.icon.size');
        height: dt('virtualscroller.loader.icon.size');
    }
`, cR = `
.p-virtualscroller {
    position: relative;
    overflow: auto;
    contain: strict;
    transform: translateZ(0);
    will-change: scroll-position;
    outline: 0 none;
}

.p-virtualscroller-content {
    position: absolute;
    top: 0;
    left: 0;
    min-height: 100%;
    min-width: 100%;
    will-change: transform;
}

.p-virtualscroller-spacer {
    position: absolute;
    top: 0;
    left: 0;
    height: 1px;
    width: 1px;
    transform-origin: 0 0;
    pointer-events: none;
}

.p-virtualscroller-loader {
    position: sticky;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

.p-virtualscroller-loader-mask {
    display: flex;
    align-items: center;
    justify-content: center;
}

.p-virtualscroller-horizontal > .p-virtualscroller-content {
    display: flex;
}

.p-virtualscroller-inline .p-virtualscroller-content {
    position: static;
}

.p-virtualscroller .p-virtualscroller-loading {
    transform: none !important;
    min-height: 0;
    position: sticky;
    inset-block-start: 0;
    inset-inline-start: 0;
}
`, jv = bt.extend({
  name: "virtualscroller",
  css: cR,
  style: uR
}), dR = {
  name: "BaseVirtualScroller",
  extends: Ho,
  props: {
    id: {
      type: String,
      default: null
    },
    style: null,
    class: null,
    items: {
      type: Array,
      default: null
    },
    itemSize: {
      type: [Number, Array],
      default: 0
    },
    scrollHeight: null,
    scrollWidth: null,
    orientation: {
      type: String,
      default: "vertical"
    },
    numToleratedItems: {
      type: Number,
      default: null
    },
    delay: {
      type: Number,
      default: 0
    },
    resizeDelay: {
      type: Number,
      default: 10
    },
    lazy: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    loaderDisabled: {
      type: Boolean,
      default: !1
    },
    columns: {
      type: Array,
      default: null
    },
    loading: {
      type: Boolean,
      default: !1
    },
    showSpacer: {
      type: Boolean,
      default: !0
    },
    showLoader: {
      type: Boolean,
      default: !1
    },
    tabindex: {
      type: Number,
      default: 0
    },
    inline: {
      type: Boolean,
      default: !1
    },
    step: {
      type: Number,
      default: 0
    },
    appendOnly: {
      type: Boolean,
      default: !1
    },
    autoSize: {
      type: Boolean,
      default: !1
    }
  },
  style: jv,
  provide: function() {
    return {
      $pcVirtualScroller: this,
      $parentInstance: this
    };
  },
  beforeMount: function() {
    var e;
    jv.loadCSS({
      nonce: (e = this.$primevueConfig) === null || e === void 0 || (e = e.csp) === null || e === void 0 ? void 0 : e.nonce
    });
  }
};
function Gl(i) {
  "@babel/helpers - typeof";
  return Gl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Gl(i);
}
function Rv(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xa(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Rv(Object(n), !0).forEach(function(r) {
      j1(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : Rv(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function j1(i, e, n) {
  return (e = hR(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function hR(i) {
  var e = fR(i, "string");
  return Gl(e) == "symbol" ? e : e + "";
}
function fR(i, e) {
  if (Gl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Gl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var R1 = {
  name: "VirtualScroller",
  extends: dR,
  inheritAttrs: !1,
  emits: ["update:numToleratedItems", "scroll", "scroll-index-change", "lazy-load"],
  data: function() {
    var e = this.isBoth();
    return {
      first: e ? {
        rows: 0,
        cols: 0
      } : 0,
      last: e ? {
        rows: 0,
        cols: 0
      } : 0,
      page: e ? {
        rows: 0,
        cols: 0
      } : 0,
      numItemsInViewport: e ? {
        rows: 0,
        cols: 0
      } : 0,
      lastScrollPos: e ? {
        top: 0,
        left: 0
      } : 0,
      d_numToleratedItems: this.numToleratedItems,
      d_loading: this.loading,
      loaderArr: [],
      spacerStyle: {},
      contentStyle: {}
    };
  },
  element: null,
  content: null,
  lastScrollPos: null,
  scrollTimeout: null,
  resizeTimeout: null,
  defaultWidth: 0,
  defaultHeight: 0,
  defaultContentWidth: 0,
  defaultContentHeight: 0,
  isRangeChanged: !1,
  lazyLoadState: {},
  resizeListener: null,
  resizeObserver: null,
  initialized: !1,
  watch: {
    numToleratedItems: function(e) {
      this.d_numToleratedItems = e;
    },
    loading: function(e, n) {
      this.lazy && e !== n && e !== this.d_loading && (this.d_loading = e);
    },
    items: {
      handler: function(e, n) {
        (!n || n.length !== (e || []).length) && (this.init(), this.calculateAutoSize());
      },
      deep: !0
    },
    itemSize: function() {
      this.init(), this.calculateAutoSize();
    },
    orientation: function() {
      this.lastScrollPos = this.isBoth() ? {
        top: 0,
        left: 0
      } : 0;
    },
    scrollHeight: function() {
      this.init(), this.calculateAutoSize();
    },
    scrollWidth: function() {
      this.init(), this.calculateAutoSize();
    }
  },
  mounted: function() {
    this.viewInit(), this.lastScrollPos = this.isBoth() ? {
      top: 0,
      left: 0
    } : 0, this.lazyLoadState = this.lazyLoadState || {};
  },
  updated: function() {
    !this.initialized && this.viewInit();
  },
  unmounted: function() {
    this.unbindResizeListener(), this.initialized = !1;
  },
  methods: {
    viewInit: function() {
      Fc(this.element) && (this.setContentEl(this.content), this.init(), this.calculateAutoSize(), this.defaultWidth = ls(this.element), this.defaultHeight = as(this.element), this.defaultContentWidth = ls(this.content), this.defaultContentHeight = as(this.content), this.initialized = !0), this.element && this.bindResizeListener();
    },
    init: function() {
      this.disabled || (this.setSize(), this.calculateOptions(), this.setSpacerSize());
    },
    isVertical: function() {
      return this.orientation === "vertical";
    },
    isHorizontal: function() {
      return this.orientation === "horizontal";
    },
    isBoth: function() {
      return this.orientation === "both";
    },
    scrollTo: function(e) {
      this.element && this.element.scrollTo(e);
    },
    scrollToIndex: function(e) {
      var n = this, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "auto", o = this.isBoth(), s = this.isHorizontal(), a = o ? e.every(function(x) {
        return x > -1;
      }) : e > -1;
      if (a) {
        var l = this.first, u = this.element, c = u.scrollTop, d = c === void 0 ? 0 : c, h = u.scrollLeft, p = h === void 0 ? 0 : h, m = this.calculateNumItems(), v = m.numToleratedItems, y = this.getContentPosition(), w = this.itemSize, g = function() {
          var I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, F = arguments.length > 1 ? arguments[1] : void 0;
          return I <= F ? 0 : I;
        }, k = function(I, F, B) {
          return I * F + B;
        }, _ = function() {
          var I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return n.scrollTo({
            left: I,
            top: F,
            behavior: r
          });
        }, S = o ? {
          rows: 0,
          cols: 0
        } : 0, b = !1, C = !1;
        o ? (S = {
          rows: g(e[0], v[0]),
          cols: g(e[1], v[1])
        }, _(k(S.cols, w[1], y.left), k(S.rows, w[0], y.top)), C = this.lastScrollPos.top !== d || this.lastScrollPos.left !== p, b = S.rows !== l.rows || S.cols !== l.cols) : (S = g(e, v), s ? _(k(S, w, y.left), d) : _(p, k(S, w, y.top)), C = this.lastScrollPos !== (s ? p : d), b = S !== l), this.isRangeChanged = b, C && (this.first = S);
      }
    },
    scrollInView: function(e, n) {
      var r = this, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "auto";
      if (n) {
        var s = this.isBoth(), a = this.isHorizontal(), l = s ? e.every(function(w) {
          return w > -1;
        }) : e > -1;
        if (l) {
          var u = this.getRenderedRange(), c = u.first, d = u.viewport, h = function() {
            var g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            return r.scrollTo({
              left: g,
              top: k,
              behavior: o
            });
          }, p = n === "to-start", m = n === "to-end";
          if (p) {
            if (s)
              d.first.rows - c.rows > e[0] ? h(d.first.cols * this.itemSize[1], (d.first.rows - 1) * this.itemSize[0]) : d.first.cols - c.cols > e[1] && h((d.first.cols - 1) * this.itemSize[1], d.first.rows * this.itemSize[0]);
            else if (d.first - c > e) {
              var v = (d.first - 1) * this.itemSize;
              a ? h(v, 0) : h(0, v);
            }
          } else if (m) {
            if (s)
              d.last.rows - c.rows <= e[0] + 1 ? h(d.first.cols * this.itemSize[1], (d.first.rows + 1) * this.itemSize[0]) : d.last.cols - c.cols <= e[1] + 1 && h((d.first.cols + 1) * this.itemSize[1], d.first.rows * this.itemSize[0]);
            else if (d.last - c <= e + 1) {
              var y = (d.first + 1) * this.itemSize;
              a ? h(y, 0) : h(0, y);
            }
          }
        }
      } else
        this.scrollToIndex(e, o);
    },
    getRenderedRange: function() {
      var e = function(h, p) {
        return Math.floor(h / (p || h));
      }, n = this.first, r = 0;
      if (this.element) {
        var o = this.isBoth(), s = this.isHorizontal(), a = this.element, l = a.scrollTop, u = a.scrollLeft;
        if (o)
          n = {
            rows: e(l, this.itemSize[0]),
            cols: e(u, this.itemSize[1])
          }, r = {
            rows: n.rows + this.numItemsInViewport.rows,
            cols: n.cols + this.numItemsInViewport.cols
          };
        else {
          var c = s ? u : l;
          n = e(c, this.itemSize), r = n + this.numItemsInViewport;
        }
      }
      return {
        first: this.first,
        last: this.last,
        viewport: {
          first: n,
          last: r
        }
      };
    },
    calculateNumItems: function() {
      var e = this.isBoth(), n = this.isHorizontal(), r = this.itemSize, o = this.getContentPosition(), s = this.element ? this.element.offsetWidth - o.left : 0, a = this.element ? this.element.offsetHeight - o.top : 0, l = function(p, m) {
        return Math.ceil(p / (m || p));
      }, u = function(p) {
        return Math.ceil(p / 2);
      }, c = e ? {
        rows: l(a, r[0]),
        cols: l(s, r[1])
      } : l(n ? s : a, r), d = this.d_numToleratedItems || (e ? [u(c.rows), u(c.cols)] : u(c));
      return {
        numItemsInViewport: c,
        numToleratedItems: d
      };
    },
    calculateOptions: function() {
      var e = this, n = this.isBoth(), r = this.first, o = this.calculateNumItems(), s = o.numItemsInViewport, a = o.numToleratedItems, l = function(d, h, p) {
        var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
        return e.getLast(d + h + (d < p ? 2 : 3) * p, m);
      }, u = n ? {
        rows: l(r.rows, s.rows, a[0]),
        cols: l(r.cols, s.cols, a[1], !0)
      } : l(r, s, a);
      this.last = u, this.numItemsInViewport = s, this.d_numToleratedItems = a, this.$emit("update:numToleratedItems", this.d_numToleratedItems), this.showLoader && (this.loaderArr = n ? Array.from({
        length: s.rows
      }).map(function() {
        return Array.from({
          length: s.cols
        });
      }) : Array.from({
        length: s
      })), this.lazy && Promise.resolve().then(function() {
        var c;
        e.lazyLoadState = {
          first: e.step ? n ? {
            rows: 0,
            cols: r.cols
          } : 0 : r,
          last: Math.min(e.step ? e.step : u, ((c = e.items) === null || c === void 0 ? void 0 : c.length) || 0)
        }, e.$emit("lazy-load", e.lazyLoadState);
      });
    },
    calculateAutoSize: function() {
      var e = this;
      this.autoSize && !this.d_loading && Promise.resolve().then(function() {
        if (e.content) {
          var n = e.isBoth(), r = e.isHorizontal(), o = e.isVertical();
          e.content.style.minHeight = e.content.style.minWidth = "auto", e.content.style.position = "relative", e.element.style.contain = "none";
          var s = [ls(e.element), as(e.element)], a = s[0], l = s[1];
          (n || r) && (e.element.style.width = a < e.defaultWidth ? a + "px" : e.scrollWidth || e.defaultWidth + "px"), (n || o) && (e.element.style.height = l < e.defaultHeight ? l + "px" : e.scrollHeight || e.defaultHeight + "px"), e.content.style.minHeight = e.content.style.minWidth = "", e.content.style.position = "", e.element.style.contain = "";
        }
      });
    },
    getLast: function() {
      var e, n, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, o = arguments.length > 1 ? arguments[1] : void 0;
      return this.items ? Math.min(o ? ((e = this.columns || this.items[0]) === null || e === void 0 ? void 0 : e.length) || 0 : ((n = this.items) === null || n === void 0 ? void 0 : n.length) || 0, r) : 0;
    },
    getContentPosition: function() {
      if (this.content) {
        var e = getComputedStyle(this.content), n = parseFloat(e.paddingLeft) + Math.max(parseFloat(e.left) || 0, 0), r = parseFloat(e.paddingRight) + Math.max(parseFloat(e.right) || 0, 0), o = parseFloat(e.paddingTop) + Math.max(parseFloat(e.top) || 0, 0), s = parseFloat(e.paddingBottom) + Math.max(parseFloat(e.bottom) || 0, 0);
        return {
          left: n,
          right: r,
          top: o,
          bottom: s,
          x: n + r,
          y: o + s
        };
      }
      return {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        x: 0,
        y: 0
      };
    },
    setSize: function() {
      var e = this;
      if (this.element) {
        var n = this.isBoth(), r = this.isHorizontal(), o = this.element.parentElement, s = this.scrollWidth || "".concat(this.element.offsetWidth || o.offsetWidth, "px"), a = this.scrollHeight || "".concat(this.element.offsetHeight || o.offsetHeight, "px"), l = function(c, d) {
          return e.element.style[c] = d;
        };
        n || r ? (l("height", a), l("width", s)) : l("height", a);
      }
    },
    setSpacerSize: function() {
      var e = this, n = this.items;
      if (n) {
        var r = this.isBoth(), o = this.isHorizontal(), s = this.getContentPosition(), a = function(u, c, d) {
          var h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          return e.spacerStyle = Xa(Xa({}, e.spacerStyle), j1({}, "".concat(u), (c || []).length * d + h + "px"));
        };
        r ? (a("height", n, this.itemSize[0], s.y), a("width", this.columns || n[1], this.itemSize[1], s.x)) : o ? a("width", this.columns || n, this.itemSize, s.x) : a("height", n, this.itemSize, s.y);
      }
    },
    setContentPosition: function(e) {
      var n = this;
      if (this.content && !this.appendOnly) {
        var r = this.isBoth(), o = this.isHorizontal(), s = e ? e.first : this.first, a = function(d, h) {
          return d * h;
        }, l = function() {
          var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return n.contentStyle = Xa(Xa({}, n.contentStyle), {
            transform: "translate3d(".concat(d, "px, ").concat(h, "px, 0)")
          });
        };
        if (r)
          l(a(s.cols, this.itemSize[1]), a(s.rows, this.itemSize[0]));
        else {
          var u = a(s, this.itemSize);
          o ? l(u, 0) : l(0, u);
        }
      }
    },
    onScrollPositionChange: function(e) {
      var n = this, r = e.target, o = this.isBoth(), s = this.isHorizontal(), a = this.getContentPosition(), l = function(X, j) {
        return X ? X > j ? X - j : X : 0;
      }, u = function(X, j) {
        return Math.floor(X / (j || X));
      }, c = function(X, j, ee, ie, M, W) {
        return X <= M ? M : W ? ee - ie - M : j + M - 1;
      }, d = function(X, j, ee, ie, M, W, R, V) {
        if (X <= W) return 0;
        var ae = Math.max(0, R ? X < j ? ee : X - W : X > j ? ee : X - 2 * W), $e = n.getLast(ae, V);
        return ae > $e ? $e - M : ae;
      }, h = function(X, j, ee, ie, M, W) {
        var R = j + ie + 2 * M;
        return X >= M && (R += M + 1), n.getLast(R, W);
      }, p = l(r.scrollTop, a.top), m = l(r.scrollLeft, a.left), v = o ? {
        rows: 0,
        cols: 0
      } : 0, y = this.last, w = !1, g = this.lastScrollPos;
      if (o) {
        var k = this.lastScrollPos.top <= p, _ = this.lastScrollPos.left <= m;
        if (!this.appendOnly || this.appendOnly && (k || _)) {
          var S = {
            rows: u(p, this.itemSize[0]),
            cols: u(m, this.itemSize[1])
          }, b = {
            rows: c(S.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], k),
            cols: c(S.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], _)
          };
          v = {
            rows: d(S.rows, b.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], k),
            cols: d(S.cols, b.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], _, !0)
          }, y = {
            rows: h(S.rows, v.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0]),
            cols: h(S.cols, v.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], !0)
          }, w = v.rows !== this.first.rows || y.rows !== this.last.rows || v.cols !== this.first.cols || y.cols !== this.last.cols || this.isRangeChanged, g = {
            top: p,
            left: m
          };
        }
      } else {
        var C = s ? m : p, x = this.lastScrollPos <= C;
        if (!this.appendOnly || this.appendOnly && x) {
          var I = u(C, this.itemSize), F = c(I, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, x);
          v = d(I, F, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, x), y = h(I, v, this.last, this.numItemsInViewport, this.d_numToleratedItems), w = v !== this.first || y !== this.last || this.isRangeChanged, g = C;
        }
      }
      return {
        first: v,
        last: y,
        isRangeChanged: w,
        scrollPos: g
      };
    },
    onScrollChange: function(e) {
      var n = this.onScrollPositionChange(e), r = n.first, o = n.last, s = n.isRangeChanged, a = n.scrollPos;
      if (s) {
        var l = {
          first: r,
          last: o
        };
        if (this.setContentPosition(l), this.first = r, this.last = o, this.lastScrollPos = a, this.$emit("scroll-index-change", l), this.lazy && this.isPageChanged(r)) {
          var u, c, d = {
            first: this.step ? Math.min(this.getPageByFirst(r) * this.step, (((u = this.items) === null || u === void 0 ? void 0 : u.length) || 0) - this.step) : r,
            last: Math.min(this.step ? (this.getPageByFirst(r) + 1) * this.step : o, ((c = this.items) === null || c === void 0 ? void 0 : c.length) || 0)
          }, h = this.lazyLoadState.first !== d.first || this.lazyLoadState.last !== d.last;
          h && this.$emit("lazy-load", d), this.lazyLoadState = d;
        }
      }
    },
    onScroll: function(e) {
      var n = this;
      if (this.$emit("scroll", e), this.delay) {
        if (this.scrollTimeout && clearTimeout(this.scrollTimeout), this.isPageChanged()) {
          if (!this.d_loading && this.showLoader) {
            var r = this.onScrollPositionChange(e), o = r.isRangeChanged, s = o || (this.step ? this.isPageChanged() : !1);
            s && (this.d_loading = !0);
          }
          this.scrollTimeout = setTimeout(function() {
            n.onScrollChange(e), n.d_loading && n.showLoader && (!n.lazy || n.loading === void 0) && (n.d_loading = !1, n.page = n.getPageByFirst());
          }, this.delay);
        }
      } else
        this.onScrollChange(e);
    },
    onResize: function() {
      var e = this;
      this.resizeTimeout && clearTimeout(this.resizeTimeout), this.resizeTimeout = setTimeout(function() {
        if (Fc(e.element)) {
          var n = e.isBoth(), r = e.isVertical(), o = e.isHorizontal(), s = [ls(e.element), as(e.element)], a = s[0], l = s[1], u = a !== e.defaultWidth, c = l !== e.defaultHeight, d = n ? u || c : o ? u : r ? c : !1;
          d && (e.d_numToleratedItems = e.numToleratedItems, e.defaultWidth = a, e.defaultHeight = l, e.defaultContentWidth = ls(e.content), e.defaultContentHeight = as(e.content), e.init());
        }
      }, this.resizeDelay);
    },
    bindResizeListener: function() {
      var e = this;
      this.resizeListener || (this.resizeListener = this.onResize.bind(this), window.addEventListener("resize", this.resizeListener), window.addEventListener("orientationchange", this.resizeListener), this.resizeObserver = new ResizeObserver(function() {
        e.onResize();
      }), this.resizeObserver.observe(this.element));
    },
    unbindResizeListener: function() {
      this.resizeListener && (window.removeEventListener("resize", this.resizeListener), window.removeEventListener("orientationchange", this.resizeListener), this.resizeListener = null), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null);
    },
    getOptions: function(e) {
      var n = (this.items || []).length, r = this.isBoth() ? this.first.rows + e : this.first + e;
      return {
        index: r,
        count: n,
        first: r === 0,
        last: r === n - 1,
        even: r % 2 === 0,
        odd: r % 2 !== 0
      };
    },
    getLoaderOptions: function(e, n) {
      var r = this.loaderArr.length;
      return Xa({
        index: e,
        count: r,
        first: e === 0,
        last: e === r - 1,
        even: e % 2 === 0,
        odd: e % 2 !== 0
      }, n);
    },
    getPageByFirst: function(e) {
      return Math.floor(((e ?? this.first) + this.d_numToleratedItems * 4) / (this.step || 1));
    },
    isPageChanged: function(e) {
      return this.step && !this.lazy ? this.page !== this.getPageByFirst(e ?? this.first) : !0;
    },
    setContentEl: function(e) {
      this.content = e || this.content || ba(this.element, '[data-pc-section="content"]');
    },
    elementRef: function(e) {
      this.element = e;
    },
    contentRef: function(e) {
      this.content = e;
    }
  },
  computed: {
    containerClass: function() {
      return ["p-virtualscroller", this.class, {
        "p-virtualscroller-inline": this.inline,
        "p-virtualscroller-both p-both-scroll": this.isBoth(),
        "p-virtualscroller-horizontal p-horizontal-scroll": this.isHorizontal()
      }];
    },
    contentClass: function() {
      return ["p-virtualscroller-content", {
        "p-virtualscroller-loading": this.d_loading
      }];
    },
    loaderClass: function() {
      return ["p-virtualscroller-loader", {
        "p-virtualscroller-loader-mask": !this.$slots.loader
      }];
    },
    loadedItems: function() {
      var e = this;
      return this.items && !this.d_loading ? this.isBoth() ? this.items.slice(this.appendOnly ? 0 : this.first.rows, this.last.rows).map(function(n) {
        return e.columns ? n : n.slice(e.appendOnly ? 0 : e.first.cols, e.last.cols);
      }) : this.isHorizontal() && this.columns ? this.items : this.items.slice(this.appendOnly ? 0 : this.first, this.last) : [];
    },
    loadedRows: function() {
      return this.d_loading ? this.loaderDisabled ? this.loaderArr : [] : this.loadedItems;
    },
    loadedColumns: function() {
      if (this.columns) {
        var e = this.isBoth(), n = this.isHorizontal();
        if (e || n)
          return this.d_loading && this.loaderDisabled ? e ? this.loaderArr[0] : this.loaderArr : this.columns.slice(e ? this.first.cols : this.first, e ? this.last.cols : this.last);
      }
      return this.columns;
    }
  },
  components: {
    SpinnerIcon: kd
  }
}, pR = ["tabindex"];
function mR(i, e, n, r, o, s) {
  var a = Tn("SpinnerIcon");
  return i.disabled ? ($(), A(Fe, {
    key: 1
  }, [it(i.$slots, "default"), it(i.$slots, "content", {
    items: i.items,
    rows: i.items,
    columns: s.loadedColumns
  })], 64)) : ($(), A("div", ke({
    key: 0,
    ref: s.elementRef,
    class: s.containerClass,
    tabindex: i.tabindex,
    style: i.style,
    onScroll: e[0] || (e[0] = function() {
      return s.onScroll && s.onScroll.apply(s, arguments);
    })
  }, i.ptmi("root")), [it(i.$slots, "content", {
    styleClass: s.contentClass,
    items: s.loadedItems,
    getItemOptions: s.getOptions,
    loading: o.d_loading,
    getLoaderOptions: s.getLoaderOptions,
    itemSize: i.itemSize,
    rows: s.loadedRows,
    columns: s.loadedColumns,
    contentRef: s.contentRef,
    spacerStyle: o.spacerStyle,
    contentStyle: o.contentStyle,
    vertical: s.isVertical(),
    horizontal: s.isHorizontal(),
    both: s.isBoth()
  }, function() {
    return [f("div", ke({
      ref: s.contentRef,
      class: s.contentClass,
      style: o.contentStyle
    }, i.ptm("content")), [($(!0), A(Fe, null, Ke(s.loadedItems, function(l, u) {
      return it(i.$slots, "item", {
        key: u,
        item: l,
        options: s.getOptions(u)
      });
    }), 128))], 16)];
  }), i.showSpacer ? ($(), A("div", ke({
    key: 0,
    class: "p-virtualscroller-spacer",
    style: o.spacerStyle
  }, i.ptm("spacer")), null, 16)) : ve("", !0), !i.loaderDisabled && i.showLoader && o.d_loading ? ($(), A("div", ke({
    key: 1,
    class: s.loaderClass
  }, i.ptm("loader")), [i.$slots && i.$slots.loader ? ($(!0), A(Fe, {
    key: 0
  }, Ke(o.loaderArr, function(l, u) {
    return it(i.$slots, "loader", {
      key: u,
      options: s.getLoaderOptions(u, s.isBoth() && {
        numCols: i.d_numItemsInViewport.cols
      })
    });
  }), 128)) : ve("", !0), it(i.$slots, "loadingicon", {}, function() {
    return [Ve(a, ke({
      spin: "",
      class: "p-virtualscroller-loading-icon"
    }, i.ptm("loadingIcon")), null, 16)];
  })], 16)) : ve("", !0)], 16, pR));
}
R1.render = mR;
var gR = `
    .p-select {
        display: inline-flex;
        cursor: pointer;
        position: relative;
        user-select: none;
        background: dt('select.background');
        border: 1px solid dt('select.border.color');
        transition:
            background dt('select.transition.duration'),
            color dt('select.transition.duration'),
            border-color dt('select.transition.duration'),
            outline-color dt('select.transition.duration'),
            box-shadow dt('select.transition.duration');
        border-radius: dt('select.border.radius');
        outline-color: transparent;
        box-shadow: dt('select.shadow');
    }

    .p-select:not(.p-disabled):hover {
        border-color: dt('select.hover.border.color');
    }

    .p-select:not(.p-disabled).p-focus {
        border-color: dt('select.focus.border.color');
        box-shadow: dt('select.focus.ring.shadow');
        outline: dt('select.focus.ring.width') dt('select.focus.ring.style') dt('select.focus.ring.color');
        outline-offset: dt('select.focus.ring.offset');
    }

    .p-select.p-variant-filled {
        background: dt('select.filled.background');
    }

    .p-select.p-variant-filled:not(.p-disabled):hover {
        background: dt('select.filled.hover.background');
    }

    .p-select.p-variant-filled:not(.p-disabled).p-focus {
        background: dt('select.filled.focus.background');
    }

    .p-select.p-invalid {
        border-color: dt('select.invalid.border.color');
    }

    .p-select.p-disabled {
        opacity: 1;
        background: dt('select.disabled.background');
    }

    .p-select-clear-icon {
        align-self: center;
        color: dt('select.clear.icon.color');
        inset-inline-end: dt('select.dropdown.width');
    }

    .p-select-dropdown {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        background: transparent;
        color: dt('select.dropdown.color');
        width: dt('select.dropdown.width');
        border-start-end-radius: dt('select.border.radius');
        border-end-end-radius: dt('select.border.radius');
    }

    .p-select-label {
        display: block;
        white-space: nowrap;
        overflow: hidden;
        flex: 1 1 auto;
        width: 1%;
        padding: dt('select.padding.y') dt('select.padding.x');
        text-overflow: ellipsis;
        cursor: pointer;
        color: dt('select.color');
        background: transparent;
        border: 0 none;
        outline: 0 none;
        font-size: 1rem;
    }

    .p-select-label.p-placeholder {
        color: dt('select.placeholder.color');
    }

    .p-select.p-invalid .p-select-label.p-placeholder {
        color: dt('select.invalid.placeholder.color');
    }

    .p-select.p-disabled .p-select-label {
        color: dt('select.disabled.color');
    }

    .p-select-label-empty {
        overflow: hidden;
        opacity: 0;
    }

    input.p-select-label {
        cursor: default;
    }

    .p-select-overlay {
        position: absolute;
        top: 0;
        left: 0;
        background: dt('select.overlay.background');
        color: dt('select.overlay.color');
        border: 1px solid dt('select.overlay.border.color');
        border-radius: dt('select.overlay.border.radius');
        box-shadow: dt('select.overlay.shadow');
        min-width: 100%;
        transform-origin: inherit;
        will-change: transform;
    }

    .p-select-header {
        padding: dt('select.list.header.padding');
    }

    .p-select-filter {
        width: 100%;
    }

    .p-select-list-container {
        overflow: auto;
    }

    .p-select-option-group {
        cursor: auto;
        margin: 0;
        padding: dt('select.option.group.padding');
        background: dt('select.option.group.background');
        color: dt('select.option.group.color');
        font-weight: dt('select.option.group.font.weight');
    }

    .p-select-list {
        margin: 0;
        padding: 0;
        list-style-type: none;
        padding: dt('select.list.padding');
        gap: dt('select.list.gap');
        display: flex;
        flex-direction: column;
    }

    .p-select-option {
        cursor: pointer;
        font-weight: normal;
        white-space: nowrap;
        position: relative;
        overflow: hidden;
        display: flex;
        align-items: center;
        padding: dt('select.option.padding');
        border: 0 none;
        color: dt('select.option.color');
        background: transparent;
        transition:
            background dt('select.transition.duration'),
            color dt('select.transition.duration'),
            border-color dt('select.transition.duration'),
            box-shadow dt('select.transition.duration'),
            outline-color dt('select.transition.duration');
        border-radius: dt('select.option.border.radius');
    }

    .p-select-option:not(.p-select-option-selected):not(.p-disabled).p-focus {
        background: dt('select.option.focus.background');
        color: dt('select.option.focus.color');
    }

    .p-select-option:not(.p-select-option-selected):not(.p-disabled):hover {
        background: dt('select.option.focus.background');
        color: dt('select.option.focus.color');
    }

    .p-select-option.p-select-option-selected {
        background: dt('select.option.selected.background');
        color: dt('select.option.selected.color');
    }

    .p-select-option.p-select-option-selected.p-focus {
        background: dt('select.option.selected.focus.background');
        color: dt('select.option.selected.focus.color');
    }
   
    .p-select-option-blank-icon {
        flex-shrink: 0;
    }

    .p-select-option-check-icon {
        position: relative;
        flex-shrink: 0;
        margin-inline-start: dt('select.checkmark.gutter.start');
        margin-inline-end: dt('select.checkmark.gutter.end');
        color: dt('select.checkmark.color');
    }

    .p-select-empty-message {
        padding: dt('select.empty.message.padding');
    }

    .p-select-fluid {
        display: flex;
        width: 100%;
    }

    .p-select-sm .p-select-label {
        font-size: dt('select.sm.font.size');
        padding-block: dt('select.sm.padding.y');
        padding-inline: dt('select.sm.padding.x');
    }

    .p-select-sm .p-select-dropdown .p-icon {
        font-size: dt('select.sm.font.size');
        width: dt('select.sm.font.size');
        height: dt('select.sm.font.size');
    }

    .p-select-lg .p-select-label {
        font-size: dt('select.lg.font.size');
        padding-block: dt('select.lg.padding.y');
        padding-inline: dt('select.lg.padding.x');
    }

    .p-select-lg .p-select-dropdown .p-icon {
        font-size: dt('select.lg.font.size');
        width: dt('select.lg.font.size');
        height: dt('select.lg.font.size');
    }

    .p-floatlabel-in .p-select-filter {
        padding-block-start: dt('select.padding.y');
        padding-block-end: dt('select.padding.y');
    }
`, vR = {
  root: function(e) {
    var n = e.instance, r = e.props, o = e.state;
    return ["p-select p-component p-inputwrapper", {
      "p-disabled": r.disabled,
      "p-invalid": n.$invalid,
      "p-variant-filled": n.$variant === "filled",
      "p-focus": o.focused,
      "p-inputwrapper-filled": n.$filled,
      "p-inputwrapper-focus": o.focused || o.overlayVisible,
      "p-select-open": o.overlayVisible,
      "p-select-fluid": n.$fluid,
      "p-select-sm p-inputfield-sm": r.size === "small",
      "p-select-lg p-inputfield-lg": r.size === "large"
    }];
  },
  label: function(e) {
    var n, r = e.instance, o = e.props;
    return ["p-select-label", {
      "p-placeholder": !o.editable && r.label === o.placeholder,
      "p-select-label-empty": !o.editable && !r.$slots.value && (r.label === "p-emptylabel" || ((n = r.label) === null || n === void 0 ? void 0 : n.length) === 0)
    }];
  },
  clearIcon: "p-select-clear-icon",
  dropdown: "p-select-dropdown",
  loadingicon: "p-select-loading-icon",
  dropdownIcon: "p-select-dropdown-icon",
  overlay: "p-select-overlay p-component",
  header: "p-select-header",
  pcFilter: "p-select-filter",
  listContainer: "p-select-list-container",
  list: "p-select-list",
  optionGroup: "p-select-option-group",
  optionGroupLabel: "p-select-option-group-label",
  option: function(e) {
    var n = e.instance, r = e.props, o = e.state, s = e.option, a = e.focusedOption;
    return ["p-select-option", {
      "p-select-option-selected": n.isSelected(s) && r.highlightOnSelect,
      "p-focus": o.focusedOptionIndex === a,
      "p-disabled": n.isOptionDisabled(s)
    }];
  },
  optionLabel: "p-select-option-label",
  optionCheckIcon: "p-select-option-check-icon",
  optionBlankIcon: "p-select-option-blank-icon",
  emptyMessage: "p-select-empty-message"
}, yR = bt.extend({
  name: "select",
  style: gR,
  classes: vR
}), bR = {
  name: "BaseSelect",
  extends: Ep,
  props: {
    options: Array,
    optionLabel: [String, Function],
    optionValue: [String, Function],
    optionDisabled: [String, Function],
    optionGroupLabel: [String, Function],
    optionGroupChildren: [String, Function],
    scrollHeight: {
      type: String,
      default: "14rem"
    },
    filter: Boolean,
    filterPlaceholder: String,
    filterLocale: String,
    filterMatchMode: {
      type: String,
      default: "contains"
    },
    filterFields: {
      type: Array,
      default: null
    },
    editable: Boolean,
    placeholder: {
      type: String,
      default: null
    },
    dataKey: null,
    showClear: {
      type: Boolean,
      default: !1
    },
    inputId: {
      type: String,
      default: null
    },
    inputClass: {
      type: [String, Object],
      default: null
    },
    inputStyle: {
      type: Object,
      default: null
    },
    labelId: {
      type: String,
      default: null
    },
    labelClass: {
      type: [String, Object],
      default: null
    },
    labelStyle: {
      type: Object,
      default: null
    },
    panelClass: {
      type: [String, Object],
      default: null
    },
    overlayStyle: {
      type: Object,
      default: null
    },
    overlayClass: {
      type: [String, Object],
      default: null
    },
    panelStyle: {
      type: Object,
      default: null
    },
    appendTo: {
      type: [String, Object],
      default: "body"
    },
    loading: {
      type: Boolean,
      default: !1
    },
    clearIcon: {
      type: String,
      default: void 0
    },
    dropdownIcon: {
      type: String,
      default: void 0
    },
    filterIcon: {
      type: String,
      default: void 0
    },
    loadingIcon: {
      type: String,
      default: void 0
    },
    resetFilterOnHide: {
      type: Boolean,
      default: !1
    },
    resetFilterOnClear: {
      type: Boolean,
      default: !1
    },
    virtualScrollerOptions: {
      type: Object,
      default: null
    },
    autoOptionFocus: {
      type: Boolean,
      default: !1
    },
    autoFilterFocus: {
      type: Boolean,
      default: !1
    },
    selectOnFocus: {
      type: Boolean,
      default: !1
    },
    focusOnHover: {
      type: Boolean,
      default: !0
    },
    highlightOnSelect: {
      type: Boolean,
      default: !0
    },
    checkmark: {
      type: Boolean,
      default: !1
    },
    filterMessage: {
      type: String,
      default: null
    },
    selectionMessage: {
      type: String,
      default: null
    },
    emptySelectionMessage: {
      type: String,
      default: null
    },
    emptyFilterMessage: {
      type: String,
      default: null
    },
    emptyMessage: {
      type: String,
      default: null
    },
    tabindex: {
      type: Number,
      default: 0
    },
    ariaLabel: {
      type: String,
      default: null
    },
    ariaLabelledby: {
      type: String,
      default: null
    }
  },
  style: yR,
  provide: function() {
    return {
      $pcSelect: this,
      $parentInstance: this
    };
  }
};
function Xl(i) {
  "@babel/helpers - typeof";
  return Xl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Xl(i);
}
function wR(i) {
  return CR(i) || SR(i) || xR(i) || _R();
}
function _R() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function xR(i, e) {
  if (i) {
    if (typeof i == "string") return vf(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? vf(i, e) : void 0;
  }
}
function SR(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function CR(i) {
  if (Array.isArray(i)) return vf(i);
}
function vf(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function Nv(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zv(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Nv(Object(n), !0).forEach(function(r) {
      os(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : Nv(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function os(i, e, n) {
  return (e = kR(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function kR(i) {
  var e = OR(i, "string");
  return Xl(e) == "symbol" ? e : e + "";
}
function OR(i, e) {
  if (Xl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Xl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var N1 = {
  name: "Select",
  extends: bR,
  inheritAttrs: !1,
  emits: ["change", "focus", "blur", "before-show", "before-hide", "show", "hide", "filter"],
  outsideClickListener: null,
  scrollHandler: null,
  resizeListener: null,
  labelClickListener: null,
  matchMediaOrientationListener: null,
  overlay: null,
  list: null,
  virtualScroller: null,
  searchTimeout: null,
  searchValue: null,
  isModelValueChanged: !1,
  data: function() {
    return {
      clicked: !1,
      focused: !1,
      focusedOptionIndex: -1,
      filterValue: null,
      overlayVisible: !1,
      queryOrientation: null
    };
  },
  watch: {
    modelValue: function() {
      this.isModelValueChanged = !0;
    },
    options: function() {
      this.autoUpdateModel();
    }
  },
  mounted: function() {
    this.autoUpdateModel(), this.bindLabelClickListener(), this.bindMatchMediaOrientationListener();
  },
  updated: function() {
    this.overlayVisible && this.isModelValueChanged && this.scrollInView(this.findSelectedOptionIndex()), this.isModelValueChanged = !1;
  },
  beforeUnmount: function() {
    this.unbindOutsideClickListener(), this.unbindResizeListener(), this.unbindLabelClickListener(), this.unbindMatchMediaOrientationListener(), this.scrollHandler && (this.scrollHandler.destroy(), this.scrollHandler = null), this.overlay && (Ui.clear(this.overlay), this.overlay = null);
  },
  methods: {
    getOptionIndex: function(e, n) {
      return this.virtualScrollerDisabled ? e : n && n(e).index;
    },
    getOptionLabel: function(e) {
      return this.optionLabel ? Hr(e, this.optionLabel) : e;
    },
    getOptionValue: function(e) {
      return this.optionValue ? Hr(e, this.optionValue) : e;
    },
    getOptionRenderKey: function(e, n) {
      return (this.dataKey ? Hr(e, this.dataKey) : this.getOptionLabel(e)) + "_" + n;
    },
    getPTItemOptions: function(e, n, r, o) {
      return this.ptm(o, {
        context: {
          option: e,
          index: r,
          selected: this.isSelected(e),
          focused: this.focusedOptionIndex === this.getOptionIndex(r, n),
          disabled: this.isOptionDisabled(e)
        }
      });
    },
    isOptionDisabled: function(e) {
      return this.optionDisabled ? Hr(e, this.optionDisabled) : !1;
    },
    isOptionGroup: function(e) {
      return this.optionGroupLabel && e.optionGroup && e.group;
    },
    getOptionGroupLabel: function(e) {
      return Hr(e, this.optionGroupLabel);
    },
    getOptionGroupChildren: function(e) {
      return Hr(e, this.optionGroupChildren);
    },
    getAriaPosInset: function(e) {
      var n = this;
      return (this.optionGroupLabel ? e - this.visibleOptions.slice(0, e).filter(function(r) {
        return n.isOptionGroup(r);
      }).length : e) + 1;
    },
    show: function(e) {
      this.$emit("before-show"), this.overlayVisible = !0, this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.editable ? -1 : this.findSelectedOptionIndex(), e && Yn(this.$refs.focusInput);
    },
    hide: function(e) {
      var n = this, r = function() {
        n.$emit("before-hide"), n.overlayVisible = !1, n.clicked = !1, n.focusedOptionIndex = -1, n.searchValue = "", n.resetFilterOnHide && (n.filterValue = null), e && Yn(n.$refs.focusInput);
      };
      setTimeout(function() {
        r();
      }, 0);
    },
    onFocus: function(e) {
      this.disabled || (this.focused = !0, this.overlayVisible && (this.focusedOptionIndex = this.focusedOptionIndex !== -1 ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.editable ? -1 : this.findSelectedOptionIndex(), this.scrollInView(this.focusedOptionIndex)), this.$emit("focus", e));
    },
    onBlur: function(e) {
      var n = this;
      setTimeout(function() {
        var r, o;
        n.focused = !1, n.focusedOptionIndex = -1, n.searchValue = "", n.$emit("blur", e), (r = (o = n.formField).onBlur) === null || r === void 0 || r.call(o, e);
      }, 100);
    },
    onKeyDown: function(e) {
      if (this.disabled) {
        e.preventDefault();
        return;
      }
      if (xC())
        switch (e.code) {
          case "Backspace":
            this.onBackspaceKey(e, this.editable);
            break;
          case "Enter":
          case "NumpadDecimal":
            this.onEnterKey(e);
            break;
          default:
            e.preventDefault();
            return;
        }
      var n = e.metaKey || e.ctrlKey;
      switch (e.code) {
        case "ArrowDown":
          this.onArrowDownKey(e);
          break;
        case "ArrowUp":
          this.onArrowUpKey(e, this.editable);
          break;
        case "ArrowLeft":
        case "ArrowRight":
          this.onArrowLeftKey(e, this.editable);
          break;
        case "Home":
          this.onHomeKey(e, this.editable);
          break;
        case "End":
          this.onEndKey(e, this.editable);
          break;
        case "PageDown":
          this.onPageDownKey(e);
          break;
        case "PageUp":
          this.onPageUpKey(e);
          break;
        case "Space":
          this.onSpaceKey(e, this.editable);
          break;
        case "Enter":
        case "NumpadEnter":
          this.onEnterKey(e);
          break;
        case "Escape":
          this.onEscapeKey(e);
          break;
        case "Tab":
          this.onTabKey(e);
          break;
        case "Backspace":
          this.onBackspaceKey(e, this.editable);
          break;
        case "ShiftLeft":
        case "ShiftRight":
          break;
        default:
          !n && dC(e.key) && (!this.overlayVisible && this.show(), !this.editable && this.searchOptions(e, e.key), this.filter && (this.filterValue = e.key));
          break;
      }
      this.clicked = !1;
    },
    onEditableInput: function(e) {
      var n = e.target.value;
      this.searchValue = "";
      var r = this.searchOptions(e, n);
      !r && (this.focusedOptionIndex = -1), this.updateModel(e, n), !this.overlayVisible && gt(n) && this.show();
    },
    onContainerClick: function(e) {
      this.disabled || this.loading || e.target.tagName === "INPUT" || e.target.getAttribute("data-pc-section") === "clearicon" || e.target.closest('[data-pc-section="clearicon"]') || ((!this.overlay || !this.overlay.contains(e.target)) && (this.overlayVisible ? this.hide(!0) : this.show(!0)), this.clicked = !0);
    },
    onClearClick: function(e) {
      this.updateModel(e, null), this.resetFilterOnClear && (this.filterValue = null);
    },
    onFirstHiddenFocus: function(e) {
      var n = e.relatedTarget === this.$refs.focusInput ? Zs(this.overlay, ':not([data-p-hidden-focusable="true"])') : this.$refs.focusInput;
      Yn(n);
    },
    onLastHiddenFocus: function(e) {
      var n = e.relatedTarget === this.$refs.focusInput ? Q0(this.overlay, ':not([data-p-hidden-focusable="true"])') : this.$refs.focusInput;
      Yn(n);
    },
    onOptionSelect: function(e, n) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, o = this.getOptionValue(n);
      this.updateModel(e, o), r && this.hide(!0);
    },
    onOptionMouseMove: function(e, n) {
      this.focusOnHover && this.changeFocusedOptionIndex(e, n);
    },
    onFilterChange: function(e) {
      var n = e.target.value;
      this.filterValue = n, this.focusedOptionIndex = -1, this.$emit("filter", {
        originalEvent: e,
        value: n
      }), !this.virtualScrollerDisabled && this.virtualScroller.scrollToIndex(0);
    },
    onFilterKeyDown: function(e) {
      if (!e.isComposing)
        switch (e.code) {
          case "ArrowDown":
            this.onArrowDownKey(e);
            break;
          case "ArrowUp":
            this.onArrowUpKey(e, !0);
            break;
          case "ArrowLeft":
          case "ArrowRight":
            this.onArrowLeftKey(e, !0);
            break;
          case "Home":
            this.onHomeKey(e, !0);
            break;
          case "End":
            this.onEndKey(e, !0);
            break;
          case "Enter":
          case "NumpadEnter":
            this.onEnterKey(e);
            break;
          case "Escape":
            this.onEscapeKey(e);
            break;
          case "Tab":
            this.onTabKey(e);
            break;
        }
    },
    onFilterBlur: function() {
      this.focusedOptionIndex = -1;
    },
    onFilterUpdated: function() {
      this.overlayVisible && this.alignOverlay();
    },
    onOverlayClick: function(e) {
      F1.emit("overlay-click", {
        originalEvent: e,
        target: this.$el
      });
    },
    onOverlayKeyDown: function(e) {
      switch (e.code) {
        case "Escape":
          this.onEscapeKey(e);
          break;
      }
    },
    onArrowDownKey: function(e) {
      if (!this.overlayVisible)
        this.show(), this.editable && this.changeFocusedOptionIndex(e, this.findSelectedOptionIndex());
      else {
        var n = this.focusedOptionIndex !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findFirstOptionIndex() : this.findFirstFocusedOptionIndex();
        this.changeFocusedOptionIndex(e, n);
      }
      e.preventDefault();
    },
    onArrowUpKey: function(e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      if (e.altKey && !n)
        this.focusedOptionIndex !== -1 && this.onOptionSelect(e, this.visibleOptions[this.focusedOptionIndex]), this.overlayVisible && this.hide(), e.preventDefault();
      else {
        var r = this.focusedOptionIndex !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findLastOptionIndex() : this.findLastFocusedOptionIndex();
        this.changeFocusedOptionIndex(e, r), !this.overlayVisible && this.show(), e.preventDefault();
      }
    },
    onArrowLeftKey: function(e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      n && (this.focusedOptionIndex = -1);
    },
    onHomeKey: function(e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      if (n) {
        var r = e.currentTarget;
        e.shiftKey ? r.setSelectionRange(0, e.target.selectionStart) : (r.setSelectionRange(0, 0), this.focusedOptionIndex = -1);
      } else
        this.changeFocusedOptionIndex(e, this.findFirstOptionIndex()), !this.overlayVisible && this.show();
      e.preventDefault();
    },
    onEndKey: function(e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      if (n) {
        var r = e.currentTarget;
        if (e.shiftKey)
          r.setSelectionRange(e.target.selectionStart, r.value.length);
        else {
          var o = r.value.length;
          r.setSelectionRange(o, o), this.focusedOptionIndex = -1;
        }
      } else
        this.changeFocusedOptionIndex(e, this.findLastOptionIndex()), !this.overlayVisible && this.show();
      e.preventDefault();
    },
    onPageUpKey: function(e) {
      this.scrollInView(0), e.preventDefault();
    },
    onPageDownKey: function(e) {
      this.scrollInView(this.visibleOptions.length - 1), e.preventDefault();
    },
    onEnterKey: function(e) {
      this.overlayVisible ? (this.focusedOptionIndex !== -1 && this.onOptionSelect(e, this.visibleOptions[this.focusedOptionIndex]), this.hide(!0)) : (this.focusedOptionIndex = -1, this.onArrowDownKey(e)), e.preventDefault();
    },
    onSpaceKey: function(e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      !n && this.onEnterKey(e);
    },
    onEscapeKey: function(e) {
      this.overlayVisible && this.hide(!0), e.preventDefault(), e.stopPropagation();
    },
    onTabKey: function(e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      n || (this.overlayVisible && this.hasFocusableElements() ? (Yn(this.$refs.firstHiddenFocusableElementOnOverlay), e.preventDefault()) : (this.focusedOptionIndex !== -1 && this.onOptionSelect(e, this.visibleOptions[this.focusedOptionIndex]), this.overlayVisible && this.hide(this.filter)));
    },
    onBackspaceKey: function(e) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      n && !this.overlayVisible && this.show();
    },
    onOverlayEnter: function(e) {
      var n = this;
      Ui.set("overlay", e, this.$primevue.config.zIndex.overlay), K0(e, {
        position: "absolute",
        top: "0"
      }), this.alignOverlay(), this.scrollInView(), this.$attrSelector && e.setAttribute(this.$attrSelector, ""), setTimeout(function() {
        n.autoFilterFocus && n.filter && Yn(n.$refs.filterInput.$el), n.autoUpdateModel();
      }, 1);
    },
    onOverlayAfterEnter: function() {
      this.bindOutsideClickListener(), this.bindScrollListener(), this.bindResizeListener(), this.$emit("show");
    },
    onOverlayLeave: function() {
      var e = this;
      this.unbindOutsideClickListener(), this.unbindScrollListener(), this.unbindResizeListener(), this.autoFilterFocus && this.filter && !this.editable && this.$nextTick(function() {
        e.$refs.filterInput && Yn(e.$refs.filterInput.$el);
      }), this.$emit("hide"), this.overlay = null;
    },
    onOverlayAfterLeave: function(e) {
      Ui.clear(e);
    },
    alignOverlay: function() {
      this.appendTo === "self" ? q0(this.overlay, this.$el) : this.overlay && (this.overlay.style.minWidth = dr(this.$el) + "px", Y0(this.overlay, this.$el));
    },
    bindOutsideClickListener: function() {
      var e = this;
      this.outsideClickListener || (this.outsideClickListener = function(n) {
        var r = n.composedPath();
        e.overlayVisible && e.overlay && !r.includes(e.$el) && !r.includes(e.overlay) && e.hide();
      }, document.addEventListener("click", this.outsideClickListener, !0));
    },
    unbindOutsideClickListener: function() {
      this.outsideClickListener && (document.removeEventListener("click", this.outsideClickListener, !0), this.outsideClickListener = null);
    },
    bindScrollListener: function() {
      var e = this;
      this.scrollHandler || (this.scrollHandler = new Op(this.$refs.container, function() {
        e.overlayVisible && e.hide();
      })), this.scrollHandler.bindScrollListener();
    },
    unbindScrollListener: function() {
      this.scrollHandler && this.scrollHandler.unbindScrollListener();
    },
    bindResizeListener: function() {
      var e = this;
      this.resizeListener || (this.resizeListener = function() {
        e.overlayVisible && !Jf() && e.hide();
      }, window.addEventListener("resize", this.resizeListener));
    },
    unbindResizeListener: function() {
      this.resizeListener && (window.removeEventListener("resize", this.resizeListener), this.resizeListener = null);
    },
    bindLabelClickListener: function() {
      var e = this;
      if (!this.editable && !this.labelClickListener) {
        var n = document.querySelector('label[for="'.concat(this.labelId, '"]'));
        n && Fc(n) && (this.labelClickListener = function() {
          Yn(e.$refs.focusInput);
        }, n.addEventListener("click", this.labelClickListener));
      }
    },
    unbindLabelClickListener: function() {
      if (this.labelClickListener) {
        var e = document.querySelector('label[for="'.concat(this.labelId, '"]'));
        e && Fc(e) && e.removeEventListener("click", this.labelClickListener);
      }
    },
    bindMatchMediaOrientationListener: function() {
      var e = this;
      if (!this.matchMediaOrientationListener) {
        var n = matchMedia("(orientation: portrait)");
        this.queryOrientation = n, this.matchMediaOrientationListener = function() {
          e.alignOverlay();
        }, this.queryOrientation.addEventListener("change", this.matchMediaOrientationListener);
      }
    },
    unbindMatchMediaOrientationListener: function() {
      this.matchMediaOrientationListener && (this.queryOrientation.removeEventListener("change", this.matchMediaOrientationListener), this.queryOrientation = null, this.matchMediaOrientationListener = null);
    },
    hasFocusableElements: function() {
      return Zf(this.overlay, ':not([data-p-hidden-focusable="true"])').length > 0;
    },
    isOptionExactMatched: function(e) {
      var n;
      return this.isValidOption(e) && typeof this.getOptionLabel(e) == "string" && ((n = this.getOptionLabel(e)) === null || n === void 0 ? void 0 : n.toLocaleLowerCase(this.filterLocale)) == this.searchValue.toLocaleLowerCase(this.filterLocale);
    },
    isOptionStartsWith: function(e) {
      var n;
      return this.isValidOption(e) && typeof this.getOptionLabel(e) == "string" && ((n = this.getOptionLabel(e)) === null || n === void 0 ? void 0 : n.toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue.toLocaleLowerCase(this.filterLocale)));
    },
    isValidOption: function(e) {
      return gt(e) && !(this.isOptionDisabled(e) || this.isOptionGroup(e));
    },
    isValidSelectedOption: function(e) {
      return this.isValidOption(e) && this.isSelected(e);
    },
    isSelected: function(e) {
      return z0(this.d_value, this.getOptionValue(e), this.equalityKey);
    },
    findFirstOptionIndex: function() {
      var e = this;
      return this.visibleOptions.findIndex(function(n) {
        return e.isValidOption(n);
      });
    },
    findLastOptionIndex: function() {
      var e = this;
      return Wm(this.visibleOptions, function(n) {
        return e.isValidOption(n);
      });
    },
    findNextOptionIndex: function(e) {
      var n = this, r = e < this.visibleOptions.length - 1 ? this.visibleOptions.slice(e + 1).findIndex(function(o) {
        return n.isValidOption(o);
      }) : -1;
      return r > -1 ? r + e + 1 : e;
    },
    findPrevOptionIndex: function(e) {
      var n = this, r = e > 0 ? Wm(this.visibleOptions.slice(0, e), function(o) {
        return n.isValidOption(o);
      }) : -1;
      return r > -1 ? r : e;
    },
    findSelectedOptionIndex: function() {
      var e = this;
      return this.visibleOptions.findIndex(function(n) {
        return e.isValidSelectedOption(n);
      });
    },
    findFirstFocusedOptionIndex: function() {
      var e = this.findSelectedOptionIndex();
      return e < 0 ? this.findFirstOptionIndex() : e;
    },
    findLastFocusedOptionIndex: function() {
      var e = this.findSelectedOptionIndex();
      return e < 0 ? this.findLastOptionIndex() : e;
    },
    searchOptions: function(e, n) {
      var r = this;
      this.searchValue = (this.searchValue || "") + n;
      var o = -1, s = !1;
      return gt(this.searchValue) && (o = this.visibleOptions.findIndex(function(a) {
        return r.isOptionExactMatched(a);
      }), o === -1 && (o = this.visibleOptions.findIndex(function(a) {
        return r.isOptionStartsWith(a);
      })), o !== -1 && (s = !0), o === -1 && this.focusedOptionIndex === -1 && (o = this.findFirstFocusedOptionIndex()), o !== -1 && this.changeFocusedOptionIndex(e, o)), this.searchTimeout && clearTimeout(this.searchTimeout), this.searchTimeout = setTimeout(function() {
        r.searchValue = "", r.searchTimeout = null;
      }, 500), s;
    },
    changeFocusedOptionIndex: function(e, n) {
      this.focusedOptionIndex !== n && (this.focusedOptionIndex = n, this.scrollInView(), this.selectOnFocus && this.onOptionSelect(e, this.visibleOptions[n], !1));
    },
    scrollInView: function() {
      var e = this, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      this.$nextTick(function() {
        var r = n !== -1 ? "".concat(e.$id, "_").concat(n) : e.focusedOptionId, o = ba(e.list, 'li[id="'.concat(r, '"]'));
        o ? o.scrollIntoView && o.scrollIntoView({
          block: "nearest",
          inline: "nearest"
        }) : e.virtualScrollerDisabled || e.virtualScroller && e.virtualScroller.scrollToIndex(n !== -1 ? n : e.focusedOptionIndex);
      });
    },
    autoUpdateModel: function() {
      this.autoOptionFocus && (this.focusedOptionIndex = this.findFirstFocusedOptionIndex()), this.selectOnFocus && this.autoOptionFocus && !this.$filled && this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex], !1);
    },
    updateModel: function(e, n) {
      this.writeValue(n, e), this.$emit("change", {
        originalEvent: e,
        value: n
      });
    },
    flatOptions: function(e) {
      var n = this;
      return (e || []).reduce(function(r, o, s) {
        r.push({
          optionGroup: o,
          group: !0,
          index: s
        });
        var a = n.getOptionGroupChildren(o);
        return a && a.forEach(function(l) {
          return r.push(l);
        }), r;
      }, []);
    },
    overlayRef: function(e) {
      this.overlay = e;
    },
    listRef: function(e, n) {
      this.list = e, n && n(e);
    },
    virtualScrollerRef: function(e) {
      this.virtualScroller = e;
    }
  },
  computed: {
    visibleOptions: function() {
      var e = this, n = this.optionGroupLabel ? this.flatOptions(this.options) : this.options || [];
      if (this.filterValue) {
        var r = LC.filter(n, this.searchFields, this.filterValue, this.filterMatchMode, this.filterLocale);
        if (this.optionGroupLabel) {
          var o = this.options || [], s = [];
          return o.forEach(function(a) {
            var l = e.getOptionGroupChildren(a), u = l.filter(function(c) {
              return r.includes(c);
            });
            u.length > 0 && s.push(zv(zv({}, a), {}, os({}, typeof e.optionGroupChildren == "string" ? e.optionGroupChildren : "items", wR(u))));
          }), this.flatOptions(s);
        }
        return r;
      }
      return n;
    },
    // @deprecated use $filled instead
    hasSelectedOption: function() {
      return this.$filled;
    },
    label: function() {
      var e = this.findSelectedOptionIndex();
      return e !== -1 ? this.getOptionLabel(this.visibleOptions[e]) : this.placeholder || "p-emptylabel";
    },
    editableInputValue: function() {
      var e = this.findSelectedOptionIndex();
      return e !== -1 ? this.getOptionLabel(this.visibleOptions[e]) : this.d_value || "";
    },
    equalityKey: function() {
      return this.optionValue ? null : this.dataKey;
    },
    searchFields: function() {
      return this.filterFields || [this.optionLabel];
    },
    filterResultMessageText: function() {
      return gt(this.visibleOptions) ? this.filterMessageText.replaceAll("{0}", this.visibleOptions.length) : this.emptyFilterMessageText;
    },
    filterMessageText: function() {
      return this.filterMessage || this.$primevue.config.locale.searchMessage || "";
    },
    emptyFilterMessageText: function() {
      return this.emptyFilterMessage || this.$primevue.config.locale.emptySearchMessage || this.$primevue.config.locale.emptyFilterMessage || "";
    },
    emptyMessageText: function() {
      return this.emptyMessage || this.$primevue.config.locale.emptyMessage || "";
    },
    selectionMessageText: function() {
      return this.selectionMessage || this.$primevue.config.locale.selectionMessage || "";
    },
    emptySelectionMessageText: function() {
      return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || "";
    },
    selectedMessageText: function() {
      return this.$filled ? this.selectionMessageText.replaceAll("{0}", "1") : this.emptySelectionMessageText;
    },
    focusedOptionId: function() {
      return this.focusedOptionIndex !== -1 ? "".concat(this.$id, "_").concat(this.focusedOptionIndex) : null;
    },
    ariaSetSize: function() {
      var e = this;
      return this.visibleOptions.filter(function(n) {
        return !e.isOptionGroup(n);
      }).length;
    },
    isClearIconVisible: function() {
      return this.showClear && this.d_value != null && !this.disabled && !this.loading;
    },
    virtualScrollerDisabled: function() {
      return !this.virtualScrollerOptions;
    },
    containerDataP: function() {
      return ui(os({
        invalid: this.$invalid,
        disabled: this.disabled,
        focus: this.focused,
        fluid: this.$fluid,
        filled: this.$variant === "filled"
      }, this.size, this.size));
    },
    labelDataP: function() {
      return ui(os(os({
        placeholder: !this.editable && this.label === this.placeholder,
        clearable: this.showClear,
        disabled: this.disabled,
        editable: this.editable
      }, this.size, this.size), "empty", !this.editable && !this.$slots.value && (this.label === "p-emptylabel" || this.label.length === 0)));
    },
    dropdownIconDataP: function() {
      return ui(os({}, this.size, this.size));
    },
    overlayDataP: function() {
      return ui(os({}, "portal-" + this.appendTo, "portal-" + this.appendTo));
    }
  },
  directives: {
    ripple: Sp
  },
  components: {
    InputText: Ed,
    VirtualScroller: R1,
    Portal: Td,
    InputIcon: V1,
    IconField: A1,
    TimesIcon: Od,
    ChevronDownIcon: I1,
    SpinnerIcon: kd,
    SearchIcon: L1,
    CheckIcon: P1,
    BlankIcon: M1
  }
}, ER = ["id", "data-p"], TR = ["name", "id", "value", "placeholder", "tabindex", "disabled", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-invalid", "data-p"], DR = ["name", "id", "tabindex", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-invalid", "aria-disabled", "data-p"], $R = ["data-p"], MR = ["id"], PR = ["id"], IR = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onMousedown", "onMousemove", "data-p-selected", "data-p-focused", "data-p-disabled"];
function LR(i, e, n, r, o, s) {
  var a = Tn("SpinnerIcon"), l = Tn("InputText"), u = Tn("SearchIcon"), c = Tn("InputIcon"), d = Tn("IconField"), h = Tn("CheckIcon"), p = Tn("BlankIcon"), m = Tn("VirtualScroller"), v = Tn("Portal"), y = Vf("ripple");
  return $(), A("div", ke({
    ref: "container",
    id: i.$id,
    class: i.cx("root"),
    onClick: e[12] || (e[12] = function() {
      return s.onContainerClick && s.onContainerClick.apply(s, arguments);
    }),
    "data-p": s.containerDataP
  }, i.ptmi("root")), [i.editable ? ($(), A("input", ke({
    key: 0,
    ref: "focusInput",
    name: i.name,
    id: i.labelId || i.inputId,
    type: "text",
    class: [i.cx("label"), i.inputClass, i.labelClass],
    style: [i.inputStyle, i.labelStyle],
    value: s.editableInputValue,
    placeholder: i.placeholder,
    tabindex: i.disabled ? -1 : i.tabindex,
    disabled: i.disabled,
    autocomplete: "off",
    role: "combobox",
    "aria-label": i.ariaLabel,
    "aria-labelledby": i.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-expanded": o.overlayVisible,
    "aria-controls": o.overlayVisible ? i.$id + "_list" : void 0,
    "aria-activedescendant": o.focused ? s.focusedOptionId : void 0,
    "aria-invalid": i.invalid || void 0,
    onFocus: e[0] || (e[0] = function() {
      return s.onFocus && s.onFocus.apply(s, arguments);
    }),
    onBlur: e[1] || (e[1] = function() {
      return s.onBlur && s.onBlur.apply(s, arguments);
    }),
    onKeydown: e[2] || (e[2] = function() {
      return s.onKeyDown && s.onKeyDown.apply(s, arguments);
    }),
    onInput: e[3] || (e[3] = function() {
      return s.onEditableInput && s.onEditableInput.apply(s, arguments);
    }),
    "data-p": s.labelDataP
  }, i.ptm("label")), null, 16, TR)) : ($(), A("span", ke({
    key: 1,
    ref: "focusInput",
    name: i.name,
    id: i.labelId || i.inputId,
    class: [i.cx("label"), i.inputClass, i.labelClass],
    style: [i.inputStyle, i.labelStyle],
    tabindex: i.disabled ? -1 : i.tabindex,
    role: "combobox",
    "aria-label": i.ariaLabel || (s.label === "p-emptylabel" ? void 0 : s.label),
    "aria-labelledby": i.ariaLabelledby,
    "aria-haspopup": "listbox",
    "aria-expanded": o.overlayVisible,
    "aria-controls": i.$id + "_list",
    "aria-activedescendant": o.focused ? s.focusedOptionId : void 0,
    "aria-invalid": i.invalid || void 0,
    "aria-disabled": i.disabled,
    onFocus: e[4] || (e[4] = function() {
      return s.onFocus && s.onFocus.apply(s, arguments);
    }),
    onBlur: e[5] || (e[5] = function() {
      return s.onBlur && s.onBlur.apply(s, arguments);
    }),
    onKeydown: e[6] || (e[6] = function() {
      return s.onKeyDown && s.onKeyDown.apply(s, arguments);
    }),
    "data-p": s.labelDataP
  }, i.ptm("label")), [it(i.$slots, "value", {
    value: i.d_value,
    placeholder: i.placeholder
  }, function() {
    var w;
    return [vt(Q(s.label === "p-emptylabel" ? "" : (w = s.label) !== null && w !== void 0 ? w : "empty"), 1)];
  })], 16, DR)), s.isClearIconVisible ? it(i.$slots, "clearicon", {
    key: 2,
    class: _e(i.cx("clearIcon")),
    clearCallback: s.onClearClick
  }, function() {
    return [($(), st(vr(i.clearIcon ? "i" : "TimesIcon"), ke({
      ref: "clearIcon",
      class: [i.cx("clearIcon"), i.clearIcon],
      onClick: s.onClearClick
    }, i.ptm("clearIcon"), {
      "data-pc-section": "clearicon"
    }), null, 16, ["class", "onClick"]))];
  }) : ve("", !0), f("div", ke({
    class: i.cx("dropdown")
  }, i.ptm("dropdown")), [i.loading ? it(i.$slots, "loadingicon", {
    key: 0,
    class: _e(i.cx("loadingIcon"))
  }, function() {
    return [i.loadingIcon ? ($(), A("span", ke({
      key: 0,
      class: [i.cx("loadingIcon"), "pi-spin", i.loadingIcon],
      "aria-hidden": "true"
    }, i.ptm("loadingIcon")), null, 16)) : ($(), st(a, ke({
      key: 1,
      class: i.cx("loadingIcon"),
      spin: "",
      "aria-hidden": "true"
    }, i.ptm("loadingIcon")), null, 16, ["class"]))];
  }) : it(i.$slots, "dropdownicon", {
    key: 1,
    class: _e(i.cx("dropdownIcon"))
  }, function() {
    return [($(), st(vr(i.dropdownIcon ? "span" : "ChevronDownIcon"), ke({
      class: [i.cx("dropdownIcon"), i.dropdownIcon],
      "aria-hidden": "true",
      "data-p": s.dropdownIconDataP
    }, i.ptm("dropdownIcon")), null, 16, ["class", "data-p"]))];
  })], 16), Ve(v, {
    appendTo: i.appendTo
  }, {
    default: Wt(function() {
      return [Ve(Uf, ke({
        name: "p-anchored-overlay",
        onEnter: s.onOverlayEnter,
        onAfterEnter: s.onOverlayAfterEnter,
        onLeave: s.onOverlayLeave,
        onAfterLeave: s.onOverlayAfterLeave
      }, i.ptm("transition")), {
        default: Wt(function() {
          return [o.overlayVisible ? ($(), A("div", ke({
            key: 0,
            ref: s.overlayRef,
            class: [i.cx("overlay"), i.panelClass, i.overlayClass],
            style: [i.panelStyle, i.overlayStyle],
            onClick: e[10] || (e[10] = function() {
              return s.onOverlayClick && s.onOverlayClick.apply(s, arguments);
            }),
            onKeydown: e[11] || (e[11] = function() {
              return s.onOverlayKeyDown && s.onOverlayKeyDown.apply(s, arguments);
            }),
            "data-p": s.overlayDataP
          }, i.ptm("overlay")), [f("span", ke({
            ref: "firstHiddenFocusableElementOnOverlay",
            role: "presentation",
            "aria-hidden": "true",
            class: "p-hidden-accessible p-hidden-focusable",
            tabindex: 0,
            onFocus: e[7] || (e[7] = function() {
              return s.onFirstHiddenFocus && s.onFirstHiddenFocus.apply(s, arguments);
            })
          }, i.ptm("hiddenFirstFocusableEl"), {
            "data-p-hidden-accessible": !0,
            "data-p-hidden-focusable": !0
          }), null, 16), it(i.$slots, "header", {
            value: i.d_value,
            options: s.visibleOptions
          }), i.filter ? ($(), A("div", ke({
            key: 0,
            class: i.cx("header")
          }, i.ptm("header")), [Ve(d, {
            unstyled: i.unstyled,
            pt: i.ptm("pcFilterContainer")
          }, {
            default: Wt(function() {
              return [Ve(l, {
                ref: "filterInput",
                type: "text",
                value: o.filterValue,
                onVnodeMounted: s.onFilterUpdated,
                onVnodeUpdated: s.onFilterUpdated,
                class: _e(i.cx("pcFilter")),
                placeholder: i.filterPlaceholder,
                variant: i.variant,
                unstyled: i.unstyled,
                role: "searchbox",
                autocomplete: "off",
                "aria-owns": i.$id + "_list",
                "aria-activedescendant": s.focusedOptionId,
                onKeydown: s.onFilterKeyDown,
                onBlur: s.onFilterBlur,
                onInput: s.onFilterChange,
                pt: i.ptm("pcFilter"),
                formControl: {
                  novalidate: !0
                }
              }, null, 8, ["value", "onVnodeMounted", "onVnodeUpdated", "class", "placeholder", "variant", "unstyled", "aria-owns", "aria-activedescendant", "onKeydown", "onBlur", "onInput", "pt"]), Ve(c, {
                unstyled: i.unstyled,
                pt: i.ptm("pcFilterIconContainer")
              }, {
                default: Wt(function() {
                  return [it(i.$slots, "filtericon", {}, function() {
                    return [i.filterIcon ? ($(), A("span", ke({
                      key: 0,
                      class: i.filterIcon
                    }, i.ptm("filterIcon")), null, 16)) : ($(), st(u, yw(ke({
                      key: 1
                    }, i.ptm("filterIcon"))), null, 16))];
                  })];
                }),
                _: 3
              }, 8, ["unstyled", "pt"])];
            }),
            _: 3
          }, 8, ["unstyled", "pt"]), f("span", ke({
            role: "status",
            "aria-live": "polite",
            class: "p-hidden-accessible"
          }, i.ptm("hiddenFilterResult"), {
            "data-p-hidden-accessible": !0
          }), Q(s.filterResultMessageText), 17)], 16)) : ve("", !0), f("div", ke({
            class: i.cx("listContainer"),
            style: {
              "max-height": s.virtualScrollerDisabled ? i.scrollHeight : ""
            }
          }, i.ptm("listContainer")), [Ve(m, ke({
            ref: s.virtualScrollerRef
          }, i.virtualScrollerOptions, {
            items: s.visibleOptions,
            style: {
              height: i.scrollHeight
            },
            tabindex: -1,
            disabled: s.virtualScrollerDisabled,
            pt: i.ptm("virtualScroller")
          }), z_({
            content: Wt(function(w) {
              var g = w.styleClass, k = w.contentRef, _ = w.items, S = w.getItemOptions, b = w.contentStyle, C = w.itemSize;
              return [f("ul", ke({
                ref: function(I) {
                  return s.listRef(I, k);
                },
                id: i.$id + "_list",
                class: [i.cx("list"), g],
                style: b,
                role: "listbox"
              }, i.ptm("list")), [($(!0), A(Fe, null, Ke(_, function(x, I) {
                return $(), A(Fe, {
                  key: s.getOptionRenderKey(x, s.getOptionIndex(I, S))
                }, [s.isOptionGroup(x) ? ($(), A("li", ke({
                  key: 0,
                  id: i.$id + "_" + s.getOptionIndex(I, S),
                  style: {
                    height: C ? C + "px" : void 0
                  },
                  class: i.cx("optionGroup"),
                  role: "option"
                }, {
                  ref_for: !0
                }, i.ptm("optionGroup")), [it(i.$slots, "optiongroup", {
                  option: x.optionGroup,
                  index: s.getOptionIndex(I, S)
                }, function() {
                  return [f("span", ke({
                    class: i.cx("optionGroupLabel")
                  }, {
                    ref_for: !0
                  }, i.ptm("optionGroupLabel")), Q(s.getOptionGroupLabel(x.optionGroup)), 17)];
                })], 16, PR)) : ot(($(), A("li", ke({
                  key: 1,
                  id: i.$id + "_" + s.getOptionIndex(I, S),
                  class: i.cx("option", {
                    option: x,
                    focusedOption: s.getOptionIndex(I, S)
                  }),
                  style: {
                    height: C ? C + "px" : void 0
                  },
                  role: "option",
                  "aria-label": s.getOptionLabel(x),
                  "aria-selected": s.isSelected(x),
                  "aria-disabled": s.isOptionDisabled(x),
                  "aria-setsize": s.ariaSetSize,
                  "aria-posinset": s.getAriaPosInset(s.getOptionIndex(I, S)),
                  onMousedown: function(B) {
                    return s.onOptionSelect(B, x);
                  },
                  onMousemove: function(B) {
                    return s.onOptionMouseMove(B, s.getOptionIndex(I, S));
                  },
                  onClick: e[8] || (e[8] = tt(function() {
                  }, ["stop"])),
                  "data-p-selected": !i.checkmark && s.isSelected(x),
                  "data-p-focused": o.focusedOptionIndex === s.getOptionIndex(I, S),
                  "data-p-disabled": s.isOptionDisabled(x)
                }, {
                  ref_for: !0
                }, s.getPTItemOptions(x, S, I, "option")), [i.checkmark ? ($(), A(Fe, {
                  key: 0
                }, [s.isSelected(x) ? ($(), st(h, ke({
                  key: 0,
                  class: i.cx("optionCheckIcon")
                }, {
                  ref_for: !0
                }, i.ptm("optionCheckIcon")), null, 16, ["class"])) : ($(), st(p, ke({
                  key: 1,
                  class: i.cx("optionBlankIcon")
                }, {
                  ref_for: !0
                }, i.ptm("optionBlankIcon")), null, 16, ["class"]))], 64)) : ve("", !0), it(i.$slots, "option", {
                  option: x,
                  selected: s.isSelected(x),
                  index: s.getOptionIndex(I, S)
                }, function() {
                  return [f("span", ke({
                    class: i.cx("optionLabel")
                  }, {
                    ref_for: !0
                  }, i.ptm("optionLabel")), Q(s.getOptionLabel(x)), 17)];
                })], 16, IR)), [[y]])], 64);
              }), 128)), o.filterValue && (!_ || _ && _.length === 0) ? ($(), A("li", ke({
                key: 0,
                class: i.cx("emptyMessage"),
                role: "option"
              }, i.ptm("emptyMessage"), {
                "data-p-hidden-accessible": !0
              }), [it(i.$slots, "emptyfilter", {}, function() {
                return [vt(Q(s.emptyFilterMessageText), 1)];
              })], 16)) : !i.options || i.options && i.options.length === 0 ? ($(), A("li", ke({
                key: 1,
                class: i.cx("emptyMessage"),
                role: "option"
              }, i.ptm("emptyMessage"), {
                "data-p-hidden-accessible": !0
              }), [it(i.$slots, "empty", {}, function() {
                return [vt(Q(s.emptyMessageText), 1)];
              })], 16)) : ve("", !0)], 16, MR)];
            }),
            _: 2
          }, [i.$slots.loader ? {
            name: "loader",
            fn: Wt(function(w) {
              var g = w.options;
              return [it(i.$slots, "loader", {
                options: g
              })];
            }),
            key: "0"
          } : void 0]), 1040, ["items", "style", "disabled", "pt"])], 16), it(i.$slots, "footer", {
            value: i.d_value,
            options: s.visibleOptions
          }), !i.options || i.options && i.options.length === 0 ? ($(), A("span", ke({
            key: 1,
            role: "status",
            "aria-live": "polite",
            class: "p-hidden-accessible"
          }, i.ptm("hiddenEmptyMessage"), {
            "data-p-hidden-accessible": !0
          }), Q(s.emptyMessageText), 17)) : ve("", !0), f("span", ke({
            role: "status",
            "aria-live": "polite",
            class: "p-hidden-accessible"
          }, i.ptm("hiddenSelectedMessage"), {
            "data-p-hidden-accessible": !0
          }), Q(s.selectedMessageText), 17), f("span", ke({
            ref: "lastHiddenFocusableElementOnOverlay",
            role: "presentation",
            "aria-hidden": "true",
            class: "p-hidden-accessible p-hidden-focusable",
            tabindex: 0,
            onFocus: e[9] || (e[9] = function() {
              return s.onLastHiddenFocus && s.onLastHiddenFocus.apply(s, arguments);
            })
          }, i.ptm("hiddenLastFocusableEl"), {
            "data-p-hidden-accessible": !0,
            "data-p-hidden-focusable": !0
          }), null, 16)], 16, $R)) : ve("", !0)];
        }),
        _: 3
      }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 3
  }, 8, ["appendTo"])], 16, ER);
}
N1.render = LR;
var AR = {
  name: "Dropdown",
  extends: N1,
  mounted: function() {
    console.warn("Deprecated since v4. Use Select component instead.");
  }
}, z1 = {
  name: "AngleDownIcon",
  extends: kr
};
function VR(i) {
  return NR(i) || RR(i) || jR(i) || FR();
}
function FR() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function jR(i, e) {
  if (i) {
    if (typeof i == "string") return yf(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? yf(i, e) : void 0;
  }
}
function RR(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function NR(i) {
  if (Array.isArray(i)) return yf(i);
}
function yf(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function zR(i, e, n, r, o, s) {
  return $(), A("svg", ke({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i.pti()), VR(e[0] || (e[0] = [f("path", {
    d: "M3.58659 4.5007C3.68513 4.50023 3.78277 4.51945 3.87379 4.55723C3.9648 4.59501 4.04735 4.65058 4.11659 4.7207L7.11659 7.7207L10.1166 4.7207C10.2619 4.65055 10.4259 4.62911 10.5843 4.65956C10.7427 4.69002 10.8871 4.77074 10.996 4.88976C11.1049 5.00877 11.1726 5.15973 11.1889 5.32022C11.2052 5.48072 11.1693 5.6422 11.0866 5.7807L7.58659 9.2807C7.44597 9.42115 7.25534 9.50004 7.05659 9.50004C6.85784 9.50004 6.66722 9.42115 6.52659 9.2807L3.02659 5.7807C2.88614 5.64007 2.80725 5.44945 2.80725 5.2507C2.80725 5.05195 2.88614 4.86132 3.02659 4.7207C3.09932 4.64685 3.18675 4.58911 3.28322 4.55121C3.37969 4.51331 3.48305 4.4961 3.58659 4.5007Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
z1.render = zR;
var B1 = {
  name: "AngleUpIcon",
  extends: kr
};
function BR(i) {
  return GR(i) || WR(i) || UR(i) || HR();
}
function HR() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function UR(i, e) {
  if (i) {
    if (typeof i == "string") return bf(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? bf(i, e) : void 0;
  }
}
function WR(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function GR(i) {
  if (Array.isArray(i)) return bf(i);
}
function bf(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function XR(i, e, n, r, o, s) {
  return $(), A("svg", ke({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i.pti()), BR(e[0] || (e[0] = [f("path", {
    d: "M10.4134 9.49931C10.3148 9.49977 10.2172 9.48055 10.1262 9.44278C10.0352 9.405 9.95263 9.34942 9.88338 9.27931L6.88338 6.27931L3.88338 9.27931C3.73811 9.34946 3.57409 9.3709 3.41567 9.34044C3.25724 9.30999 3.11286 9.22926 3.00395 9.11025C2.89504 8.99124 2.82741 8.84028 2.8111 8.67978C2.79478 8.51928 2.83065 8.35781 2.91338 8.21931L6.41338 4.71931C6.55401 4.57886 6.74463 4.49997 6.94338 4.49997C7.14213 4.49997 7.33276 4.57886 7.47338 4.71931L10.9734 8.21931C11.1138 8.35994 11.1927 8.55056 11.1927 8.74931C11.1927 8.94806 11.1138 9.13868 10.9734 9.27931C10.9007 9.35315 10.8132 9.41089 10.7168 9.44879C10.6203 9.48669 10.5169 9.5039 10.4134 9.49931Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
B1.render = XR;
var YR = `
    .p-inputnumber {
        display: inline-flex;
        position: relative;
    }

    .p-inputnumber-button {
        display: flex;
        align-items: center;
        justify-content: center;
        flex: 0 0 auto;
        cursor: pointer;
        background: dt('inputnumber.button.background');
        color: dt('inputnumber.button.color');
        width: dt('inputnumber.button.width');
        transition:
            background dt('inputnumber.transition.duration'),
            color dt('inputnumber.transition.duration'),
            border-color dt('inputnumber.transition.duration'),
            outline-color dt('inputnumber.transition.duration');
    }

    .p-inputnumber-button:disabled {
        cursor: auto;
    }

    .p-inputnumber-button:not(:disabled):hover {
        background: dt('inputnumber.button.hover.background');
        color: dt('inputnumber.button.hover.color');
    }

    .p-inputnumber-button:not(:disabled):active {
        background: dt('inputnumber.button.active.background');
        color: dt('inputnumber.button.active.color');
    }

    .p-inputnumber-stacked .p-inputnumber-button {
        position: relative;
        flex: 1 1 auto;
        border: 0 none;
    }

    .p-inputnumber-stacked .p-inputnumber-button-group {
        display: flex;
        flex-direction: column;
        position: absolute;
        inset-block-start: 1px;
        inset-inline-end: 1px;
        height: calc(100% - 2px);
        z-index: 1;
    }

    .p-inputnumber-stacked .p-inputnumber-increment-button {
        padding: 0;
        border-start-end-radius: calc(dt('inputnumber.button.border.radius') - 1px);
    }

    .p-inputnumber-stacked .p-inputnumber-decrement-button {
        padding: 0;
        border-end-end-radius: calc(dt('inputnumber.button.border.radius') - 1px);
    }

    .p-inputnumber-stacked .p-inputnumber-input {
        padding-inline-end: calc(dt('inputnumber.button.width') + dt('form.field.padding.x'));
    }

    .p-inputnumber-horizontal .p-inputnumber-button {
        border: 1px solid dt('inputnumber.button.border.color');
    }

    .p-inputnumber-horizontal .p-inputnumber-button:hover {
        border-color: dt('inputnumber.button.hover.border.color');
    }

    .p-inputnumber-horizontal .p-inputnumber-button:active {
        border-color: dt('inputnumber.button.active.border.color');
    }

    .p-inputnumber-horizontal .p-inputnumber-increment-button {
        order: 3;
        border-start-end-radius: dt('inputnumber.button.border.radius');
        border-end-end-radius: dt('inputnumber.button.border.radius');
        border-inline-start: 0 none;
    }

    .p-inputnumber-horizontal .p-inputnumber-input {
        order: 2;
        border-radius: 0;
    }

    .p-inputnumber-horizontal .p-inputnumber-decrement-button {
        order: 1;
        border-start-start-radius: dt('inputnumber.button.border.radius');
        border-end-start-radius: dt('inputnumber.button.border.radius');
        border-inline-end: 0 none;
    }

    .p-floatlabel:has(.p-inputnumber-horizontal) label {
        margin-inline-start: dt('inputnumber.button.width');
    }

    .p-inputnumber-vertical {
        flex-direction: column;
    }

    .p-inputnumber-vertical .p-inputnumber-button {
        border: 1px solid dt('inputnumber.button.border.color');
        padding: dt('inputnumber.button.vertical.padding');
    }

    .p-inputnumber-vertical .p-inputnumber-button:hover {
        border-color: dt('inputnumber.button.hover.border.color');
    }

    .p-inputnumber-vertical .p-inputnumber-button:active {
        border-color: dt('inputnumber.button.active.border.color');
    }

    .p-inputnumber-vertical .p-inputnumber-increment-button {
        order: 1;
        border-start-start-radius: dt('inputnumber.button.border.radius');
        border-start-end-radius: dt('inputnumber.button.border.radius');
        width: 100%;
        border-block-end: 0 none;
    }

    .p-inputnumber-vertical .p-inputnumber-input {
        order: 2;
        border-radius: 0;
        text-align: center;
    }

    .p-inputnumber-vertical .p-inputnumber-decrement-button {
        order: 3;
        border-end-start-radius: dt('inputnumber.button.border.radius');
        border-end-end-radius: dt('inputnumber.button.border.radius');
        width: 100%;
        border-block-start: 0 none;
    }

    .p-inputnumber-input {
        flex: 1 1 auto;
    }

    .p-inputnumber-fluid {
        width: 100%;
    }

    .p-inputnumber-fluid .p-inputnumber-input {
        width: 1%;
    }

    .p-inputnumber-fluid.p-inputnumber-vertical .p-inputnumber-input {
        width: 100%;
    }

    .p-inputnumber:has(.p-inputtext-sm) .p-inputnumber-button .p-icon {
        font-size: dt('form.field.sm.font.size');
        width: dt('form.field.sm.font.size');
        height: dt('form.field.sm.font.size');
    }

    .p-inputnumber:has(.p-inputtext-lg) .p-inputnumber-button .p-icon {
        font-size: dt('form.field.lg.font.size');
        width: dt('form.field.lg.font.size');
        height: dt('form.field.lg.font.size');
    }

    .p-inputnumber-clear-icon {
        position: absolute;
        top: 50%;
        margin-top: -0.5rem;
        cursor: pointer;
        inset-inline-end: dt('form.field.padding.x');
        color: dt('form.field.icon.color');
    }

    .p-inputnumber:has(.p-inputnumber-clear-icon) .p-inputnumber-input {
        padding-inline-end: calc((dt('form.field.padding.x') * 2) + dt('icon.size'));
    }

    .p-inputnumber-stacked .p-inputnumber-clear-icon {
        inset-inline-end: calc(dt('inputnumber.button.width') + dt('form.field.padding.x'));
    }

    .p-inputnumber-stacked:has(.p-inputnumber-clear-icon) .p-inputnumber-input {
        padding-inline-end: calc(dt('inputnumber.button.width') + (dt('form.field.padding.x') * 2) + dt('icon.size'));
    }

    .p-inputnumber-horizontal .p-inputnumber-clear-icon {
        inset-inline-end: calc(dt('inputnumber.button.width') + dt('form.field.padding.x'));
    }
`, KR = {
  root: function(e) {
    var n = e.instance, r = e.props;
    return ["p-inputnumber p-component p-inputwrapper", {
      "p-invalid": n.$invalid,
      "p-inputwrapper-filled": n.$filled || r.allowEmpty === !1,
      "p-inputwrapper-focus": n.focused,
      "p-inputnumber-stacked": r.showButtons && r.buttonLayout === "stacked",
      "p-inputnumber-horizontal": r.showButtons && r.buttonLayout === "horizontal",
      "p-inputnumber-vertical": r.showButtons && r.buttonLayout === "vertical",
      "p-inputnumber-fluid": n.$fluid
    }];
  },
  pcInputText: "p-inputnumber-input",
  clearIcon: "p-inputnumber-clear-icon",
  buttonGroup: "p-inputnumber-button-group",
  incrementButton: function(e) {
    var n = e.instance, r = e.props;
    return ["p-inputnumber-button p-inputnumber-increment-button", {
      "p-disabled": r.showButtons && r.max !== null && n.maxBoundry()
    }];
  },
  decrementButton: function(e) {
    var n = e.instance, r = e.props;
    return ["p-inputnumber-button p-inputnumber-decrement-button", {
      "p-disabled": r.showButtons && r.min !== null && n.minBoundry()
    }];
  }
}, qR = bt.extend({
  name: "inputnumber",
  style: YR,
  classes: KR
}), ZR = {
  name: "BaseInputNumber",
  extends: Ep,
  props: {
    format: {
      type: Boolean,
      default: !0
    },
    showButtons: {
      type: Boolean,
      default: !1
    },
    buttonLayout: {
      type: String,
      default: "stacked"
    },
    incrementButtonClass: {
      type: String,
      default: null
    },
    decrementButtonClass: {
      type: String,
      default: null
    },
    incrementButtonIcon: {
      type: String,
      default: void 0
    },
    incrementIcon: {
      type: String,
      default: void 0
    },
    decrementButtonIcon: {
      type: String,
      default: void 0
    },
    decrementIcon: {
      type: String,
      default: void 0
    },
    locale: {
      type: String,
      default: void 0
    },
    localeMatcher: {
      type: String,
      default: void 0
    },
    mode: {
      type: String,
      default: "decimal"
    },
    prefix: {
      type: String,
      default: null
    },
    suffix: {
      type: String,
      default: null
    },
    currency: {
      type: String,
      default: void 0
    },
    currencyDisplay: {
      type: String,
      default: void 0
    },
    useGrouping: {
      type: Boolean,
      default: !0
    },
    minFractionDigits: {
      type: Number,
      default: void 0
    },
    maxFractionDigits: {
      type: Number,
      default: void 0
    },
    roundingMode: {
      type: String,
      default: "halfExpand",
      validator: function(e) {
        return ["ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", "halfEven"].includes(e);
      }
    },
    min: {
      type: Number,
      default: null
    },
    max: {
      type: Number,
      default: null
    },
    step: {
      type: Number,
      default: 1
    },
    allowEmpty: {
      type: Boolean,
      default: !0
    },
    highlightOnFocus: {
      type: Boolean,
      default: !1
    },
    showClear: {
      type: Boolean,
      default: !1
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    placeholder: {
      type: String,
      default: null
    },
    inputId: {
      type: String,
      default: null
    },
    inputClass: {
      type: [String, Object],
      default: null
    },
    inputStyle: {
      type: Object,
      default: null
    },
    ariaLabelledby: {
      type: String,
      default: null
    },
    ariaLabel: {
      type: String,
      default: null
    },
    required: {
      type: Boolean,
      default: !1
    }
  },
  style: qR,
  provide: function() {
    return {
      $pcInputNumber: this,
      $parentInstance: this
    };
  }
};
function Yl(i) {
  "@babel/helpers - typeof";
  return Yl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Yl(i);
}
function Bv(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hv(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Bv(Object(n), !0).forEach(function(r) {
      wf(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : Bv(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function wf(i, e, n) {
  return (e = JR(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function JR(i) {
  var e = QR(i, "string");
  return Yl(e) == "symbol" ? e : e + "";
}
function QR(i, e) {
  if (Yl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Yl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
function eN(i) {
  return rN(i) || iN(i) || nN(i) || tN();
}
function tN() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function nN(i, e) {
  if (i) {
    if (typeof i == "string") return _f(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _f(i, e) : void 0;
  }
}
function iN(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function rN(i) {
  if (Array.isArray(i)) return _f(i);
}
function _f(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
var H1 = {
  name: "InputNumber",
  extends: ZR,
  inheritAttrs: !1,
  emits: ["input", "focus", "blur"],
  inject: {
    $pcFluid: {
      default: null
    }
  },
  numberFormat: null,
  _numeral: null,
  _decimal: null,
  _group: null,
  _minusSign: null,
  _currency: null,
  _suffix: null,
  _prefix: null,
  _index: null,
  groupChar: "",
  isSpecialChar: null,
  prefixChar: null,
  suffixChar: null,
  timer: null,
  data: function() {
    return {
      // @deprecated
      d_modelValue: this.d_value,
      focused: !1
    };
  },
  watch: {
    d_value: {
      immediate: !0,
      handler: function(e) {
        var n;
        this.d_modelValue = e, (n = this.$refs.clearIcon) !== null && n !== void 0 && (n = n.$el) !== null && n !== void 0 && n.style && (this.$refs.clearIcon.$el.style.display = Ji(e) ? "none" : "block");
      }
    },
    locale: function(e, n) {
      this.updateConstructParser(e, n);
    },
    localeMatcher: function(e, n) {
      this.updateConstructParser(e, n);
    },
    mode: function(e, n) {
      this.updateConstructParser(e, n);
    },
    currency: function(e, n) {
      this.updateConstructParser(e, n);
    },
    currencyDisplay: function(e, n) {
      this.updateConstructParser(e, n);
    },
    useGrouping: function(e, n) {
      this.updateConstructParser(e, n);
    },
    minFractionDigits: function(e, n) {
      this.updateConstructParser(e, n);
    },
    maxFractionDigits: function(e, n) {
      this.updateConstructParser(e, n);
    },
    suffix: function(e, n) {
      this.updateConstructParser(e, n);
    },
    prefix: function(e, n) {
      this.updateConstructParser(e, n);
    }
  },
  created: function() {
    this.constructParser();
  },
  mounted: function() {
    var e;
    (e = this.$refs.clearIcon) !== null && e !== void 0 && (e = e.$el) !== null && e !== void 0 && e.style && (this.$refs.clearIcon.$el.style.display = this.$filled ? "block" : "none");
  },
  methods: {
    getOptions: function() {
      return {
        localeMatcher: this.localeMatcher,
        style: this.mode,
        currency: this.currency,
        currencyDisplay: this.currencyDisplay,
        useGrouping: this.useGrouping,
        minimumFractionDigits: this.minFractionDigits,
        maximumFractionDigits: this.maxFractionDigits,
        roundingMode: this.roundingMode
      };
    },
    constructParser: function() {
      this.numberFormat = new Intl.NumberFormat(this.locale, this.getOptions());
      var e = eN(new Intl.NumberFormat(this.locale, {
        useGrouping: !1
      }).format(9876543210)).reverse(), n = new Map(e.map(function(r, o) {
        return [r, o];
      }));
      this._numeral = new RegExp("[".concat(e.join(""), "]"), "g"), this._group = this.getGroupingExpression(), this._minusSign = this.getMinusSignExpression(), this._currency = this.getCurrencyExpression(), this._decimal = this.getDecimalExpression(), this._suffix = this.getSuffixExpression(), this._prefix = this.getPrefixExpression(), this._index = function(r) {
        return n.get(r);
      };
    },
    updateConstructParser: function(e, n) {
      e !== n && this.constructParser();
    },
    escapeRegExp: function(e) {
      return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    },
    getDecimalExpression: function() {
      var e = new Intl.NumberFormat(this.locale, Hv(Hv({}, this.getOptions()), {}, {
        useGrouping: !1
      }));
      return new RegExp("[".concat(e.format(1.1).replace(this._currency, "").trim().replace(this._numeral, ""), "]"), "g");
    },
    getGroupingExpression: function() {
      var e = new Intl.NumberFormat(this.locale, {
        useGrouping: !0
      });
      return this.groupChar = e.format(1e6).trim().replace(this._numeral, "").charAt(0), new RegExp("[".concat(this.groupChar, "]"), "g");
    },
    getMinusSignExpression: function() {
      var e = new Intl.NumberFormat(this.locale, {
        useGrouping: !1
      });
      return new RegExp("[".concat(e.format(-1).trim().replace(this._numeral, ""), "]"), "g");
    },
    getCurrencyExpression: function() {
      if (this.currency) {
        var e = new Intl.NumberFormat(this.locale, {
          style: "currency",
          currency: this.currency,
          currencyDisplay: this.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
          roundingMode: this.roundingMode
        });
        return new RegExp("[".concat(e.format(1).replace(/\s/g, "").replace(this._numeral, "").replace(this._group, ""), "]"), "g");
      }
      return new RegExp("[]", "g");
    },
    getPrefixExpression: function() {
      if (this.prefix)
        this.prefixChar = this.prefix;
      else {
        var e = new Intl.NumberFormat(this.locale, {
          style: this.mode,
          currency: this.currency,
          currencyDisplay: this.currencyDisplay
        });
        this.prefixChar = e.format(1).split("1")[0];
      }
      return new RegExp("".concat(this.escapeRegExp(this.prefixChar || "")), "g");
    },
    getSuffixExpression: function() {
      if (this.suffix)
        this.suffixChar = this.suffix;
      else {
        var e = new Intl.NumberFormat(this.locale, {
          style: this.mode,
          currency: this.currency,
          currencyDisplay: this.currencyDisplay,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
          roundingMode: this.roundingMode
        });
        this.suffixChar = e.format(1).split("1")[1];
      }
      return new RegExp("".concat(this.escapeRegExp(this.suffixChar || "")), "g");
    },
    formatValue: function(e) {
      if (e != null) {
        if (e === "-")
          return e;
        if (this.format) {
          var n = new Intl.NumberFormat(this.locale, this.getOptions()), r = n.format(e);
          return this.prefix && (r = this.prefix + r), this.suffix && (r = r + this.suffix), r;
        }
        return e.toString();
      }
      return "";
    },
    parseValue: function(e) {
      var n = e.replace(this._suffix, "").replace(this._prefix, "").trim().replace(/\s/g, "").replace(this._currency, "").replace(this._group, "").replace(this._minusSign, "-").replace(this._decimal, ".").replace(this._numeral, this._index);
      if (n) {
        if (n === "-")
          return n;
        var r = +n;
        return isNaN(r) ? null : r;
      }
      return null;
    },
    repeat: function(e, n, r) {
      var o = this;
      if (!this.readonly) {
        var s = n || 500;
        this.clearTimer(), this.timer = setTimeout(function() {
          o.repeat(e, 40, r);
        }, s), this.spin(e, r);
      }
    },
    addWithPrecision: function(e, n) {
      var r = e.toString(), o = n.toString(), s = r.includes(".") ? r.split(".")[1].length : 0, a = o.includes(".") ? o.split(".")[1].length : 0, l = Math.max(s, a), u = Math.pow(10, l);
      return Math.round((e + n) * u) / u;
    },
    spin: function(e, n) {
      if (this.$refs.input) {
        var r = this.step * n, o = this.parseValue(this.$refs.input.$el.value) || 0, s = this.validateValue(this.addWithPrecision(o, r));
        this.updateInput(s, null, "spin"), this.updateModel(e, s), this.handleOnInput(e, o, s);
      }
    },
    onUpButtonMouseDown: function(e) {
      this.disabled || (this.$refs.input.$el.focus(), this.repeat(e, null, 1), e.preventDefault());
    },
    onUpButtonMouseUp: function() {
      this.disabled || this.clearTimer();
    },
    onUpButtonMouseLeave: function() {
      this.disabled || this.clearTimer();
    },
    onUpButtonKeyUp: function() {
      this.disabled || this.clearTimer();
    },
    onUpButtonKeyDown: function(e) {
      (e.code === "Space" || e.code === "Enter" || e.code === "NumpadEnter") && this.repeat(e, null, 1);
    },
    onDownButtonMouseDown: function(e) {
      this.disabled || (this.$refs.input.$el.focus(), this.repeat(e, null, -1), e.preventDefault());
    },
    onDownButtonMouseUp: function() {
      this.disabled || this.clearTimer();
    },
    onDownButtonMouseLeave: function() {
      this.disabled || this.clearTimer();
    },
    onDownButtonKeyUp: function() {
      this.disabled || this.clearTimer();
    },
    onDownButtonKeyDown: function(e) {
      (e.code === "Space" || e.code === "Enter" || e.code === "NumpadEnter") && this.repeat(e, null, -1);
    },
    onUserInput: function() {
      this.isSpecialChar && (this.$refs.input.$el.value = this.lastValue), this.isSpecialChar = !1;
    },
    onInputKeyDown: function(e) {
      if (!this.readonly && !e.isComposing) {
        if (e.altKey || e.ctrlKey || e.metaKey) {
          this.isSpecialChar = !0, this.lastValue = this.$refs.input.$el.value;
          return;
        }
        this.lastValue = e.target.value;
        var n = e.target.selectionStart, r = e.target.selectionEnd, o = r - n, s = e.target.value, a = null, l = e.code || e.key;
        switch (l) {
          case "ArrowUp":
            this.spin(e, 1), e.preventDefault();
            break;
          case "ArrowDown":
            this.spin(e, -1), e.preventDefault();
            break;
          case "ArrowLeft":
            if (o > 1) {
              var u = this.isNumeralChar(s.charAt(n)) ? n + 1 : n + 2;
              this.$refs.input.$el.setSelectionRange(u, u);
            } else this.isNumeralChar(s.charAt(n - 1)) || e.preventDefault();
            break;
          case "ArrowRight":
            if (o > 1) {
              var c = r - 1;
              this.$refs.input.$el.setSelectionRange(c, c);
            } else this.isNumeralChar(s.charAt(n)) || e.preventDefault();
            break;
          case "Tab":
          case "Enter":
          case "NumpadEnter":
            a = this.validateValue(this.parseValue(s)), this.$refs.input.$el.value = this.formatValue(a), this.$refs.input.$el.setAttribute("aria-valuenow", a), this.updateModel(e, a);
            break;
          case "Backspace": {
            if (e.preventDefault(), n === r) {
              n >= s.length && this.suffixChar !== null && (n = s.length - this.suffixChar.length, this.$refs.input.$el.setSelectionRange(n, n));
              var d = s.charAt(n - 1), h = this.getDecimalCharIndexes(s), p = h.decimalCharIndex, m = h.decimalCharIndexWithoutPrefix;
              if (this.isNumeralChar(d)) {
                var v = this.getDecimalLength(s);
                if (this._group.test(d))
                  this._group.lastIndex = 0, a = s.slice(0, n - 2) + s.slice(n - 1);
                else if (this._decimal.test(d))
                  this._decimal.lastIndex = 0, v ? this.$refs.input.$el.setSelectionRange(n - 1, n - 1) : a = s.slice(0, n - 1) + s.slice(n);
                else if (p > 0 && n > p) {
                  var y = this.isDecimalMode() && (this.minFractionDigits || 0) < v ? "" : "0";
                  a = s.slice(0, n - 1) + y + s.slice(n);
                } else m === 1 ? (a = s.slice(0, n - 1) + "0" + s.slice(n), a = this.parseValue(a) > 0 ? a : "") : a = s.slice(0, n - 1) + s.slice(n);
              }
              this.updateValue(e, a, null, "delete-single");
            } else
              a = this.deleteRange(s, n, r), this.updateValue(e, a, null, "delete-range");
            break;
          }
          case "Delete":
            if (e.preventDefault(), n === r) {
              var w = s.charAt(n), g = this.getDecimalCharIndexes(s), k = g.decimalCharIndex, _ = g.decimalCharIndexWithoutPrefix;
              if (this.isNumeralChar(w)) {
                var S = this.getDecimalLength(s);
                if (this._group.test(w))
                  this._group.lastIndex = 0, a = s.slice(0, n) + s.slice(n + 2);
                else if (this._decimal.test(w))
                  this._decimal.lastIndex = 0, S ? this.$refs.input.$el.setSelectionRange(n + 1, n + 1) : a = s.slice(0, n) + s.slice(n + 1);
                else if (k > 0 && n > k) {
                  var b = this.isDecimalMode() && (this.minFractionDigits || 0) < S ? "" : "0";
                  a = s.slice(0, n) + b + s.slice(n + 1);
                } else _ === 1 ? (a = s.slice(0, n) + "0" + s.slice(n + 1), a = this.parseValue(a) > 0 ? a : "") : a = s.slice(0, n) + s.slice(n + 1);
              }
              this.updateValue(e, a, null, "delete-back-single");
            } else
              a = this.deleteRange(s, n, r), this.updateValue(e, a, null, "delete-range");
            break;
          case "Home":
            e.preventDefault(), gt(this.min) && this.updateModel(e, this.min);
            break;
          case "End":
            e.preventDefault(), gt(this.max) && this.updateModel(e, this.max);
            break;
        }
      }
    },
    onInputKeyPress: function(e) {
      if (!this.readonly) {
        var n = e.key, r = this.isDecimalSign(n), o = this.isMinusSign(n);
        e.code !== "Enter" && e.preventDefault(), (Number(n) >= 0 && Number(n) <= 9 || o || r) && this.insert(e, n, {
          isDecimalSign: r,
          isMinusSign: o
        });
      }
    },
    onPaste: function(e) {
      if (!this.readonly) {
        e.preventDefault();
        var n = (e.clipboardData || window.clipboardData).getData("Text");
        if (!(this.inputId === "integeronly" && /[^\d-]/.test(n)) && n) {
          var r = this.parseValue(n);
          r != null && this.insert(e, r.toString());
        }
      }
    },
    onClearClick: function(e) {
      this.updateModel(e, null), this.$refs.input.$el.focus();
    },
    allowMinusSign: function() {
      return this.min === null || this.min < 0;
    },
    isMinusSign: function(e) {
      return this._minusSign.test(e) || e === "-" ? (this._minusSign.lastIndex = 0, !0) : !1;
    },
    isDecimalSign: function(e) {
      var n;
      return (n = this.locale) !== null && n !== void 0 && n.includes("fr") && [".", ","].includes(e) || this._decimal.test(e) ? (this._decimal.lastIndex = 0, !0) : !1;
    },
    isDecimalMode: function() {
      return this.mode === "decimal";
    },
    getDecimalCharIndexes: function(e) {
      var n = e.search(this._decimal);
      this._decimal.lastIndex = 0;
      var r = e.replace(this._prefix, "").trim().replace(/\s/g, "").replace(this._currency, ""), o = r.search(this._decimal);
      return this._decimal.lastIndex = 0, {
        decimalCharIndex: n,
        decimalCharIndexWithoutPrefix: o
      };
    },
    getCharIndexes: function(e) {
      var n = e.search(this._decimal);
      this._decimal.lastIndex = 0;
      var r = e.search(this._minusSign);
      this._minusSign.lastIndex = 0;
      var o = e.search(this._suffix);
      this._suffix.lastIndex = 0;
      var s = e.search(this._currency);
      return this._currency.lastIndex = 0, {
        decimalCharIndex: n,
        minusCharIndex: r,
        suffixCharIndex: o,
        currencyCharIndex: s
      };
    },
    insert: function(e, n) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        isDecimalSign: !1,
        isMinusSign: !1
      }, o = n.search(this._minusSign);
      if (this._minusSign.lastIndex = 0, !(!this.allowMinusSign() && o !== -1)) {
        var s = this.$refs.input.$el.selectionStart, a = this.$refs.input.$el.selectionEnd, l = this.$refs.input.$el.value.trim(), u = this.getCharIndexes(l), c = u.decimalCharIndex, d = u.minusCharIndex, h = u.suffixCharIndex, p = u.currencyCharIndex, m;
        if (r.isMinusSign) {
          var v = d === -1;
          (s === 0 || s === p + 1) && (m = l, (v || a !== 0) && (m = this.insertText(l, n, 0, a)), this.updateValue(e, m, n, "insert"));
        } else if (r.isDecimalSign)
          c > 0 && s === c ? this.updateValue(e, l, n, "insert") : c > s && c < a ? (m = this.insertText(l, n, s, a), this.updateValue(e, m, n, "insert")) : c === -1 && this.maxFractionDigits && (m = this.insertText(l, n, s, a), this.updateValue(e, m, n, "insert"));
        else {
          var y = this.numberFormat.resolvedOptions().maximumFractionDigits, w = s !== a ? "range-insert" : "insert";
          if (c > 0 && s > c) {
            if (s + n.length - (c + 1) <= y) {
              var g = p >= s ? p - 1 : h >= s ? h : l.length;
              m = l.slice(0, s) + n + l.slice(s + n.length, g) + l.slice(g), this.updateValue(e, m, n, w);
            }
          } else
            m = this.insertText(l, n, s, a), this.updateValue(e, m, n, w);
        }
      }
    },
    insertText: function(e, n, r, o) {
      var s = n === "." ? n : n.split(".");
      if (s.length === 2) {
        var a = e.slice(r, o).search(this._decimal);
        return this._decimal.lastIndex = 0, a > 0 ? e.slice(0, r) + this.formatValue(n) + e.slice(o) : this.formatValue(n) || e;
      } else return o - r === e.length ? this.formatValue(n) : r === 0 ? n + e.slice(o) : o === e.length ? e.slice(0, r) + n : e.slice(0, r) + n + e.slice(o);
    },
    deleteRange: function(e, n, r) {
      var o;
      return r - n === e.length ? o = "" : n === 0 ? o = e.slice(r) : r === e.length ? o = e.slice(0, n) : o = e.slice(0, n) + e.slice(r), o;
    },
    initCursor: function() {
      var e = this.$refs.input.$el.selectionStart, n = this.$refs.input.$el.value, r = n.length, o = null, s = (this.prefixChar || "").length;
      n = n.replace(this._prefix, ""), e = e - s;
      var a = n.charAt(e);
      if (this.isNumeralChar(a))
        return e + s;
      for (var l = e - 1; l >= 0; )
        if (a = n.charAt(l), this.isNumeralChar(a)) {
          o = l + s;
          break;
        } else
          l--;
      if (o !== null)
        this.$refs.input.$el.setSelectionRange(o + 1, o + 1);
      else {
        for (l = e; l < r; )
          if (a = n.charAt(l), this.isNumeralChar(a)) {
            o = l + s;
            break;
          } else
            l++;
        o !== null && this.$refs.input.$el.setSelectionRange(o, o);
      }
      return o || 0;
    },
    onInputClick: function() {
      var e = this.$refs.input.$el.value;
      !this.readonly && e !== Gm() && this.initCursor();
    },
    isNumeralChar: function(e) {
      return e.length === 1 && (this._numeral.test(e) || this._decimal.test(e) || this._group.test(e) || this._minusSign.test(e)) ? (this.resetRegex(), !0) : !1;
    },
    resetRegex: function() {
      this._numeral.lastIndex = 0, this._decimal.lastIndex = 0, this._group.lastIndex = 0, this._minusSign.lastIndex = 0;
    },
    updateValue: function(e, n, r, o) {
      var s = this.$refs.input.$el.value, a = null;
      n != null && (a = this.parseValue(n), a = !a && !this.allowEmpty ? 0 : a, this.updateInput(a, r, o, n), this.handleOnInput(e, s, a));
    },
    handleOnInput: function(e, n, r) {
      if (this.isValueChanged(n, r)) {
        var o, s;
        this.$emit("input", {
          originalEvent: e,
          value: r,
          formattedValue: n
        }), (o = (s = this.formField).onInput) === null || o === void 0 || o.call(s, {
          originalEvent: e,
          value: r
        });
      }
    },
    isValueChanged: function(e, n) {
      if (n === null && e !== null)
        return !0;
      if (n != null) {
        var r = typeof e == "string" ? this.parseValue(e) : e;
        return n !== r;
      }
      return !1;
    },
    validateValue: function(e) {
      return e === "-" || e == null ? null : this.min != null && e < this.min ? this.min : this.max != null && e > this.max ? this.max : e;
    },
    updateInput: function(e, n, r, o) {
      var s;
      n = n || "";
      var a = this.$refs.input.$el.value, l = this.formatValue(e), u = a.length;
      if (l !== o && (l = this.concatValues(l, o)), u === 0) {
        this.$refs.input.$el.value = l, this.$refs.input.$el.setSelectionRange(0, 0);
        var c = this.initCursor(), d = c + n.length;
        this.$refs.input.$el.setSelectionRange(d, d);
      } else {
        var h = this.$refs.input.$el.selectionStart, p = this.$refs.input.$el.selectionEnd;
        this.$refs.input.$el.value = l;
        var m = l.length;
        if (r === "range-insert") {
          var v = this.parseValue((a || "").slice(0, h)), y = v !== null ? v.toString() : "", w = y.split("").join("(".concat(this.groupChar, ")?")), g = new RegExp(w, "g");
          g.test(l);
          var k = n.split("").join("(".concat(this.groupChar, ")?")), _ = new RegExp(k, "g");
          _.test(l.slice(g.lastIndex)), p = g.lastIndex + _.lastIndex, this.$refs.input.$el.setSelectionRange(p, p);
        } else if (m === u)
          r === "insert" || r === "delete-back-single" ? this.$refs.input.$el.setSelectionRange(p + 1, p + 1) : r === "delete-single" ? this.$refs.input.$el.setSelectionRange(p - 1, p - 1) : (r === "delete-range" || r === "spin") && this.$refs.input.$el.setSelectionRange(p, p);
        else if (r === "delete-back-single") {
          var S = a.charAt(p - 1), b = a.charAt(p), C = u - m, x = this._group.test(b);
          x && C === 1 ? p += 1 : !x && this.isNumeralChar(S) && (p += -1 * C + 1), this._group.lastIndex = 0, this.$refs.input.$el.setSelectionRange(p, p);
        } else if (a === "-" && r === "insert") {
          this.$refs.input.$el.setSelectionRange(0, 0);
          var I = this.initCursor(), F = I + n.length + 1;
          this.$refs.input.$el.setSelectionRange(F, F);
        } else
          p = p + (m - u), this.$refs.input.$el.setSelectionRange(p, p);
      }
      this.$refs.input.$el.setAttribute("aria-valuenow", e), (s = this.$refs.clearIcon) !== null && s !== void 0 && (s = s.$el) !== null && s !== void 0 && s.style && (this.$refs.clearIcon.$el.style.display = Ji(l) ? "none" : "block");
    },
    concatValues: function(e, n) {
      if (e && n) {
        var r = n.search(this._decimal);
        return this._decimal.lastIndex = 0, this.suffixChar ? r !== -1 ? e.replace(this.suffixChar, "").split(this._decimal)[0] + n.replace(this.suffixChar, "").slice(r) + this.suffixChar : e : r !== -1 ? e.split(this._decimal)[0] + n.slice(r) : e;
      }
      return e;
    },
    getDecimalLength: function(e) {
      if (e) {
        var n = e.split(this._decimal);
        if (n.length === 2)
          return n[1].replace(this._suffix, "").trim().replace(/\s/g, "").replace(this._currency, "").length;
      }
      return 0;
    },
    updateModel: function(e, n) {
      this.writeValue(n, e);
    },
    onInputFocus: function(e) {
      this.focused = !0, !this.disabled && !this.readonly && this.$refs.input.$el.value !== Gm() && this.highlightOnFocus && e.target.select(), this.$emit("focus", e);
    },
    onInputBlur: function(e) {
      var n, r;
      this.focused = !1;
      var o = e.target, s = this.validateValue(this.parseValue(o.value));
      this.$emit("blur", {
        originalEvent: e,
        value: o.value
      }), (n = (r = this.formField).onBlur) === null || n === void 0 || n.call(r, e), o.value = this.formatValue(s), o.setAttribute("aria-valuenow", s), this.updateModel(e, s), !this.disabled && !this.readonly && this.highlightOnFocus && vC();
    },
    clearTimer: function() {
      this.timer && clearTimeout(this.timer);
    },
    maxBoundry: function() {
      return this.d_value >= this.max;
    },
    minBoundry: function() {
      return this.d_value <= this.min;
    }
  },
  computed: {
    upButtonListeners: function() {
      var e = this;
      return {
        mousedown: function(r) {
          return e.onUpButtonMouseDown(r);
        },
        mouseup: function(r) {
          return e.onUpButtonMouseUp(r);
        },
        mouseleave: function(r) {
          return e.onUpButtonMouseLeave(r);
        },
        keydown: function(r) {
          return e.onUpButtonKeyDown(r);
        },
        keyup: function(r) {
          return e.onUpButtonKeyUp(r);
        }
      };
    },
    downButtonListeners: function() {
      var e = this;
      return {
        mousedown: function(r) {
          return e.onDownButtonMouseDown(r);
        },
        mouseup: function(r) {
          return e.onDownButtonMouseUp(r);
        },
        mouseleave: function(r) {
          return e.onDownButtonMouseLeave(r);
        },
        keydown: function(r) {
          return e.onDownButtonKeyDown(r);
        },
        keyup: function(r) {
          return e.onDownButtonKeyUp(r);
        }
      };
    },
    formattedValue: function() {
      var e = !this.d_value && !this.allowEmpty ? 0 : this.d_value;
      return this.formatValue(e);
    },
    getFormatter: function() {
      return this.numberFormat;
    },
    dataP: function() {
      return ui(wf(wf({
        invalid: this.$invalid,
        fluid: this.$fluid,
        filled: this.$variant === "filled"
      }, this.size, this.size), this.buttonLayout, this.showButtons && this.buttonLayout));
    }
  },
  components: {
    InputText: Ed,
    AngleUpIcon: B1,
    AngleDownIcon: z1,
    TimesIcon: Od
  }
}, oN = ["data-p"], sN = ["data-p"], aN = ["disabled", "data-p"], lN = ["disabled", "data-p"], uN = ["disabled", "data-p"], cN = ["disabled", "data-p"];
function dN(i, e, n, r, o, s) {
  var a = Tn("InputText"), l = Tn("TimesIcon");
  return $(), A("span", ke({
    class: i.cx("root")
  }, i.ptmi("root"), {
    "data-p": s.dataP
  }), [Ve(a, {
    ref: "input",
    id: i.inputId,
    name: i.$formName,
    role: "spinbutton",
    class: _e([i.cx("pcInputText"), i.inputClass]),
    style: Pt(i.inputStyle),
    defaultValue: s.formattedValue,
    "aria-valuemin": i.min,
    "aria-valuemax": i.max,
    "aria-valuenow": i.d_value,
    inputmode: i.mode === "decimal" && !i.minFractionDigits ? "numeric" : "decimal",
    disabled: i.disabled,
    readonly: i.readonly,
    placeholder: i.placeholder,
    "aria-labelledby": i.ariaLabelledby,
    "aria-label": i.ariaLabel,
    required: i.required,
    size: i.size,
    invalid: i.invalid,
    variant: i.variant,
    onInput: s.onUserInput,
    onKeydown: s.onInputKeyDown,
    onKeypress: s.onInputKeyPress,
    onPaste: s.onPaste,
    onClick: s.onInputClick,
    onFocus: s.onInputFocus,
    onBlur: s.onInputBlur,
    pt: i.ptm("pcInputText"),
    unstyled: i.unstyled,
    "data-p": s.dataP
  }, null, 8, ["id", "name", "class", "style", "defaultValue", "aria-valuemin", "aria-valuemax", "aria-valuenow", "inputmode", "disabled", "readonly", "placeholder", "aria-labelledby", "aria-label", "required", "size", "invalid", "variant", "onInput", "onKeydown", "onKeypress", "onPaste", "onClick", "onFocus", "onBlur", "pt", "unstyled", "data-p"]), i.showClear && i.buttonLayout !== "vertical" ? it(i.$slots, "clearicon", {
    key: 0,
    class: _e(i.cx("clearIcon")),
    clearCallback: s.onClearClick
  }, function() {
    return [Ve(l, ke({
      ref: "clearIcon",
      class: [i.cx("clearIcon")],
      onClick: s.onClearClick
    }, i.ptm("clearIcon")), null, 16, ["class", "onClick"])];
  }) : ve("", !0), i.showButtons && i.buttonLayout === "stacked" ? ($(), A("span", ke({
    key: 1,
    class: i.cx("buttonGroup")
  }, i.ptm("buttonGroup"), {
    "data-p": s.dataP
  }), [it(i.$slots, "incrementbutton", {
    listeners: s.upButtonListeners
  }, function() {
    return [f("button", ke({
      class: [i.cx("incrementButton"), i.incrementButtonClass]
    }, xu(s.upButtonListeners), {
      disabled: i.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, i.ptm("incrementButton"), {
      "data-p": s.dataP
    }), [it(i.$slots, i.$slots.incrementicon ? "incrementicon" : "incrementbuttonicon", {}, function() {
      return [($(), st(vr(i.incrementIcon || i.incrementButtonIcon ? "span" : "AngleUpIcon"), ke({
        class: [i.incrementIcon, i.incrementButtonIcon]
      }, i.ptm("incrementIcon"), {
        "data-pc-section": "incrementicon"
      }), null, 16, ["class"]))];
    })], 16, aN)];
  }), it(i.$slots, "decrementbutton", {
    listeners: s.downButtonListeners
  }, function() {
    return [f("button", ke({
      class: [i.cx("decrementButton"), i.decrementButtonClass]
    }, xu(s.downButtonListeners), {
      disabled: i.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, i.ptm("decrementButton"), {
      "data-p": s.dataP
    }), [it(i.$slots, i.$slots.decrementicon ? "decrementicon" : "decrementbuttonicon", {}, function() {
      return [($(), st(vr(i.decrementIcon || i.decrementButtonIcon ? "span" : "AngleDownIcon"), ke({
        class: [i.decrementIcon, i.decrementButtonIcon]
      }, i.ptm("decrementIcon"), {
        "data-pc-section": "decrementicon"
      }), null, 16, ["class"]))];
    })], 16, lN)];
  })], 16, sN)) : ve("", !0), it(i.$slots, "incrementbutton", {
    listeners: s.upButtonListeners
  }, function() {
    return [i.showButtons && i.buttonLayout !== "stacked" ? ($(), A("button", ke({
      key: 0,
      class: [i.cx("incrementButton"), i.incrementButtonClass]
    }, xu(s.upButtonListeners), {
      disabled: i.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, i.ptm("incrementButton"), {
      "data-p": s.dataP
    }), [it(i.$slots, i.$slots.incrementicon ? "incrementicon" : "incrementbuttonicon", {}, function() {
      return [($(), st(vr(i.incrementIcon || i.incrementButtonIcon ? "span" : "AngleUpIcon"), ke({
        class: [i.incrementIcon, i.incrementButtonIcon]
      }, i.ptm("incrementIcon"), {
        "data-pc-section": "incrementicon"
      }), null, 16, ["class"]))];
    })], 16, uN)) : ve("", !0)];
  }), it(i.$slots, "decrementbutton", {
    listeners: s.downButtonListeners
  }, function() {
    return [i.showButtons && i.buttonLayout !== "stacked" ? ($(), A("button", ke({
      key: 0,
      class: [i.cx("decrementButton"), i.decrementButtonClass]
    }, xu(s.downButtonListeners), {
      disabled: i.disabled,
      tabindex: -1,
      "aria-hidden": "true",
      type: "button"
    }, i.ptm("decrementButton"), {
      "data-p": s.dataP
    }), [it(i.$slots, i.$slots.decrementicon ? "decrementicon" : "decrementbuttonicon", {}, function() {
      return [($(), st(vr(i.decrementIcon || i.decrementButtonIcon ? "span" : "AngleDownIcon"), ke({
        class: [i.decrementIcon, i.decrementButtonIcon]
      }, i.ptm("decrementIcon"), {
        "data-pc-section": "decrementicon"
      }), null, 16, ["class"]))];
    })], 16, cN)) : ve("", !0)];
  })], 16, oN);
}
H1.render = dN;
var hN = `
    .p-colorpicker {
        display: inline-block;
        position: relative;
    }

    .p-colorpicker-dragging {
        cursor: pointer;
    }

    .p-colorpicker-preview {
        width: dt('colorpicker.preview.width');
        height: dt('colorpicker.preview.height');
        padding: 0;
        border: 0 none;
        border-radius: dt('colorpicker.preview.border.radius');
        transition:
            background dt('colorpicker.transition.duration'),
            color dt('colorpicker.transition.duration'),
            border-color dt('colorpicker.transition.duration'),
            outline-color dt('colorpicker.transition.duration'),
            box-shadow dt('colorpicker.transition.duration');
        outline-color: transparent;
        cursor: pointer;
    }

    .p-colorpicker-preview:enabled:focus-visible {
        border-color: dt('colorpicker.preview.focus.border.color');
        box-shadow: dt('colorpicker.preview.focus.ring.shadow');
        outline: dt('colorpicker.preview.focus.ring.width') dt('colorpicker.preview.focus.ring.style') dt('colorpicker.preview.focus.ring.color');
        outline-offset: dt('colorpicker.preview.focus.ring.offset');
    }

    .p-colorpicker-panel {
        background: dt('colorpicker.panel.background');
        border: 1px solid dt('colorpicker.panel.border.color');
        border-radius: dt('colorpicker.panel.border.radius');
        box-shadow: dt('colorpicker.panel.shadow');
        width: 193px;
        height: 166px;
        position: absolute;
        top: 0;
        left: 0;
    }

    .p-colorpicker-panel-inline {
        box-shadow: none;
        position: static;
    }

    .p-colorpicker-content {
        position: relative;
    }

    .p-colorpicker-color-selector {
        width: 150px;
        height: 150px;
        inset-block-start: 8px;
        inset-inline-start: 8px;
        position: absolute;
    }

    .p-colorpicker-color-background {
        width: 100%;
        height: 100%;
        background: linear-gradient(to top, #000 0%, rgba(0, 0, 0, 0) 100%), linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);
    }

    .p-colorpicker-color-handle {
        position: absolute;
        inset-block-start: 0px;
        inset-inline-start: 150px;
        border-radius: 100%;
        width: 10px;
        height: 10px;
        border-width: 1px;
        border-style: solid;
        margin: -5px 0 0 -5px;
        cursor: pointer;
        opacity: 0.85;
        border-color: dt('colorpicker.handle.color');
    }

    .p-colorpicker-hue {
        width: 17px;
        height: 150px;
        inset-block-start: 8px;
        inset-inline-start: 167px;
        position: absolute;
        opacity: 0.85;
        background: linear-gradient(0deg, red 0, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, red);
    }

    .p-colorpicker-hue-handle {
        position: absolute;
        inset-block-start: 150px;
        inset-inline-start: 0px;
        width: 21px;
        margin-inline-start: -2px;
        margin-block-start: -5px;
        height: 10px;
        border-width: 2px;
        border-style: solid;
        opacity: 0.85;
        cursor: pointer;
        border-color: dt('colorpicker.handle.color');
    }
`, fN = {
  root: "p-colorpicker p-component",
  preview: function(e) {
    var n = e.props;
    return ["p-colorpicker-preview", {
      "p-disabled": n.disabled
    }];
  },
  panel: function(e) {
    var n = e.instance, r = e.props;
    return ["p-colorpicker-panel", {
      "p-colorpicker-panel-inline": r.inline,
      "p-disabled": r.disabled,
      "p-invalid": n.$invalid
    }];
  },
  colorSelector: "p-colorpicker-color-selector",
  colorBackground: "p-colorpicker-color-background",
  colorHandle: "p-colorpicker-color-handle",
  hue: "p-colorpicker-hue",
  hueHandle: "p-colorpicker-hue-handle"
}, pN = bt.extend({
  name: "colorpicker",
  style: hN,
  classes: fN
}), mN = {
  name: "BaseColorPicker",
  extends: kp,
  props: {
    defaultColor: {
      type: null,
      default: "ff0000"
    },
    inline: {
      type: Boolean,
      default: !1
    },
    format: {
      type: String,
      default: "hex"
    },
    tabindex: {
      type: String,
      default: null
    },
    autoZIndex: {
      type: Boolean,
      default: !0
    },
    baseZIndex: {
      type: Number,
      default: 0
    },
    appendTo: {
      type: [String, Object],
      default: "body"
    },
    inputId: {
      type: String,
      default: null
    },
    panelClass: null,
    overlayClass: null
  },
  style: pN,
  provide: function() {
    return {
      $pcColorPicker: this,
      $parentInstance: this
    };
  }
}, U1 = {
  name: "ColorPicker",
  extends: mN,
  inheritAttrs: !1,
  emits: ["change", "show", "hide"],
  data: function() {
    return {
      overlayVisible: !1
    };
  },
  hsbValue: null,
  localHue: null,
  outsideClickListener: null,
  documentMouseMoveListener: null,
  documentMouseUpListener: null,
  scrollHandler: null,
  resizeListener: null,
  hueDragging: null,
  colorDragging: null,
  selfUpdate: null,
  picker: null,
  colorSelector: null,
  colorHandle: null,
  hueView: null,
  hueHandle: null,
  watch: {
    modelValue: {
      immediate: !0,
      handler: function(e) {
        this.hsbValue = this.toHSB(e), this.selfUpdate ? this.selfUpdate = !1 : this.updateUI();
      }
    }
  },
  beforeUnmount: function() {
    this.unbindOutsideClickListener(), this.unbindDragListeners(), this.unbindResizeListener(), this.scrollHandler && (this.scrollHandler.destroy(), this.scrollHandler = null), this.picker && this.autoZIndex && Ui.clear(this.picker), this.clearRefs();
  },
  mounted: function() {
    this.updateUI();
  },
  methods: {
    pickColor: function(e) {
      var n = this.colorSelector.getBoundingClientRect(), r = n.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0), o = n.left + document.body.scrollLeft, s = Math.floor(100 * Math.max(0, Math.min(150, (e.pageX || e.changedTouches[0].pageX) - o)) / 150), a = Math.floor(100 * (150 - Math.max(0, Math.min(150, (e.pageY || e.changedTouches[0].pageY) - r))) / 150);
      this.hsbValue = this.validateHSB({
        h: this.localHue,
        s,
        b: a
      }), this.selfUpdate = !0, this.updateColorHandle(), this.updateInput(), this.updateModel(e);
    },
    pickHue: function(e) {
      var n = this.hueView.getBoundingClientRect().top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0);
      this.localHue = Math.floor(360 * (150 - Math.max(0, Math.min(150, (e.pageY || e.changedTouches[0].pageY) - n))) / 150), this.hsbValue = this.validateHSB({
        h: this.localHue,
        s: this.hsbValue.s,
        b: this.hsbValue.b
      }), this.selfUpdate = !0, this.updateColorSelector(), this.updateHue(), this.updateModel(e), this.updateInput();
    },
    updateModel: function(e) {
      var n = this.d_value;
      switch (this.format) {
        case "hex":
          n = this.HSBtoHEX(this.hsbValue);
          break;
        case "rgb":
          n = this.HSBtoRGB(this.hsbValue);
          break;
        case "hsb":
          n = this.hsbValue;
          break;
      }
      this.writeValue(n, e), this.$emit("change", {
        event: e,
        value: n
      });
    },
    updateColorSelector: function() {
      if (this.colorSelector) {
        var e = this.validateHSB({
          h: this.hsbValue.h,
          s: 100,
          b: 100
        });
        this.colorSelector.style.backgroundColor = "#" + this.HSBtoHEX(e);
      }
    },
    updateColorHandle: function() {
      this.colorHandle && (this.colorHandle.style.left = Math.floor(150 * this.hsbValue.s / 100) + "px", this.colorHandle.style.top = Math.floor(150 * (100 - this.hsbValue.b) / 100) + "px");
    },
    updateHue: function() {
      this.hueHandle && (this.hueHandle.style.top = Math.floor(150 - 150 * this.hsbValue.h / 360) + "px");
    },
    updateInput: function() {
      this.$refs.input && (this.$refs.input.style.backgroundColor = "#" + this.HSBtoHEX(this.hsbValue));
    },
    updateUI: function() {
      this.updateHue(), this.updateColorHandle(), this.updateInput(), this.updateColorSelector();
    },
    validateHSB: function(e) {
      return {
        h: Math.min(360, Math.max(0, e.h)),
        s: Math.min(100, Math.max(0, e.s)),
        b: Math.min(100, Math.max(0, e.b))
      };
    },
    validateRGB: function(e) {
      return {
        r: Math.min(255, Math.max(0, e.r)),
        g: Math.min(255, Math.max(0, e.g)),
        b: Math.min(255, Math.max(0, e.b))
      };
    },
    validateHEX: function(e) {
      var n = 6 - e.length;
      if (n > 0) {
        for (var r = [], o = 0; o < n; o++)
          r.push("0");
        r.push(e), e = r.join("");
      }
      return e;
    },
    HEXtoRGB: function(e) {
      var n = parseInt(e.indexOf("#") > -1 ? e.substring(1) : e, 16);
      return {
        r: n >> 16,
        g: (n & 65280) >> 8,
        b: n & 255
      };
    },
    HEXtoHSB: function(e) {
      return this.RGBtoHSB(this.HEXtoRGB(e));
    },
    RGBtoHSB: function(e) {
      var n = {
        h: 0,
        s: 0,
        b: 0
      }, r = Math.min(e.r, e.g, e.b), o = Math.max(e.r, e.g, e.b), s = o - r;
      return n.b = o, n.s = o !== 0 ? 255 * s / o : 0, n.s !== 0 ? e.r === o ? n.h = (e.g - e.b) / s : e.g === o ? n.h = 2 + (e.b - e.r) / s : n.h = 4 + (e.r - e.g) / s : n.h = -1, n.h *= 60, n.h < 0 && (n.h += 360), n.s *= 100 / 255, n.b *= 100 / 255, n;
    },
    HSBtoRGB: function(e) {
      var n = {
        r: null,
        g: null,
        b: null
      }, r = Math.round(e.h), o = Math.round(e.s * 255 / 100), s = Math.round(e.b * 255 / 100);
      if (o === 0)
        n = {
          r: s,
          g: s,
          b: s
        };
      else {
        var a = s, l = (255 - o) * s / 255, u = (a - l) * (r % 60) / 60;
        r === 360 && (r = 0), r < 60 ? (n.r = a, n.b = l, n.g = l + u) : r < 120 ? (n.g = a, n.b = l, n.r = a - u) : r < 180 ? (n.g = a, n.r = l, n.b = l + u) : r < 240 ? (n.b = a, n.r = l, n.g = a - u) : r < 300 ? (n.b = a, n.g = l, n.r = l + u) : r < 360 ? (n.r = a, n.g = l, n.b = a - u) : (n.r = 0, n.g = 0, n.b = 0);
      }
      return {
        r: Math.round(n.r),
        g: Math.round(n.g),
        b: Math.round(n.b)
      };
    },
    RGBtoHEX: function(e) {
      var n = [e.r.toString(16), e.g.toString(16), e.b.toString(16)];
      for (var r in n)
        n[r].length === 1 && (n[r] = "0" + n[r]);
      return n.join("");
    },
    HSBtoHEX: function(e) {
      return this.RGBtoHEX(this.HSBtoRGB(e));
    },
    toHSB: function(e) {
      var n;
      if (e)
        switch (this.format) {
          case "hex":
            n = this.HEXtoHSB(e);
            break;
          case "rgb":
            n = this.RGBtoHSB(e);
            break;
          case "hsb":
            n = e;
            break;
        }
      else
        n = this.HEXtoHSB(this.defaultColor);
      return n.s === 0 || n.b === 0 ? n.h = this.localHue : this.localHue = n.h, n;
    },
    onOverlayEnter: function(e) {
      this.updateUI(), this.alignOverlay(), this.bindOutsideClickListener(), this.bindScrollListener(), this.bindResizeListener(), this.autoZIndex && Ui.set("overlay", e, this.baseZIndex + this.$primevue.config.zIndex.overlay), this.$attrSelector && e.setAttribute(this.$attrSelector, ""), this.$emit("show");
    },
    onOverlayLeave: function() {
      this.unbindOutsideClickListener(), this.unbindScrollListener(), this.unbindResizeListener(), this.clearRefs(), this.$emit("hide");
    },
    onOverlayAfterLeave: function(e) {
      this.autoZIndex && Ui.clear(e);
    },
    alignOverlay: function() {
      this.appendTo === "self" ? q0(this.picker, this.$refs.input) : Y0(this.picker, this.$refs.input);
    },
    onInputClick: function() {
      this.disabled || (this.overlayVisible = !this.overlayVisible);
    },
    onInputKeydown: function(e) {
      switch (e.code) {
        case "Space":
          this.overlayVisible = !this.overlayVisible, e.preventDefault();
          break;
        case "Escape":
        case "Tab":
          this.overlayVisible = !1;
          break;
      }
    },
    onInputBlur: function(e) {
      var n, r;
      (n = (r = this.formField).onBlur) === null || n === void 0 || n.call(r);
    },
    onColorMousedown: function(e) {
      this.disabled || (this.bindDragListeners(), this.onColorDragStart(e));
    },
    onColorDragStart: function(e) {
      this.disabled || (this.colorDragging = !0, this.pickColor(e), this.$el.setAttribute("p-colorpicker-dragging", "true"), !this.isUnstyled && Ms(this.$el, "p-colorpicker-dragging"), e.preventDefault());
    },
    onDrag: function(e) {
      this.colorDragging && (this.pickColor(e), e.preventDefault()), this.hueDragging && (this.pickHue(e), e.preventDefault());
    },
    onDragEnd: function() {
      this.colorDragging = !1, this.hueDragging = !1, this.$el.setAttribute("p-colorpicker-dragging", "false"), !this.isUnstyled && Ss(this.$el, "p-colorpicker-dragging"), this.unbindDragListeners();
    },
    onHueMousedown: function(e) {
      this.disabled || (this.bindDragListeners(), this.onHueDragStart(e));
    },
    onHueDragStart: function(e) {
      this.disabled || (this.hueDragging = !0, this.pickHue(e), !this.isUnstyled && Ms(this.$el, "p-colorpicker-dragging"), e.preventDefault());
    },
    isInputClicked: function(e) {
      return this.$refs.input && this.$refs.input.isSameNode(e.target);
    },
    bindDragListeners: function() {
      this.bindDocumentMouseMoveListener(), this.bindDocumentMouseUpListener();
    },
    unbindDragListeners: function() {
      this.unbindDocumentMouseMoveListener(), this.unbindDocumentMouseUpListener();
    },
    bindOutsideClickListener: function() {
      var e = this;
      this.outsideClickListener || (this.outsideClickListener = function(n) {
        e.overlayVisible && e.picker && !e.picker.contains(n.target) && !e.isInputClicked(n) && (e.overlayVisible = !1);
      }, document.addEventListener("click", this.outsideClickListener, !0));
    },
    unbindOutsideClickListener: function() {
      this.outsideClickListener && (document.removeEventListener("click", this.outsideClickListener, !0), this.outsideClickListener = null);
    },
    bindScrollListener: function() {
      var e = this;
      this.scrollHandler || (this.scrollHandler = new Op(this.$refs.container, function() {
        e.overlayVisible && (e.overlayVisible = !1);
      })), this.scrollHandler.bindScrollListener();
    },
    unbindScrollListener: function() {
      this.scrollHandler && this.scrollHandler.unbindScrollListener();
    },
    bindResizeListener: function() {
      var e = this;
      this.resizeListener || (this.resizeListener = function() {
        e.overlayVisible && !Jf() && (e.overlayVisible = !1);
      }, window.addEventListener("resize", this.resizeListener));
    },
    unbindResizeListener: function() {
      this.resizeListener && (window.removeEventListener("resize", this.resizeListener), this.resizeListener = null);
    },
    bindDocumentMouseMoveListener: function() {
      this.documentMouseMoveListener || (this.documentMouseMoveListener = this.onDrag.bind(this), document.addEventListener("mousemove", this.documentMouseMoveListener));
    },
    unbindDocumentMouseMoveListener: function() {
      this.documentMouseMoveListener && (document.removeEventListener("mousemove", this.documentMouseMoveListener), this.documentMouseMoveListener = null);
    },
    bindDocumentMouseUpListener: function() {
      this.documentMouseUpListener || (this.documentMouseUpListener = this.onDragEnd.bind(this), document.addEventListener("mouseup", this.documentMouseUpListener));
    },
    unbindDocumentMouseUpListener: function() {
      this.documentMouseUpListener && (document.removeEventListener("mouseup", this.documentMouseUpListener), this.documentMouseUpListener = null);
    },
    pickerRef: function(e) {
      this.picker = e;
    },
    colorSelectorRef: function(e) {
      this.colorSelector = e;
    },
    colorHandleRef: function(e) {
      this.colorHandle = e;
    },
    hueViewRef: function(e) {
      this.hueView = e;
    },
    hueHandleRef: function(e) {
      this.hueHandle = e;
    },
    clearRefs: function() {
      this.picker = null, this.colorSelector = null, this.colorHandle = null, this.hueView = null, this.hueHandle = null;
    },
    onOverlayClick: function(e) {
      F1.emit("overlay-click", {
        originalEvent: e,
        target: this.$el
      });
    }
  },
  components: {
    Portal: Td
  }
};
function Kl(i) {
  "@babel/helpers - typeof";
  return Kl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Kl(i);
}
function Uv(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wv(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Uv(Object(n), !0).forEach(function(r) {
      gN(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : Uv(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function gN(i, e, n) {
  return (e = vN(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function vN(i) {
  var e = yN(i, "string");
  return Kl(e) == "symbol" ? e : e + "";
}
function yN(i, e) {
  if (Kl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Kl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var bN = ["id", "tabindex", "disabled"];
function wN(i, e, n, r, o, s) {
  var a = Tn("Portal");
  return $(), A("div", ke({
    ref: "container",
    class: i.cx("root")
  }, i.ptmi("root")), [i.inline ? ve("", !0) : ($(), A("input", ke({
    key: 0,
    ref: "input",
    id: i.inputId,
    type: "text",
    class: i.cx("preview"),
    readonly: "",
    tabindex: i.tabindex,
    disabled: i.disabled,
    onClick: e[0] || (e[0] = function() {
      return s.onInputClick && s.onInputClick.apply(s, arguments);
    }),
    onKeydown: e[1] || (e[1] = function() {
      return s.onInputKeydown && s.onInputKeydown.apply(s, arguments);
    }),
    onBlur: e[2] || (e[2] = function() {
      return s.onInputBlur && s.onInputBlur.apply(s, arguments);
    })
  }, i.ptm("preview")), null, 16, bN)), Ve(a, {
    appendTo: i.appendTo,
    disabled: i.inline
  }, {
    default: Wt(function() {
      return [Ve(Uf, ke({
        name: "p-anchored-overlay",
        onEnter: s.onOverlayEnter,
        onLeave: s.onOverlayLeave,
        onAfterLeave: s.onOverlayAfterLeave
      }, i.ptm("transition")), {
        default: Wt(function() {
          return [i.inline || o.overlayVisible ? ($(), A("div", ke({
            key: 0,
            ref: s.pickerRef,
            class: [i.cx("panel"), i.panelClass, i.overlayClass],
            onClick: e[11] || (e[11] = function() {
              return s.onOverlayClick && s.onOverlayClick.apply(s, arguments);
            })
          }, Wv(Wv({}, i.ptm("panel")), i.ptm("overlay"))), [f("div", ke({
            class: i.cx("content")
          }, i.ptm("content")), [f("div", ke({
            ref: s.colorSelectorRef,
            class: i.cx("colorSelector"),
            onMousedown: e[3] || (e[3] = function(l) {
              return s.onColorMousedown(l);
            }),
            onTouchstart: e[4] || (e[4] = function(l) {
              return s.onColorDragStart(l);
            }),
            onTouchmove: e[5] || (e[5] = function(l) {
              return s.onDrag(l);
            }),
            onTouchend: e[6] || (e[6] = function(l) {
              return s.onDragEnd();
            })
          }, i.ptm("colorSelector")), [f("div", ke({
            class: i.cx("colorBackground")
          }, i.ptm("colorBackground")), [f("div", ke({
            ref: s.colorHandleRef,
            class: i.cx("colorHandle")
          }, i.ptm("colorHandle")), null, 16)], 16)], 16), f("div", ke({
            ref: s.hueViewRef,
            class: i.cx("hue"),
            onMousedown: e[7] || (e[7] = function(l) {
              return s.onHueMousedown(l);
            }),
            onTouchstart: e[8] || (e[8] = function(l) {
              return s.onHueDragStart(l);
            }),
            onTouchmove: e[9] || (e[9] = function(l) {
              return s.onDrag(l);
            }),
            onTouchend: e[10] || (e[10] = function(l) {
              return s.onDragEnd();
            })
          }, i.ptm("hue")), [f("div", ke({
            ref: s.hueHandleRef,
            class: i.cx("hueHandle")
          }, i.ptm("hueHandle")), null, 16)], 16)], 16)], 16)) : ve("", !0)];
        }),
        _: 1
      }, 16, ["onEnter", "onLeave", "onAfterLeave"])];
    }),
    _: 1
  }, 8, ["appendTo", "disabled"])], 16);
}
U1.render = wN;
var W1 = {
  name: "WindowMaximizeIcon",
  extends: kr
};
function _N(i) {
  return kN(i) || CN(i) || SN(i) || xN();
}
function xN() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function SN(i, e) {
  if (i) {
    if (typeof i == "string") return xf(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? xf(i, e) : void 0;
  }
}
function CN(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function kN(i) {
  if (Array.isArray(i)) return xf(i);
}
function xf(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function ON(i, e, n, r, o, s) {
  return $(), A("svg", ke({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i.pti()), _N(e[0] || (e[0] = [f("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14ZM9.77805 7.42192C9.89013 7.534 10.0415 7.59788 10.2 7.59995C10.3585 7.59788 10.5099 7.534 10.622 7.42192C10.7341 7.30985 10.798 7.15844 10.8 6.99995V3.94242C10.8066 3.90505 10.8096 3.86689 10.8089 3.82843C10.8079 3.77159 10.7988 3.7157 10.7824 3.6623C10.756 3.55552 10.701 3.45698 10.622 3.37798C10.5099 3.2659 10.3585 3.20202 10.2 3.19995H7.00002C6.84089 3.19995 6.68828 3.26317 6.57576 3.37569C6.46324 3.48821 6.40002 3.64082 6.40002 3.79995C6.40002 3.95908 6.46324 4.11169 6.57576 4.22422C6.68828 4.33674 6.84089 4.39995 7.00002 4.39995H8.80006L6.19997 7.00005C6.10158 7.11005 6.04718 7.25246 6.04718 7.40005C6.04718 7.54763 6.10158 7.69004 6.19997 7.80005C6.30202 7.91645 6.44561 7.98824 6.59997 8.00005C6.75432 7.98824 6.89791 7.91645 6.99997 7.80005L9.60002 5.26841V6.99995C9.6021 7.15844 9.66598 7.30985 9.77805 7.42192ZM1.4 14H3.8C4.17066 13.9979 4.52553 13.8498 4.78763 13.5877C5.04973 13.3256 5.1979 12.9707 5.2 12.6V10.2C5.1979 9.82939 5.04973 9.47452 4.78763 9.21242C4.52553 8.95032 4.17066 8.80215 3.8 8.80005H1.4C1.02934 8.80215 0.674468 8.95032 0.412371 9.21242C0.150274 9.47452 0.00210008 9.82939 0 10.2V12.6C0.00210008 12.9707 0.150274 13.3256 0.412371 13.5877C0.674468 13.8498 1.02934 13.9979 1.4 14ZM1.25858 10.0586C1.29609 10.0211 1.34696 10 1.4 10H3.8C3.85304 10 3.90391 10.0211 3.94142 10.0586C3.97893 10.0961 4 10.147 4 10.2V12.6C4 12.6531 3.97893 12.704 3.94142 12.7415C3.90391 12.779 3.85304 12.8 3.8 12.8H1.4C1.34696 12.8 1.29609 12.779 1.25858 12.7415C1.22107 12.704 1.2 12.6531 1.2 12.6V10.2C1.2 10.147 1.22107 10.0961 1.25858 10.0586Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
W1.render = ON;
var G1 = {
  name: "WindowMinimizeIcon",
  extends: kr
};
function EN(i) {
  return MN(i) || $N(i) || DN(i) || TN();
}
function TN() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function DN(i, e) {
  if (i) {
    if (typeof i == "string") return Sf(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Sf(i, e) : void 0;
  }
}
function $N(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function MN(i) {
  if (Array.isArray(i)) return Sf(i);
}
function Sf(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function PN(i, e, n, r, o, s) {
  return $(), A("svg", ke({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, i.pti()), EN(e[0] || (e[0] = [f("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0ZM6.368 7.952C6.44137 7.98326 6.52025 7.99958 6.6 8H9.8C9.95913 8 10.1117 7.93678 10.2243 7.82426C10.3368 7.71174 10.4 7.55913 10.4 7.4C10.4 7.24087 10.3368 7.08826 10.2243 6.97574C10.1117 6.86321 9.95913 6.8 9.8 6.8H8.048L10.624 4.224C10.73 4.11026 10.7877 3.95982 10.7849 3.80438C10.7822 3.64894 10.7192 3.50063 10.6093 3.3907C10.4994 3.28077 10.3511 3.2178 10.1956 3.21506C10.0402 3.21232 9.88974 3.27002 9.776 3.376L7.2 5.952V4.2C7.2 4.04087 7.13679 3.88826 7.02426 3.77574C6.91174 3.66321 6.75913 3.6 6.6 3.6C6.44087 3.6 6.28826 3.66321 6.17574 3.77574C6.06321 3.88826 6 4.04087 6 4.2V7.4C6.00042 7.47975 6.01674 7.55862 6.048 7.632C6.07656 7.70442 6.11971 7.7702 6.17475 7.82524C6.2298 7.88029 6.29558 7.92344 6.368 7.952ZM1.4 8.80005H3.8C4.17066 8.80215 4.52553 8.95032 4.78763 9.21242C5.04973 9.47452 5.1979 9.82939 5.2 10.2V12.6C5.1979 12.9707 5.04973 13.3256 4.78763 13.5877C4.52553 13.8498 4.17066 13.9979 3.8 14H1.4C1.02934 13.9979 0.674468 13.8498 0.412371 13.5877C0.150274 13.3256 0.00210008 12.9707 0 12.6V10.2C0.00210008 9.82939 0.150274 9.47452 0.412371 9.21242C0.674468 8.95032 1.02934 8.80215 1.4 8.80005ZM3.94142 12.7415C3.97893 12.704 4 12.6531 4 12.6V10.2C4 10.147 3.97893 10.0961 3.94142 10.0586C3.90391 10.0211 3.85304 10 3.8 10H1.4C1.34696 10 1.29609 10.0211 1.25858 10.0586C1.22107 10.0961 1.2 10.147 1.2 10.2V12.6C1.2 12.6531 1.22107 12.704 1.25858 12.7415C1.29609 12.779 1.34696 12.8 1.4 12.8H3.8C3.85304 12.8 3.90391 12.779 3.94142 12.7415Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
G1.render = PN;
var IN = bt.extend({
  name: "focustrap-directive"
}), LN = rt.extend({
  style: IN
});
function ql(i) {
  "@babel/helpers - typeof";
  return ql = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ql(i);
}
function Gv(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xv(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Gv(Object(n), !0).forEach(function(r) {
      AN(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : Gv(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function AN(i, e, n) {
  return (e = VN(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function VN(i) {
  var e = FN(i, "string");
  return ql(e) == "symbol" ? e : e + "";
}
function FN(i, e) {
  if (ql(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (ql(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var jN = LN.extend("focustrap", {
  mounted: function(e, n) {
    var r = n.value || {}, o = r.disabled;
    o || (this.createHiddenFocusableElements(e, n), this.bind(e, n), this.autoElementFocus(e, n)), e.setAttribute("data-pd-focustrap", !0), this.$el = e;
  },
  updated: function(e, n) {
    var r = n.value || {}, o = r.disabled;
    o && this.unbind(e);
  },
  unmounted: function(e) {
    this.unbind(e);
  },
  methods: {
    getComputedSelector: function(e) {
      return ':not(.p-hidden-focusable):not([data-p-hidden-focusable="true"])'.concat(e ?? "");
    },
    bind: function(e, n) {
      var r = this, o = n.value || {}, s = o.onFocusIn, a = o.onFocusOut;
      e.$_pfocustrap_mutationobserver = new MutationObserver(function(l) {
        l.forEach(function(u) {
          if (u.type === "childList" && !e.contains(document.activeElement)) {
            var c = function(h) {
              var p = Xm(h) ? Xm(h, r.getComputedSelector(e.$_pfocustrap_focusableselector)) ? h : Zs(e, r.getComputedSelector(e.$_pfocustrap_focusableselector)) : Zs(h);
              return gt(p) ? p : h.nextSibling && c(h.nextSibling);
            };
            Yn(c(u.nextSibling));
          }
        });
      }), e.$_pfocustrap_mutationobserver.disconnect(), e.$_pfocustrap_mutationobserver.observe(e, {
        childList: !0
      }), e.$_pfocustrap_focusinlistener = function(l) {
        return s && s(l);
      }, e.$_pfocustrap_focusoutlistener = function(l) {
        return a && a(l);
      }, e.addEventListener("focusin", e.$_pfocustrap_focusinlistener), e.addEventListener("focusout", e.$_pfocustrap_focusoutlistener);
    },
    unbind: function(e) {
      e.$_pfocustrap_mutationobserver && e.$_pfocustrap_mutationobserver.disconnect(), e.$_pfocustrap_focusinlistener && e.removeEventListener("focusin", e.$_pfocustrap_focusinlistener) && (e.$_pfocustrap_focusinlistener = null), e.$_pfocustrap_focusoutlistener && e.removeEventListener("focusout", e.$_pfocustrap_focusoutlistener) && (e.$_pfocustrap_focusoutlistener = null);
    },
    autoFocus: function(e) {
      this.autoElementFocus(this.$el, {
        value: Xv(Xv({}, e), {}, {
          autoFocus: !0
        })
      });
    },
    autoElementFocus: function(e, n) {
      var r = n.value || {}, o = r.autoFocusSelector, s = o === void 0 ? "" : o, a = r.firstFocusableSelector, l = a === void 0 ? "" : a, u = r.autoFocus, c = u === void 0 ? !1 : u, d = Zs(e, "[autofocus]".concat(this.getComputedSelector(s)));
      c && !d && (d = Zs(e, this.getComputedSelector(l))), Yn(d);
    },
    onFirstHiddenElementFocus: function(e) {
      var n, r = e.currentTarget, o = e.relatedTarget, s = o === r.$_pfocustrap_lasthiddenfocusableelement || !((n = this.$el) !== null && n !== void 0 && n.contains(o)) ? Zs(r.parentElement, this.getComputedSelector(r.$_pfocustrap_focusableselector)) : r.$_pfocustrap_lasthiddenfocusableelement;
      Yn(s);
    },
    onLastHiddenElementFocus: function(e) {
      var n, r = e.currentTarget, o = e.relatedTarget, s = o === r.$_pfocustrap_firsthiddenfocusableelement || !((n = this.$el) !== null && n !== void 0 && n.contains(o)) ? Q0(r.parentElement, this.getComputedSelector(r.$_pfocustrap_focusableselector)) : r.$_pfocustrap_firsthiddenfocusableelement;
      Yn(s);
    },
    createHiddenFocusableElements: function(e, n) {
      var r = this, o = n.value || {}, s = o.tabIndex, a = s === void 0 ? 0 : s, l = o.firstFocusableSelector, u = l === void 0 ? "" : l, c = o.lastFocusableSelector, d = c === void 0 ? "" : c, h = function(y) {
        return cl("span", {
          class: "p-hidden-accessible p-hidden-focusable",
          tabIndex: a,
          role: "presentation",
          "aria-hidden": !0,
          "data-p-hidden-accessible": !0,
          "data-p-hidden-focusable": !0,
          onFocus: y == null ? void 0 : y.bind(r)
        });
      }, p = h(this.onFirstHiddenElementFocus), m = h(this.onLastHiddenElementFocus);
      p.$_pfocustrap_lasthiddenfocusableelement = m, p.$_pfocustrap_focusableselector = u, p.setAttribute("data-pc-section", "firstfocusableelement"), m.$_pfocustrap_firsthiddenfocusableelement = p, m.$_pfocustrap_focusableselector = d, m.setAttribute("data-pc-section", "lastfocusableelement"), e.prepend(p), e.append(m);
    }
  }
});
function Yv() {
  mC({
    variableName: cb("scrollbar.width").name
  });
}
function Kv() {
  gC({
    variableName: cb("scrollbar.width").name
  });
}
var RN = `
    .p-dialog {
        max-height: 90%;
        transform: scale(1);
        border-radius: dt('dialog.border.radius');
        box-shadow: dt('dialog.shadow');
        background: dt('dialog.background');
        border: 1px solid dt('dialog.border.color');
        color: dt('dialog.color');
        will-change: transform;
    }

    .p-dialog-content {
        overflow-y: auto;
        padding: dt('dialog.content.padding');
    }

    .p-dialog-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-shrink: 0;
        padding: dt('dialog.header.padding');
    }

    .p-dialog-title {
        font-weight: dt('dialog.title.font.weight');
        font-size: dt('dialog.title.font.size');
    }

    .p-dialog-footer {
        flex-shrink: 0;
        padding: dt('dialog.footer.padding');
        display: flex;
        justify-content: flex-end;
        gap: dt('dialog.footer.gap');
    }

    .p-dialog-header-actions {
        display: flex;
        align-items: center;
        gap: dt('dialog.header.gap');
    }

    .p-dialog-top .p-dialog,
    .p-dialog-bottom .p-dialog,
    .p-dialog-left .p-dialog,
    .p-dialog-right .p-dialog,
    .p-dialog-topleft .p-dialog,
    .p-dialog-topright .p-dialog,
    .p-dialog-bottomleft .p-dialog,
    .p-dialog-bottomright .p-dialog {
        margin: 1rem;
    }

    .p-dialog-maximized {
        width: 100vw !important;
        height: 100vh !important;
        top: 0px !important;
        left: 0px !important;
        max-height: 100%;
        height: 100%;
        border-radius: 0;
    }

    .p-dialog-maximized .p-dialog-content {
        flex-grow: 1;
    }

    .p-dialog .p-resizable-handle {
        position: absolute;
        font-size: 0.1px;
        display: block;
        cursor: se-resize;
        width: 12px;
        height: 12px;
        right: 1px;
        bottom: 1px;
    }

    .p-dialog-enter-active {
        animation: p-animate-dialog-enter 300ms cubic-bezier(.19,1,.22,1);
    }

    .p-dialog-leave-active {
        animation: p-animate-dialog-leave 300ms cubic-bezier(.19,1,.22,1);
    }

    @keyframes p-animate-dialog-enter {
        from {
            opacity: 0;
            transform: scale(0.93);
        }
    }

    @keyframes p-animate-dialog-leave {
        to {
            opacity: 0;
            transform: scale(0.93);
        }
    }
`, NN = {
  mask: function(e) {
    var n = e.position, r = e.modal;
    return {
      position: "fixed",
      height: "100%",
      width: "100%",
      left: 0,
      top: 0,
      display: "flex",
      justifyContent: n === "left" || n === "topleft" || n === "bottomleft" ? "flex-start" : n === "right" || n === "topright" || n === "bottomright" ? "flex-end" : "center",
      alignItems: n === "top" || n === "topleft" || n === "topright" ? "flex-start" : n === "bottom" || n === "bottomleft" || n === "bottomright" ? "flex-end" : "center",
      pointerEvents: r ? "auto" : "none"
    };
  },
  root: {
    display: "flex",
    flexDirection: "column",
    pointerEvents: "auto"
  }
}, zN = {
  mask: function(e) {
    var n = e.props, r = ["left", "right", "top", "topleft", "topright", "bottom", "bottomleft", "bottomright"], o = r.find(function(s) {
      return s === n.position;
    });
    return ["p-dialog-mask", {
      "p-overlay-mask p-overlay-mask-enter-active": n.modal
    }, o ? "p-dialog-".concat(o) : ""];
  },
  root: function(e) {
    var n = e.props, r = e.instance;
    return ["p-dialog p-component", {
      "p-dialog-maximized": n.maximizable && r.maximized
    }];
  },
  header: "p-dialog-header",
  title: "p-dialog-title",
  headerActions: "p-dialog-header-actions",
  pcMaximizeButton: "p-dialog-maximize-button",
  pcCloseButton: "p-dialog-close-button",
  content: "p-dialog-content",
  footer: "p-dialog-footer"
}, BN = bt.extend({
  name: "dialog",
  style: RN,
  classes: zN,
  inlineStyles: NN
}), HN = {
  name: "BaseDialog",
  extends: Ho,
  props: {
    header: {
      type: null,
      default: null
    },
    footer: {
      type: null,
      default: null
    },
    visible: {
      type: Boolean,
      default: !1
    },
    modal: {
      type: Boolean,
      default: null
    },
    contentStyle: {
      type: null,
      default: null
    },
    contentClass: {
      type: String,
      default: null
    },
    contentProps: {
      type: null,
      default: null
    },
    maximizable: {
      type: Boolean,
      default: !1
    },
    dismissableMask: {
      type: Boolean,
      default: !1
    },
    closable: {
      type: Boolean,
      default: !0
    },
    closeOnEscape: {
      type: Boolean,
      default: !0
    },
    showHeader: {
      type: Boolean,
      default: !0
    },
    blockScroll: {
      type: Boolean,
      default: !1
    },
    baseZIndex: {
      type: Number,
      default: 0
    },
    autoZIndex: {
      type: Boolean,
      default: !0
    },
    position: {
      type: String,
      default: "center"
    },
    breakpoints: {
      type: Object,
      default: null
    },
    draggable: {
      type: Boolean,
      default: !0
    },
    keepInViewport: {
      type: Boolean,
      default: !0
    },
    minX: {
      type: Number,
      default: 0
    },
    minY: {
      type: Number,
      default: 0
    },
    appendTo: {
      type: [String, Object],
      default: "body"
    },
    closeIcon: {
      type: String,
      default: void 0
    },
    maximizeIcon: {
      type: String,
      default: void 0
    },
    minimizeIcon: {
      type: String,
      default: void 0
    },
    closeButtonProps: {
      type: Object,
      default: function() {
        return {
          severity: "secondary",
          text: !0,
          rounded: !0
        };
      }
    },
    maximizeButtonProps: {
      type: Object,
      default: function() {
        return {
          severity: "secondary",
          text: !0,
          rounded: !0
        };
      }
    },
    _instance: null
  },
  style: BN,
  provide: function() {
    return {
      $pcDialog: this,
      $parentInstance: this
    };
  }
}, X1 = {
  name: "Dialog",
  extends: HN,
  inheritAttrs: !1,
  emits: ["update:visible", "show", "hide", "after-hide", "maximize", "unmaximize", "dragstart", "dragend"],
  provide: function() {
    var e = this;
    return {
      dialogRef: Ee(function() {
        return e._instance;
      })
    };
  },
  data: function() {
    return {
      containerVisible: this.visible,
      maximized: !1,
      focusableMax: null,
      focusableClose: null,
      target: null
    };
  },
  documentKeydownListener: null,
  container: null,
  mask: null,
  content: null,
  headerContainer: null,
  footerContainer: null,
  maximizableButton: null,
  closeButton: null,
  styleElement: null,
  dragging: null,
  documentDragListener: null,
  documentDragEndListener: null,
  lastPageX: null,
  lastPageY: null,
  maskMouseDownTarget: null,
  updated: function() {
    this.visible && (this.containerVisible = this.visible);
  },
  beforeUnmount: function() {
    this.unbindDocumentState(), this.unbindGlobalListeners(), this.destroyStyle(), this.mask && this.autoZIndex && Ui.clear(this.mask), this.container = null, this.mask = null;
  },
  mounted: function() {
    this.breakpoints && this.createStyle();
  },
  methods: {
    close: function() {
      this.$emit("update:visible", !1);
    },
    onEnter: function() {
      this.$emit("show"), this.target = document.activeElement, this.enableDocumentSettings(), this.bindGlobalListeners(), this.autoZIndex && Ui.set("modal", this.mask, this.baseZIndex + this.$primevue.config.zIndex.modal);
    },
    onAfterEnter: function() {
      this.focus();
    },
    onBeforeLeave: function() {
      this.modal && !this.isUnstyled && Ms(this.mask, "p-overlay-mask-leave-active"), this.dragging && this.documentDragEndListener && this.documentDragEndListener();
    },
    onLeave: function() {
      this.$emit("hide"), Yn(this.target), this.target = null, this.focusableClose = null, this.focusableMax = null;
    },
    onAfterLeave: function() {
      this.autoZIndex && Ui.clear(this.mask), this.containerVisible = !1, this.unbindDocumentState(), this.unbindGlobalListeners(), this.$emit("after-hide");
    },
    onMaskMouseDown: function(e) {
      this.maskMouseDownTarget = e.target;
    },
    onMaskMouseUp: function() {
      this.dismissableMask && this.modal && this.mask === this.maskMouseDownTarget && this.close();
    },
    focus: function() {
      var e = function(o) {
        return o && o.querySelector("[autofocus]");
      }, n = this.$slots.footer && e(this.footerContainer);
      n || (n = this.$slots.header && e(this.headerContainer), n || (n = this.$slots.default && e(this.content), n || (this.maximizable ? (this.focusableMax = !0, n = this.maximizableButton) : (this.focusableClose = !0, n = this.closeButton)))), n && Yn(n, {
        focusVisible: !0
      });
    },
    maximize: function(e) {
      this.maximized ? (this.maximized = !1, this.$emit("unmaximize", e)) : (this.maximized = !0, this.$emit("maximize", e)), this.modal || (this.maximized ? Yv() : Kv());
    },
    enableDocumentSettings: function() {
      (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) && Yv();
    },
    unbindDocumentState: function() {
      (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) && Kv();
    },
    onKeyDown: function(e) {
      e.code === "Escape" && this.closeOnEscape && this.close();
    },
    bindDocumentKeyDownListener: function() {
      this.documentKeydownListener || (this.documentKeydownListener = this.onKeyDown.bind(this), window.document.addEventListener("keydown", this.documentKeydownListener));
    },
    unbindDocumentKeyDownListener: function() {
      this.documentKeydownListener && (window.document.removeEventListener("keydown", this.documentKeydownListener), this.documentKeydownListener = null);
    },
    containerRef: function(e) {
      this.container = e;
    },
    maskRef: function(e) {
      this.mask = e;
    },
    contentRef: function(e) {
      this.content = e;
    },
    headerContainerRef: function(e) {
      this.headerContainer = e;
    },
    footerContainerRef: function(e) {
      this.footerContainer = e;
    },
    maximizableRef: function(e) {
      this.maximizableButton = e ? e.$el : void 0;
    },
    closeButtonRef: function(e) {
      this.closeButton = e ? e.$el : void 0;
    },
    createStyle: function() {
      if (!this.styleElement && !this.isUnstyled) {
        var e;
        this.styleElement = document.createElement("style"), this.styleElement.type = "text/css", nb(this.styleElement, "nonce", (e = this.$primevue) === null || e === void 0 || (e = e.config) === null || e === void 0 || (e = e.csp) === null || e === void 0 ? void 0 : e.nonce), document.head.appendChild(this.styleElement);
        var n = "";
        for (var r in this.breakpoints)
          n += `
                        @media screen and (max-width: `.concat(r, `) {
                            .p-dialog[`).concat(this.$attrSelector, `] {
                                width: `).concat(this.breakpoints[r], ` !important;
                            }
                        }
                    `);
        this.styleElement.innerHTML = n;
      }
    },
    destroyStyle: function() {
      this.styleElement && (document.head.removeChild(this.styleElement), this.styleElement = null);
    },
    initDrag: function(e) {
      e.target.closest("div").getAttribute("data-pc-section") !== "headeractions" && this.draggable && (this.dragging = !0, this.lastPageX = e.pageX, this.lastPageY = e.pageY, this.container.style.margin = "0", document.body.setAttribute("data-p-unselectable-text", "true"), !this.isUnstyled && K0(document.body, {
        "user-select": "none"
      }), this.$emit("dragstart", e));
    },
    bindGlobalListeners: function() {
      this.draggable && (this.bindDocumentDragListener(), this.bindDocumentDragEndListener()), this.closeOnEscape && this.bindDocumentKeyDownListener();
    },
    unbindGlobalListeners: function() {
      this.unbindDocumentDragListener(), this.unbindDocumentDragEndListener(), this.unbindDocumentKeyDownListener();
    },
    bindDocumentDragListener: function() {
      var e = this;
      this.documentDragListener = function(n) {
        if (e.dragging) {
          var r = dr(e.container), o = Nr(e.container), s = n.pageX - e.lastPageX, a = n.pageY - e.lastPageY, l = e.container.getBoundingClientRect(), u = l.left + s, c = l.top + a, d = ca(), h = getComputedStyle(e.container), p = parseFloat(h.marginLeft), m = parseFloat(h.marginTop);
          e.container.style.position = "fixed", e.keepInViewport ? (u >= e.minX && u + r < d.width && (e.lastPageX = n.pageX, e.container.style.left = u - p + "px"), c >= e.minY && c + o < d.height && (e.lastPageY = n.pageY, e.container.style.top = c - m + "px")) : (e.lastPageX = n.pageX, e.container.style.left = u - p + "px", e.lastPageY = n.pageY, e.container.style.top = c - m + "px");
        }
      }, window.document.addEventListener("mousemove", this.documentDragListener);
    },
    unbindDocumentDragListener: function() {
      this.documentDragListener && (window.document.removeEventListener("mousemove", this.documentDragListener), this.documentDragListener = null);
    },
    bindDocumentDragEndListener: function() {
      var e = this;
      this.documentDragEndListener = function(n) {
        e.dragging && (e.dragging = !1, document.body.removeAttribute("data-p-unselectable-text"), !e.isUnstyled && (document.body.style["user-select"] = ""), e.$emit("dragend", n));
      }, window.document.addEventListener("mouseup", this.documentDragEndListener);
    },
    unbindDocumentDragEndListener: function() {
      this.documentDragEndListener && (window.document.removeEventListener("mouseup", this.documentDragEndListener), this.documentDragEndListener = null);
    }
  },
  computed: {
    maximizeIconComponent: function() {
      return this.maximized ? this.minimizeIcon ? "span" : "WindowMinimizeIcon" : this.maximizeIcon ? "span" : "WindowMaximizeIcon";
    },
    ariaLabelledById: function() {
      return this.header != null || this.$attrs["aria-labelledby"] !== null ? this.$id + "_header" : null;
    },
    closeAriaLabel: function() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    },
    dataP: function() {
      return ui({
        maximized: this.maximized,
        modal: this.modal
      });
    }
  },
  directives: {
    ripple: Sp,
    focustrap: jN
  },
  components: {
    Button: Cp,
    Portal: Td,
    WindowMinimizeIcon: G1,
    WindowMaximizeIcon: W1,
    TimesIcon: Od
  }
};
function Zl(i) {
  "@babel/helpers - typeof";
  return Zl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Zl(i);
}
function qv(i, e) {
  var n = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(i, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zv(i) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? qv(Object(n), !0).forEach(function(r) {
      UN(i, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : qv(Object(n)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return i;
}
function UN(i, e, n) {
  return (e = WN(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function WN(i) {
  var e = GN(i, "string");
  return Zl(e) == "symbol" ? e : e + "";
}
function GN(i, e) {
  if (Zl(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Zl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
var XN = ["data-p"], YN = ["aria-labelledby", "aria-modal", "data-p"], KN = ["id"], qN = ["data-p"];
function ZN(i, e, n, r, o, s) {
  var a = Tn("Button"), l = Tn("Portal"), u = Vf("focustrap");
  return $(), st(l, {
    appendTo: i.appendTo
  }, {
    default: Wt(function() {
      return [o.containerVisible ? ($(), A("div", ke({
        key: 0,
        ref: s.maskRef,
        class: i.cx("mask"),
        style: i.sx("mask", !0, {
          position: i.position,
          modal: i.modal
        }),
        onMousedown: e[1] || (e[1] = function() {
          return s.onMaskMouseDown && s.onMaskMouseDown.apply(s, arguments);
        }),
        onMouseup: e[2] || (e[2] = function() {
          return s.onMaskMouseUp && s.onMaskMouseUp.apply(s, arguments);
        }),
        "data-p": s.dataP
      }, i.ptm("mask")), [Ve(Uf, ke({
        name: "p-dialog",
        onEnter: s.onEnter,
        onAfterEnter: s.onAfterEnter,
        onBeforeLeave: s.onBeforeLeave,
        onLeave: s.onLeave,
        onAfterLeave: s.onAfterLeave,
        appear: ""
      }, i.ptm("transition")), {
        default: Wt(function() {
          return [i.visible ? ot(($(), A("div", ke({
            key: 0,
            ref: s.containerRef,
            class: i.cx("root"),
            style: i.sx("root"),
            role: "dialog",
            "aria-labelledby": s.ariaLabelledById,
            "aria-modal": i.modal,
            "data-p": s.dataP
          }, i.ptmi("root")), [i.$slots.container ? it(i.$slots, "container", {
            key: 0,
            closeCallback: s.close,
            maximizeCallback: function(d) {
              return s.maximize(d);
            },
            initDragCallback: s.initDrag
          }) : ($(), A(Fe, {
            key: 1
          }, [i.showHeader ? ($(), A("div", ke({
            key: 0,
            ref: s.headerContainerRef,
            class: i.cx("header"),
            onMousedown: e[0] || (e[0] = function() {
              return s.initDrag && s.initDrag.apply(s, arguments);
            })
          }, i.ptm("header")), [it(i.$slots, "header", {
            class: _e(i.cx("title"))
          }, function() {
            return [i.header ? ($(), A("span", ke({
              key: 0,
              id: s.ariaLabelledById,
              class: i.cx("title")
            }, i.ptm("title")), Q(i.header), 17, KN)) : ve("", !0)];
          }), f("div", ke({
            class: i.cx("headerActions")
          }, i.ptm("headerActions")), [i.maximizable ? it(i.$slots, "maximizebutton", {
            key: 0,
            maximized: o.maximized,
            maximizeCallback: function(d) {
              return s.maximize(d);
            }
          }, function() {
            return [Ve(a, ke({
              ref: s.maximizableRef,
              autofocus: o.focusableMax,
              class: i.cx("pcMaximizeButton"),
              onClick: s.maximize,
              tabindex: i.maximizable ? "0" : "-1",
              unstyled: i.unstyled
            }, i.maximizeButtonProps, {
              pt: i.ptm("pcMaximizeButton"),
              "data-pc-group-section": "headericon"
            }), {
              icon: Wt(function(c) {
                return [it(i.$slots, "maximizeicon", {
                  maximized: o.maximized
                }, function() {
                  return [($(), st(vr(s.maximizeIconComponent), ke({
                    class: [c.class, o.maximized ? i.minimizeIcon : i.maximizeIcon]
                  }, i.ptm("pcMaximizeButton").icon), null, 16, ["class"]))];
                })];
              }),
              _: 3
            }, 16, ["autofocus", "class", "onClick", "tabindex", "unstyled", "pt"])];
          }) : ve("", !0), i.closable ? it(i.$slots, "closebutton", {
            key: 1,
            closeCallback: s.close
          }, function() {
            return [Ve(a, ke({
              ref: s.closeButtonRef,
              autofocus: o.focusableClose,
              class: i.cx("pcCloseButton"),
              onClick: s.close,
              "aria-label": s.closeAriaLabel,
              unstyled: i.unstyled
            }, i.closeButtonProps, {
              pt: i.ptm("pcCloseButton"),
              "data-pc-group-section": "headericon"
            }), {
              icon: Wt(function(c) {
                return [it(i.$slots, "closeicon", {}, function() {
                  return [($(), st(vr(i.closeIcon ? "span" : "TimesIcon"), ke({
                    class: [i.closeIcon, c.class]
                  }, i.ptm("pcCloseButton").icon), null, 16, ["class"]))];
                })];
              }),
              _: 3
            }, 16, ["autofocus", "class", "onClick", "aria-label", "unstyled", "pt"])];
          }) : ve("", !0)], 16)], 16)) : ve("", !0), f("div", ke({
            ref: s.contentRef,
            class: [i.cx("content"), i.contentClass],
            style: i.contentStyle,
            "data-p": s.dataP
          }, Zv(Zv({}, i.contentProps), i.ptm("content"))), [it(i.$slots, "default")], 16, qN), i.footer || i.$slots.footer ? ($(), A("div", ke({
            key: 1,
            ref: s.footerContainerRef,
            class: i.cx("footer")
          }, i.ptm("footer")), [it(i.$slots, "footer", {}, function() {
            return [vt(Q(i.footer), 1)];
          })], 16)) : ve("", !0)], 64))], 16, YN)), [[u, {
            disabled: !i.modal
          }]]) : ve("", !0)];
        }),
        _: 3
      }, 16, ["onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"])], 16, XN)) : ve("", !0)];
    }),
    _: 3
  }, 8, ["appendTo"]);
}
X1.render = ZN;
var JN = `
    .p-tooltip {
        position: absolute;
        display: none;
        max-width: dt('tooltip.max.width');
    }

    .p-tooltip-right,
    .p-tooltip-left {
        padding: 0 dt('tooltip.gutter');
    }

    .p-tooltip-top,
    .p-tooltip-bottom {
        padding: dt('tooltip.gutter') 0;
    }

    .p-tooltip-text {
        white-space: pre-line;
        word-break: break-word;
        background: dt('tooltip.background');
        color: dt('tooltip.color');
        padding: dt('tooltip.padding');
        box-shadow: dt('tooltip.shadow');
        border-radius: dt('tooltip.border.radius');
    }

    .p-tooltip-arrow {
        position: absolute;
        width: 0;
        height: 0;
        border-color: transparent;
        border-style: solid;
    }

    .p-tooltip-right .p-tooltip-arrow {
        margin-top: calc(-1 * dt('tooltip.gutter'));
        border-width: dt('tooltip.gutter') dt('tooltip.gutter') dt('tooltip.gutter') 0;
        border-right-color: dt('tooltip.background');
    }

    .p-tooltip-left .p-tooltip-arrow {
        margin-top: calc(-1 * dt('tooltip.gutter'));
        border-width: dt('tooltip.gutter') 0 dt('tooltip.gutter') dt('tooltip.gutter');
        border-left-color: dt('tooltip.background');
    }

    .p-tooltip-top .p-tooltip-arrow {
        margin-left: calc(-1 * dt('tooltip.gutter'));
        border-width: dt('tooltip.gutter') dt('tooltip.gutter') 0 dt('tooltip.gutter');
        border-top-color: dt('tooltip.background');
        border-bottom-color: dt('tooltip.background');
    }

    .p-tooltip-bottom .p-tooltip-arrow {
        margin-left: calc(-1 * dt('tooltip.gutter'));
        border-width: 0 dt('tooltip.gutter') dt('tooltip.gutter') dt('tooltip.gutter');
        border-top-color: dt('tooltip.background');
        border-bottom-color: dt('tooltip.background');
    }
`, QN = {
  root: "p-tooltip p-component",
  arrow: "p-tooltip-arrow",
  text: "p-tooltip-text"
}, e9 = bt.extend({
  name: "tooltip-directive",
  style: JN,
  classes: QN
}), t9 = rt.extend({
  style: e9
});
function n9(i, e) {
  return s9(i) || o9(i, e) || r9(i, e) || i9();
}
function i9() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function r9(i, e) {
  if (i) {
    if (typeof i == "string") return Jv(i, e);
    var n = {}.toString.call(i).slice(8, -1);
    return n === "Object" && i.constructor && (n = i.constructor.name), n === "Map" || n === "Set" ? Array.from(i) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Jv(i, e) : void 0;
  }
}
function Jv(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = i[n];
  return r;
}
function o9(i, e) {
  var n = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (n != null) {
    var r, o, s, a, l = [], u = !0, c = !1;
    try {
      if (s = (n = n.call(i)).next, e !== 0) for (; !(u = (r = s.call(n)).done) && (l.push(r.value), l.length !== e); u = !0) ;
    } catch (d) {
      c = !0, o = d;
    } finally {
      try {
        if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return;
      } finally {
        if (c) throw o;
      }
    }
    return l;
  }
}
function s9(i) {
  if (Array.isArray(i)) return i;
}
function Qv(i, e, n) {
  return (e = a9(e)) in i ? Object.defineProperty(i, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = n, i;
}
function a9(i) {
  var e = l9(i, "string");
  return Fo(e) == "symbol" ? e : e + "";
}
function l9(i, e) {
  if (Fo(i) != "object" || !i) return i;
  var n = i[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(i, e);
    if (Fo(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
function Fo(i) {
  "@babel/helpers - typeof";
  return Fo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Fo(i);
}
var u9 = t9.extend("tooltip", {
  beforeMount: function(e, n) {
    var r, o = this.getTarget(e);
    if (o.$_ptooltipModifiers = this.getModifiers(n), n.value) {
      if (typeof n.value == "string")
        o.$_ptooltipValue = n.value, o.$_ptooltipDisabled = !1, o.$_ptooltipEscape = !0, o.$_ptooltipClass = null, o.$_ptooltipFitContent = !0, o.$_ptooltipIdAttr = Za("pv_id") + "_tooltip", o.$_ptooltipShowDelay = 0, o.$_ptooltipHideDelay = 0, o.$_ptooltipAutoHide = !0;
      else if (Fo(n.value) === "object" && n.value) {
        if (Ji(n.value.value) || n.value.value.trim() === "") return;
        o.$_ptooltipValue = n.value.value, o.$_ptooltipDisabled = !!n.value.disabled === n.value.disabled ? n.value.disabled : !1, o.$_ptooltipEscape = !!n.value.escape === n.value.escape ? n.value.escape : !0, o.$_ptooltipClass = n.value.class || "", o.$_ptooltipFitContent = !!n.value.fitContent === n.value.fitContent ? n.value.fitContent : !0, o.$_ptooltipIdAttr = n.value.id || Za("pv_id") + "_tooltip", o.$_ptooltipShowDelay = n.value.showDelay || 0, o.$_ptooltipHideDelay = n.value.hideDelay || 0, o.$_ptooltipAutoHide = !!n.value.autoHide === n.value.autoHide ? n.value.autoHide : !0;
      }
    } else return;
    o.$_ptooltipZIndex = (r = n.instance.$primevue) === null || r === void 0 || (r = r.config) === null || r === void 0 || (r = r.zIndex) === null || r === void 0 ? void 0 : r.tooltip, this.bindEvents(o, n), e.setAttribute("data-pd-tooltip", !0);
  },
  updated: function(e, n) {
    var r = this.getTarget(e);
    if (r.$_ptooltipModifiers = this.getModifiers(n), this.unbindEvents(r), !!n.value) {
      if (typeof n.value == "string")
        r.$_ptooltipValue = n.value, r.$_ptooltipDisabled = !1, r.$_ptooltipEscape = !0, r.$_ptooltipClass = null, r.$_ptooltipIdAttr = r.$_ptooltipIdAttr || Za("pv_id") + "_tooltip", r.$_ptooltipShowDelay = 0, r.$_ptooltipHideDelay = 0, r.$_ptooltipAutoHide = !0, this.bindEvents(r, n);
      else if (Fo(n.value) === "object" && n.value)
        if (Ji(n.value.value) || n.value.value.trim() === "") {
          this.unbindEvents(r, n);
          return;
        } else
          r.$_ptooltipValue = n.value.value, r.$_ptooltipDisabled = !!n.value.disabled === n.value.disabled ? n.value.disabled : !1, r.$_ptooltipEscape = !!n.value.escape === n.value.escape ? n.value.escape : !0, r.$_ptooltipClass = n.value.class || "", r.$_ptooltipFitContent = !!n.value.fitContent === n.value.fitContent ? n.value.fitContent : !0, r.$_ptooltipIdAttr = n.value.id || r.$_ptooltipIdAttr || Za("pv_id") + "_tooltip", r.$_ptooltipShowDelay = n.value.showDelay || 0, r.$_ptooltipHideDelay = n.value.hideDelay || 0, r.$_ptooltipAutoHide = !!n.value.autoHide === n.value.autoHide ? n.value.autoHide : !0, this.bindEvents(r, n);
    }
  },
  unmounted: function(e, n) {
    var r = this.getTarget(e);
    this.hide(e, 0), this.remove(r), this.unbindEvents(r, n), r.$_ptooltipScrollHandler && (r.$_ptooltipScrollHandler.destroy(), r.$_ptooltipScrollHandler = null);
  },
  timer: void 0,
  methods: {
    bindEvents: function(e, n) {
      var r = this, o = e.$_ptooltipModifiers;
      o.focus ? (e.$_ptooltipFocusEvent = function(s) {
        return r.onFocus(s, n);
      }, e.$_ptooltipBlurEvent = this.onBlur.bind(this), e.addEventListener("focus", e.$_ptooltipFocusEvent), e.addEventListener("blur", e.$_ptooltipBlurEvent)) : (e.$_ptooltipMouseEnterEvent = function(s) {
        return r.onMouseEnter(s, n);
      }, e.$_ptooltipMouseLeaveEvent = this.onMouseLeave.bind(this), e.$_ptooltipClickEvent = this.onClick.bind(this), e.addEventListener("mouseenter", e.$_ptooltipMouseEnterEvent), e.addEventListener("mouseleave", e.$_ptooltipMouseLeaveEvent), e.addEventListener("click", e.$_ptooltipClickEvent)), e.$_ptooltipKeydownEvent = this.onKeydown.bind(this), e.addEventListener("keydown", e.$_ptooltipKeydownEvent), e.$_pWindowResizeEvent = this.onWindowResize.bind(this, e);
    },
    unbindEvents: function(e) {
      var n = e.$_ptooltipModifiers;
      n.focus ? (e.removeEventListener("focus", e.$_ptooltipFocusEvent), e.$_ptooltipFocusEvent = null, e.removeEventListener("blur", e.$_ptooltipBlurEvent), e.$_ptooltipBlurEvent = null) : (e.removeEventListener("mouseenter", e.$_ptooltipMouseEnterEvent), e.$_ptooltipMouseEnterEvent = null, e.removeEventListener("mouseleave", e.$_ptooltipMouseLeaveEvent), e.$_ptooltipMouseLeaveEvent = null, e.removeEventListener("click", e.$_ptooltipClickEvent), e.$_ptooltipClickEvent = null), e.removeEventListener("keydown", e.$_ptooltipKeydownEvent), window.removeEventListener("resize", e.$_pWindowResizeEvent), e.$_ptooltipId && this.remove(e);
    },
    bindScrollListener: function(e) {
      var n = this;
      e.$_ptooltipScrollHandler || (e.$_ptooltipScrollHandler = new Op(e, function() {
        n.hide(e);
      })), e.$_ptooltipScrollHandler.bindScrollListener();
    },
    unbindScrollListener: function(e) {
      e.$_ptooltipScrollHandler && e.$_ptooltipScrollHandler.unbindScrollListener();
    },
    onMouseEnter: function(e, n) {
      var r = e.currentTarget, o = r.$_ptooltipShowDelay;
      this.show(r, n, o);
    },
    onMouseLeave: function(e) {
      var n = e.currentTarget, r = n.$_ptooltipHideDelay, o = n.$_ptooltipAutoHide;
      if (o)
        this.hide(n, r);
      else {
        var s = To(e.target, "data-pc-name") === "tooltip" || To(e.target, "data-pc-section") === "arrow" || To(e.target, "data-pc-section") === "text" || To(e.relatedTarget, "data-pc-name") === "tooltip" || To(e.relatedTarget, "data-pc-section") === "arrow" || To(e.relatedTarget, "data-pc-section") === "text";
        !s && this.hide(n, r);
      }
    },
    onFocus: function(e, n) {
      var r = e.currentTarget, o = r.$_ptooltipShowDelay;
      this.show(r, n, o);
    },
    onBlur: function(e) {
      var n = e.currentTarget, r = n.$_ptooltipHideDelay;
      this.hide(n, r);
    },
    onClick: function(e) {
      var n = e.currentTarget, r = n.$_ptooltipHideDelay;
      this.hide(n, r);
    },
    onKeydown: function(e) {
      var n = e.currentTarget, r = n.$_ptooltipHideDelay;
      e.code === "Escape" && this.hide(e.currentTarget, r);
    },
    onWindowResize: function(e) {
      Jf() || this.hide(e), window.removeEventListener("resize", e.$_pWindowResizeEvent);
    },
    tooltipActions: function(e, n) {
      if (!(e.$_ptooltipDisabled || !J0(e) || !e.$_ptooltipPendingShow)) {
        e.$_ptooltipPendingShow = !1;
        var r = this.create(e, n);
        this.align(e), !this.isUnstyled() && yC(r, 250);
        var o = this;
        window.addEventListener("resize", e.$_pWindowResizeEvent), r.addEventListener("mouseleave", function s() {
          o.hide(e), r.removeEventListener("mouseleave", s), e.removeEventListener("mouseenter", e.$_ptooltipMouseEnterEvent), setTimeout(function() {
            return e.addEventListener("mouseenter", e.$_ptooltipMouseEnterEvent);
          }, 50);
        }), this.bindScrollListener(e), Ui.set("tooltip", r, e.$_ptooltipZIndex);
      }
    },
    show: function(e, n, r) {
      var o = this;
      r !== void 0 ? (this.timer = setTimeout(function() {
        return o.tooltipActions(e, n);
      }, r), e.$_ptooltipPendingShow = !0) : (this.tooltipActions(e, n), e.$_ptooltipPendingShow = !1);
    },
    tooltipRemoval: function(e) {
      this.remove(e), this.unbindScrollListener(e), window.removeEventListener("resize", e.$_pWindowResizeEvent);
    },
    hide: function(e, n) {
      var r = this;
      clearTimeout(this.timer), e.$_ptooltipPendingShow = !1, n !== void 0 ? setTimeout(function() {
        return r.tooltipRemoval(e);
      }, n) : this.tooltipRemoval(e);
    },
    getTooltipElement: function(e) {
      return document.getElementById(e.$_ptooltipId);
    },
    getArrowElement: function(e) {
      var n = this.getTooltipElement(e);
      return ba(n, '[data-pc-section="arrow"]');
    },
    create: function(e) {
      var n = e.$_ptooltipModifiers, r = cl("div", {
        class: !this.isUnstyled() && this.cx("arrow"),
        "p-bind": this.ptm("arrow", {
          context: n
        })
      }), o = cl("div", {
        class: !this.isUnstyled() && this.cx("text"),
        "p-bind": this.ptm("text", {
          context: n
        })
      });
      e.$_ptooltipEscape ? (o.innerHTML = "", o.appendChild(document.createTextNode(e.$_ptooltipValue))) : o.innerHTML = e.$_ptooltipValue;
      var s = cl("div", Qv(Qv({
        id: e.$_ptooltipIdAttr,
        role: "tooltip",
        style: {
          display: "inline-block",
          width: e.$_ptooltipFitContent ? "fit-content" : void 0,
          pointerEvents: !this.isUnstyled() && e.$_ptooltipAutoHide && "none"
        },
        class: [!this.isUnstyled() && this.cx("root"), e.$_ptooltipClass]
      }, this.$attrSelector, ""), "p-bind", this.ptm("root", {
        context: n
      })), r, o);
      return document.body.appendChild(s), e.$_ptooltipId = s.id, this.$el = s, s;
    },
    remove: function(e) {
      if (e) {
        var n = this.getTooltipElement(e);
        n && n.parentElement && (Ui.clear(n), document.body.removeChild(n)), e.$_ptooltipId = null;
      }
    },
    align: function(e) {
      var n = e.$_ptooltipModifiers;
      n.top ? (this.alignTop(e), this.isOutOfBounds(e) && (this.alignBottom(e), this.isOutOfBounds(e) && this.alignTop(e))) : n.left ? (this.alignLeft(e), this.isOutOfBounds(e) && (this.alignRight(e), this.isOutOfBounds(e) && (this.alignTop(e), this.isOutOfBounds(e) && (this.alignBottom(e), this.isOutOfBounds(e) && this.alignLeft(e))))) : n.bottom ? (this.alignBottom(e), this.isOutOfBounds(e) && (this.alignTop(e), this.isOutOfBounds(e) && this.alignBottom(e))) : (this.alignRight(e), this.isOutOfBounds(e) && (this.alignLeft(e), this.isOutOfBounds(e) && (this.alignTop(e), this.isOutOfBounds(e) && (this.alignBottom(e), this.isOutOfBounds(e) && this.alignRight(e)))));
    },
    getHostOffset: function(e) {
      var n = e.getBoundingClientRect(), r = n.left + Kf(), o = n.top + qf();
      return {
        left: r,
        top: o
      };
    },
    alignRight: function(e) {
      this.preAlign(e, "right");
      var n = this.getTooltipElement(e), r = this.getArrowElement(e), o = this.getHostOffset(e), s = o.left + dr(e), a = o.top + (Nr(e) - Nr(n)) / 2;
      n.style.left = s + "px", n.style.top = a + "px", r.style.top = "50%", r.style.right = null, r.style.bottom = null, r.style.left = "0";
    },
    alignLeft: function(e) {
      this.preAlign(e, "left");
      var n = this.getTooltipElement(e), r = this.getArrowElement(e), o = this.getHostOffset(e), s = o.left - dr(n), a = o.top + (Nr(e) - Nr(n)) / 2;
      n.style.left = s + "px", n.style.top = a + "px", r.style.top = "50%", r.style.right = "0", r.style.bottom = null, r.style.left = null;
    },
    alignTop: function(e) {
      this.preAlign(e, "top");
      var n = this.getTooltipElement(e), r = this.getArrowElement(e), o = dr(n), s = dr(e), a = ca(), l = a.width, u = this.getHostOffset(e), c = u.left + (s - o) / 2, d = u.top - Nr(n);
      c < 0 ? c = 0 : c + o > l && (c = Math.floor(u.left + s - o)), n.style.left = c + "px", n.style.top = d + "px";
      var h = u.left - this.getHostOffset(n).left + s / 2;
      r.style.top = null, r.style.right = null, r.style.bottom = "0", r.style.left = h + "px";
    },
    alignBottom: function(e) {
      this.preAlign(e, "bottom");
      var n = this.getTooltipElement(e), r = this.getArrowElement(e), o = dr(n), s = dr(e), a = ca(), l = a.width, u = this.getHostOffset(e), c = u.left + (s - o) / 2, d = u.top + Nr(e);
      c < 0 ? c = 0 : c + o > l && (c = Math.floor(u.left + s - o)), n.style.left = c + "px", n.style.top = d + "px";
      var h = u.left - this.getHostOffset(n).left + s / 2;
      r.style.top = "0", r.style.right = null, r.style.bottom = null, r.style.left = h + "px";
    },
    preAlign: function(e, n) {
      var r = this.getTooltipElement(e);
      r.style.left = "-999px", r.style.top = "-999px", Ss(r, "p-tooltip-".concat(r.$_ptooltipPosition)), !this.isUnstyled() && Ms(r, "p-tooltip-".concat(n)), r.$_ptooltipPosition = n, r.setAttribute("data-p-position", n);
    },
    isOutOfBounds: function(e) {
      var n = this.getTooltipElement(e), r = n.getBoundingClientRect(), o = r.top, s = r.left, a = dr(n), l = Nr(n), u = ca();
      return s + a > u.width || s < 0 || o < 0 || o + l > u.height;
    },
    getTarget: function(e) {
      var n;
      return W0(e, "p-inputwrapper") && (n = ba(e, "input")) !== null && n !== void 0 ? n : e;
    },
    getModifiers: function(e) {
      return e.modifiers && Object.keys(e.modifiers).length ? e.modifiers : e.arg && Fo(e.arg) === "object" ? Object.entries(e.arg).reduce(function(n, r) {
        var o = n9(r, 2), s = o[0], a = o[1];
        return (s === "event" || s === "position") && (n[a] = !0), n;
      }, {}) : {};
    }
  }
});
const c9 = () => {
  const i = document.createElement("link");
  i.rel = "stylesheet", i.href = "https://unpkg.com/primevue/resources/themes/lara-dark-blue/theme.css", document.head.appendChild(i);
  const e = document.createElement("link");
  e.rel = "stylesheet", e.href = "https://unpkg.com/primeicons/primeicons.css", document.head.appendChild(e);
};
c9();
const er = SS(UV), d9 = QS();
er.use(d9);
er.use(s2);
er.component("PButton", Cp);
er.component("PSlider", $1);
er.component("PDropdown", AR);
er.component("PInputText", Ed);
er.component("PInputNumber", H1);
er.component("PColorPicker", U1);
er.component("PDialog", X1);
er.directive("tooltip", u9);
const ey = document.getElementById("weyl-compositor-root");
ey ? er.mount(ey) : console.error("[Weyl] Could not find #weyl-compositor-root container");
window.addEventListener("weyl:inputs-ready", async (i) => {
  const e = i, { useCompositorStore: n } = await Promise.resolve().then(() => ik);
  n().loadInputs(e.detail);
});
window.addEventListener("weyl:keydown", async (i) => {
  console.log("[Weyl] Keydown:", i.detail);
});
console.log("[Weyl] Vue app mounted");
export {
  f9 as c,
  a2 as g
};
