/**
 * Property tests for ui/src/services/svgExport.ts
 * 
 * Tests: controlPointsToPathData, exportSplineLayerToSVG, 
 *        exportCompositionToSVG, exportSplineLayer, exportLayers
 * 
 * Audit: 2026-01-06
 */

import { describe, it, expect } from "vitest";
import * as fc from "fast-check";
import {
  controlPointsToPathData,
  exportSplineLayerToSVG,
  exportCompositionToSVG,
  exportSplineLayer,
  exportLayers,
  SVGExportService,
  type SVGExportOptions,
} from "@/services/svgExport";
import type { ControlPoint } from "@/types/spline";
import type { Layer } from "@/types/project";
import { createAnimatableProperty } from "@/types/animation";
import { createDefaultTransform } from "@/types/transform";

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//                                                              // arbitraries
// ═══════════════════════════════════════════════════════════════════════════

const controlPointArb: fc.Arbitrary<ControlPoint> = fc.record({
  id: fc.string({ minLength: 1 }),
  x: fc.float({ min: Math.fround(-1000), max: Math.fround(1000), noNaN: true }),
  y: fc.float({ min: Math.fround(-1000), max: Math.fround(1000), noNaN: true }),
  handleIn: fc.oneof(
    fc.constant(null),
    fc.record({
      x: fc.float({ min: Math.fround(-1000), max: Math.fround(1000), noNaN: true }),
      y: fc.float({ min: Math.fround(-1000), max: Math.fround(1000), noNaN: true }),
    })
  ),
  handleOut: fc.oneof(
    fc.constant(null),
    fc.record({
      x: fc.float({ min: Math.fround(-1000), max: Math.fround(1000), noNaN: true }),
      y: fc.float({ min: Math.fround(-1000), max: Math.fround(1000), noNaN: true }),
    })
  ),
  type: fc.constantFrom<"corner" | "smooth" | "symmetric">("corner", "smooth", "symmetric"),
});

const controlPointsArb = fc.array(controlPointArb, { minLength: 0, maxLength: 20 });

function createSplineLayer(
  controlPoints: ControlPoint[],
  closed = false,
  stroke = "#000000",
  fill = "none"
): Layer {
  return {
    id: `layer-${Date.now()}`,
    name: "Test Spline",
    type: "spline",
    visible: true,
    locked: false,
    isolate: false,
    threeD: false,
    motionBlur: false,
    startFrame: 0,
    endFrame: 100,
    inPoint: 0,
    outPoint: 100,
    opacity: createAnimatableProperty("opacity", 100, "number"),
    blendMode: "normal",
    parentId: null,
    transform: {
      position: createAnimatableProperty("position", { x: 0, y: 0 }, "position"),
      scale: createAnimatableProperty("scale", { x: 100, y: 100 }, "position"),
      rotation: createAnimatableProperty("rotation", 0, "number"),
      origin: createAnimatableProperty("origin", { x: 0, y: 0 }, "position"),
    },
    properties: [],
    effects: [],
    data: {
      pathData: "", // Will be generated by controlPointsToPathData
      controlPoints,
      closed,
      stroke,
      strokeWidth: 2,
      fill,
    },
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// controlPointsToPathData TESTS
// ═══════════════════════════════════════════════════════════════════════════

describe("PROPERTY: controlPointsToPathData", () => {
  it("returns empty string for empty points array", () => {
    const result = controlPointsToPathData([], false);
    expect(result).toBe("");
  });

  it("starts with M command for non-empty arrays", () => {
    fc.assert(
      fc.property(
        fc.array(controlPointArb, { minLength: 1, maxLength: 10 }),
        (points) => {
          const result = controlPointsToPathData(points, false);
          expect(result.startsWith("M")).toBe(true);
        }
      )
    );
  });

  it("ends with Z for closed paths", () => {
    fc.assert(
      fc.property(
        fc.array(controlPointArb, { minLength: 3, maxLength: 10 }), // Minimum 3 points for closed path (triangle)
        (points) => {
          const result = controlPointsToPathData(points, true);
          expect(result.endsWith("Z")).toBe(true);
        }
      )
    );
  });

  it("does not end with Z for open paths", () => {
    fc.assert(
      fc.property(
        fc.array(controlPointArb, { minLength: 2, maxLength: 10 }),
        (points) => {
          const result = controlPointsToPathData(points, false);
          expect(result.endsWith("Z")).toBe(false);
        }
      )
    );
  });

  it("contains only valid SVG path commands (M, L, C, Z)", () => {
    fc.assert(
      fc.property(controlPointsArb, fc.boolean(), (points, closed) => {
        const result = controlPointsToPathData(points, closed);
        // Should only contain M, L, C, Z commands, numbers, commas, spaces, and dots
        const validChars = /^[MLC Z0-9.,\-\s]*$/;
        expect(validChars.test(result)).toBe(true);
      })
    );
  });

  it("respects precision parameter", () => {
    // Linear segment (no handles) - realistic for straight lines
    const points: ControlPoint[] = [
      { id: "p1", x: 100.123456789, y: 200.987654321, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 300.111111111, y: 400.999999999, handleIn: null, handleOut: null, type: "corner" },
    ];
    
    const result1 = controlPointsToPathData(points, false, 1);
    const result3 = controlPointsToPathData(points, false, 3);
    const result6 = controlPointsToPathData(points, false, 6);
    
    // Lower precision = shorter output (generally)
    expect(result1.length).toBeLessThanOrEqual(result3.length);
    expect(result3.length).toBeLessThanOrEqual(result6.length);
  });

  it("single point produces only M command", () => {
    // Single point - handles don't matter, realistic corner point
    const point: ControlPoint = { id: "p1", x: 100, y: 200, handleIn: null, handleOut: null, type: "corner" };
    const result = controlPointsToPathData([point], false);
    expect(result).toBe("M100,200");
  });

  it("linear segments use L command (no handles)", () => {
    // Linear segment - realistic corner points with no handles
    const points: ControlPoint[] = [
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 100, y: 100, handleIn: null, handleOut: null, type: "corner" },
    ];
    const result = controlPointsToPathData(points, false);
    expect(result).toContain("L");
    expect(result).not.toContain("C");
  });

  it("curved segments use C command (with handles)", () => {
    // Curved segment - realistic smooth points with bezier handles
    // Handles positioned to create a smooth S-curve
    const points: ControlPoint[] = [
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: { x: 33, y: 0 }, type: "smooth" },
      { id: "p2", x: 100, y: 100, handleIn: { x: 67, y: 100 }, handleOut: null, type: "smooth" },
    ];
    const result = controlPointsToPathData(points, false);
    expect(result).toContain("C");
  });

  it("mixed handles create ramps (one curved, one linear)", () => {
    // Realistic user scenario: ramp shape - first segment curved, second linear
    // User manipulates handles on purpose to create a ramp effect
    const points: ControlPoint[] = [
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: { x: 25, y: 0 }, type: "smooth" }, // Curved out
      { id: "p2", x: 50, y: 50, handleIn: { x: 25, y: 50 }, handleOut: null, type: "smooth" }, // Curved in
      { id: "p3", x: 100, y: 100, handleIn: null, handleOut: null, type: "corner" }, // Linear
    ];
    const result = controlPointsToPathData(points, false);
    // Should contain C for curved segment, L for linear segment
    expect(result).toContain("C");
    expect(result).toContain("L");
  });

  it("closed path with mixed handles (realistic shape manipulation)", () => {
    // Realistic closed shape: triangle with one curved edge (ramp)
    // User manipulates handles on purpose to create ramp effect
    const points: ControlPoint[] = [
      { id: "p1", x: 50, y: 0, handleIn: null, handleOut: null, type: "corner" }, // Top - linear
      { id: "p2", x: 0, y: 100, handleIn: null, handleOut: { x: 20, y: 50 }, type: "smooth" }, // Left - curved out (ramp)
      { id: "p3", x: 100, y: 100, handleIn: { x: 80, y: 50 }, handleOut: null, type: "smooth" }, // Right - curved in (ramp)
    ];
    const result = controlPointsToPathData(points, true);
    expect(result).toContain("C"); // Curved segment
    expect(result).toContain("L"); // Linear segment
    expect(result.endsWith("Z")).toBe(true); // Closed
  });
});

// ═══════════════════════════════════════════════════════════════════════════
// SVGExportService TESTS
// ═══════════════════════════════════════════════════════════════════════════

describe("PROPERTY: SVGExportService", () => {
  it("constructor accepts custom options", () => {
    const service = new SVGExportService({
      precision: 5,
      minify: true,
    });
    expect(service).toBeDefined();
  });

  it("exportSplineLayer returns valid SVG structure", () => {
    fc.assert(
      fc.property(
        fc.array(controlPointArb, { minLength: 1, maxLength: 5 }),
        fc.boolean(),
        (points, closed) => {
          const layer = createSplineLayer(points, closed);
          const result = exportSplineLayerToSVG(layer);
          
          expect(result.svg).toContain('<?xml version="1.0"');
          expect(result.svg).toContain("<svg");
          expect(result.svg).toContain("</svg>");
          expect(result.pathCount).toBe(1);
          expect(result.warnings.length).toBe(0);
        }
      )
    );
  });

  it("exportSplineLayer warns for non-spline layers", () => {
    const layer: Layer = {
      id: "test",
      name: "Test",
      type: "image", // Not a spline!
      visible: true,
      locked: false,
      isolate: false,
      threeD: false,
      motionBlur: false,
      startFrame: 0,
      endFrame: 100,
      inPoint: 0,
      outPoint: 100,
      blendMode: "normal",
      opacity: createAnimatableProperty("opacity", 100, "number"),
      transform: createDefaultTransform(),
      effects: [],
      properties: [],
      parentId: null,
      data: null,
    };
    
    const result = exportSplineLayerToSVG(layer);
    expect(result.warnings.length).toBeGreaterThan(0);
    expect(result.svg).toBe("");
    expect(result.pathCount).toBe(0);
  });

  it("exportComposition includes all spline layers", () => {
    // Realistic linear paths - corner points
    const layer1 = createSplineLayer([
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 100, y: 100, handleIn: null, handleOut: null, type: "corner" }
    ], false);
    const layer2 = createSplineLayer([
      { id: "p3", x: 50, y: 50, handleIn: null, handleOut: null, type: "corner" },
      { id: "p4", x: 150, y: 150, handleIn: null, handleOut: null, type: "corner" }
    ], false);
    const composition = { settings: { width: 1920, height: 1080 } };
    
    const result = exportCompositionToSVG(composition, [layer1, layer2]);
    
    expect(result.pathCount).toBe(2);
    expect(result.svg).toContain("<g id=");
    expect(result.width).toBe(1920);
    expect(result.height).toBe(1080);
  });

  it("minify option removes whitespace", () => {
    // Realistic linear path
    const layer = createSplineLayer([
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 100, y: 100, handleIn: null, handleOut: null, type: "corner" }
    ], false);
    
    const normal = exportSplineLayerToSVG(layer, { minify: false });
    const minified = exportSplineLayerToSVG(layer, { minify: true });
    
    expect(minified.svg.length).toBeLessThan(normal.svg.length);
    expect(minified.svg).not.toContain("\n  ");
  });

  it("includeMetadata option adds comment", () => {
    // Realistic linear path
    const layer = createSplineLayer([
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 100, y: 100, handleIn: null, handleOut: null, type: "corner" }
    ], false);
    
    const withMeta = exportSplineLayerToSVG(layer, { includeMetadata: true });
    const withoutMeta = exportSplineLayerToSVG(layer, { includeMetadata: false });
    
    expect(withMeta.svg).toContain("Lattice Compositor");
    expect(withoutMeta.svg).not.toContain("Lattice Compositor");
  });

  it("includeStrokes option controls stroke attribute", () => {
    // Realistic linear path with custom stroke
    const layer = createSplineLayer([
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 100, y: 100, handleIn: null, handleOut: null, type: "corner" }
    ], false, "#FF0000");
    
    const withStrokes = exportSplineLayerToSVG(layer, { includeStrokes: true });
    const withoutStrokes = exportSplineLayerToSVG(layer, { includeStrokes: false });
    
    expect(withStrokes.svg).toContain('stroke="#FF0000"');
    expect(withoutStrokes.svg).toContain('stroke="none"');
  });

  it("includeFills option controls fill attribute", () => {
    // Realistic closed path with fill - triangle with mixed handles (ramp-like shape)
    // User creates a triangle but curves one edge for a ramp effect
    const layer = createSplineLayer([
      { id: "p1", x: 50, y: 0, handleIn: null, handleOut: null, type: "corner" }, // Top point - linear
      { id: "p2", x: 0, y: 100, handleIn: null, handleOut: { x: 25, y: 50 }, type: "smooth" }, // Left point - curved out (ramp)
      { id: "p3", x: 100, y: 100, handleIn: { x: 75, y: 50 }, handleOut: null, type: "smooth" }, // Right point - curved in (ramp)
    ], true, "#000", "#00FF00");
    
    const withFills = exportSplineLayerToSVG(layer, { includeFills: true });
    const withoutFills = exportSplineLayerToSVG(layer, { includeFills: false });
    
    expect(withFills.svg).toContain('fill="#00FF00"');
    expect(withoutFills.svg).toContain('fill="none"');
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                                   // simple // export // functions // tests
// ═══════════════════════════════════════════════════════════════════════════

describe("PROPERTY: exportSplineLayer (simple)", () => {
  it("returns SVG string directly", () => {
    // Realistic linear path
    const layer = createSplineLayer([
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 100, y: 100, handleIn: null, handleOut: null, type: "corner" }
    ], false);
    const result = exportSplineLayer(layer);
    
    expect(typeof result).toBe("string");
    expect(result).toContain("<svg");
  });

  it("returns empty string for non-spline layers", () => {
    const layer: Layer = {
      id: "test",
      name: "Test",
      type: "image",
      visible: true,
      locked: false,
      isolate: false,
      threeD: false,
      motionBlur: false,
      startFrame: 0,
      endFrame: 100,
      inPoint: 0,
      outPoint: 100,
      blendMode: "normal",
      opacity: createAnimatableProperty("opacity", 100, "number"),
      transform: createDefaultTransform(),
      effects: [],
      properties: [],
      parentId: null,
      data: null,
    };
    const result = exportSplineLayer(layer);
    expect(result).toBe("");
  });
});

describe("PROPERTY: exportLayers (simple)", () => {
  it("returns SVG string directly", () => {
    // Realistic linear paths
    const layer1 = createSplineLayer([
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 100, y: 100, handleIn: null, handleOut: null, type: "corner" }
    ], false);
    const layer2 = createSplineLayer([
      { id: "p3", x: 50, y: 50, handleIn: null, handleOut: null, type: "corner" },
      { id: "p4", x: 150, y: 150, handleIn: null, handleOut: null, type: "corner" }
    ], false);
    
    const result = exportLayers([layer1, layer2]);
    
    expect(typeof result).toBe("string");
    expect(result).toContain("<svg");
    expect(result).toContain("<g id=");
  });

  it("uses viewBox dimensions when provided", () => {
    // Realistic linear path
    const layer = createSplineLayer([
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 100, y: 100, handleIn: null, handleOut: null, type: "corner" }
    ], false);
    const result = exportLayers([layer], { viewBox: { x: 0, y: 0, width: 800, height: 600 } });
    
    expect(result).toContain('width="800"');
    expect(result).toContain('height="600"');
  });

  it("uses default dimensions when viewBox not provided", () => {
    // Realistic linear path
    const layer = createSplineLayer([
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 100, y: 100, handleIn: null, handleOut: null, type: "corner" }
    ], false);
    const result = exportLayers([layer]);
    
    expect(result).toContain('width="1920"');
    expect(result).toContain('height="1080"');
  });

  it("handles empty layers array", () => {
    const result = exportLayers([]);
    expect(result).toContain("<svg");
    expect(result).toContain("</svg>");
    expect(result).not.toContain("<path");
  });

  it("skips non-spline layers", () => {
    // Realistic linear path
    const splineLayer = createSplineLayer([
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 100, y: 100, handleIn: null, handleOut: null, type: "corner" }
    ], false);
    const imageLayer: Layer = {
      id: "img",
      name: "Image",
      type: "image",
      visible: true,
      locked: false,
      isolate: false,
      threeD: false,
      motionBlur: false,
      startFrame: 0,
      endFrame: 100,
      inPoint: 0,
      outPoint: 100,
      blendMode: "normal",
      opacity: createAnimatableProperty("opacity", 100, "number"),
      transform: createDefaultTransform(),
      effects: [],
      properties: [],
      parentId: null,
      data: null,
    };
    
    const result = exportLayers([splineLayer, imageLayer]);
    
    // Should only have 1 path (the spline)
    // Lean4/PureScript/Haskell: Explicit pattern matching - no lazy || []
    const matchResult = result.match(/<path/g);
    const matches = (matchResult !== null && matchResult !== undefined && Array.isArray(matchResult)) ? matchResult : [];
    const pathCount = matches.length;
    expect(pathCount).toBe(1);
  });
});

// ═══════════════════════════════════════════════════════════════════════════
//                                                            // edge // cases
// ═══════════════════════════════════════════════════════════════════════════

describe("PROPERTY: SVG Export Edge Cases", () => {
  it("handles very large coordinates", () => {
    // Edge case: extreme coordinates - realistic corner points
    const points: ControlPoint[] = [
      { id: "p1", x: 999999, y: 999999, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: -999999, y: -999999, handleIn: null, handleOut: null, type: "corner" },
    ];
    const result = controlPointsToPathData(points, false);
    expect(result).toContain("999999");
    expect(result).toContain("-999999");
  });

  it("handles very small coordinates (near zero)", () => {
    // Edge case: near-zero coordinates - realistic corner points
    const points: ControlPoint[] = [
      { id: "p1", x: 0.0001, y: 0.0001, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: 0.0002, y: 0.0002, handleIn: null, handleOut: null, type: "corner" },
    ];
    const result = controlPointsToPathData(points, false, 6);
    expect(result).toBeTruthy();
    expect(result.startsWith("M")).toBe(true);
  });

  it("handles negative coordinates", () => {
    // Edge case: negative coordinates - realistic corner points
    const points: ControlPoint[] = [
      { id: "p1", x: -100, y: -200, handleIn: null, handleOut: null, type: "corner" },
      { id: "p2", x: -50, y: -100, handleIn: null, handleOut: null, type: "corner" },
    ];
    const result = controlPointsToPathData(points, false);
    expect(result).toContain("-100");
    expect(result).toContain("-200");
  });

  it("sanitizes layer IDs with special characters", () => {
    const layer = createSplineLayer([
      { id: "p1", x: 0, y: 0, handleIn: null, handleOut: null, type: "smooth" },
      { id: "p2", x: 100, y: 100, handleIn: null, handleOut: null, type: "smooth" }
    ], false);
    layer.id = "layer<>\"'&/\\";
    
    const result = exportLayers([layer]);
    // ID should be sanitized
    expect(result).not.toContain("<>");
    expect(result).toContain("<g id=");
  });
});
