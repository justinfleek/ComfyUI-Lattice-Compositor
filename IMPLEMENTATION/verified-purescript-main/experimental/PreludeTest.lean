import Lean
open Lean

inductive PSExpr where
  | Var : String → PSExpr
  | Lam : String → PSExpr → PSExpr
  | App : PSExpr → PSExpr → PSExpr
  deriving Repr, BEq

def prettyPS : PSExpr → String
  | .Var n => n
  | .Lam arg body => "\\x" ++ arg ++ " -> " ++ prettyPS body
  | .App f arg =>
      let fStr := prettyPS f
      let argStr := prettyPS arg
      fStr ++ " " ++ argStr

-- Parse a simple Prelude function
def parseSimpleFunc : String → PSExpr × String
  | "id" ++ rest => (PSExpr.Var "id", rest)
  | "const" ++ rest =>
      match rest with
      | "a" ++ rest' =>
        match rest' with
        | b ++ rest'' => (PSExpr.Var "a", rest'')
        | _ => (PSExpr.Var "a", "")
      | _ => (PSExpr.Var "const", "")
  | name ++ _ => (PSExpr.Var "unknown name " ++ name, "")

def parseBody : String → List (String × String)
  | name ++ " " ++ body =>
      match body with
      | "" => []
      | "=" ++ rest =>
          match rest with
          | "type" ++ "=" ++ body' => [("type", body')]
            | _ => [("name", rest)]

def parsePreludeFunction : String → PSExpr
  | name ++ rest =>
      let (name', rest') := parseSimpleFunc (name ++ " " ") rest
      match rest' with
      | "=" ++ body =>
          let params := parseBody body
          let body' := params.head.snd
          PSExpr.Lam name' body'
      | _ => PSExpr.Var name'

-- Parse identity function from Prelude
def identityFromPrelude : PSExpr :=
  let (name, rest) := parseSimpleFunc "id" "(x -> x)"
  PSExpr.Lam name' (PSExpr.Var "x")

def main : IO Unit := do
  IO.println "\n=== PARSED PRELUDE FUNCTION ==="
  IO.println s!"identity: {prettyPS identityFromPrelude}"
  IO.println "\n=== PRETTY PRINTED ==="
  IO.println "module Prelude where"
  IO.println "identity :: forall a. a -> a"
  IO.println "identity x = x"
  IO.println ""
  IO.println "--- Generated by Lean 4 PureScript transpiler"

#eval main
