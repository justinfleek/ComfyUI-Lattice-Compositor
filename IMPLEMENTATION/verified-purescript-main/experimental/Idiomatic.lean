import Lean
open Lean

-- PureScript Lambda Calculus AST
inductive PSExpr where
  | Var : String → PSExpr
  | Lam : String → PSExpr → PSExpr
  | App : PSExpr → PSExpr → PSExpr
  deriving Repr, BEq

def isVar : PSExpr → Bool
  | .Var _ => true
  | _ => false

def prettyPS : PSExpr → String
  | .Var n => n
  | .Lam arg body => s!"\\{arg} -> {prettyPS body}"
  | .App f arg =>
      let fStr := prettyPS f
      let argStr := prettyPS arg
      if isVar f then
        s!"{fStr} {argStr}"
      else
        s!"({fStr} {argStr})"

def identity : PSExpr :=
  PSExpr.Lam "x" (PSExpr.Var "x")

def compose : PSExpr :=
  PSExpr.Lam "f" (PSExpr.Lam "g" (PSExpr.Lam "x" (
    PSExpr.App (PSExpr.Var "f") (PSExpr.App (PSExpr.Var "g") (PSExpr.Var "x"))
  ))

def churchTrue : PSExpr :=
  PSExpr.Lam "t" (PSExpr.Lam "f" (PSExpr.Var "t"))

def churchFalse : PSExpr :=
  PSExpr.Lam "f" (PSExpr.Lam "t" (PSExpr.Var "t"))

def churchAnd : PSExpr :=
  PSExpr.Lam "p" (PSExpr.Lam "q" (PSExpr.App (PSExpr.Var "p") (PSExpr.App (PSExpr.Var "q") churchFalse)))

def Y : PSExpr :=
  PSExpr.Lam "f" (PSExpr.App (PSExpr.Lam "x" (PSExpr.App (PSExpr.Var "f") (PSExpr.Var "x")) (PSExpr.Lam "x" (PSExpr.App (PSExpr.Var "f") (PSExpr.Var "x"))))

def output : String :=
  s!"module Church where\n\nidentity = {prettyPS identity}\n\ncompose = {prettyPS compose}\n\ntrue = {prettyPS churchTrue}\n\nfalse = {prettyPS churchFalse}\n\nand = {prettyPS churchAnd}\n\nY = {prettyPS Y}\n\n-- Generated by Lean 4"

def main : IO Unit := do
  IO.println output

#eval main
