import Lean
open Lean

inductive PSExpr where
  | Var : String → PSExpr
  | Lam : String → PSExpr → PSExpr
  | App : PSExpr → PSExpr → PSExpr
  deriving Repr, BEq

def isVar : PSExpr → Bool
  | .Var _ => true
  | _ => false

def prettyPS : PSExpr → String
  | .Var n => n
  | .Lam arg body => "\\\\" ++ arg ++ " -> " ++ prettyPS body
  | .App f arg =>
      let fStr := prettyPS f
      let argStr := prettyPS arg
      if isVar f then
        fStr ++ " " ++ argStr
      else
        "(" ++ fStr ++ " " ++ argStr ++ ")"

def identity : PSExpr :=
  PSExpr.Lam "x" (PSExpr.Var "x")

def compose : PSExpr :=
  PSExpr.Lam "f" (PSExpr.Lam "g" (PSExpr.Lam "x" (PSExpr.App (PSExpr.Var "f") (PSExpr.App (PSExpr.Var "g") (PSExpr.Var "x"))))

def churchTrue : PSExpr :=
  PSExpr.Lam "t" (PSExpr.Lam "f" (PSExpr.Var "t"))

def churchFalse : PSExpr :=
  PSExpr.Lam "f" (PSExpr.Lam "t" (PSExpr.Var "t"))

def churchAnd : PSExpr :=
  PSExpr.Lam "p" (PSExpr.Lam "q" (PSExpr.App (PSExpr.Var "p") (PSExpr.App (PSExpr.Var "q") churchFalse)))

def Y : PSExpr :=
  PSExpr.Lam "f" (PSExpr.Lam "x" (PSExpr.App (PSExpr.Var "f") (PSExpr.App (PSExpr.Var "x") (PSExpr.Lam "x" (PSExpr.App (PSExpr.Var "f") (PSExpr.Var "x"))))

def main : IO Unit := do
  IO.println "module Church where\n\nidentity = " ++ prettyPS identity
  IO.println "\ncompose = " ++ prettyPS compose
  IO.println "\ntrue = " ++ prettyPS churchTrue
  IO.println "\nfalse = " ++ prettyPS churchFalse
  IO.println "\nand = " ++ prettyPS churchAnd
  IO.println "\nY = " ++ prettyPS Y
  IO.println "\n-- Generated by Lean 4"

#eval main
