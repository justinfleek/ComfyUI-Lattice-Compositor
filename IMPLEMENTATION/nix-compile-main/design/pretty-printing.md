# Design: Structured Pretty Printing

## Status
*   **Current State**: Ad-hoc string concatenation (`<>`) and list joining (`intercalate`).
*   **Issues**:
    *   No automatic line wrapping for large types (e.g., nested attribute sets).
    *   Bash code generation is fragile and hard to read/maintain.
    *   Error messages are hard-coded text blocks.
*   **Goal**: Integrate `prettyprinter` (Wadler-Leijen style) for robust, adaptable output.

## Dependencies

Add to `nix-compile.cabal`:
```cabal
build-depends:
    prettyprinter >= 1.7 && < 1.8,
    prettyprinter-ansi-terminal >= 1.1 && < 1.2
```

## Strategy

### 1. Unified Pretty Module (`lib/NixCompile/Pretty.hs`)
Create a central module to re-export `prettyprinter` types and define project-specific styles (e.g., colors for types vs variables).

```haskell
module NixCompile.Pretty
  ( module Prettyprinter
  , module Prettyprinter.Render.Terminal
  , styleType
  , styleVar
  , ...
  ) where
```

### 2. Type System (`lib/NixCompile/Nix/Types.hs`)
Implement `Pretty` instances for `NixType`.

**Current:**
```haskell
prettyAttrs m = "{ " <> T.intercalate ", " ... <> " }"
```

**Proposed:**
```haskell
instance Pretty NixType where
  pretty = \case
    TAttrs m ->
      group $ vsep
        [ "{"
        , indent 2 (vsep (map prettyField (Map.toList m)))
        , "}"
        ]
```
*Benefit:* Automatically switches between one-line `{ a: Int, b: String }` and multi-line:
```
{
  a : Int,
  b : String
}
```
when the width is exceeded.

### 3. Bash Generation (`lib/NixCompile/Emit/Config.hs`)
Replace string lists with `Doc` structures.

**Proposed:**
```haskell
emitConfigFunction :: Schema -> Doc AnsiStyle
emitConfigFunction schema =
  vsep
    [ "# Generated by nix-compile"
    , "emit-config() {"
    , indent 2 $ vsep
        [ "local format=\"${1:-json}\""
        , "case \"$format\" in"
        , indent 2 $ vsep
            [ "json)"
            , indent 2 (emitConfigJson schema)
            , ";;"
            -- ...
            ]
        , "esac"
        ]
    , "}"
    ]
```

### 5. Nix Code Formatting (Replacing nixpkgs-fmt)
**Goal:** Provide a native, opinionated formatter for Nix code, replacing the deprecated `nixpkgs-fmt`.

**Approach:**
1.  **Parse (`hnix`)**: We already parse Nix into `NExprLoc` (annotated AST).
2.  **Transform**: Convert `NExprLoc` into a `Doc` stream using `prettyprinter`, enforcing standard style (RFC 166 / `nixfmt`-style).
    *   *Indentation*: 2 spaces.
    *   *Lists/Sets*: Vertical expansion when items don't fit on one line.
    *   *Comments*: Preserve comments (attached to spans in `hnix`).
3.  **Command**: `nix-compile fmt <file>` (already scaffolding exists, currently just adds types).
4.  **Preservation**: Must preserve comments and strict ordering of keys (or standard sort if desired).

**Module Structure:**
*   `lib/NixCompile/Nix/Format.hs`: Main entry point (AST -> Doc).
*   `lib/NixCompile/Nix/Pretty.hs`: (Extend) `Pretty` instances for `NExpr` / `NExprLoc`.

### 6. Documentation & Discovery (Docs Extraction & Noogle)
**Goal**: Make `nix-compile` a one-stop-shop for Nix development by adding documentation extraction and search (Noogle-style).

**Sub-goals:**
1.  **Extract**: Extract function signatures and doc-comments (RFC 145 style `/** ... */` or leading `#` comments) from Nix derivations.
2.  **Index**: Generate a structured index (JSON) of the codebase's functions and values.
3.  **Search**: Provide a CLI command `nix-compile search <query>` (or `noogle`) to fuzzy-find functions/options.
4.  **Noogle Compatibility**: Export data compatible with the [Noogle](https://noogle.dev) index format.

**Module Structure:**
*   `lib/NixCompile/Docs/Extract.hs`: Parsing doc comments from `NExprLoc`.
*   `lib/NixCompile/Docs/Types.hs`: Data types for Documentation items.
*   `lib/NixCompile/Docs/Search.hs`: Simple fuzzy search logic.
*   `lib/NixCompile/Docs/Noogle.hs`: Export to Noogle schema.

**Command CLI:**
*   `nix-compile search <query>`: Search local functions.
*   `nix-compile docs --json`: Emit documentation index.

### 7. Language Server Protocol (Nix LSP) (The "Universal Tool")
**Goal**: Integrate an LSP server (`nix-compile lsp`) to provide realtime feedback, leveraging the existing static analysis engine. This positions `nix-compile` as a "God's own Nix LSP" by unifying:
1.  **Format** (`nixpkgs-fmt` replacement)
2.  **Lint** (Bash/Nix forbidden constructs)
3.  **Check** (Bash/Nix type inference)
4.  **Docs** (Noogle integration)
5.  **Completion** (from schema)

**Comparison**:
*   `rnix-lsp`: Archived/Deprecated.
*   `nil` (Rust): Good, but doesn't have our Bash type inference.
*   `nixd` (C++): Deep integration, but separate ecosystem.
*   `nix-compile` (Haskell): Unique value prop is **Bash-aware** Nix analysis and type inference.

**Features:**
*   **Diagnostics**: Real-time reporting of `ALEPH-*` errors (forbidden syntax, type mismatches).
*   **Hover**: Show inferred types for variables (e.g., hover over `${PORT}` -> `TInt`).
*   **Formatting**: Use the new pretty printer.
*   **Completion**: Recommend config keys (`config.services...`) based on schema.
*   **Definition**: Jump to variable definition (already in `Scope.hs`).

**Module Structure:**
*   `lib/NixCompile/LSP/Server.hs`: Main LSP loop (using `lsp` library).
*   `lib/NixCompile/LSP/Handlers.hs`: Request handlers.
*   `lib/NixCompile/LSP/State.hs`: Cache management (incremental analysis).

**Command CLI:**
*   `nix-compile lsp`: Start language server (stdio).

## Implementation Steps

1.  **Add Dependencies**: Update `nix-compile.cabal` (add `lsp`, `lsp-types`).
2.  **Scaffold**: Create `lib/NixCompile/Pretty.hs` (and `lib/NixCompile/LSP/`).
3.  **Refactor Types**: Replace `prettyType` with `Pretty` instance in `NixCompile.Nix.Types`.
4.  **Refactor Emitter**: Rewrite `NixCompile.Emit.Config` to produce `Doc`.
5.  **Implement Nix Formatter**: Implement `Pretty` for `NExprLoc` in `NixCompile.Nix.Pretty`, handling layout rules.
6.  **Implement Doc Extractor**: Create `Docs` modules to extract comments and types.
7.  **Implement Search**: Add `search` command using the extracted index.
8.  **Implement LSP**: Create basic LSP server that delegates to existing modules (Lint, Check, Format).
9.  **Update CLI**: Update `app/nix-compile.hs` to include new commands (`search`, `docs`, `lsp`).

