{"version":3,"file":"node_animations.js","sources":["../src/effects/types.ts","../src/effects/node-effects.ts","../src/extensions/node-animations.ts"],"sourcesContent":["/**\n * Animation effect types and interfaces for node animations.\n * These define the structure for animation effects without ComfyUI dependencies.\n *\n * @module effects/types\n */\n\nimport type { ComfyNode } from '@/core/types';\n\n// =============================================================================\n// Animation Effect Types\n// =============================================================================\n\n/** Parameters for animation rendering */\nexport interface AnimationParams {\n    /** Current animation phase (0 to 2Ï€, continuous) */\n    phase: number;\n    /** Animation intensity multiplier (0-2) */\n    intensity: number;\n    /** Whether in static mode (no animation) */\n    isStaticMode: boolean;\n    /** Whether animation should be paused */\n    isPaused: boolean;\n    /** Animation speed multiplier */\n    animSpeed: number;\n    /** Animation direction (1 = forward, -1 = reverse) */\n    direction: number;\n}\n\n/** Quality settings for animation rendering */\nexport interface QualitySettings {\n    /** Quality level (1 = low, 2 = medium, 3 = high) */\n    quality: number;\n    /** Glow intensity (0-1) */\n    glowIntensity: number;\n    /** Animation size multiplier */\n    animationSize: number;\n}\n\n/** Particle settings for effects */\nexport interface ParticleSettings {\n    /** Whether to show particles */\n    showParticles: boolean;\n    /** Particle density multiplier (0.5-2) */\n    density: number;\n    /** Particle speed multiplier */\n    speed: number;\n    /** Particle intensity (0.1-2) */\n    intensity: number;\n    /** Particle size multiplier */\n    size: number;\n    /** Particle glow intensity */\n    glowIntensity: number;\n}\n\n/** Color settings for animation */\nexport interface ColorSettings {\n    /** Primary color */\n    primary: string;\n    /** Secondary color */\n    secondary: string;\n    /** Accent color */\n    accent: string;\n    /** Hover outline color */\n    hoverColor: string;\n    /** Whether to show hover effects */\n    showHover: boolean;\n}\n\n/** Complete settings for node animation effects */\nexport interface NodeEffectSettings {\n    animation: AnimationParams;\n    quality: QualitySettings;\n    particles: ParticleSettings;\n    colors: ColorSettings;\n}\n\n/** Animation effect function signature */\nexport type AnimationEffect = (\n    ctx: CanvasRenderingContext2D,\n    node: ComfyNode,\n    settings: NodeEffectSettings,\n    particleTime: number\n) => void;\n\n/** Animation style identifier */\nexport type NodeAnimationStyleName =\n    | 'gentlePulse'\n    | 'neonNexus'\n    | 'cosmicRipple'\n    | 'flowerOfLife';\n\n// =============================================================================\n// Calculation Helpers\n// =============================================================================\n\n/**\n * Calculate the effective static mode state.\n */\nexport function isEffectivelyStatic(params: AnimationParams): boolean {\n    return params.isStaticMode || params.isPaused;\n}\n\n/**\n * Calculate the scaled animation time.\n */\nexport function getScaledTime(params: AnimationParams): number {\n    return isEffectivelyStatic(params) ? params.phase : params.phase * params.animSpeed;\n}\n\n/**\n * Calculate glow radius for a node.\n */\nexport function calculateGlowRadius(\n    node: ComfyNode,\n    quality: QualitySettings\n): number {\n    return (\n        Math.max(node.size[0], node.size[1]) *\n        (0.5 + quality.quality * 0.1) *\n        quality.animationSize\n    );\n}\n\n/**\n * Calculate breathing effect scale.\n *\n * @param phase - Current animation phase\n * @param direction - Animation direction (1 or -1)\n * @param animSpeed - Animation speed multiplier\n * @param isStatic - Whether in static mode\n * @returns Scale value for breathing effect (0-1)\n */\nexport function calculateBreatheScale(\n    phase: number,\n    direction: number,\n    animSpeed: number,\n    isStatic: boolean\n): number {\n    const breathePhase = isStatic ? phase : phase * 0.375 * direction * animSpeed;\n    return Math.pow(Math.sin(breathePhase), 2);\n}\n\n/**\n * Calculate particle position with organic movement.\n *\n * @param index - Particle index\n * @param particleCount - Total particle count\n * @param particleTime - Current particle animation time\n * @param orbitRadius - Base orbit radius\n * @param params - Animation parameters\n * @returns Position {x, y} and size factor\n */\nexport function calculateParticlePosition(\n    index: number,\n    particleCount: number,\n    particleTime: number,\n    orbitRadius: number,\n    settings: {\n        particleSpeed: number;\n        particleIntensity: number;\n        isStatic: boolean;\n        phase: number;\n        quality: number;\n    }\n): { x: number; y: number; sizeFactor: number } {\n    const { particleSpeed, particleIntensity, isStatic, phase, quality } = settings;\n\n    const particleOffset = index * ((Math.PI * 2) / particleCount);\n    const individualSpeed = isStatic\n        ? 1\n        : (0.5 + Math.sin(index) * 0.25) * particleIntensity * particleSpeed;\n\n    const particlePhase = isStatic\n        ? phase + particleOffset\n        : particleTime * individualSpeed + particleOffset;\n\n    // Calculate dynamic orbit radius\n    const dynamicOrbit =\n        orbitRadius *\n        (0.8 +\n            Math.sin(isStatic ? phase + index : particleTime * 0.2 * particleSpeed + index) * 0.25 +\n            Math.cos(isStatic ? phase + index * 0.7 : particleTime * 0.3 * particleSpeed + index * 0.7) * 0.25);\n\n    const angle = particlePhase + (index * Math.PI * 2) / particleCount;\n    const randomFactor = quality > 1 ? 12 : 6;\n\n    // Enhanced organic movement\n    const torusEffect = particleIntensity * 2.0;\n    const orbitOffset = Math.sin(particleTime * 0.3 * particleSpeed + index) * torusEffect;\n\n    // Jitter for natural movement\n    const jitterX = isStatic\n        ? 0\n        : Math.sin(particleTime * 3 * particleSpeed + index) * 1.2 * particleIntensity +\n        Math.cos(particleTime * 2 * particleSpeed + index * 0.5) * 0.5 * particleIntensity;\n\n    const jitterY = isStatic\n        ? 0\n        : Math.cos(particleTime * 2.5 * particleSpeed + index) * 1.2 * particleIntensity +\n        Math.sin(particleTime * 1.5 * particleSpeed + index * 0.7) * 0.5 * particleIntensity;\n\n    const verticalOffset = -dynamicOrbit * 0.3;\n\n    const x =\n        Math.cos(angle) * (dynamicOrbit + orbitOffset) +\n        Math.sin(isStatic ? phase + index : particleTime * 0.2 * particleSpeed + index) * randomFactor +\n        jitterX;\n\n    const y =\n        Math.sin(angle) * (dynamicOrbit + orbitOffset) +\n        verticalOffset +\n        Math.cos(isStatic ? phase + index : particleTime * 0.15 * particleSpeed + index) * randomFactor +\n        jitterY;\n\n    // Size variation\n    const sizeFactor = isStatic\n        ? 1\n        : 0.7 + Math.sin(particleTime * 0.5 * particleSpeed + index) * 0.4 + Math.random() * 0.3;\n\n    return { x, y, sizeFactor };\n}\n\n/**\n * Calculate particle blink factor for twinkling effect.\n */\nexport function calculateBlinkFactor(\n    index: number,\n    particleTime: number,\n    particleSpeed: number,\n    isStatic: boolean\n): number {\n    if (isStatic) return 0.8;\n\n    const blinkOffset = Math.abs((Math.sin(index * 12.9898) * 43758.5453) % (2 * Math.PI));\n    const blinkSpeed = 1.2 + Math.sin(index * 0.7) * 0.6;\n\n    return 0.4 + 0.8 * Math.pow(Math.sin(particleTime * blinkSpeed * particleSpeed + blinkOffset), 2);\n}\n","/**\n * Node animation effects.\n * These functions render visual effects around nodes in ComfyUI.\n *\n * @module effects/node-effects\n */\n\nimport type { ComfyNode } from '@/core/types';\nimport type { NodeEffectSettings } from './types';\nimport { withAlpha } from '@/utils/colors';\nimport {\n    isEffectivelyStatic,\n    calculateGlowRadius,\n    calculateBreatheScale,\n    calculateParticlePosition,\n    calculateBlinkFactor,\n} from './types';\n\n// =============================================================================\n// Shared Drawing Functions\n// =============================================================================\n\n/**\n * Draw a hover outline around a selected/hovered node.\n */\nexport function drawHoverOutline(\n    ctx: CanvasRenderingContext2D,\n    node: ComfyNode,\n    settings: NodeEffectSettings\n): void {\n    if (!settings.colors.showHover) return;\n    if (!node.selected && !node.mouseOver) return;\n\n    const { hoverColor } = settings.colors;\n    const { glowIntensity } = settings.quality;\n    const outlineGlowSize = 15 * glowIntensity;\n\n    ctx.save();\n    ctx.shadowColor = withAlpha(hoverColor, 0.5);\n    ctx.shadowBlur = node.selected ? outlineGlowSize * 1.5 : outlineGlowSize;\n    ctx.strokeStyle = withAlpha(hoverColor, 0.7);\n    ctx.lineWidth = 2;\n    ctx.strokeRect(-node.size[0] / 2, -node.size[1] / 2, node.size[0], node.size[1]);\n    ctx.restore();\n}\n\n/**\n * Draw the base glow effect for gentle pulse style.\n */\nexport function drawPulseGlow(\n    ctx: CanvasRenderingContext2D,\n    glowRadius: number,\n    breatheScale: number,\n    intensity: number,\n    settings: NodeEffectSettings\n): void {\n    const { primary, secondary, accent } = settings.colors;\n    const { glowIntensity, quality } = settings.quality;\n    const modifiedIntensity = intensity * 0.75;\n    const pulseScale = 0.4 + 0.4 * breatheScale * modifiedIntensity;\n\n    // Inner glow gradient\n    const innerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius * pulseScale);\n    const innerAlpha = 0.2 * glowIntensity * (0.5 + breatheScale * 0.5);\n    innerGlow.addColorStop(0, withAlpha('#ffffff', Math.min(innerAlpha + 0.15, 1)));\n    innerGlow.addColorStop(0.3, withAlpha(primary, innerAlpha));\n    innerGlow.addColorStop(0.7, withAlpha(secondary, innerAlpha * 0.6));\n    innerGlow.addColorStop(1, withAlpha(accent, 0));\n\n    // Outer glow gradient\n    const outerGlow = ctx.createRadialGradient(\n        0,\n        0,\n        glowRadius * 0.6 * pulseScale,\n        0,\n        0,\n        glowRadius * (1.2 + glowIntensity * 0.4) * pulseScale\n    );\n    const outerAlpha = 0.1 * glowIntensity * (0.5 + breatheScale * 0.5);\n    outerGlow.addColorStop(0, withAlpha(secondary, outerAlpha));\n    outerGlow.addColorStop(0.6, withAlpha(accent, outerAlpha * 0.5));\n    outerGlow.addColorStop(1, withAlpha(accent, 0));\n\n    // Draw inner glow\n    ctx.beginPath();\n    ctx.arc(0, 0, glowRadius * pulseScale, 0, Math.PI * 2);\n    ctx.fillStyle = innerGlow;\n    ctx.globalAlpha = Math.min(0.2 + Math.abs(breatheScale) * 0.3 + glowIntensity * 0.2, 1);\n    ctx.fill();\n\n    // Draw outer glow\n    ctx.beginPath();\n    ctx.arc(0, 0, glowRadius * (1.2 + glowIntensity * 0.4) * pulseScale, 0, Math.PI * 2);\n    ctx.fillStyle = outerGlow;\n    ctx.globalAlpha = Math.min(0.15 + Math.abs(breatheScale) * 0.2 + glowIntensity * 0.15, 1);\n    ctx.fill();\n\n    // Quality-based shadow\n    if (quality > 1) {\n        ctx.shadowColor = withAlpha(secondary, 0.3);\n        ctx.shadowBlur = 10 * glowIntensity * (quality * 0.5);\n    }\n}\n\n/**\n * Draw particles around a node.\n */\nexport function drawParticles(\n    ctx: CanvasRenderingContext2D,\n    node: ComfyNode,\n    settings: NodeEffectSettings,\n    particleTime: number,\n    getParticleColor: (index: number, time: number, count: number) => string\n): void {\n    const { particles, quality, animation } = settings;\n    if (!particles.showParticles) return;\n\n    const isStatic = isEffectivelyStatic(animation);\n    const glowRadius = calculateGlowRadius(node, quality);\n    const baseParticleCount = 8 + quality.quality * 2;\n    const particleCount = Math.floor(baseParticleCount * particles.density);\n\n    for (let i = 0; i < particleCount; i++) {\n        const position = calculateParticlePosition(i, particleCount, particleTime, glowRadius, {\n            particleSpeed: particles.speed,\n            particleIntensity: particles.intensity,\n            isStatic,\n            phase: animation.phase,\n            quality: quality.quality,\n        });\n\n        const baseParticleSize = (4 + quality.quality) * quality.animationSize * particles.size;\n        const particleSize = baseParticleSize * position.sizeFactor;\n\n        const particleColor = getParticleColor(i, particleTime * particles.speed, particleCount);\n\n        // Particle glow gradient\n        const particleGlow = ctx.createRadialGradient(\n            position.x,\n            position.y,\n            0,\n            position.x,\n            position.y,\n            particleSize * 2.0\n        );\n        particleGlow.addColorStop(0, withAlpha(particleColor, 0.8 * particles.glowIntensity));\n        particleGlow.addColorStop(0.4, withAlpha(particleColor, 0.4 * particles.glowIntensity));\n        particleGlow.addColorStop(1, withAlpha(particleColor, 0));\n\n        const blinkFactor = calculateBlinkFactor(i, particleTime, particles.speed, isStatic);\n        const particleAlpha = Math.min(blinkFactor, 1) * particles.glowIntensity;\n\n        // Draw outer glow\n        ctx.beginPath();\n        ctx.arc(position.x, position.y, particleSize * 2.0, 0, Math.PI * 2);\n        ctx.fillStyle = particleGlow;\n        ctx.globalAlpha = particleAlpha * 0.8;\n        ctx.fill();\n\n        // Draw core\n        ctx.beginPath();\n        ctx.arc(position.x, position.y, particleSize * 0.6, 0, Math.PI * 2);\n        ctx.fillStyle = particleColor;\n        ctx.globalAlpha = Math.min(particleAlpha * 1.5, 1);\n        ctx.fill();\n    }\n}\n\n// =============================================================================\n// Effect Renderers\n// =============================================================================\n\n/**\n * Gentle Pulse animation effect.\n * Creates a soft, breathing glow with firefly-like particles.\n */\nexport function gentlePulse(\n    ctx: CanvasRenderingContext2D,\n    node: ComfyNode,\n    settings: NodeEffectSettings,\n    particleTime: number,\n    getParticleColor: (index: number, time: number, count: number) => string\n): void {\n    const isStatic = isEffectivelyStatic(settings.animation);\n    const glowRadius = calculateGlowRadius(node, settings.quality);\n    const breatheScale = calculateBreatheScale(\n        settings.animation.phase,\n        settings.animation.direction,\n        settings.animation.animSpeed,\n        isStatic\n    );\n\n    ctx.save();\n    ctx.translate(node.size[0] / 2, node.size[1] / 2);\n\n    // Draw hover outline\n    drawHoverOutline(ctx, node, settings);\n\n    // Draw glow effects (skip if particles only mode)\n    if (!node.particlesOnly) {\n        drawPulseGlow(ctx, glowRadius, breatheScale, settings.animation.intensity, settings);\n    }\n\n    // Draw particles\n    drawParticles(ctx, node, settings, particleTime, getParticleColor);\n\n    // Clean up\n    ctx.shadowColor = 'transparent';\n    ctx.shadowBlur = 0;\n    ctx.restore();\n}\n\n/**\n * Neon Nexus animation effect.\n * Creates electric, neon-style glow with geometric patterns.\n */\nexport function neonNexus(\n    ctx: CanvasRenderingContext2D,\n    node: ComfyNode,\n    settings: NodeEffectSettings,\n    particleTime: number,\n    getParticleColor: (index: number, time: number, count: number) => string\n): void {\n    const isStatic = isEffectivelyStatic(settings.animation);\n    const glowRadius = calculateGlowRadius(node, settings.quality);\n    const { primary, secondary, accent } = settings.colors;\n    const { glowIntensity, quality } = settings.quality;\n    const { phase, animSpeed, direction, intensity } = settings.animation;\n\n    ctx.save();\n    ctx.translate(node.size[0] / 2, node.size[1] / 2);\n\n    // Draw hover outline\n    drawHoverOutline(ctx, node, settings);\n\n    // Neon-specific effects\n    if (!node.particlesOnly) {\n        const neonPhase = isStatic ? phase : phase * 0.5 * direction * animSpeed;\n\n        // Electric glow effect\n        const electricGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);\n        const electricAlpha = 0.3 * glowIntensity * (0.6 + Math.sin(neonPhase) * 0.4);\n        electricGlow.addColorStop(0, withAlpha(primary, electricAlpha));\n        electricGlow.addColorStop(0.5, withAlpha(secondary, electricAlpha * 0.5));\n        electricGlow.addColorStop(1, withAlpha(accent, 0));\n\n        ctx.beginPath();\n        ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);\n        ctx.fillStyle = electricGlow;\n        ctx.globalAlpha = intensity * 0.8;\n        ctx.fill();\n\n        // Draw hexagonal pattern for neon effect\n        if (quality > 1) {\n            const hexSize = glowRadius * 0.3;\n            const hexCount = quality + 2;\n            ctx.strokeStyle = withAlpha(primary, 0.3 * glowIntensity);\n            ctx.lineWidth = 1;\n\n            for (let i = 0; i < hexCount; i++) {\n                const hexAngle = (i / hexCount) * Math.PI * 2 + neonPhase * 0.3;\n                const hexDist = glowRadius * 0.6 * (1 + Math.sin(neonPhase + i) * 0.2);\n\n                ctx.save();\n                ctx.translate(Math.cos(hexAngle) * hexDist, Math.sin(hexAngle) * hexDist);\n                ctx.rotate(hexAngle + neonPhase * 0.5);\n\n                ctx.beginPath();\n                for (let j = 0; j < 6; j++) {\n                    const angle = (j / 6) * Math.PI * 2;\n                    const x = Math.cos(angle) * hexSize;\n                    const y = Math.sin(angle) * hexSize;\n                    j === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n                }\n                ctx.closePath();\n                ctx.globalAlpha = 0.2 + Math.sin(neonPhase + i * 0.5) * 0.1;\n                ctx.stroke();\n                ctx.restore();\n            }\n        }\n    }\n\n    // Draw particles\n    drawParticles(ctx, node, settings, particleTime, getParticleColor);\n\n    ctx.shadowColor = 'transparent';\n    ctx.shadowBlur = 0;\n    ctx.restore();\n}\n\n/**\n * Cosmic Ripple animation effect.\n * Creates expanding ring effects with cosmic colors.\n */\nexport function cosmicRipple(\n    ctx: CanvasRenderingContext2D,\n    node: ComfyNode,\n    settings: NodeEffectSettings,\n    particleTime: number,\n    getParticleColor: (index: number, time: number, count: number) => string\n): void {\n    const isStatic = isEffectivelyStatic(settings.animation);\n    const glowRadius = calculateGlowRadius(node, settings.quality);\n    const { primary, secondary, accent } = settings.colors;\n    const { glowIntensity, quality } = settings.quality;\n    const { phase, animSpeed, intensity } = settings.animation;\n\n    ctx.save();\n    ctx.translate(node.size[0] / 2, node.size[1] / 2);\n\n    // Draw hover outline\n    drawHoverOutline(ctx, node, settings);\n\n    // Cosmic ripple effects\n    if (!node.particlesOnly) {\n        const ripplePhase = isStatic ? phase : phase * animSpeed;\n        const rippleCount = quality + 2;\n\n        for (let i = 0; i < rippleCount; i++) {\n            const rippleProgress = ((ripplePhase * 0.25 + i / rippleCount) % 1);\n            const rippleRadius = glowRadius * 0.3 + glowRadius * 0.9 * rippleProgress;\n            const rippleAlpha = (1 - rippleProgress) * 0.4 * glowIntensity * intensity;\n\n            ctx.beginPath();\n            ctx.arc(0, 0, rippleRadius, 0, Math.PI * 2);\n            ctx.strokeStyle = withAlpha(\n                i % 3 === 0 ? primary : i % 3 === 1 ? secondary : accent,\n                rippleAlpha\n            );\n            ctx.lineWidth = 2 * (1 - rippleProgress);\n            ctx.stroke();\n        }\n\n        // Central glow\n        const centerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius * 0.4);\n        centerGlow.addColorStop(0, withAlpha(primary, 0.4 * glowIntensity));\n        centerGlow.addColorStop(1, withAlpha(accent, 0));\n\n        ctx.beginPath();\n        ctx.arc(0, 0, glowRadius * 0.4, 0, Math.PI * 2);\n        ctx.fillStyle = centerGlow;\n        ctx.globalAlpha = intensity * 0.6;\n        ctx.fill();\n    }\n\n    // Draw particles\n    drawParticles(ctx, node, settings, particleTime, getParticleColor);\n\n    ctx.shadowColor = 'transparent';\n    ctx.shadowBlur = 0;\n    ctx.restore();\n}\n\n/**\n * Flower of Life animation effect.\n * Creates sacred geometry patterns with overlapping circles.\n */\nexport function flowerOfLife(\n    ctx: CanvasRenderingContext2D,\n    node: ComfyNode,\n    settings: NodeEffectSettings,\n    particleTime: number,\n    getParticleColor: (index: number, time: number, count: number) => string\n): void {\n    const isStatic = isEffectivelyStatic(settings.animation);\n    const glowRadius = calculateGlowRadius(node, settings.quality);\n    const { primary, secondary, accent } = settings.colors;\n    const { glowIntensity, quality } = settings.quality;\n    const { phase, animSpeed, direction, intensity } = settings.animation;\n\n    ctx.save();\n    ctx.translate(node.size[0] / 2, node.size[1] / 2);\n\n    // Draw hover outline\n    drawHoverOutline(ctx, node, settings);\n\n    // Flower of life pattern\n    if (!node.particlesOnly) {\n        const flowerPhase = isStatic ? phase : phase * 0.3 * direction * animSpeed;\n        const petalRadius = glowRadius * 0.25;\n        const petalCount = 6;\n\n        ctx.save();\n        ctx.rotate(flowerPhase * 0.5);\n\n        // Central flower pattern\n        for (let layer = 0; layer < quality; layer++) {\n            const layerRadius = petalRadius * (1 + layer * 0.8);\n            const layerAlpha = 0.3 * glowIntensity * (1 - layer * 0.2) * intensity;\n\n            for (let i = 0; i < petalCount; i++) {\n                const angle = (i / petalCount) * Math.PI * 2;\n                const x = Math.cos(angle) * layerRadius;\n                const y = Math.sin(angle) * layerRadius;\n\n                ctx.beginPath();\n                ctx.arc(x, y, petalRadius, 0, Math.PI * 2);\n                ctx.strokeStyle = withAlpha(\n                    layer % 3 === 0 ? primary : layer % 3 === 1 ? secondary : accent,\n                    layerAlpha\n                );\n                ctx.lineWidth = 1.5;\n                ctx.stroke();\n            }\n        }\n\n        // Central circle\n        ctx.beginPath();\n        ctx.arc(0, 0, petalRadius, 0, Math.PI * 2);\n        ctx.strokeStyle = withAlpha(primary, 0.4 * glowIntensity * intensity);\n        ctx.lineWidth = 2;\n        ctx.stroke();\n\n        ctx.restore();\n\n        // Background glow\n        const bgGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);\n        bgGlow.addColorStop(0, withAlpha(primary, 0.15 * glowIntensity));\n        bgGlow.addColorStop(0.5, withAlpha(secondary, 0.08 * glowIntensity));\n        bgGlow.addColorStop(1, withAlpha(accent, 0));\n\n        ctx.beginPath();\n        ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);\n        ctx.fillStyle = bgGlow;\n        ctx.globalAlpha = intensity * 0.5;\n        ctx.fill();\n    }\n\n    // Draw particles\n    drawParticles(ctx, node, settings, particleTime, getParticleColor);\n\n    ctx.shadowColor = 'transparent';\n    ctx.shadowBlur = 0;\n    ctx.restore();\n}\n\n// =============================================================================\n// Exports\n// =============================================================================\n\n/** Map of all node animation effects */\nexport const NodeEffects = {\n    gentlePulse,\n    neonNexus,\n    cosmicRipple,\n    flowerOfLife,\n};\n\n/**\n * Get an effect by style number.\n */\nexport function getNodeEffect(style: number): typeof gentlePulse {\n    switch (style) {\n        case 1:\n            return gentlePulse;\n        case 2:\n            return neonNexus;\n        case 3:\n            return cosmicRipple;\n        case 4:\n            return flowerOfLife;\n        default:\n            return gentlePulse;\n    }\n}\n","/// <reference path=\"../comfy.d.ts\" />\n/**\n * ComfyUI Enhanced Node Animations Extension\n * \n * This extension adds visual enhancements to nodes, including:\n * - Idle animations (breathing, pulsing)\n * - Selection highlights\n * - Execution state visualization (active/running nodes)\n * \n * @module extensions/node-animations\n */\n\nimport { app } from '/scripts/app.js';\nimport {\n    createNodeState,\n    createTimingManager,\n    NODE_DEFAULTS,\n    type NodeState,\n    type ComfyExtension,\n    type ComfyApp,\n    type ComfyNode,\n    type NodeAnimationStyleName,\n    type Color,\n} from '@/core';\nimport { getNodeEffect } from '@/effects/node-effects';\nimport { createPatternDesignerWindow } from '@/utils';\n\n// =============================================================================\n// Settings\n// =============================================================================\n\nfunction getSetting<T>(name: string): T {\n    const defaultValue = NODE_DEFAULTS[name as keyof typeof NODE_DEFAULTS];\n    return app.ui.settings.getSettingValue(name, defaultValue) as T;\n}\n\n// =============================================================================\n// Extension Implementation\n// =============================================================================\n\nconst ext: ComfyExtension = {\n    name: 'enhanced.node.animations',\n\n    async setup(app: ComfyApp) {\n        const state: NodeState = createNodeState();\n        const timing = createTimingManager();\n\n        // Animation Loop\n        let isEnabled = true;\n        let pauseDuringRender = true;\n        let animStyle = 0;\n\n        // Update settings every 500ms instead of every frame (60fps) to save resources\n        let lastSettingsUpdate = 0;\n        function updateSettingsCache() {\n            isEnabled = getSetting<boolean>('ðŸ“¦ Enhanced Nodes.Animations.Enabled');\n            pauseDuringRender = getSetting<boolean>('ðŸ“¦ Enhanced Nodes.Pause.During.Render');\n            animStyle = getSetting<number>('ðŸ“¦ Enhanced Nodes.Animate');\n        }\n\n        function renderLoop(timestamp: number) {\n            // Update settings cache occasionally\n            if (timestamp - lastSettingsUpdate > 500) {\n                updateSettingsCache();\n                lastSettingsUpdate = timestamp;\n            }\n\n            timing.update(timestamp);\n\n            const isRendering = app.graph && (app.graph as any).is_rendering;\n\n            if (!isEnabled || (isRendering && pauseDuringRender)) {\n                if (state.isRunning) {\n                    state.isRunning = false;\n                    app.graph?.setDirtyCanvas(true, true);\n                }\n                requestAnimationFrame(renderLoop);\n                return;\n            }\n\n            state.isRunning = true;\n\n            const speed = getSetting<number>('ðŸ“¦ Enhanced Nodes.Animation.Speed');\n            const dt = (timestamp - state.lastFrame) / 1000;\n            state.lastFrame = timestamp;\n            state.phase += dt * speed;\n\n            // Trigger redraw only if visible or needed\n            app.graph?.setDirtyCanvas(true, false);\n            requestAnimationFrame(renderLoop);\n        }\n\n        requestAnimationFrame(renderLoop);\n\n        // =====================================================================\n        // Canvas Overrides\n        // =====================================================================\n\n        const originalDrawNode = LGraphCanvas.prototype.drawNode;\n\n        LGraphCanvas.prototype.drawNode = function (node: ComfyNode, ctx: CanvasRenderingContext2D) {\n            // 1. Pre-render effects (Behind node)\n            if (isEnabled && animStyle > 0 && state.isRunning) {\n                // Determine effect type based on mapping\n                const effectName: NodeAnimationStyleName =\n                    animStyle === 1 ? 'gentlePulse' :\n                        animStyle === 2 ? 'neonNexus' :\n                            animStyle === 3 ? 'cosmicRipple' :\n                                animStyle === 4 ? 'flowerOfLife' : 'gentlePulse';\n\n                const effect = getNodeEffect(effectName as any);\n\n                if (effect) {\n                    const glowIntensity = getSetting<number>('ðŸ“¦ Enhanced Nodes.Glow.Intensity') || 1;\n                    const glowSize = getSetting<number>('ðŸ“¦ Enhanced Nodes.Animation.Size') || 1;\n                    const quality = getSetting<number>('ðŸ“¦ Enhanced Nodes.Quality') || 1;\n\n                    // Active/Running state override\n                    const isRunning = node.id === (app as any).runningNodeId;\n                    const isSelected = this.selected_nodes && this.selected_nodes[node.id];\n\n                    const primaryColor = isRunning ? '#00ff00' : (isSelected ? '#00ffff' : node.color || '#333');\n\n                    ctx.save();\n                    // @ts-ignore - handled by getNodeEffect\n                    effect(\n                        ctx,\n                        node,\n                        {\n                            animation: { phase: state.phase, intensity: glowIntensity, direction: 1, animSpeed: 1, isStaticMode: false, isPaused: false },\n                            quality: { quality, animationSize: glowSize, glowIntensity },\n                            particles: { showParticles: true, density: 1, speed: 1, intensity: 1, size: 1, glowIntensity: 0.5 * glowIntensity },\n                            colors: { primary: primaryColor as Color, secondary: '#ffffff', accent: primaryColor as Color, hoverColor: primaryColor as string, showHover: true }\n                        },\n                        state.phase,\n                        () => primaryColor\n                    );\n                    ctx.restore();\n                }\n            }\n\n            // 2. Render Node (Original)\n            originalDrawNode.call(this, node, ctx);\n        };\n\n        // UI & Ã†motion Studio About\n        app.ui.settings.addSetting({\n            id: 'ðŸ“¦ Enhanced Nodes.UI & Ã†motion Studio About',\n            name: 'ðŸ”½ Info Panel',\n            type: 'combo',\n            options: [\n                { value: 0, text: 'Closed Panel' },\n                { value: 1, text: 'Open Panel' }\n            ],\n            defaultValue: NODE_DEFAULTS['ðŸ“¦ Enhanced Nodes.UI & Ã†motion Studio About'],\n            onChange: (value: number) => {\n                if (value === 1) {\n                    document.body.appendChild(createPatternDesignerWindow());\n                    // Reset setting back to 0 (Closed) after opening\n                    setTimeout(() => app.ui.settings.setSettingValue('ðŸ“¦ Enhanced Nodes.UI & Ã†motion Studio About', 0), 100);\n                }\n            }\n        });\n\n        console.log('[EnhancedNodes] Extension registered and ready.');\n    }\n};\n\napp.registerExtension(ext);\n"],"names":["app"],"mappings":"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"}