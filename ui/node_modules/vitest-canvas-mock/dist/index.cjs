//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let moo_color = require("moo-color");
let vitest = require("vitest");
let cssfontparser = require("cssfontparser");
cssfontparser = __toESM(cssfontparser);

//#region src/classes/CanvasGradient.js
var CanvasGradient$1 = class {
	constructor() {
		this.addColorStop = vitest.vi.fn(this.addColorStop.bind(this));
	}
	addColorStop(offset, color) {
		const numoffset = Number(offset);
		if (!Number.isFinite(numoffset) || numoffset < 0 || numoffset > 1) throw new DOMException(`Failed to execute 'addColorStop' on 'CanvasGradient': The provided value ('${numoffset}') is outside the range (0.0, 1.0)`, "IndexSizeError");
		try {
			new moo_color.MooColor(color);
		} catch {
			throw new SyntaxError(`Failed to execute 'addColorStop' on 'CanvasGradient': The value provided ('${color}') could not be parsed as a color.`);
		}
	}
};

//#endregion
//#region src/classes/CanvasPattern.js
var CanvasPattern = class {
	constructor() {
		this.setTransform = vitest.vi.fn(this.setTransform.bind(this));
	}
	setTransform(value) {
		if (arguments.length > 0 && !(value instanceof Object)) throw new TypeError("Failed to execute 'setTransform' on 'CanvasPattern': parameter 1 ('transform') is not an object.");
	}
};

//#endregion
//#region src/mock/createCanvasEvent.js
/**
* This function returns a CanvasRenderingContext2DEvent. Whenever an operation would modify the canvas
* context, this function should be used to generate an "event" that represents that sort of modification.
* This will be used to mock for snapshots.
*
* @example
* interface CanvasRenderingContext2DEvent {
*   type: string;
*   transform: [number, number, number, number, number, number]; // the resulting current transform
*   props: {
*     // if the event is a property was set, `event.props.value` would be set
*     [propName: string]: any;
*   };
* }
*/
function createCanvasEvent(type, transform, props) {
	return {
		type,
		transform,
		props
	};
}

//#endregion
//#region src/classes/DOMMatrix.js
function sumMultipleOfMatricesCells(matrix1Array, matrix2Array, { i, j }) {
	let sum = 0;
	for (let k = 0; k < 4; k++) {
		const matrix1Index = j - 1 + k * 4;
		const matrix2Index = (i - 1) * 4 + k;
		sum += matrix1Array[matrix1Index] * matrix2Array[matrix2Index];
	}
	return sum;
}
function multiplyMatrices(leftMatrix, rightMatrix) {
	const leftMatrixArray = leftMatrix.toFloat64Array();
	const rightMatrixArray = rightMatrix.toFloat64Array();
	for (let i = 1; i <= 4; i++) for (let j = 1; j <= 4; j++) leftMatrix[`m${i}${j}`] = sumMultipleOfMatricesCells(leftMatrixArray, rightMatrixArray, {
		i,
		j
	});
}
var DOMMatrix = class DOMMatrix {
	_is2D = true;
	m11 = 1;
	m12 = 0;
	m13 = 0;
	m14 = 0;
	m21 = 0;
	m22 = 1;
	m23 = 0;
	m24 = 0;
	m31 = 0;
	m32 = 0;
	m33 = 1;
	m34 = 0;
	m41 = 0;
	m42 = 0;
	m43 = 0;
	m44 = 1;
	constructor(transform) {
		if (transform instanceof DOMMatrix) return transform;
		if (transform && transform.length === 6) {
			this.m11 = transform[0];
			this.m12 = transform[1];
			this.m21 = transform[2];
			this.m22 = transform[3];
			this.m41 = transform[4];
			this.m42 = transform[5];
			this._is2D = true;
			return this;
		}
		if (transform && transform.length === 16) {
			this.m11 = transform[0];
			this.m12 = transform[1];
			this.m13 = transform[2];
			this.m14 = transform[3];
			this.m21 = transform[4];
			this.m22 = transform[5];
			this.m23 = transform[6];
			this.m24 = transform[7];
			this.m31 = transform[8];
			this.m32 = transform[9];
			this.m33 = transform[10];
			this.m34 = transform[11];
			this.m41 = transform[12];
			this.m42 = transform[13];
			this.m43 = transform[14];
			this.m44 = transform[15];
			this._is2D = false;
			return this;
		}
		if (transform) throw new TypeError("Failed to construct 'DOMMatrix': The sequence must contain 6 elements for a 2D matrix or 16 elements for a 3D matrix.");
		this._is2D = false;
	}
	get isIdentity() {
		if (this._is2D) return this.m11 === 1 && this.m12 === 0 && this.m21 === 0 && this.m22 === 1 && this.m41 === 0 && this.m42 === 0;
		else return this.m11 === 1 && this.m12 === 0 && this.m13 === 0 && this.m14 === 0 && this.m21 === 0 && this.m22 === 1 && this.m23 === 0 && this.m24 === 0 && this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 && this.m41 === 0 && this.m42 === 0 && this.m43 === 0 && this.m44 === 1;
	}
	get a() {
		return this.m11;
	}
	set a(value) {
		this.m11 = value;
	}
	get b() {
		return this.m12;
	}
	set b(value) {
		this.m12 = value;
	}
	get c() {
		return this.m21;
	}
	set c(value) {
		this.m21 = value;
	}
	get d() {
		return this.m22;
	}
	set d(value) {
		this.m22 = value;
	}
	get e() {
		return this.m41;
	}
	set e(value) {
		this.m41 = value;
	}
	get f() {
		return this.m42;
	}
	set f(value) {
		this.m42 = value;
	}
	get is2D() {
		return this._is2D;
	}
	toFloat32Array() {
		return new Float32Array([
			this.m11,
			this.m12,
			this.m13,
			this.m14,
			this.m21,
			this.m22,
			this.m23,
			this.m24,
			this.m31,
			this.m32,
			this.m33,
			this.m34,
			this.m41,
			this.m42,
			this.m43,
			this.m44
		]);
	}
	toFloat64Array() {
		return new Float64Array([
			this.m11,
			this.m12,
			this.m13,
			this.m14,
			this.m21,
			this.m22,
			this.m23,
			this.m24,
			this.m31,
			this.m32,
			this.m33,
			this.m34,
			this.m41,
			this.m42,
			this.m43,
			this.m44
		]);
	}
	translateSelf(x, y, z) {
		const tx = Number(x);
		const ty = Number(y);
		const tz = Number.isNaN(Number(z)) ? 0 : Number(z);
		const translationMatrix = new DOMMatrix();
		translationMatrix.m41 = tx;
		translationMatrix.m42 = ty;
		translationMatrix.m43 = tz;
		multiplyMatrices(this, translationMatrix);
		if (tz) this._is2D = false;
		return this;
	}
	translate(x, y, z) {
		let translatedMatrix;
		if (this.is2D) translatedMatrix = new DOMMatrix([
			this.a,
			this.b,
			this.c,
			this.d,
			this.e,
			this.f
		]);
		else translatedMatrix = new DOMMatrix(this.toFloat32Array());
		return translatedMatrix.translateSelf(x, y, z);
	}
	scaleSelf(scaleX, scaleY, scaleZ, originX, originY, originZ) {
		const sx = Number(scaleX);
		const sy = Number.isNaN(Number(scaleY)) ? sx : Number(scaleY);
		const sz = Number.isNaN(Number(scaleZ)) ? 1 : Number(scaleZ);
		const ox = Number.isNaN(Number(originX)) ? 0 : Number(originX);
		const oy = Number.isNaN(Number(originY)) ? 0 : Number(originY);
		const oz = Number.isNaN(Number(originZ)) ? 0 : Number(originZ);
		this.translateSelf(ox, oy, oz);
		const scaleMatrix = new DOMMatrix();
		scaleMatrix.m11 = sx;
		scaleMatrix.m22 = sy;
		scaleMatrix.m33 = sz;
		multiplyMatrices(this, scaleMatrix);
		this.translateSelf(-ox, -oy, -oz);
		if (Math.abs(sz) !== 1) this._is2D = false;
		return this;
	}
	scale(scaleX, scaleY, scaleZ, originX, originY, originZ) {
		let scaledMatrix;
		if (this.is2D) scaledMatrix = new DOMMatrix([
			this.a,
			this.b,
			this.c,
			this.d,
			this.e,
			this.f
		]);
		else scaledMatrix = new DOMMatrix(this.toFloat32Array());
		return scaledMatrix.scaleSelf(scaleX, scaleY, scaleZ, originX, originY, originZ);
	}
};

//#endregion
//#region src/classes/Path2D.js
const Path2DFunc = ["addPath"];
const borrowedFromCanvas = [
	"closePath",
	"moveTo",
	"lineTo",
	"bezierCurveTo",
	"quadraticCurveTo",
	"arc",
	"arcTo",
	"ellipse",
	"rect"
];
var Path2D = class Path2D {
	_path = [];
	_events = [];
	_stackIndex = 0;
	_transformStack = [[
		1,
		0,
		0,
		1,
		0,
		0
	]];
	constructor() {
		borrowedFromCanvas.forEach((key) => {
			this[key] = vitest.vi.fn(CanvasRenderingContext2D$1.prototype[key].bind(this));
		});
		Path2DFunc.forEach((key) => {
			this[key] = vitest.vi.fn(this[key].bind(this));
		});
	}
	addPath(path) {
		if (arguments.length < 1) throw new TypeError("Failed to execute 'addPath' on 'Path2D': 1 argument required, but only 0 present.");
		if (!(path instanceof Path2D)) throw new TypeError("Failed to execute 'addPath' on 'Path2D': parameter 1 is not of type 'Path2D'.");
		for (let i = 0; i < path._path.length; i++) this._path.push(path._path[i]);
	}
};

//#endregion
//#region src/classes/TextMetrics.js
var TextMetrics = class {
	width = 0;
	actualBoundingBoxLeft = 0;
	actualBoundingBoxRight = 0;
	fontBoundingBoxAscent = 0;
	fontBoundingBoxDescent = 0;
	actualBoundingBoxAscent = 0;
	actualBoundingBoxDescent = 0;
	emHeightAscent = 0;
	emHeightDescent = 0;
	hangingBaseline = 0;
	alphabeticBaseline = 0;
	ideographicBaseline = 0;
	constructor(text) {
		this.width = text.length;
	}
};

//#endregion
//#region src/classes/CanvasRenderingContext2D.js
const testFuncs = [
	"setLineDash",
	"getLineDash",
	"setTransform",
	"getTransform",
	"getImageData",
	"save",
	"restore",
	"createPattern",
	"createRadialGradient",
	"addHitRegion",
	"arc",
	"arcTo",
	"beginPath",
	"clip",
	"closePath",
	"scale",
	"stroke",
	"clearHitRegions",
	"clearRect",
	"fillRect",
	"strokeRect",
	"rect",
	"roundRect",
	"resetTransform",
	"translate",
	"moveTo",
	"lineTo",
	"bezierCurveTo",
	"createLinearGradient",
	"ellipse",
	"measureText",
	"rotate",
	"drawImage",
	"drawFocusIfNeeded",
	"isPointInPath",
	"isPointInStroke",
	"putImageData",
	"strokeText",
	"fillText",
	"quadraticCurveTo",
	"removeHitRegion",
	"fill",
	"transform",
	"scrollPathIntoView",
	"createImageData"
];
const compositeOperations = [
	"source-over",
	"source-in",
	"source-out",
	"source-atop",
	"destination-over",
	"destination-in",
	"destination-out",
	"destination-atop",
	"lighter",
	"copy",
	"xor",
	"multiply",
	"screen",
	"overlay",
	"darken",
	"lighten",
	"color-dodge",
	"color-burn",
	"hard-light",
	"soft-light",
	"difference",
	"exclusion",
	"hue",
	"saturation",
	"color",
	"luminosity"
];
function getTransformSlice(ctx) {
	return ctx._transformStack[ctx._stackIndex].slice();
}
/**
* Returns the string serialization of a CSS color, according to https://www.w3.org/TR/2dcontext/#serialization-of-a-color
*/
function serializeColor(value) {
	return value.getAlpha() === 1 ? value.toHex() : value.toRgb();
}
var CanvasRenderingContext2D$1 = class CanvasRenderingContext2D$1 {
	/**
	* Every time a function call would result in a drawing operation, it should be added to this array.
	* This goes for only draw call functions.
	*/
	_drawCalls = [];
	__getDrawCalls() {
		return this._drawCalls.slice();
	}
	/**
	* Clear the list of draw calls
	*/
	__clearDrawCalls() {
		this._drawCalls = [];
	}
	/**
	* Every time a function call results in something that would have modified the state of the context,
	* an event is added to this array. This goes for every property set, and draw call.
	*/
	_events = [];
	__getEvents() {
		return this._events.slice();
	}
	/**
	* Clear the list of events
	*/
	__clearEvents() {
		this._events = [];
	}
	/**
	* This array keeps track of the current path, so that fill and stroke operations can store the
	* path.
	*/
	_path = [createCanvasEvent("beginPath", [
		1,
		0,
		0,
		1,
		0,
		0
	], {})];
	__getPath() {
		return this._path.slice();
	}
	/**
	* Clear the path and reset it to a single beginPath event.
	*/
	__clearPath() {
		const event = createCanvasEvent("beginPath", getTransformSlice(this), {});
		this._clipIndex = 1;
		this._path = [event];
	}
	/**
	* Get the current clipping region.
	*/
	__getClippingRegion() {
		return this._clipStack[this._stackIndex];
	}
	_directionStack = ["inherit"];
	_fillStyleStack = ["#000000"];
	_filterStack = ["none"];
	_fontStack = ["10px sans-serif"];
	_globalAlphaStack = [1];
	_globalCompositeOperationStack = ["source-over"];
	_imageSmoothingEnabledStack = [true];
	_imageSmoothingQualityStack = ["low"];
	_lineCapStack = ["butt"];
	_lineDashOffsetStack = [0];
	_lineDashStack = [[]];
	_lineJoinStack = ["miter"];
	_lineWidthStack = [1];
	_miterLimitStack = [10];
	_shadowBlurStack = [0];
	_shadowColorStack = ["rgba(0, 0, 0, 0)"];
	_shadowOffsetXStack = [0];
	_shadowOffsetYStack = [0];
	_stackIndex = 0;
	_strokeStyleStack = ["#000000"];
	_textAlignStack = ["start"];
	_textBaselineStack = ["alphabetic"];
	_transformStack = [[
		1,
		0,
		0,
		1,
		0,
		0
	]];
	_clipStack = [[]];
	constructor(canvas) {
		testFuncs.forEach((key) => {
			this[key] = vitest.vi.fn(CanvasRenderingContext2D$1.prototype[key].bind(this));
		});
		this._canvas = canvas;
	}
	addHitRegion(options = {}) {
		const { path, fillRule, id, parentID, cursor, control, label, role } = options;
		if (!path && !id) throw new DOMException(`Failed to execute 'addHitRegion' on '${this.constructor.name}': Both id and control are null.`, "ConstraintError");
		if (fillRule && fillRule !== "evenodd" && fillRule !== "nonzero") throw new TypeError(`Failed to execute 'addHitRegion' on '${this.constructor.name}': The provided value '${fillRule}' is not a valid enum value of type CanvasFillRule.`);
		this._events.push(createCanvasEvent("addHitRegion", getTransformSlice(this), {
			path,
			fillRule,
			id,
			parentID,
			cursor,
			control,
			label,
			role
		}));
	}
	arc(x, y, radius, startAngle, endAngle, anticlockwise = false) {
		if (arguments.length < 5) throw new TypeError(`Failed to execute 'arc' on '${this.constructor.name}': 5 arguments required, but only ${arguments.length} present.`);
		const xResult = Number(x);
		const yResult = Number(y);
		const radiusResult = Number(radius);
		const startAngleResult = Number(startAngle);
		const endAngleResult = Number(endAngle);
		const anticlockwiseResult = Boolean(anticlockwise);
		if (!Number.isFinite(xResult + yResult + radiusResult + startAngleResult + endAngleResult)) return;
		if (Number(radius) < 0) throw new DOMException(`Failed to execute 'arc' on '${this.constructor.name}': The radius provided (${radius}) is negative.`, "IndexSizeError");
		const event = createCanvasEvent("arc", getTransformSlice(this), {
			x: xResult,
			y: yResult,
			radius: radiusResult,
			startAngle: startAngleResult,
			endAngle: endAngleResult,
			anticlockwise: anticlockwiseResult
		});
		this._path.push(event);
		this._events.push(event);
	}
	arcTo(cpx1, cpy1, cpx2, cpy2, radius) {
		if (arguments.length < 5) throw new TypeError(`Failed to execute 'arcTo' on '${this.constructor.name}': 5 arguments required, but only ${arguments.length} present.`);
		const cpx1Result = Number(cpx1);
		const cpy1Result = Number(cpy1);
		const cpx2Result = Number(cpx2);
		const cpy2Result = Number(cpy2);
		const radiusResult = Number(radius);
		if (!Number.isFinite(cpx1Result + cpx2Result + cpy1Result + cpy2Result + radiusResult)) return;
		if (radiusResult < 0) throw new DOMException(`Failed to execute 'arcTo' on '${this.constructor.name}': The radius provided (${radius}) is negative.`, "IndexSizeError");
		const event = createCanvasEvent("arcTo", getTransformSlice(this), {
			cpx1: cpx1Result,
			cpy1: cpy1Result,
			cpx2: cpx2Result,
			cpy2: cpy2Result,
			radius: radiusResult
		});
		this._path.push(event);
		this._events.push(event);
	}
	beginPath() {
		this.__clearPath();
		this._events.push(this._path[0]);
	}
	bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y) {
		if (arguments.length < 6) throw new TypeError(`Failed to execute 'bezierCurveTo' on '${this.constructor.name}': 6 arguments required, but only ${arguments.length} present.`);
		const cpx1Result = Number(cpx1);
		const cpy1Result = Number(cpy1);
		const cpx2Result = Number(cpx2);
		const cpy2Result = Number(cpy2);
		const xResult = Number(x);
		const yResult = Number(y);
		if (!Number.isFinite(cpx1Result + cpy1Result + cpx2Result + cpy2Result + xResult + yResult)) return;
		const event = createCanvasEvent("bezierCurveTo", getTransformSlice(this), {
			cpx1,
			cpy1,
			cpx2,
			cpy2,
			x,
			y
		});
		this._path.push(event);
		this._events.push(event);
	}
	get canvas() {
		return this._canvas;
	}
	clearHitRegions() {
		const event = createCanvasEvent("clearHitRegions", getTransformSlice(this), {});
		this._events.push(event);
	}
	clearRect(x, y, width, height) {
		if (arguments.length < 4) throw new TypeError(`Failed to execute 'clearRect' on '${this.constructor.name}': 4 arguments required, but only ${arguments.length} present.`);
		const xResult = Number(x);
		const yResult = Number(y);
		const widthResult = Number(width);
		const heightResult = Number(height);
		if (!Number.isFinite(x + y + width + height)) return;
		const event = createCanvasEvent("clearRect", getTransformSlice(this), {
			x: xResult,
			y: yResult,
			width: widthResult,
			height: heightResult
		});
		this._events.push(event);
		this._drawCalls.push(event);
	}
	/**
	* This index points to the next path item that should be written to the clipStack
	* when ctx.clip() is called.
	*/
	_clipIndex = 1;
	clip(path, fillRule) {
		let clipPath;
		if (arguments.length === 0) {
			fillRule = "nonzero";
			path = this._path.slice();
			clipPath = path.slice(this._clipIndex);
			this._clipIndex = path.length;
		} else {
			if (arguments.length === 1) fillRule = "nonzero";
			if (path instanceof Path2D) {
				fillRule = String(fillRule);
				if (fillRule !== "nonzero" && fillRule !== "evenodd") throw new TypeError(`Failed to execute 'clip' on '${this.constructor.name}': The provided value '${fillRule}' is not a valid enum value of type CanvasFillRule.`);
				path = path._path.slice();
				clipPath = path;
			} else {
				fillRule = String(path);
				if (fillRule !== "nonzero" && fillRule !== "evenodd") throw new TypeError(`Failed to execute 'clip' on '${this.constructor.name}': The provided value '${fillRule}' is not a valid enum value of type CanvasFillRule.`);
				path = this._path.slice();
				clipPath = path.slice(this._clipIndex);
				this._clipIndex = path.length;
			}
		}
		const event = createCanvasEvent("clip", getTransformSlice(this), {
			path,
			fillRule
		});
		this._path.push(event);
		this._events.push(event);
		const currentClip = this._clipStack[this._stackIndex];
		this._clipStack[this._stackIndex] = currentClip.concat(clipPath);
	}
	closePath() {
		const event = createCanvasEvent("closePath", getTransformSlice(this), {});
		this._events.push(event);
		this._path.push(event);
	}
	createImageData(width, height) {
		if (arguments.length < 1) throw new TypeError(`Failed to execute 'createImageData' on '${this.constructor.name}': 1 argument required, but only 0 present.`);
		else if (arguments.length === 1) {
			if (!(width instanceof ImageData)) throw new TypeError(`Failed to execute 'createImageData' on '${this.constructor.name}': parameter 1 is not of type 'ImageData'.`);
			const result = new ImageData(width.width, width.height);
			result.data.set(width.data);
			const event = createCanvasEvent("createImageData", getTransformSlice(this), {
				width: width.width,
				height: width.height
			});
			this._events.push(event);
			return result;
		} else {
			width = Math.abs(Number(width));
			height = Math.abs(Number(height));
			if (!Number.isFinite(width) || width === 0) throw new TypeError(`Failed to execute 'createImageData' on '${this.constructor.name}': The source width is 0.`);
			if (!Number.isFinite(height) || height === 0) throw new TypeError(`Failed to execute 'createImageData' on '${this.constructor.name}': The source height is 0.`);
			const event = createCanvasEvent("createImageData", getTransformSlice(this), {
				width,
				height
			});
			this._events.push(event);
			return new ImageData(width, height);
		}
	}
	createLinearGradient(x0, y0, x1, y1) {
		if (arguments.length < 4) throw new TypeError(`Failed to execute 'createLinearGradient' on '${this.constructor.name}': 4 arguments required, but only ${arguments.length} present.`);
		const x0Result = Number(x0);
		const y0Result = Number(y0);
		const x1Result = Number(x1);
		const y1Result = Number(y1);
		if (!Number.isFinite(x0Result + y0Result + x1Result + y1Result)) throw new TypeError(`Failed to execute 'createLinearGradient' on '${this.constructor.name}': The provided double value is non-finite.`);
		const event = createCanvasEvent("createLinearGradient", getTransformSlice(this), {
			x0: x0Result,
			y0: y0Result,
			x1: x1Result,
			y1: y1Result
		});
		this._events.push(event);
		return new CanvasGradient();
	}
	createPattern(image, type) {
		if (arguments.length === 1) throw new TypeError(`Failed to execute 'createPattern' on '${this.constructor.name}': 2 arguments required, but only 1 present.`);
		if (type === null) type = "repeat";
		if (type === "") type = "repeat";
		if (type === "repeat" || type === "repeat-x" || type === "repeat-y" || type === "no-repeat") {
			const event = createCanvasEvent("createPattern", getTransformSlice(this), {
				image,
				type
			});
			if (image instanceof ImageBitmap) {
				if (image._closed) throw new DOMException("Failed to execute 'createPattern' on 'CanvasRenderingContext2D': The image source is detached.", "InvalidStateError");
				this._events.push(event);
				return new CanvasPattern();
			}
			if (image instanceof HTMLImageElement) {
				this._events.push(event);
				return new CanvasPattern();
			}
			if (image instanceof HTMLVideoElement) {
				this._events.push(event);
				return new CanvasPattern();
			}
			if (image instanceof HTMLCanvasElement) {
				this._events.push(event);
				return new CanvasPattern();
			}
		} else throw new TypeError(`Failed to execute 'createPattern' on '${this.constructor.name}': The provided type ('${type}') is not one of 'repeat', 'no-repeat', 'repeat-x', or 'repeat-y'.`);
		throw new TypeError(`Failed to execute 'createPattern' on '${this.constructor.name}': The provided value is not of type '(CSSImageValue or HTMLImageElement or SVGImageElement or HTMLVideoElement or HTMLCanvasElement or ImageBitmap or OffscreenCanvas)'`);
	}
	createRadialGradient(x0, y0, r0, x1, y1, r1) {
		if (arguments.length < 6) throw new TypeError(`Failed to execute 'createRadialGradient' on '${this.constructor.name}': 6 arguments required, but only ${arguments.length} present.`);
		const x0Result = Number(x0);
		const y0Result = Number(y0);
		const r0Result = Number(r0);
		const x1Result = Number(x1);
		const y1Result = Number(y1);
		const r1Result = Number(r1);
		if (!Number.isFinite(x0Result + y0Result + r0Result + x1Result + y1Result + r1Result)) throw new TypeError(`Failed to execute 'createRadialGradient' on '${this.constructor.name}': The provided double value is non-finite.`);
		if (r0Result < 0) throw new DOMException(`Failed to execute 'createRadialGradient' on '${this.constructor.name}': The r0 provided is less than 0.`, "IndexSizeError");
		if (r1Result < 0) throw new DOMException(`Failed to execute 'createRadialGradient' on '${this.constructor.name}': The r1 provided is less than 0.`, "IndexSizeError");
		const event = createCanvasEvent("createRadialGradient", getTransformSlice(this), {
			x0: x0Result,
			y0: y0Result,
			r0: r0Result,
			x1: x1Result,
			y1: y1Result,
			r1: r1Result
		});
		this._events.push(event);
		return new CanvasGradient();
	}
	set currentTransform(value) {
		if (value instanceof DOMMatrix) {
			this._transformStack[this._stackIndex][0] = value.a;
			this._transformStack[this._stackIndex][1] = value.b;
			this._transformStack[this._stackIndex][2] = value.c;
			this._transformStack[this._stackIndex][3] = value.d;
			this._transformStack[this._stackIndex][4] = value.e;
			this._transformStack[this._stackIndex][5] = value.f;
			const event = createCanvasEvent("currentTransform", getTransformSlice(this), {
				a: value.a,
				b: value.b,
				c: value.c,
				d: value.d,
				e: value.e,
				f: value.f
			});
			this._events.push(event);
		}
	}
	get currentTransform() {
		return new DOMMatrix(this._transformStack[this._stackIndex]);
	}
	set direction(value) {
		if (value === "rtl" || value === "ltr" || value === "inherit") {
			this._directionStack[this._stackIndex] = value;
			const event = createCanvasEvent("direction", getTransformSlice(this), { value });
			this._events.push(event);
		}
	}
	get direction() {
		return this._directionStack[this._stackIndex];
	}
	drawFocusIfNeeded(path, element) {
		if (arguments.length === 0) throw new TypeError(`Failed to execute 'drawFocusIfNeeded' on '${this.constructor.name}': 1 argument required, but only 0 present.`);
		if (arguments.length === 2 && !(path instanceof Path2D)) throw new TypeError(`Failed to execute 'drawFocusIfNeeded' on '${this.constructor.name}': parameter 1 is not of type 'Path2D'.`);
		if (arguments.length === 1) {
			element = path;
			path = null;
		}
		if (!(element instanceof Element)) throw new TypeError(`Failed to execute 'drawFocusIfNeeded' on '${this.constructor.name}': parameter ${arguments.length} is not of type 'Element'.`);
		const event = createCanvasEvent("drawFocusIfNeeded", getTransformSlice(this), {
			path: path ? path._path : null,
			element
		});
		this._events.push(event);
	}
	drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
		if (arguments.length < 3) throw new TypeError(`Failed to execute 'drawImage' on '${this.constructor.name}': 3 arguments required, but only ${arguments.length} present.`);
		if (arguments.length === 4 || arguments.length > 5 && arguments.length < 9) throw new TypeError(`Failed to execute 'drawImage' on '${this.constructor.name}': Valid arities are: [3, 5, 9], but 4 arguments provided.`);
		let valid = false;
		if (img instanceof HTMLImageElement) valid = true;
		if (img instanceof ImageBitmap) {
			if (img._closed) throw new DOMException("DOMException: Failed to execute 'drawImage' on 'CanvasRenderingContext2D': The image source is detached.", "InvalidStateError");
			valid = true;
		}
		if (img instanceof HTMLVideoElement) valid = true;
		if (img instanceof HTMLCanvasElement) valid = true;
		if (!valid) throw new TypeError(`Failed to execute 'drawImage' on '${this.constructor.name}': The provided value is not of type '(CSSImageValue or HTMLImageElement or SVGImageElement or HTMLVideoElement or HTMLCanvasElement or ImageBitmap or OffscreenCanvas)'`);
		const sxResult = Number(sx);
		const syResult = Number(sy);
		const sWidthResult = Number(sWidth);
		const sHeightResult = Number(sHeight);
		const dxResult = Number(dx);
		const dyResult = Number(dy);
		const dWidthResult = Number(dWidth);
		const dHeightResult = Number(dHeight);
		if (arguments.length === 3) {
			if (!Number.isFinite(sxResult + syResult)) return;
			sx = 0;
			sy = 0;
			sWidth = img.width;
			sHeight = img.height;
			dx = sxResult;
			dy = syResult;
			dWidth = img.width;
			dHeight = img.height;
		} else if (arguments.length === 5) {
			if (!Number.isFinite(sxResult + syResult + sWidthResult + sHeightResult)) return;
			sx = 0;
			sy = 0;
			sWidth = img.width;
			sHeight = img.height;
			dx = sxResult;
			dy = syResult;
			dWidth = sWidth;
			dHeight = sHeight;
		} else {
			if (!Number.isFinite(sx + sy + sWidth + sHeight + dx + dy + dWidth + dHeight)) return;
			sx = sxResult;
			sy = syResult;
			sWidth = sWidthResult;
			sHeight = sHeightResult;
			dx = dxResult;
			dy = dyResult;
			dWidth = dWidthResult;
			dHeight = dHeightResult;
		}
		const event = createCanvasEvent("drawImage", getTransformSlice(this), {
			img,
			sx,
			sy,
			sWidth,
			sHeight,
			dx,
			dy,
			dWidth,
			dHeight
		});
		this._events.push(event);
		this._drawCalls.push(event);
	}
	ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise = false) {
		if (arguments.length < 7) throw new TypeError(`Failed to execute 'ellipse' on '${this.constructor.name}': 6 arguments required, but only ${arguments.length} present.`);
		const xResult = Number(x);
		const yResult = Number(y);
		const radiusXResult = Number(radiusX);
		const radiusYResult = Number(radiusY);
		const rotationResult = Number(rotation);
		const startAngleResult = Number(startAngle);
		const endAngleResult = Number(endAngle);
		const anticlockwiseResult = Boolean(anticlockwise);
		if (!Number.isFinite(xResult + yResult + radiusXResult + radiusYResult + rotationResult + startAngleResult + endAngleResult)) return;
		if (Number(radiusX) < 0) throw new DOMException(`Failed to execute 'ellipse' on '${this.constructor.name}': The major-axis radius provided (${radiusX}) is negative.`, "IndexSizeError");
		if (Number(radiusY) < 0) throw new DOMException(`Failed to execute 'ellipse' on '${this.constructor.name}': The minor-axis radius provided (${radiusY}) is negative.`, "IndexSizeError");
		const event = createCanvasEvent("ellipse", getTransformSlice(this), {
			x: xResult,
			y: yResult,
			radiusX: radiusXResult,
			radiusY: radiusYResult,
			rotation: rotationResult,
			startAngle: startAngleResult,
			endAngle: endAngleResult,
			anticlockwise: anticlockwiseResult
		});
		this._path.push(event);
		this._events.push(event);
	}
	fill(path, fillRule) {
		if (arguments.length === 0) {
			fillRule = "nonzero";
			path = this._path.slice();
		} else {
			if (arguments.length === 1) fillRule = "nonzero";
			if (path instanceof Path2D) {
				fillRule = String(fillRule);
				if (fillRule !== "nonzero" && fillRule !== "evenodd") throw new TypeError(`Failed to execute 'clip' on '${this.constructor.name}': The provided value '${fillRule}' is not a valid enum value of type CanvasFillRule.`);
				path = path._path.slice();
			} else {
				fillRule = String(path);
				if (fillRule !== "nonzero" && fillRule !== "evenodd") throw new TypeError(`Failed to execute 'clip' on '${this.constructor.name}': The provided value '${fillRule}' is not a valid enum value of type CanvasFillRule.`);
				path = this._path.slice();
			}
		}
		const event = createCanvasEvent("fill", getTransformSlice(this), {
			path,
			fillRule
		});
		this._events.push(event);
		this._drawCalls.push(event);
	}
	fillRect(x, y, width, height) {
		if (arguments.length < 4) throw new TypeError(`Failed to execute 'fillRect' on '${this.constructor.name}': 4 arguments required, but only ${arguments.length} present.`);
		const xResult = Number(x);
		const yResult = Number(y);
		const widthResult = Number(width);
		const heightResult = Number(height);
		if (!Number.isFinite(x + y + width + height)) return;
		const event = createCanvasEvent("fillRect", getTransformSlice(this), {
			x: xResult,
			y: yResult,
			width: widthResult,
			height: heightResult
		});
		this._events.push(event);
		this._drawCalls.push(event);
	}
	set fillStyle(value) {
		let valid = false;
		if (typeof value === "string") try {
			const result = new moo_color.MooColor(value);
			valid = true;
			value = this._fillStyleStack[this._stackIndex] = serializeColor(result);
		} catch {
			return;
		}
		else if (value instanceof CanvasGradient || value instanceof CanvasPattern) {
			valid = true;
			this._fillStyleStack[this._stackIndex] = value;
		}
		if (valid) {
			const event = createCanvasEvent("fillStyle", getTransformSlice(this), { value });
			this._events.push(event);
		}
	}
	get fillStyle() {
		return this._fillStyleStack[this._stackIndex];
	}
	fillText(text, x, y, maxWidth) {
		if (arguments.length < 3) throw new TypeError(`Failed to execute 'fillText' on '${this.constructor.name}': 3 arguments required, but only ${arguments.length} present.`);
		const textResult = String(text);
		const xResult = Number(x);
		const yResult = Number(y);
		const maxWidthResult = Number(maxWidth);
		if (arguments.length === 3 && !Number.isFinite(xResult + yResult)) return;
		if (arguments.length > 3 && !Number.isFinite(xResult + yResult + maxWidthResult)) return;
		const event = createCanvasEvent("fillText", getTransformSlice(this), {
			text: textResult,
			x: xResult,
			y: yResult,
			maxWidth: arguments.length === 3 ? null : maxWidthResult
		});
		this._events.push(event);
		this._drawCalls.push(event);
	}
	set filter(value) {
		if (value === "") value = "none";
		value = this._filterStack[this._stackIndex] = typeof value === "string" ? value : "none";
		const event = createCanvasEvent("filter", getTransformSlice(this), { value });
		this._events.push(event);
	}
	get filter() {
		return this._filterStack[this._stackIndex];
	}
	set font(value) {
		try {
			const result = (0, cssfontparser.default)(value);
			value = this._fontStack[this._stackIndex] = result.toString();
			const event = createCanvasEvent("font", getTransformSlice(this), { value });
			this._events.push(event);
		} catch {}
	}
	get font() {
		return this._fontStack[this._stackIndex];
	}
	getImageData(x, y, w, h) {
		if (arguments.length < 4) throw new TypeError(`Failed to execute 'getImageData' on '${this.constructor.name}': 4 arguments required, but only ${arguments.length} present.`);
		if (w === 0 || h === 0) throw new DOMException(`Failed to execute 'getImageData' on '${this.constructor.name}': The source ${w === 0 ? "width" : "height"} is 0.`, "IndexSizeError");
		return new ImageData(Math.abs(w), Math.abs(h));
	}
	getLineDash() {
		return this._lineDashStack[this._stackIndex];
	}
	getTransform() {
		return new DOMMatrix(this._transformStack[this._stackIndex]);
	}
	set globalAlpha(value) {
		value = Number(value);
		if (!Number.isFinite(value)) return;
		if (value < 0) return;
		if (value > 1) return;
		this._globalAlphaStack[this._stackIndex] = value;
		const event = createCanvasEvent("globalAlpha", getTransformSlice(this), { value });
		this._events.push(event);
	}
	get globalAlpha() {
		return this._globalAlphaStack[this._stackIndex];
	}
	set globalCompositeOperation(value) {
		if (compositeOperations.includes(value)) {
			this._globalCompositeOperationStack[this._stackIndex] = value;
			const event = createCanvasEvent("globalCompositeOperation", getTransformSlice(this), { value });
			this._events.push(event);
		}
	}
	get globalCompositeOperation() {
		return this._globalCompositeOperationStack[this._stackIndex];
	}
	set imageSmoothingEnabled(value) {
		value = this._imageSmoothingEnabledStack[this._stackIndex] = Boolean(value);
		const event = createCanvasEvent("imageSmoothingEnabled", getTransformSlice(this), { value });
		this._events.push(event);
	}
	get imageSmoothingEnabled() {
		return this._imageSmoothingEnabledStack[this._stackIndex];
	}
	set imageSmoothingQuality(value) {
		if (value === "high" || value === "medium" || value === "low") {
			this._imageSmoothingQualityStack[this._stackIndex] = value;
			const event = createCanvasEvent("imageSmoothingQuality", getTransformSlice(this), { value });
			this._events.push(event);
		}
	}
	get imageSmoothingQuality() {
		return this._imageSmoothingQualityStack[this._stackIndex];
	}
	isPointInPath(path, x, y, fillRule = "nonzero") {
		if (arguments.length < 2) throw new TypeError(`Failed to execute 'isPointInPath' on '${this.constructor.name}': 2 arguments required, but only ${arguments.length} present.`);
		if (!(path instanceof Path2D)) {
			if (arguments.length > 2) fillRule = y;
			y = x;
			x = path;
		}
		if (fillRule !== "nonzero" && fillRule !== "evenodd") throw new TypeError(`Failed to execute 'isPointInPath' on '${this.constructor.name}': The provided value '${fillRule}' is not a valid enum value of type CanvasFillRule.`);
		const event = createCanvasEvent("isPointInPath", getTransformSlice(this), {
			x: Number(x),
			y: Number(y),
			fillRule,
			path: path instanceof Path2D ? path._path.slice() : this._path.slice()
		});
		this._events.push(event);
		return false;
	}
	isPointInStroke(path, x, y) {
		if (arguments.length < 2) throw new TypeError(`Failed to execute 'isPointInStroke' on '${this.constructor.name}': 2 arguments required, but only ${arguments.length} present.`);
		if (!(path instanceof Path2D)) {
			y = x;
			x = path;
		}
		const event = createCanvasEvent("isPointInPath", getTransformSlice(this), {
			x: Number(x),
			y: Number(y),
			path: path instanceof Path2D ? path._path.slice() : this._path.slice()
		});
		this._events.push(event);
		return false;
	}
	set lineCap(value) {
		if (value === "butt" || value === "round" || value === "square") {
			this._lineCapStack[this._stackIndex] = value;
			const event = createCanvasEvent("lineCap", getTransformSlice(this), { value });
			this._events.push(event);
		}
	}
	get lineCap() {
		return this._lineCapStack[this._stackIndex];
	}
	set lineDashOffset(value) {
		const result = Number(value);
		if (Number.isFinite(result)) {
			this._lineDashOffsetStack[this._stackIndex] = result;
			const event = createCanvasEvent("lineDashOffset", getTransformSlice(this), { value });
			this._events.push(event);
		}
	}
	get lineDashOffset() {
		return this._lineDashOffsetStack[this._stackIndex];
	}
	set lineJoin(value) {
		if (value === "round" || value === "bevel" || value === "miter") {
			this._lineJoinStack[this._stackIndex] = value;
			const event = createCanvasEvent("lineJoin", getTransformSlice(this), { value });
			this._events.push(event);
		}
	}
	get lineJoin() {
		return this._lineJoinStack[this._stackIndex];
	}
	lineTo(x, y) {
		if (arguments.length < 2) throw new TypeError(`Failed to execute 'lineTo' on '${this.constructor.name}': 2 arguments required, but only ${arguments.length} present.`);
		const xResult = Number(x);
		const yResult = Number(y);
		if (!Number.isFinite(xResult + yResult)) return;
		const event = createCanvasEvent("lineTo", getTransformSlice(this), {
			x: xResult,
			y: yResult
		});
		this._events.push(event);
		this._path.push(event);
	}
	set lineWidth(value) {
		const result = Number(value);
		if (Number.isFinite(result) && result > 0) {
			this._lineWidthStack[this._stackIndex] = result;
			const event = createCanvasEvent("lineWidth", getTransformSlice(this), { value: result });
			this._events.push(event);
		}
	}
	get lineWidth() {
		return this._lineWidthStack[this._stackIndex];
	}
	measureText(text) {
		if (arguments.length < 1) throw new TypeError(`Failed to execute 'measureText' on '${this.constructor.name}': 1 argument required, but only 0 present.`);
		text = text == null ? "" : text;
		text = text.toString();
		const event = createCanvasEvent("measureText", getTransformSlice(this), { text });
		this._events.push(event);
		return new TextMetrics(text);
	}
	set miterLimit(value) {
		const result = Number(value);
		if (Number.isFinite(result) && result > 0) {
			this._miterLimitStack[this._stackIndex] = result;
			const event = createCanvasEvent("lineWidth", getTransformSlice(this), { value: result });
			this._events.push(event);
		}
	}
	get miterLimit() {
		return this._miterLimitStack[this._stackIndex];
	}
	moveTo(x, y) {
		if (arguments.length < 2) throw new TypeError(`Failed to execute 'moveTo' on '${this.constructor.name}': 2 arguments required, but only ${arguments.length} present.`);
		const xResult = Number(x);
		const yResult = Number(y);
		if (!Number.isFinite(x + y)) return;
		const event = createCanvasEvent("moveTo", getTransformSlice(this), {
			x: xResult,
			y: yResult
		});
		this._events.push(event);
		this._path.push(event);
	}
	putImageData(data, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
		if (arguments.length < 3) throw new TypeError(`Failed to execute 'putImageData' on '${this.constructor.name}': 3 arguments required, but only ${arguments.length} present.`);
		if (arguments.length > 3 && arguments.length < 7) throw new TypeError(`Failed to execute 'putImageData' on '${this.constructor.name}': Valid arities are: [3, 7], but ${arguments.length} arguments provided.`);
		if (!(data instanceof ImageData)) throw new TypeError(`Failed to execute 'putImageData' on '${this.constructor.name}': parameter 1 is not of type 'ImageData'.`);
		const xResult = Number(x);
		const yResult = Number(y);
		const dirtyXResult = Number(dirtyX);
		const dirtyYResult = Number(dirtyY);
		const dirtyWidthResult = Number(dirtyWidth);
		const dirtyHeightResult = Number(dirtyHeight);
		if (arguments.length === 3) {
			if (!Number.isFinite(xResult + yResult)) return;
		} else if (!Number.isFinite(xResult + yResult + dirtyXResult + dirtyYResult + dirtyWidthResult + dirtyHeightResult)) return;
		const event = createCanvasEvent("putImageData", getTransformSlice(this), {
			x: xResult,
			y: yResult,
			dirtyX: dirtyXResult,
			dirtyY: dirtyYResult,
			dirtyWidth: dirtyWidthResult,
			dirtyHeight: dirtyHeightResult
		});
		this._events.push(event);
	}
	quadraticCurveTo(cpx, cpy, x, y) {
		if (arguments.length < 4) throw new TypeError(`Failed to execute 'quadraticCurveTo' on '${this.constructor.name}': 4 arguments required, but only ${arguments.length} present.`);
		const cpxResult = Number(cpx);
		const cpyResult = Number(cpy);
		const xResult = Number(x);
		const yResult = Number(y);
		if (!Number.isFinite(cpxResult + cpyResult + xResult + yResult)) return;
		const event = createCanvasEvent("quadraticCurveTo", getTransformSlice(this), {
			cpx: cpxResult,
			cpy: cpyResult,
			x: xResult,
			y: yResult
		});
		this._events.push(event);
	}
	rect(x, y, width, height) {
		if (arguments.length < 4) throw new TypeError(`Failed to execute 'rect' on '${this.constructor.name}': 4 arguments required, but only ${arguments.length} present.`);
		if (!Number.isFinite(x + y + width + height)) return;
		const xResult = Number(x);
		const yResult = Number(y);
		const widthResult = Number(width);
		const heightResult = Number(height);
		const event = createCanvasEvent("rect", getTransformSlice(this), {
			x: xResult,
			y: yResult,
			width: widthResult,
			height: heightResult
		});
		this._events.push(event);
		this._path.push(event);
	}
	removeHitRegion(id) {
		if (arguments.length < 1) throw new TypeError(`Failed to execute 'removeHitRegion' on '${this.constructor.name}': 1 argument required, but only ${arguments.length} present.`);
		const event = createCanvasEvent("removeHitRegion", getTransformSlice(this), { id });
		this._events.push(event);
	}
	resetTransform() {
		this._transformStack[this._stackIndex][0] = 1;
		this._transformStack[this._stackIndex][1] = 0;
		this._transformStack[this._stackIndex][2] = 0;
		this._transformStack[this._stackIndex][3] = 1;
		this._transformStack[this._stackIndex][4] = 0;
		this._transformStack[this._stackIndex][5] = 0;
		const event = createCanvasEvent("resetTransform", getTransformSlice(this), {
			a: 1,
			b: 0,
			c: 0,
			d: 1,
			e: 0,
			f: 0
		});
		this._events.push(event);
	}
	restore() {
		if (this._stackIndex <= 0) return;
		this._transformStack.pop();
		this._clipStack.pop();
		this._directionStack.pop();
		this._fillStyleStack.pop();
		this._filterStack.pop();
		this._fontStack.pop();
		this._globalAlphaStack.pop();
		this._globalCompositeOperationStack.pop();
		this._imageSmoothingEnabledStack.pop();
		this._imageSmoothingQualityStack.pop();
		this._lineCapStack.pop();
		this._lineDashStack.pop();
		this._lineDashOffsetStack.pop();
		this._lineJoinStack.pop();
		this._lineWidthStack.pop();
		this._miterLimitStack.pop();
		this._shadowBlurStack.pop();
		this._shadowColorStack.pop();
		this._shadowOffsetXStack.pop();
		this._shadowOffsetYStack.pop();
		this._strokeStyleStack.pop();
		this._textAlignStack.pop();
		this._textBaselineStack.pop();
		this._stackIndex -= 1;
		const event = createCanvasEvent("restore", getTransformSlice(this), {});
		this._events.push(event);
	}
	roundRect(x, y, width, height, radii) {
		if (arguments.length < 4) throw new TypeError(`Failed to execute 'roundRect' on '${this.constructor.name}': 4 arguments required, but only ${arguments.length} present.`);
		if (radii.constructor === Array && (radii.length === 0 || radii.length > 4)) throw new TypeError(`Failed to execute 'roundRect' on '${this.constructor.name}': ${radii.length} radii provided. Between one and four radii are necessary.`);
		if (!Number.isFinite(x + y + width + height)) return;
		const xResult = Number(x);
		const yResult = Number(y);
		const widthResult = Number(width);
		const heightResult = Number(height);
		const event = createCanvasEvent("roundRect", getTransformSlice(this), {
			x: xResult,
			y: yResult,
			width: widthResult,
			height: heightResult,
			radii
		});
		this._events.push(event);
		this._path.push(event);
	}
	rotate(angle) {
		if (arguments.length < 1) throw new TypeError(`Failed to execute 'rotate' on '${this.constructor.name}': 1 argument required, but only 0 present.`);
		angle = Number(angle);
		if (!Number.isFinite(angle)) return;
		const a = this._transformStack[this._stackIndex][0];
		const b = this._transformStack[this._stackIndex][1];
		const c = this._transformStack[this._stackIndex][2];
		const d = this._transformStack[this._stackIndex][3];
		const cos = Math.cos(angle);
		const sin = Math.sin(angle);
		this._transformStack[this._stackIndex][0] = a * cos + c * sin;
		this._transformStack[this._stackIndex][1] = b * cos + d * sin;
		this._transformStack[this._stackIndex][2] = c * cos - a * sin;
		this._transformStack[this._stackIndex][3] = d * cos - b * sin;
		const event = createCanvasEvent("rotate", getTransformSlice(this), { angle });
		this._events.push(event);
	}
	save() {
		const stackIndex = this._stackIndex;
		this._transformStack.push(this._transformStack[stackIndex].slice());
		this._directionStack.push(this._directionStack[stackIndex]);
		this._fillStyleStack.push(this._fillStyleStack[stackIndex]);
		this._filterStack.push(this._filterStack[stackIndex]);
		this._fontStack.push(this._fontStack[stackIndex]);
		this._globalAlphaStack.push(this._globalAlphaStack[stackIndex]);
		this._globalCompositeOperationStack.push(this._globalCompositeOperationStack[stackIndex]);
		this._imageSmoothingEnabledStack.push(this._imageSmoothingEnabledStack[stackIndex]);
		this._imageSmoothingQualityStack.push(this._imageSmoothingQualityStack[stackIndex]);
		this._lineCapStack.push(this._lineCapStack[stackIndex]);
		this._lineDashStack.push(this._lineDashStack[stackIndex]);
		this._lineDashOffsetStack.push(this._lineDashOffsetStack[stackIndex]);
		this._lineJoinStack.push(this._lineJoinStack[stackIndex]);
		this._lineWidthStack.push(this._lineWidthStack[stackIndex]);
		this._miterLimitStack.push(this._miterLimitStack[stackIndex]);
		this._shadowBlurStack.push(this._shadowBlurStack[stackIndex]);
		this._shadowColorStack.push(this._shadowColorStack[stackIndex]);
		this._shadowOffsetXStack.push(this._shadowOffsetXStack[stackIndex]);
		this._shadowOffsetYStack.push(this._shadowOffsetYStack[stackIndex]);
		this._strokeStyleStack.push(this._strokeStyleStack[stackIndex]);
		this._textAlignStack.push(this._textAlignStack[stackIndex]);
		this._textBaselineStack.push(this._textBaselineStack[stackIndex]);
		this._clipStack.push(this._clipStack[stackIndex].slice());
		this._stackIndex = stackIndex + 1;
		const event = createCanvasEvent("save", getTransformSlice(this), {});
		this._events.push(event);
	}
	scale(x, y) {
		if (arguments.length < 2) throw new TypeError(`Failed to execute 'scale' on '${this.constructor.name}': 2 arguments required, but only ${arguments.length} present.`);
		const xResult = Number(x);
		const yResult = Number(y);
		if (Number.isFinite(xResult) && Number.isFinite(yResult)) {
			this._transformStack[this._stackIndex][0] *= xResult;
			this._transformStack[this._stackIndex][1] *= xResult;
			this._transformStack[this._stackIndex][2] *= yResult;
			this._transformStack[this._stackIndex][3] *= yResult;
			const event = createCanvasEvent("scale", getTransformSlice(this), {
				x: xResult,
				y: yResult
			});
			this._events.push(event);
		}
	}
	scrollPathIntoView(path) {
		if (arguments.length > 0 && path instanceof Path2D) path = path._path.slice();
		else path = this._path.slice();
		const event = createCanvasEvent("scrollPathIntoView", getTransformSlice(this), { path });
		this._events.push(event);
	}
	setLineDash(lineDash) {
		if (![
			Array,
			Int8Array,
			Uint8Array,
			Int16Array,
			Uint16Array,
			Int32Array,
			Uint32Array,
			Float32Array,
			Float64Array
		].reduce((left, right) => left || lineDash instanceof right, false)) throw new TypeError(`Failed to execute 'setLineDash' on '${this.constructor.name}': The provided value cannot be converted to a sequence.`);
		let result = [];
		for (let i = 0; i < lineDash.length; i++) {
			const value = Number(lineDash[i]);
			if (Number.isFinite(value) && value >= 0) result.push(value);
			else return;
		}
		result = this._lineDashStack[this._stackIndex] = result.length % 2 === 1 ? result.concat(result) : result;
		const event = createCanvasEvent("setLineDash", getTransformSlice(this), { segments: result.slice() });
		this._events.push(event);
	}
	setTransform(a, b, c, d, e, f) {
		if (arguments.length === 0) {
			a = 1;
			b = 0;
			c = 0;
			d = 1;
			e = 0;
			f = 0;
		} else if (arguments.length === 1) if (a instanceof DOMMatrix) {
			const transform = a;
			a = transform.a;
			b = transform.b;
			c = transform.c;
			d = transform.d;
			e = transform.e;
			f = transform.f;
		} else throw new TypeError(`Failed to execute 'setTransform' on '${this.constructor.name}': parameter ${a} ('transform') is not an object.`);
		else if (arguments.length < 6) throw new TypeError(`Failed to execute 'setTransform' on '${this.constructor.name}': Valid arities are: [0, 1, 6], but ${arguments.length} arguments provided.`);
		a = Number(a);
		b = Number(b);
		c = Number(c);
		d = Number(d);
		e = Number(e);
		f = Number(f);
		if (!Number.isFinite(a + b + c + d + e + f)) return;
		this._transformStack[this._stackIndex][0] = a;
		this._transformStack[this._stackIndex][1] = b;
		this._transformStack[this._stackIndex][2] = c;
		this._transformStack[this._stackIndex][3] = d;
		this._transformStack[this._stackIndex][4] = e;
		this._transformStack[this._stackIndex][5] = f;
		const event = createCanvasEvent("setTransform", getTransformSlice(this), {
			a,
			b,
			c,
			d,
			e,
			f
		});
		this._events.push(event);
	}
	set shadowBlur(value) {
		const result = Number(value);
		if (Number.isFinite(result) && result > 0) {
			this._shadowBlurStack[this._stackIndex] = result;
			const event = createCanvasEvent("shadowBlur", getTransformSlice(this), { value: result });
			this._events.push(event);
		}
	}
	get shadowBlur() {
		return this._shadowBlurStack[this._stackIndex];
	}
	set shadowColor(value) {
		if (typeof value === "string") {
			try {
				const result = new moo_color.MooColor(value);
				value = this._shadowColorStack[this._stackIndex] = serializeColor(result);
			} catch {
				return;
			}
			const event = createCanvasEvent("shadowColor", getTransformSlice(this), { value });
			this._events.push(event);
		}
	}
	get shadowColor() {
		return this._shadowColorStack[this._stackIndex];
	}
	set shadowOffsetX(value) {
		const result = Number(value);
		if (Number.isFinite(result)) {
			this._shadowOffsetXStack[this._stackIndex] = result;
			const event = createCanvasEvent("shadowOffsetX", getTransformSlice(this), { value: result });
			this._events.push(event);
		}
	}
	get shadowOffsetX() {
		return this._shadowOffsetXStack[this._stackIndex];
	}
	set shadowOffsetY(value) {
		const result = Number(value);
		if (Number.isFinite(result)) {
			this._shadowOffsetXStack[this._stackIndex] = result;
			const event = createCanvasEvent("shadowOffsetY", getTransformSlice(this), { value: result });
			this._events.push(event);
		}
	}
	get shadowOffsetY() {
		return this._shadowOffsetXStack[this._stackIndex];
	}
	stroke(path) {
		if (arguments.length === 0) path = this._path.slice();
		else {
			if (!(path instanceof Path2D)) throw new TypeError(`Failed to execute 'stroke' on '${this.constructor.name}': parameter 1 is not of type 'Path2D'.`);
			path = path._path.slice();
		}
		const event = createCanvasEvent("stroke", getTransformSlice(this), { path });
		this._events.push(event);
		this._drawCalls.push(event);
	}
	strokeRect(x, y, width, height) {
		if (arguments.length < 4) throw new TypeError(`Failed to execute 'strokeRect' on '${this.constructor.name}': 4 arguments required, but only ${arguments.length} present.`);
		x = Number(x);
		y = Number(y);
		width = Number(width);
		height = Number(height);
		if (!Number.isFinite(x + y + width + height)) return;
		const event = createCanvasEvent("strokeRect", getTransformSlice(this), {
			x,
			y,
			width,
			height
		});
		this._events.push(event);
		this._drawCalls.push(event);
	}
	set strokeStyle(value) {
		let valid = false;
		if (typeof value === "string") try {
			const result = new moo_color.MooColor(value);
			valid = true;
			value = this._strokeStyleStack[this._stackIndex] = serializeColor(result);
		} catch {
			return;
		}
		else if (value instanceof CanvasGradient || value instanceof CanvasPattern) {
			valid = true;
			this._strokeStyleStack[this._stackIndex] = value;
		}
		if (valid) {
			const event = createCanvasEvent("strokeStyle", getTransformSlice(this), { value });
			this._events.push(event);
		}
	}
	get strokeStyle() {
		return this._strokeStyleStack[this._stackIndex];
	}
	strokeText(text, x, y, maxWidth) {
		if (arguments.length < 3) throw new TypeError(`Failed to execute 'strokeText' on '${this.constructor.name}': 3 arguments required, but only ${arguments.length} present.`);
		const textResult = String(text);
		const xResult = Number(x);
		const yResult = Number(y);
		const maxWidthResult = Number(maxWidth);
		if (arguments.length === 3 && !Number.isFinite(xResult + yResult)) return;
		if (arguments.length > 3 && !Number.isFinite(xResult + yResult + maxWidthResult)) return;
		const event = createCanvasEvent("strokeText", getTransformSlice(this), {
			text: textResult,
			x: xResult,
			y: yResult,
			maxWidth: arguments.length === 3 ? null : maxWidthResult
		});
		this._events.push(event);
		this._drawCalls.push(event);
	}
	set textAlign(value) {
		if (value === "left" || value === "right" || value === "center" || value === "start" || value === "end") {
			this._textAlignStack[this._stackIndex] = value;
			const event = createCanvasEvent("textAlign", getTransformSlice(this), { value });
			this._events.push(event);
		}
	}
	get textAlign() {
		return this._textAlignStack[this._stackIndex];
	}
	set textBaseline(value) {
		if (value === "top" || value === "hanging" || value === "middle" || value === "alphabetic" || value === "ideographic" || value === "bottom") {
			this._textBaselineStack[this._stackIndex] = value;
			const event = createCanvasEvent("textBaseline", getTransformSlice(this), { value });
			this._events.push(event);
		}
	}
	get textBaseline() {
		return this._textBaselineStack[this._stackIndex];
	}
	transform(a, b, c, d, e, f) {
		if (arguments.length < 6) throw new TypeError(`Failed to execute 'transform' on '${this.constructor.name}': 6 arguments required, but only ${arguments.length} present.`);
		a = Number(a);
		b = Number(b);
		c = Number(c);
		d = Number(d);
		e = Number(e);
		f = Number(f);
		if (!Number.isFinite(a + b + c + d + e + f)) return;
		const sa = this._transformStack[this._stackIndex][0];
		const sb = this._transformStack[this._stackIndex][1];
		const sc = this._transformStack[this._stackIndex][2];
		const sd = this._transformStack[this._stackIndex][3];
		const se = this._transformStack[this._stackIndex][4];
		const sf = this._transformStack[this._stackIndex][5];
		this._transformStack[this._stackIndex][0] = sa * a + sc * b;
		this._transformStack[this._stackIndex][1] = sb * a + sd * b;
		this._transformStack[this._stackIndex][2] = sa * c + sc * d;
		this._transformStack[this._stackIndex][3] = sb * c + sd * d;
		this._transformStack[this._stackIndex][4] = sa * e + sc * f + se;
		this._transformStack[this._stackIndex][5] = sb * e + sd * f + sf;
		const event = createCanvasEvent("transform", getTransformSlice(this), {
			a,
			b,
			c,
			d,
			e,
			f
		});
		this._events.push(event);
	}
	translate(x, y) {
		if (arguments.length < 2) throw new TypeError(`Failed to execute 'translate' on '${this.constructor.name}': 2 arguments required, but only ${arguments.length} present.`);
		const xResult = Number(x);
		const yResult = Number(y);
		const a = this._transformStack[this._stackIndex][0];
		const b = this._transformStack[this._stackIndex][1];
		const c = this._transformStack[this._stackIndex][2];
		const d = this._transformStack[this._stackIndex][3];
		if (Number.isFinite(xResult + yResult)) {
			this._transformStack[this._stackIndex][4] += a * xResult + c * yResult;
			this._transformStack[this._stackIndex][5] += b * xResult + d * yResult;
			const event = createCanvasEvent("translate", getTransformSlice(this), {
				x: xResult,
				y: yResult
			});
			this._events.push(event);
		}
	}
};

//#endregion
//#region src/classes/ImageBitmap.js
var ImageBitmap$1 = class {
	width = 0;
	height = 0;
	_closed = false;
	constructor(width, height) {
		this.width = width;
		this.height = height;
		this.close = vitest.vi.fn(this.close.bind(this));
	}
	close() {
		this.width = 0;
		this.height = 0;
		this._closed = true;
	}
};

//#endregion
//#region src/classes/ImageData.js
var ImageData$1 = class {
	_width = 0;
	_height = 0;
	_data = null;
	get width() {
		return this._width;
	}
	get height() {
		return this._height;
	}
	get data() {
		return this._data;
	}
	constructor(arr, w, h) {
		if (arguments.length === 2) if (arr instanceof Uint8ClampedArray) {
			if (arr.length === 0) throw new RangeError("Source length must be a positive multiple of 4.");
			if (arr.length % 4 !== 0) throw new RangeError("Source length must be a positive multiple of 4.");
			if (!Number.isFinite(w)) throw new RangeError("The width is zero or not a number.");
			if (w === 0) throw new RangeError("The width is zero or not a number.");
			this._width = w;
			this._height = arr.length / 4 / w;
			this._data = arr;
		} else {
			const width = arr;
			const height = w;
			if (!Number.isFinite(height)) throw new RangeError("The height is zero or not a number.");
			if (height === 0) throw new RangeError("The height is zero or not a number.");
			if (!Number.isFinite(width)) throw new RangeError("The width is zero or not a number.");
			if (width === 0) throw new RangeError("The width is zero or not a number.");
			this._width = width;
			this._height = height;
			this._data = new Uint8ClampedArray(width * height * 4);
		}
		else if (arguments.length === 3) {
			if (!(arr instanceof Uint8ClampedArray)) throw new TypeError("First argument must be a Uint8ClampedArray when using 3 arguments.");
			if (arr.length === 0) throw new RangeError("Source length must be a positive multiple of 4.");
			if (arr.length % 4 !== 0) throw new RangeError("Source length must be a positive multiple of 4.");
			if (!Number.isFinite(h)) throw new RangeError("The height is zero or not a number.");
			if (h === 0) throw new RangeError("The height is zero or not a number.");
			if (!Number.isFinite(w)) throw new RangeError("The width is zero or not a number.");
			if (w === 0) throw new RangeError("The width is zero or not a number.");
			if (arr.length !== w * h * 4) throw new RangeError("Source doesn'n contain the exact number of pixels needed.");
			this._width = w;
			this._height = h;
			this._data = arr;
		} else throw new TypeError("Wrong number of arguments provided.");
	}
};

//#endregion
//#region src/mock/createImageBitmap.js
var createImageBitmap_default = vitest.vi.fn(function createImageBitmap(img, sx, sy, sWidth, sHeight, options) {
	const length = arguments.length;
	return new Promise((resolve, reject) => {
		if (length === 0) return reject(/* @__PURE__ */ new TypeError("Failed to execute 'createImageBitmap' on 'Window': 1 argument required, but only 0 present."));
		if (length === 3 || length === 4) return reject(/* @__PURE__ */ new TypeError(`Failed to execute 'createImageBitmap' on 'Window': Valid arities are: [1, 2, 5, 6], but ${length} arguments provided.`));
		let validImage = false;
		if (img instanceof HTMLImageElement) validImage = true;
		if (img instanceof HTMLVideoElement) validImage = true;
		if (img instanceof HTMLCanvasElement) validImage = true;
		if (img instanceof Blob || img && img.constructor && img.constructor.name === "Blob") validImage = true;
		if (img instanceof ImageBitmap$1) validImage = true;
		if (img instanceof ImageData) validImage = true;
		if (!validImage) return reject(/* @__PURE__ */ new TypeError("Failed to execute 'createImageBitmap' on 'Window': The provided value is not of type '(HTMLImageElement or SVGImageElement or HTMLVideoElement or HTMLCanvasElement or Blob or ImageData or ImageBitmap or OffscreenCanvas)'"));
		if (length >= 2) {
			let index = 6;
			if (length === 2) {
				index = 2;
				options = sx;
			}
			if (length === 5) options = null;
			if (options !== null && options !== void 0) {
				if (typeof options !== "object") throw new TypeError(`Failed to execute 'createImageBitmap' on 'Window': parameter ${index} ('options') is not an object.`);
			}
		}
		if (length >= 5) {
			sWidth = Number(sWidth);
			sHeight = Number(sHeight);
			if (sWidth === 0 || !Number.isFinite(sWidth)) return reject(/* @__PURE__ */ new RangeError("The crop rect width is 0."));
			if (sHeight === 0 || !Number.isFinite(sHeight)) return reject(/* @__PURE__ */ new RangeError("The crop rect height is 0."));
			sWidth = Math.abs(sWidth);
			sHeight = Math.abs(sHeight);
		} else {
			sWidth = img.width || 1;
			sHeight = img.height || 1;
		}
		return resolve(new ImageBitmap$1(sWidth, sHeight));
	});
});

//#endregion
//#region src/mock/prototype.js
function mockPrototype(win) {
	/**
	* This weakmap is designed to contain all of the generated canvas contexts. It's keys are the
	* jsdom canvases obtained by using the `this` keyword inside the `#getContext('2d')` function
	* call. It's values are the generated `CanvasRenderingContext2D` objects.
	*/
	const generatedContexts = /* @__PURE__ */ new WeakMap();
	/**
	* Overrides getContext. Every test run will create a new function that overrides the current
	* value of getContext. It attempts to preserve the original getContext function by storing it on
	* the callback as a property.
	*/
	const getContext2D = vitest.vi.fn(function getContext2d(type) {
		if (type === "2d") {
			/**
			* Contexts must be idempotent. Once they are generated, they should be returned when
			* getContext() is called on the same canvas object multiple times.
			*/
			if (generatedContexts.has(this)) return generatedContexts.get(this);
			const ctx = new CanvasRenderingContext2D(this);
			generatedContexts.set(this, ctx);
			return ctx;
		}
		try {
			if (!this.dataset.internalRequireTest) require("canvas");
		} catch {
			return null;
		}
		return getContext2D.internal.call(this, type);
	});
	let htmlCanvasElementPrototype = HTMLCanvasElement.prototype;
	if (win?.HTMLCanvasElement?.prototype) htmlCanvasElementPrototype = win?.HTMLCanvasElement?.prototype;
	if (!vitest.vi.isMockFunction(htmlCanvasElementPrototype.getContext)) getContext2D.internal = htmlCanvasElementPrototype.getContext;
	else getContext2D.internal = htmlCanvasElementPrototype.getContext.internal;
	htmlCanvasElementPrototype.getContext = getContext2D;
	/**
	* This function technically throws SecurityError at runtime, but it cannot be mocked, because
	* we don't know if the canvas is tainted. These kinds of errors will be silent.
	*/
	const toBlobOverride = vitest.vi.fn(function toBlobOverride$1(callback, mimetype) {
		if (arguments.length < 1) throw new TypeError("Failed to execute 'toBlob' on 'HTMLCanvasElement': 1 argument required, but only 0 present.");
		if (typeof callback !== "function") throw new TypeError("Failed to execute 'toBlob' on 'HTMLCanvasElement': The callback provided as parameter 1 is not a function.");
		/**
		* Mime type must be image/jpeg or image/webp exactly for the browser to accept it, otherwise
		* it's image/png.
		*/
		switch (mimetype) {
			case "image/webp": break;
			case "image/jpeg": break;
			default: mimetype = "image/png";
		}
		/**
		* This section creates a blob of size width * height * 4. This is not actually valid, because
		* jpeg size is variable, and so is png. TODO: Is there a better way to do this?
		*/
		const length = this.width * this.height * 4;
		const data = new Uint8Array(length);
		const blob = new window.Blob([data], { type: mimetype });
		setTimeout(() => callback(blob), 0);
	});
	if (!vitest.vi.isMockFunction(htmlCanvasElementPrototype.toBlob)) toBlobOverride.internal = htmlCanvasElementPrototype.toBlob;
	else toBlobOverride.internal = htmlCanvasElementPrototype.toBlob.internal;
	htmlCanvasElementPrototype.toBlob = toBlobOverride;
	/**
	* This section creates a dataurl with a validated mime type. This is not actually valid, because
	* jpeg size is variable, and so is png. TODO: Is there a better way to do this?
	*/
	const toDataURLOverride = vitest.vi.fn((type, _encoderOptions) => {
		switch (type) {
			case "image/jpeg": break;
			case "image/webp": break;
			default: type = "image/png";
		}
		/**
		* This is the smallest valid data url I could generate.
		*/
		return `data:${type};base64,00`;
	});
	if (!vitest.vi.isMockFunction(htmlCanvasElementPrototype.toDataURL)) toDataURLOverride.internal = htmlCanvasElementPrototype.toDataURL;
	else toDataURLOverride.internal = htmlCanvasElementPrototype.toDataURL.internal;
	htmlCanvasElementPrototype.toDataURL = toDataURLOverride;
}

//#endregion
//#region src/window.js
/**
* Created by hustcc 17/12/25.
* Contract: i@hust.cc
*/
var window_default = (win) => {
	if (!win.Path2D) win.Path2D = Path2D;
	if (!win.CanvasGradient) win.CanvasGradient = CanvasGradient$1;
	if (!win.CanvasPattern) win.CanvasPattern = CanvasPattern;
	if (!win.CanvasRenderingContext2D) win.CanvasRenderingContext2D = CanvasRenderingContext2D$1;
	if (!win.DOMMatrix) win.DOMMatrix = DOMMatrix;
	if (!win.ImageData) win.ImageData = ImageData$1;
	if (!win.TextMetrics) win.TextMetrics = TextMetrics;
	if (!win.ImageBitmap) win.ImageBitmap = ImageBitmap$1;
	if (!win.createImageBitmap) win.createImageBitmap = createImageBitmap_default;
	mockPrototype(win);
	return win;
};

//#endregion
//#region src/index.js
/**
* Created by hustcc 17/12/25.
* Contract: i@hust.cc
*/
if (typeof window !== "undefined") window_default(globalThis.window);
function setupVitestCanvasMock(window$1) {
	window_default(window$1 || globalThis.window);
}

//#endregion
exports.setupVitestCanvasMock = setupVitestCanvasMock;