// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var max1 = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var min1 = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordInt);
var safeIndex = function (arr) {
    return function (i) {
        return function (def) {
            return Data_Maybe.fromMaybe(def)(Data_Array.index(arr)(i));
        };
    };
};
var identityCurve = [ {
    input: 0.0,
    output: 0.0
}, {
    input: 1.0,
    output: 1.0
} ];
var findSegment = function (points) {
    return function (x) {
        if (Data_Array.length(points) < 2) {
            return new Data_Tuple.Tuple({
                input: 0.0,
                output: 0.0
            }, {
                input: 1.0,
                output: 1.0
            });
        };
        if (Data_Boolean.otherwise) {
            var defaultP2 = {
                input: 1.0,
                output: 1.0
            };
            var defaultP1 = {
                input: 0.0,
                output: 0.0
            };
            var go = function ($copy_i) {
                var $tco_done = false;
                var $tco_result;
                function $tco_loop(i) {
                    if (i >= (Data_Array.length(points) - 1 | 0)) {
                        $tco_done = true;
                        return new Data_Tuple.Tuple(safeIndex(points)(Data_Array.length(points) - 2 | 0)(defaultP1), safeIndex(points)(Data_Array.length(points) - 1 | 0)(defaultP2));
                    };
                    if (Data_Boolean.otherwise) {
                        var p2 = safeIndex(points)(i + 1 | 0)(defaultP2);
                        var p1 = safeIndex(points)(i)(defaultP1);
                        var $23 = x <= p2.input;
                        if ($23) {
                            $tco_done = true;
                            return new Data_Tuple.Tuple(p1, p2);
                        };
                        $copy_i = i + 1 | 0;
                        return;
                    };
                    throw new Error("Failed pattern match at Lattice.Services.Effects.ColorCurves (line 106, column 5 - line 114, column 29): " + [ i.constructor.name ]);
                };
                while (!$tco_done) {
                    $tco_result = $tco_loop($copy_i);
                };
                return $tco_result;
            };
            return go(0);
        };
        throw new Error("Failed pattern match at Lattice.Services.Effects.ColorCurves (line 99, column 1 - line 99, column 73): " + [ points.constructor.name, x.constructor.name ]);
    };
};
var defaultCurveParams = {
    master: identityCurve,
    red: identityCurve,
    green: identityCurve,
    blue: identityCurve
};
var createGammaCurve = function (gamma) {
    var gammaAmt = max(0.1)(min(10.0)(gamma));
    var mkPoint = function (x) {
        return {
            input: x,
            output: Data_Number.pow(x)(1.0 / gammaAmt)
        };
    };
    return map(mkPoint)([ 0.0, 0.25, 0.5, 0.75, 1.0 ]);
};
var clamp01 = /* #__PURE__ */ (function () {
    var $37 = max(0.0);
    var $38 = min(1.0);
    return function ($39) {
        return $37($38($39));
    };
})();
var createLiftCurve = function (lift) {
    return function (gamma) {
        var liftAmt = clamp01(lift);
        var gammaAmt = max(0.1)(min(10.0)(gamma));
        var midOut = Data_Number.pow(0.5)(1.0 / gammaAmt);
        return [ {
            input: 0.0,
            output: liftAmt
        }, {
            input: 0.5,
            output: midOut
        }, {
            input: 1.0,
            output: 1.0
        } ];
    };
};
var createSCurve = function (amount) {
    var sign = (function () {
        var $24 = amount < 0.0;
        if ($24) {
            return -1.0;
        };
        return 1.0;
    })();
    var amt = clamp01(Data_Number.abs(amount)) * 0.25;
    var highlight = 0.75 + sign * amt;
    var shadow = 0.25 - sign * amt;
    return [ {
        input: 0.0,
        output: 0.0
    }, {
        input: 0.25,
        output: shadow
    }, {
        input: 0.75,
        output: highlight
    }, {
        input: 1.0,
        output: 1.0
    } ];
};
var cubicBezier = function (t) {
    return function (p0) {
        return function (p1) {
            return function (p2) {
                return function (p3) {
                    var t$prime = clamp01(t);
                    var t2 = t$prime * t$prime;
                    var t3 = t2 * t$prime;
                    var mt = 1.0 - t$prime;
                    var mt2 = mt * mt;
                    var mt3 = mt2 * mt;
                    return mt3 * p0 + 3.0 * mt2 * t$prime * p1 + 3.0 * mt * t2 * p2 + t3 * p3;
                };
            };
        };
    };
};
var interpolateCurve = function (points) {
    return function (x) {
        if (Data_Array.length(points) < 2) {
            return x;
        };
        if (Data_Boolean.otherwise) {
            var v = findSegment(points)(x);
            var inRange = v.value1.input - v.value0.input;
            var t = (function () {
                var $28 = inRange > 1.0e-4;
                if ($28) {
                    return (x - v.value0.input) / inRange;
                };
                return 0.0;
            })();
            var cp2 = v.value1.output - (v.value1.output - v.value0.output) / 3.0;
            var cp1 = v.value0.output + (v.value1.output - v.value0.output) / 3.0;
            return cubicBezier(t)(v.value0.output)(cp1)(cp2)(v.value1.output);
        };
        throw new Error("Failed pattern match at Lattice.Services.Effects.ColorCurves (line 117, column 1 - line 117, column 57): " + [ points.constructor.name, x.constructor.name ]);
    };
};
var buildCurveLUT = function (points) {
    return map(function (i) {
        var normalized = Data_Int.toNumber(i) / 255.0;
        var result = interpolateCurve(points)(normalized);
        return Data_Int.round(max(0.0)(min(255.0)(result * 255.0)));
    })(Data_Array.range(0)(255));
};
var applyCurveLUT = function (lut) {
    return function (value) {
        var idx = Data_Int.round(clamp01(value) * 255.0);
        var safeIdx = max1(0)(min1(255)(idx));
        var result = safeIndex(lut)(safeIdx)(idx);
        return Data_Int.toNumber(result) / 255.0;
    };
};
var applyCurves = function (params) {
    return function (v) {
        var redLUT = buildCurveLUT(params.red);
        var masterLUT = buildCurveLUT(params.master);
        var r$prime = applyCurveLUT(redLUT)(applyCurveLUT(masterLUT)(v.value0));
        var greenLUT = buildCurveLUT(params.green);
        var g$prime = applyCurveLUT(greenLUT)(applyCurveLUT(masterLUT)(v.value1.value0));
        var blueLUT = buildCurveLUT(params.blue);
        var b$prime = applyCurveLUT(blueLUT)(applyCurveLUT(masterLUT)(v.value1.value1));
        return new Data_Tuple.Tuple(clamp01(r$prime), new Data_Tuple.Tuple(clamp01(g$prime), clamp01(b$prime)));
    };
};
export {
    defaultCurveParams,
    cubicBezier,
    buildCurveLUT,
    applyCurves,
    createSCurve,
    createLiftCurve,
    createGammaCurve
};
//# sourceMappingURL=index.js.map
