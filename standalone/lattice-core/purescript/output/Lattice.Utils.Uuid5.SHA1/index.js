// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var append = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_Foldable.foldableArray);
var div = /* #__PURE__ */ Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt);
var word32ToBytesBE = function (x) {
    return [ x >> 24 & 255, x >> 16 & 255, x >> 8 & 255, x & 255 ];
};
var sha1Pad = function (msg) {
    var msgLen = Data_Array.length(msg);
    var padLen = mod((55 - mod(msgLen)(64) | 0) + 64 | 0)(64) + 1 | 0;
    var padding = append([ 128 ])(Data_Array.replicate(padLen - 1 | 0)(0));
    var bitLen = msgLen * 8 | 0;
    var lenBytes = [ 0, 0, 0, 0, bitLen >> 24 & 255, bitLen >> 16 & 255, bitLen >> 8 & 255, bitLen & 255 ];
    return append(msg)(append(padding)(lenBytes));
};
var sha1K = function (i) {
    if (i < 20) {
        return 1518500249;
    };
    if (i < 40) {
        return 1859775393;
    };
    if (i < 60) {
        return -1894007588 | 0;
    };
    if (Data_Boolean.otherwise) {
        return -899497514 | 0;
    };
    throw new Error("Failed pattern match at Lattice.Utils.Uuid5.SHA1 (line 52, column 1 - line 52, column 23): " + [ i.constructor.name ]);
};
var sha1H4 = /* #__PURE__ */ (function () {
    return -1009589776 | 0;
})();
var sha1H3 = 271733878;
var sha1H2 = /* #__PURE__ */ (function () {
    return -1732584194 | 0;
})();
var sha1H1 = /* #__PURE__ */ (function () {
    return -271733879 | 0;
})();
var sha1H0 = 1732584193;
var sha1F = function (i) {
    return function (b) {
        return function (c) {
            return function (d) {
                if (i < 20) {
                    return b & c | ~b & d;
                };
                if (i < 40) {
                    return b ^ c ^ d;
                };
                if (i < 60) {
                    return b & c | b & d | c & d;
                };
                if (Data_Boolean.otherwise) {
                    return b ^ c ^ d;
                };
                throw new Error("Failed pattern match at Lattice.Utils.Uuid5.SHA1 (line 60, column 1 - line 60, column 53): " + [ i.constructor.name, b.constructor.name, c.constructor.name, d.constructor.name ]);
            };
        };
    };
};
var rotl32 = function (x) {
    return function (n) {
        return (x << n | x >> (32 - n | 0)) & (-1 | 0);
    };
};
var getByte = function (arr) {
    return function (idx) {
        return Data_Maybe.fromMaybe(0)(Data_Array.index(arr)(idx));
    };
};
var bytesToWord32BE = function (b0) {
    return function (b1) {
        return function (b2) {
            return function (b3) {
                return (b0 & 255) << 24 | (b1 & 255) << 16 | (b2 & 255) << 8 | b3 & 255;
            };
        };
    };
};
var sha1ProcessChunk = function (chunk) {
    return function (offset) {
        return function (v) {
            var getWord32 = function (i) {
                var idx = offset + (i * 4 | 0) | 0;
                return bytesToWord32BE(getByte(chunk)(idx))(getByte(chunk)(idx + 1 | 0))(getByte(chunk)(idx + 2 | 0))(getByte(chunk)(idx + 3 | 0));
            };
            var w0_15 = map(getWord32)(Data_Array.range(0)(15));
            var extend = function (ws) {
                return function (i) {
                    var val = Data_Maybe.fromMaybe(0)(Data_Array.index(ws)(i - 3 | 0)) ^ Data_Maybe.fromMaybe(0)(Data_Array.index(ws)(i - 8 | 0)) ^ Data_Maybe.fromMaybe(0)(Data_Array.index(ws)(i - 14 | 0)) ^ Data_Maybe.fromMaybe(0)(Data_Array.index(ws)(i - 16 | 0));
                    return append(ws)([ rotl32(val)(1) ]);
                };
            };
            var w = foldl(extend)(w0_15)(Data_Array.range(16)(79));
            var step = function (v1) {
                return function (i) {
                    var wi = Data_Maybe.fromMaybe(0)(Data_Array.index(w)(i));
                    var k = sha1K(i);
                    var f = sha1F(i)(v1.b)(v1.c)(v1.d);
                    var temp = ((((rotl32(v1.a)(5) + f | 0) + v1.e | 0) + k | 0) + wi | 0) & (-1 | 0);
                    return {
                        a: temp,
                        b: v1.a,
                        c: rotl32(v1.b)(30),
                        d: v1.c,
                        e: v1.d
                    };
                };
            };
            var result = foldl(step)({
                a: v.h0,
                b: v.h1,
                c: v.h2,
                d: v.h3,
                e: v.h4
            })(Data_Array.range(0)(79));
            return {
                h0: (v.h0 + result.a | 0) & (-1 | 0),
                h1: (v.h1 + result.b | 0) & (-1 | 0),
                h2: (v.h2 + result.c | 0) & (-1 | 0),
                h3: (v.h3 + result.d | 0) & (-1 | 0),
                h4: (v.h4 + result.e | 0) & (-1 | 0)
            };
        };
    };
};
var sha1 = function (input) {
    var padded = sha1Pad(input);
    var processChunks = function (h) {
        return function (chunkIdx) {
            return sha1ProcessChunk(padded)(chunkIdx * 64 | 0)(h);
        };
    };
    var numChunks = div(Data_Array.length(padded))(64);
    var result = foldl(processChunks)({
        h0: sha1H0,
        h1: sha1H1,
        h2: sha1H2,
        h3: sha1H3,
        h4: sha1H4
    })(Data_Array.range(0)(numChunks - 1 | 0));
    return append(word32ToBytesBE(result.h0))(append(word32ToBytesBE(result.h1))(append(word32ToBytesBE(result.h2))(append(word32ToBytesBE(result.h3))(word32ToBytesBE(result.h4)))));
};
export {
    sha1
};
//# sourceMappingURL=index.js.map
