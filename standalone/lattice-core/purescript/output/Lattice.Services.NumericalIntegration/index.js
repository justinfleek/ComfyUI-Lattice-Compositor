// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
import * as $$Math from "../Math/index.js";
var add = /* #__PURE__ */ Data_Semiring.add(Data_Semiring.semiringNumber);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var trapezoid = function (fa) {
    return function (fb) {
        return function (span) {
            return ((fa + fb) / 2.0) * span;
        };
    };
};
var speedToRate = function (speedPercent) {
    return speedPercent / 100.0;
};
var minSamples = 10;
var optimalSampleCount = function (span) {
    return function (minPerFrame) {
        var raw = max(minSamples)(Data_Int.floor(span) * minPerFrame | 0);
        var $19 = mod(raw)(2) === 0;
        if ($19) {
            return raw + 1 | 0;
        };
        return raw;
    };
};
var lerp = function (a) {
    return function (b) {
        return function (t) {
            return a + (b - a) * t;
        };
    };
};
var integrateTrapezoidal = function (f) {
    return function (a) {
        return function (b) {
            return function (numSamples) {
                var span = b - a;
                var $20 = span <= 0.0;
                if ($20) {
                    return 0.0;
                };
                var h = span / Data_Int.toNumber(numSamples);
                var samples = map(function (i) {
                    var x = a + Data_Int.toNumber(i) * h;
                    var coeff = (function () {
                        var $21 = i === 0 || i === numSamples;
                        if ($21) {
                            return 0.5;
                        };
                        return 1.0;
                    })();
                    return coeff * f(x);
                })(Data_Array.range(0)(numSamples));
                var total = Data_Array.foldl(add)(0.0)(samples);
                return h * total;
            };
        };
    };
};
var defaultTolerance = 1.0e-2;
var cumulativeSourceFrames = function (speedSamples) {
    return function (h) {
        var rates = map(speedToRate)(speedSamples);
        var lastOrDefault = function (def) {
            return function (arr) {
                var v = Data_Array.index(arr)(Data_Array.length(arr) - 1 | 0);
                if (v instanceof Data_Maybe.Just) {
                    return v.value0;
                };
                if (v instanceof Data_Maybe.Nothing) {
                    return def;
                };
                throw new Error("Failed pattern match at Lattice.Services.NumericalIntegration (line 208, column 31 - line 210, column 23): " + [ v.constructor.name ]);
            };
        };
        var scanl$prime = function (f) {
            return function (init) {
                return function (arr) {
                    return Data_Array.foldl(function (acc) {
                        return function (x) {
                            return Data_Array.snoc(acc)(f(lastOrDefault(init)(acc))(x));
                        };
                    })([ init ])(arr);
                };
            };
        };
        return scanl$prime(function (acc) {
            return function (r) {
                return acc + r * h;
            };
        })(0.0)(rates);
    };
};
var calculateFrameBlend = function (fractionalFrame) {
    var clamped = $$Math.max(0.0)(fractionalFrame);
    var floorF = Data_Int.floor(clamped);
    var ceilF = Data_Int.ceil(clamped);
    var blend = clamped - Data_Int.toNumber(floorF);
    return {
        floorFrame: floorF,
        ceilFrame: ceilF,
        blendFactor: blend
    };
};
var blendFrameValues = function (valueAtFloor) {
    return function (valueAtCeil) {
        return function (blend) {
            return lerp(valueAtFloor)(valueAtCeil)(blend.blendFactor);
        };
    };
};
var binarySearchIntegral = function (integrator) {
    return function (target) {
        return function (low) {
            return function (high) {
                return function (tolerance) {
                    var search = function ($copy_lo) {
                        return function ($copy_hi) {
                            return function ($copy_fuel) {
                                var $tco_var_lo = $copy_lo;
                                var $tco_var_hi = $copy_hi;
                                var $tco_done = false;
                                var $tco_result;
                                function $tco_loop(lo, hi, fuel) {
                                    if (fuel <= 0) {
                                        $tco_done = true;
                                        return (lo + hi) / 2.0;
                                    };
                                    if (hi - lo <= tolerance) {
                                        $tco_done = true;
                                        return (lo + hi) / 2.0;
                                    };
                                    if (Data_Boolean.otherwise) {
                                        var mid = (lo + hi) / 2.0;
                                        var valueAtMid = integrator(mid);
                                        var $27 = valueAtMid < target;
                                        if ($27) {
                                            $tco_var_lo = mid;
                                            $tco_var_hi = hi;
                                            $copy_fuel = fuel - 1 | 0;
                                            return;
                                        };
                                        $tco_var_lo = lo;
                                        $tco_var_hi = mid;
                                        $copy_fuel = fuel - 1 | 0;
                                        return;
                                    };
                                    throw new Error("Failed pattern match at Lattice.Services.NumericalIntegration (line 137, column 7 - line 145, column 45): " + [ lo.constructor.name, hi.constructor.name, fuel.constructor.name ]);
                                };
                                while (!$tco_done) {
                                    $tco_result = $tco_loop($tco_var_lo, $tco_var_hi, $copy_fuel);
                                };
                                return $tco_result;
                            };
                        };
                    };
                    return search(low)(high)(100);
                };
            };
        };
    };
};
var arrayGet = function (arr) {
    return function (i) {
        var v = Data_Array.index(arr)(i);
        if (v instanceof Data_Maybe.Just) {
            return v.value0;
        };
        if (v instanceof Data_Maybe.Nothing) {
            return 0.0;
        };
        throw new Error("Failed pattern match at Lattice.Services.NumericalIntegration (line 56, column 18 - line 58, column 17): " + [ v.constructor.name ]);
    };
};
var simpsonsRule = function (samples) {
    return function (h) {
        if (Data_Array.length(samples) < 3) {
            var $32 = Data_Array.length(samples) === 2;
            if ($32) {
                return trapezoid(arrayGet(samples)(0))(arrayGet(samples)(1))(h);
            };
            var $33 = Data_Array.length(samples) === 1;
            if ($33) {
                return arrayGet(samples)(0) * h;
            };
            return 0.0;
        };
        if (Data_Boolean.otherwise) {
            var n = Data_Array.length(samples) - 1 | 0;
            var indexed = Data_Array.mapWithIndex(function (i) {
                return function (val) {
                    var coeff = (function () {
                        var $34 = i === 0;
                        if ($34) {
                            return 1.0;
                        };
                        var $35 = i === n;
                        if ($35) {
                            return 1.0;
                        };
                        var $36 = mod(i)(2) === 1;
                        if ($36) {
                            return 4.0;
                        };
                        return 2.0;
                    })();
                    return coeff * val;
                };
            })(samples);
            var total = Data_Array.foldl(add)(0.0)(indexed);
            return (h / 3.0) * total;
        };
        throw new Error("Failed pattern match at Lattice.Services.NumericalIntegration (line 67, column 1 - line 67, column 49): " + [ samples.constructor.name, h.constructor.name ]);
    };
};
var integrateSimpsons = function (f) {
    return function (a) {
        return function (b) {
            return function (numSamples) {
                var span = b - a;
                var $37 = span <= 0.0;
                if ($37) {
                    return 0.0;
                };
                var $38 = span < 1.0;
                if ($38) {
                    return trapezoid(f(a))(f(b))(span);
                };
                var n = (function () {
                    var $39 = numSamples > 0;
                    if ($39) {
                        return numSamples;
                    };
                    return optimalSampleCount(span)(2);
                })();
                var nOdd = (function () {
                    var $40 = mod(n)(2) === 0;
                    if ($40) {
                        return n + 1 | 0;
                    };
                    return n;
                })();
                var h = span / Data_Int.toNumber(nOdd);
                var samples = map(function (i) {
                    return f(a + Data_Int.toNumber(i) * h);
                })(Data_Array.range(0)(nOdd));
                return simpsonsRule(samples)(h);
            };
        };
    };
};
var integrateSpeedCurve = function (speedSamples) {
    return function (h) {
        var rateSamples = map(speedToRate)(speedSamples);
        return simpsonsRule(rateSamples)(h);
    };
};
export {
    defaultTolerance,
    minSamples,
    trapezoid,
    simpsonsRule,
    optimalSampleCount,
    integrateSimpsons,
    integrateTrapezoidal,
    binarySearchIntegral,
    calculateFrameBlend,
    lerp,
    blendFrameValues,
    speedToRate,
    integrateSpeedCurve,
    cumulativeSourceFrames
};
//# sourceMappingURL=index.js.map
