// Generated by purs version 0.15.15
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var max1 = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var sampleWeight = function (sampleIndex) {
    return function (sampleCount) {
        return function (tapered) {
            if (tapered) {
                var center = Data_Int.toNumber(sampleCount) / 2.0;
                var dist = $$Math.abs(Data_Int.toNumber(sampleIndex) - center);
                var $11 = center < 1.0e-4;
                if ($11) {
                    return 1.0;
                };
                return 1.0 - (dist / center) * 0.5;
            };
            if (Data_Boolean.otherwise) {
                return 1.0;
            };
            throw new Error("Failed pattern match at Lattice.Services.Blur.Directional (line 68, column 1 - line 68, column 48): " + [ sampleIndex.constructor.name, sampleCount.constructor.name, tapered.constructor.name ]);
        };
    };
};
var samplePosition = function (x) {
    return function (y) {
        return function (dx) {
            return function (dy) {
                return function (offset) {
                    return new Data_Tuple.Tuple(x + dx * offset, y + dy * offset);
                };
            };
        };
    };
};
var optimalSampleCount = function (blurLength) {
    var samples = Data_Int.ceil(blurLength);
    return max(3)(samples);
};
var directionalSamplePosition = function (x) {
    return function (y) {
        return function (dx) {
            return function (dy) {
                return function (blurLength) {
                    return function (sampleCount) {
                        return function (sampleIndex) {
                            var step = blurLength / Data_Int.toNumber(sampleCount);
                            var halfSamples = Data_Int.toNumber(sampleCount) / 2.0;
                            var i = Data_Int.toNumber(sampleIndex) - halfSamples;
                            var offset = i * step;
                            return samplePosition(x)(y)(dx)(dy)(offset);
                        };
                    };
                };
            };
        };
    };
};
var directionVector = function (angleRad) {
    return new Data_Tuple.Tuple($$Math.cos(angleRad), $$Math.sin(angleRad));
};
var degreesToRadians = function (degrees) {
    return (degrees * $$Math.pi) / 180.0;
};
var directionVectorDeg = function (angleDeg) {
    return directionVector(degreesToRadians(angleDeg));
};
var clampSamplePosition = function (sampleX) {
    return function (sampleY) {
        return function (width) {
            return function (height) {
                var clampedY = max1(0.0)(min(Data_Int.toNumber(height) - 1.0)(sampleY));
                var clampedX = max1(0.0)(min(Data_Int.toNumber(width) - 1.0)(sampleX));
                return new Data_Tuple.Tuple(clampedX, clampedY);
            };
        };
    };
};
export {
    directionVector,
    degreesToRadians,
    directionVectorDeg,
    samplePosition,
    directionalSamplePosition,
    sampleWeight,
    optimalSampleCount,
    clampSamplePosition
};
//# sourceMappingURL=index.js.map
