// Generated by purs version 0.15.15
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Identity from "../Data.Identity/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Effect_Aff from "../Effect.Aff/index.js";
import * as Test_Lattice_TestHelpers from "../Test.Lattice.TestHelpers/index.js";
import * as Test_Spec from "../Test.Spec/index.js";
import * as Test_Spec_Assertions from "../Test.Spec.Assertions/index.js";
var describe = /* #__PURE__ */ Test_Spec.describe(Data_Identity.monadIdentity);
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit);
var discard1 = /* #__PURE__ */ discard(/* #__PURE__ */ Test_Spec.bindSpecT(Data_Identity.bindIdentity));
var it = /* #__PURE__ */ Test_Spec.it(Data_Identity.monadIdentity)(Test_Spec.exampleMUnit);
var discard2 = /* #__PURE__ */ discard(Effect_Aff.bindAff);
var shouldEqual = /* #__PURE__ */ Test_Spec_Assertions.shouldEqual(Effect_Aff.monadThrowAff)(Data_Show.showNumber)(Data_Eq.eqNumber);
var for_ = /* #__PURE__ */ Data_Foldable.for_(Effect_Aff.applicativeAff)(Data_Foldable.foldableArray);
var pure = /* #__PURE__ */ Control_Applicative.pure(Effect_Aff.applicativeAff);
var Static = /* #__PURE__ */ (function () {
    function Static() {

    };
    Static.value = new Static();
    return Static;
})();
var Dead = /* #__PURE__ */ (function () {
    function Dead() {

    };
    Dead.value = new Dead();
    return Dead;
})();
var Dynamic = /* #__PURE__ */ (function () {
    function Dynamic() {

    };
    Dynamic.value = new Dynamic();
    return Dynamic;
})();
var Kinematic = /* #__PURE__ */ (function () {
    function Kinematic() {

    };
    Kinematic.value = new Kinematic();
    return Kinematic;
})();
var calculateInverseMass = function (v) {
    return function (v1) {
        if (v instanceof Static) {
            return 0.0;
        };
        if (v instanceof Dead) {
            return 0.0;
        };
        if (v1 === 0.0 || Data_Number["isNaN"](v1)) {
            return 1.0;
        };
        if (Data_Boolean.otherwise) {
            return 1.0 / v1;
        };
        throw new Error("Failed pattern match at Test.Lattice.Services.PhysicsEngine (line 23, column 1 - line 23, column 53): " + [ v.constructor.name, v1.constructor.name ]);
    };
};
var spec = /* #__PURE__ */ (function () {
    return describe("PhysicsEngine body calculations")(describe("inverseMass calculation")(discard1(it("static bodies have zero inverse mass")(discard2(shouldEqual(calculateInverseMass(Static.value)(10.0))(0.0))(function () {
        return shouldEqual(calculateInverseMass(Static.value)(0.0))(0.0);
    })))(function () {
        return discard1(it("dead bodies have zero inverse mass")(discard2(shouldEqual(calculateInverseMass(Dead.value)(10.0))(0.0))(function () {
            return shouldEqual(calculateInverseMass(Dead.value)(0.0))(0.0);
        })))(function () {
            return discard1(it("dynamic bodies calculate inverse mass correctly")(discard2(shouldEqual(calculateInverseMass(Dynamic.value)(1.0))(1.0))(function () {
                return discard2(shouldEqual(calculateInverseMass(Dynamic.value)(2.0))(0.5))(function () {
                    return shouldEqual(calculateInverseMass(Dynamic.value)(10.0))(0.1);
                });
            })))(function () {
                return discard1(it("BUG #5 FIXED: dynamic body with mass=0 returns 1 instead of Infinity")(discard2(shouldEqual(calculateInverseMass(Dynamic.value)(0.0))(1.0))(function () {
                    return Test_Lattice_TestHelpers.assertFinite(calculateInverseMass(Dynamic.value)(0.0));
                })))(function () {
                    return discard1(it("BUG #5 FIXED: kinematic body with mass=0 returns 1")(discard2(shouldEqual(calculateInverseMass(Kinematic.value)(0.0))(1.0))(function () {
                        return Test_Lattice_TestHelpers.assertFinite(calculateInverseMass(Kinematic.value)(0.0));
                    })))(function () {
                        return discard1(it("inverse mass is always finite for any body type")((function () {
                            var masses = [ 0.0, 0.1, 1.0, 10.0, 100.0 ];
                            var bodyTypes = [ new Data_Tuple.Tuple("static", Static.value), new Data_Tuple.Tuple("dead", Dead.value), new Data_Tuple.Tuple("dynamic", Dynamic.value), new Data_Tuple.Tuple("kinematic", Kinematic.value) ];
                            return for_(bodyTypes)(function (v) {
                                return for_(masses)(function (mass) {
                                    var result = calculateInverseMass(v.value1)(mass);
                                    if (v.value1 instanceof Static) {
                                        return shouldEqual(result)(0.0);
                                    };
                                    if (v.value1 instanceof Dead) {
                                        return shouldEqual(result)(0.0);
                                    };
                                    var $24 = mass > 0.0;
                                    if ($24) {
                                        return Test_Lattice_TestHelpers.assertFinite(result);
                                    };
                                    return pure(Data_Unit.unit);
                                });
                            });
                        })()))(function () {
                            return it("NaN mass falls back to 1 for dynamic bodies")(discard2(shouldEqual(calculateInverseMass(Dynamic.value)(Data_Number.nan))(1.0))(function () {
                                return Test_Lattice_TestHelpers.assertFinite(calculateInverseMass(Dynamic.value)(Data_Number.nan));
                            }));
                        });
                    });
                });
            });
        });
    })));
})();
export {
    spec
};
//# sourceMappingURL=index.js.map
