// Generated by purs version 0.15.15
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordInt);
var EmitRandom = /* #__PURE__ */ (function () {
    function EmitRandom() {

    };
    EmitRandom.value = new EmitRandom();
    return EmitRandom;
})();
var EmitUniform = /* #__PURE__ */ (function () {
    function EmitUniform() {

    };
    EmitUniform.value = new EmitUniform();
    return EmitUniform;
})();
var EmitSequential = /* #__PURE__ */ (function () {
    function EmitSequential() {

    };
    EmitSequential.value = new EmitSequential();
    return EmitSequential;
})();
var EmitStart = /* #__PURE__ */ (function () {
    function EmitStart() {

    };
    EmitStart.value = new EmitStart();
    return EmitStart;
})();
var EmitEnd = /* #__PURE__ */ (function () {
    function EmitEnd() {

    };
    EmitEnd.value = new EmitEnd();
    return EmitEnd;
})();
var stepAccumulator = function (accumulated) {
    return function (maxSpawn) {
        var wholeParticles = min(Data_Int.floor(accumulated))(maxSpawn);
        var remaining = $$Math.max(0.0)(accumulated - Data_Int.toNumber(wholeParticles));
        return new Data_Tuple.Tuple(wholeParticles, remaining);
    };
};
var showEmitMode = {
    show: function (v) {
        if (v instanceof EmitRandom) {
            return "EmitRandom";
        };
        if (v instanceof EmitUniform) {
            return "EmitUniform";
        };
        if (v instanceof EmitSequential) {
            return "EmitSequential";
        };
        if (v instanceof EmitStart) {
            return "EmitStart";
        };
        if (v instanceof EmitEnd) {
            return "EmitEnd";
        };
        throw new Error("Failed pattern match at Lattice.Services.Particles.Emitter (line 46, column 1 - line 51, column 27): " + [ v.constructor.name ]);
    }
};
var initialEmitterState = {
    accumulator: 0.0,
    sequentialT: 0.0,
    burstTriggered: false,
    enabled: false
};
var eqEmitMode = {
    eq: function (x) {
        return function (y) {
            if (x instanceof EmitRandom && y instanceof EmitRandom) {
                return true;
            };
            if (x instanceof EmitUniform && y instanceof EmitUniform) {
                return true;
            };
            if (x instanceof EmitSequential && y instanceof EmitSequential) {
                return true;
            };
            if (x instanceof EmitStart && y instanceof EmitStart) {
                return true;
            };
            if (x instanceof EmitEnd && y instanceof EmitEnd) {
                return true;
            };
            return false;
        };
    }
};
var effectiveEmissionRate = function (baseRate) {
    return function (audioValue) {
        var isValidPositive = function (x) {
            return !Data_Number["isNaN"](x) && (Data_Number["isFinite"](x) && x >= 0.0);
        };
        if (audioValue instanceof Data_Maybe.Just && isValidPositive(audioValue.value0)) {
            return audioValue.value0;
        };
        return $$Math.max(0.0)(baseRate);
    };
};
var calculateEmission = function (emissionRate) {
    return function (deltaTime) {
        return function (currentAcc) {
            return function (maxSpawn) {
                var particlesToEmit = emissionRate * $$Math.max(0.0)(deltaTime);
                var accumulated = currentAcc + particlesToEmit;
                return stepAccumulator(accumulated)(maxSpawn);
            };
        };
    };
};
var burstCount = function (emissionRate) {
    return function (burstMultiplier) {
        return Data_Int.floor(emissionRate * $$Math.max(0.0)(burstMultiplier) * 10.0);
    };
};
var advanceSequentialT = function (currentT) {
    return function (speed) {
        var safeSpeed = $$Math.max(1.0e-3)(speed);
        var newT = currentT + safeSpeed;
        var $16 = newT > 1.0;
        if ($16) {
            return newT - 1.0;
        };
        return newT;
    };
};
export {
    EmitRandom,
    EmitUniform,
    EmitSequential,
    EmitStart,
    EmitEnd,
    initialEmitterState,
    effectiveEmissionRate,
    burstCount,
    calculateEmission,
    stepAccumulator,
    advanceSequentialT,
    eqEmitMode,
    showEmitMode
};
//# sourceMappingURL=index.js.map
