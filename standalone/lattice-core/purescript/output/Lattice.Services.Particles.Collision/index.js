// Generated by purs version 0.15.15
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var ResponseBounce = /* #__PURE__ */ (function () {
    function ResponseBounce() {

    };
    ResponseBounce.value = new ResponseBounce();
    return ResponseBounce;
})();
var ResponseAbsorb = /* #__PURE__ */ (function () {
    function ResponseAbsorb() {

    };
    ResponseAbsorb.value = new ResponseAbsorb();
    return ResponseAbsorb;
})();
var ResponseExplode = /* #__PURE__ */ (function () {
    function ResponseExplode() {

    };
    ResponseExplode.value = new ResponseExplode();
    return ResponseExplode;
})();
var showCollisionResponse = {
    show: function (v) {
        if (v instanceof ResponseBounce) {
            return "ResponseBounce";
        };
        if (v instanceof ResponseAbsorb) {
            return "ResponseAbsorb";
        };
        if (v instanceof ResponseExplode) {
            return "ResponseExplode";
        };
        throw new Error("Failed pattern match at Lattice.Services.Particles.Collision (line 47, column 1 - line 50, column 43): " + [ v.constructor.name ]);
    }
};
var separateOverlap = function (x1) {
    return function (y1) {
        return function (x2) {
            return function (y2) {
                return function (minDist) {
                    var dy = y2 - y1;
                    var dx = x2 - x1;
                    var dist = $$Math.sqrt(dx * dx + dy * dy);
                    var $15 = dist < minDist && dist > 1.0e-4;
                    if ($15) {
                        var overlap = minDist - dist;
                        var ny = dy / dist;
                        var nx = dx / dist;
                        return new Data_Tuple.Tuple(new Data_Tuple.Tuple(x1 - nx * overlap * 0.5, y1 - ny * overlap * 0.5), new Data_Tuple.Tuple(x2 + nx * overlap * 0.5, y2 + ny * overlap * 0.5));
                    };
                    return new Data_Tuple.Tuple(new Data_Tuple.Tuple(x1, y1), new Data_Tuple.Tuple(x2, y2));
                };
            };
        };
    };
};
var noCollision = function (vx1) {
    return function (vy1) {
        return function (x1) {
            return function (y1) {
                return function (vx2) {
                    return function (vy2) {
                        return function (x2) {
                            return function (y2) {
                                return {
                                    collided: false,
                                    newVx1: vx1,
                                    newVy1: vy1,
                                    newVx2: vx2,
                                    newVy2: vy2,
                                    newX1: x1,
                                    newY1: y1,
                                    newX2: x2,
                                    newY2: y2,
                                    p1Killed: false,
                                    p2Killed: false
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
var eqCollisionResponse = {
    eq: function (x) {
        return function (y) {
            if (x instanceof ResponseBounce && y instanceof ResponseBounce) {
                return true;
            };
            if (x instanceof ResponseAbsorb && y instanceof ResponseAbsorb) {
                return true;
            };
            if (x instanceof ResponseExplode && y instanceof ResponseExplode) {
                return true;
            };
            return false;
        };
    }
};
var collisionDistance = function (size1) {
    return function (size2) {
        return function (radiusMult) {
            return (size1 / 1000.0) * radiusMult + (size2 / 1000.0) * radiusMult;
        };
    };
};
var checkWallCollision = function (x) {
    return function (y) {
        return function (vx) {
            return function (vy) {
                return function (bounciness) {
                    return function (friction) {
                        if (x < 0.0) {
                            return new Data_Tuple.Tuple(new Data_Tuple.Tuple(0.0, y), new Data_Tuple.Tuple(-vx * bounciness, vy * (1.0 - friction)));
                        };
                        if (x > 1.0) {
                            return new Data_Tuple.Tuple(new Data_Tuple.Tuple(1.0, y), new Data_Tuple.Tuple(-vx * bounciness, vy * (1.0 - friction)));
                        };
                        if (Data_Boolean.otherwise) {
                            return new Data_Tuple.Tuple(new Data_Tuple.Tuple(x, y), new Data_Tuple.Tuple(vx, vy));
                        };
                        throw new Error("Failed pattern match at Lattice.Services.Particles.Collision (line 238, column 1 - line 241, column 55): " + [ x.constructor.name, y.constructor.name, vx.constructor.name, vy.constructor.name, bounciness.constructor.name, friction.constructor.name ]);
                    };
                };
            };
        };
    };
};
var checkPairCollision = function (x1) {
    return function (y1) {
        return function (s1) {
            return function (x2) {
                return function (y2) {
                    return function (s2) {
                        return function (radiusMult) {
                            var minDist = collisionDistance(s1)(s2)(radiusMult);
                            var dy = y2 - y1;
                            var dx = x2 - x1;
                            var distSq = dx * dx + dy * dy;
                            var $24 = distSq < minDist * minDist && distSq > 1.0e-6;
                            if ($24) {
                                var dist = $$Math.sqrt(distSq);
                                var nx = dx / dist;
                                var ny = dy / dist;
                                return new Data_Maybe.Just({
                                    dist: dist,
                                    nx: nx,
                                    ny: ny
                                });
                            };
                            return Data_Maybe.Nothing.value;
                        };
                    };
                };
            };
        };
    };
};
var checkFloorCollision = function (x) {
    return function (y) {
        return function (vx) {
            return function (vy) {
                return function (floorY) {
                    return function (bounciness) {
                        return function (friction) {
                            var $25 = y > floorY;
                            if ($25) {
                                return new Data_Tuple.Tuple(new Data_Tuple.Tuple(x, floorY), new Data_Tuple.Tuple(vx * (1.0 - friction), -vy * bounciness));
                            };
                            return new Data_Tuple.Tuple(new Data_Tuple.Tuple(x, y), new Data_Tuple.Tuple(vx, vy));
                        };
                    };
                };
            };
        };
    };
};
var checkCeilingCollision = function (x) {
    return function (y) {
        return function (vx) {
            return function (vy) {
                return function (ceilingY) {
                    return function (bounciness) {
                        return function (friction) {
                            var $26 = y < ceilingY;
                            if ($26) {
                                return new Data_Tuple.Tuple(new Data_Tuple.Tuple(x, ceilingY), new Data_Tuple.Tuple(vx * (1.0 - friction), -vy * bounciness));
                            };
                            return new Data_Tuple.Tuple(new Data_Tuple.Tuple(x, y), new Data_Tuple.Tuple(vx, vy));
                        };
                    };
                };
            };
        };
    };
};
var cellKey = function (x) {
    return function (y) {
        return function (cellSize) {
            var safeCellSize = $$Math.max(1.0e-3)(cellSize);
            var cy = Data_Int.floor(y / safeCellSize);
            var cx = Data_Int.floor(x / safeCellSize);
            return new Data_Tuple.Tuple(cx, cy);
        };
    };
};
var bounceResponse = function (vx1) {
    return function (vy1) {
        return function (x1) {
            return function (y1) {
                return function (vx2) {
                    return function (vy2) {
                        return function (x2) {
                            return function (y2) {
                                return function (nx) {
                                    return function (ny) {
                                        return function (minDist) {
                                            return function (damping) {
                                                var dvy = vy1 - vy2;
                                                var dvx = vx1 - vx2;
                                                var dvDotN = dvx * nx + dvy * ny;
                                                var $27 = dvDotN > 0.0;
                                                if ($27) {
                                                    var impulseY = dvDotN * ny * damping;
                                                    var impulseX = dvDotN * nx * damping;
                                                    var dist = $$Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                                                    var overlap = (function () {
                                                        var $28 = dist > 1.0e-4;
                                                        if ($28) {
                                                            return minDist - dist;
                                                        };
                                                        return 0.0;
                                                    })();
                                                    return {
                                                        collided: true,
                                                        newVx1: vx1 - impulseX,
                                                        newVy1: vy1 - impulseY,
                                                        newVx2: vx2 + impulseX,
                                                        newVy2: vy2 + impulseY,
                                                        newX1: x1 - nx * overlap * 0.5,
                                                        newY1: y1 - ny * overlap * 0.5,
                                                        newX2: x2 + nx * overlap * 0.5,
                                                        newY2: y2 + ny * overlap * 0.5,
                                                        p1Killed: false,
                                                        p2Killed: false
                                                    };
                                                };
                                                return noCollision(vx1)(vy1)(x1)(y1)(vx2)(vy2)(x2)(y2);
                                            };
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
var applyEnvironmentCollision = function (cfg) {
    return function (x) {
        return function (y) {
            return function (vx) {
                return function (vy) {
                    var v = (function () {
                        if (cfg.floorEnabled) {
                            return checkFloorCollision(x)(y)(vx)(vy)(cfg.floorY)(cfg.bounciness)(cfg.friction);
                        };
                        return new Data_Tuple.Tuple(new Data_Tuple.Tuple(x, y), new Data_Tuple.Tuple(vx, vy));
                    })();
                    var v1 = (function () {
                        if (cfg.ceilingEnabled) {
                            return checkCeilingCollision(v.value0.value0)(v.value0.value1)(v.value1.value0)(v.value1.value1)(cfg.ceilingY)(cfg.bounciness)(cfg.friction);
                        };
                        return new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value0, v.value0.value1), new Data_Tuple.Tuple(v.value1.value0, v.value1.value1));
                    })();
                    var v2 = (function () {
                        if (cfg.wallsEnabled) {
                            return checkWallCollision(v1.value0.value0)(v1.value0.value1)(v1.value1.value0)(v1.value1.value1)(cfg.bounciness)(cfg.friction);
                        };
                        return new Data_Tuple.Tuple(new Data_Tuple.Tuple(v1.value0.value0, v1.value0.value1), new Data_Tuple.Tuple(v1.value1.value0, v1.value1.value1));
                    })();
                    return new Data_Tuple.Tuple(new Data_Tuple.Tuple(v2.value0.value0, v2.value0.value1), new Data_Tuple.Tuple(v2.value1.value0, v2.value1.value1));
                };
            };
        };
    };
};
export {
    ResponseBounce,
    ResponseAbsorb,
    ResponseExplode,
    cellKey,
    collisionDistance,
    checkPairCollision,
    bounceResponse,
    separateOverlap,
    checkFloorCollision,
    checkCeilingCollision,
    checkWallCollision,
    applyEnvironmentCollision,
    eqCollisionResponse,
    showCollisionResponse
};
//# sourceMappingURL=index.js.map
