// Generated by purs version 0.15.15
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Lattice_Services_Noise_SimplexNoise from "../Lattice.Services.Noise.SimplexNoise/index.js";
import * as $$Math from "../Math/index.js";
var div1 = /* #__PURE__ */ Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt);
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var Grid = /* #__PURE__ */ (function () {
    function Grid() {

    };
    Grid.value = new Grid();
    return Grid;
})();
var Circle = /* #__PURE__ */ (function () {
    function Circle() {

    };
    Circle.value = new Circle();
    return Circle;
})();
var Random = /* #__PURE__ */ (function () {
    function Random() {

    };
    Random.value = new Random();
    return Random;
})();
var EaseIn = /* #__PURE__ */ (function () {
    function EaseIn() {

    };
    EaseIn.value = new EaseIn();
    return EaseIn;
})();
var EaseOut = /* #__PURE__ */ (function () {
    function EaseOut() {

    };
    EaseOut.value = new EaseOut();
    return EaseOut;
})();
var EaseInOut = /* #__PURE__ */ (function () {
    function EaseInOut() {

    };
    EaseInOut.value = new EaseInOut();
    return EaseInOut;
})();
var separationForce = function (params) {
    return function (p1) {
        return function (p2) {
            var dy = p1.y - p2.y;
            var dx = p1.x - p2.x;
            var dist = $$Math.sqrt(dx * dx + dy * dy);
            var $17 = dist < params.separation && dist > 0.0;
            if ($17) {
                var factor = (params.separation - dist) * 0.1;
                return {
                    fx: (dx / dist) * factor,
                    fy: (dy / dist) * factor
                };
            };
            return {
                fx: 0.0,
                fy: 0.0
            };
        };
    };
};
var riverPath = function (params) {
    return function (x) {
        var t = x / params.base.width;
        return params.base.height / 2.0 + $$Math.sin(t * $$Math.pi * 2.0 * params.curve) * params.base.height * 0.25;
    };
};
var origin = {
    x: 0.0,
    y: 0.0
};
var initVortexParticle = function (startAngle) {
    return function (startRadius) {
        return {
            angle: startAngle,
            radius: startRadius
        };
    };
};
var initExplosionParticle = function (params) {
    return function (angle) {
        return function (speed) {
            var center = (function () {
                var $18 = params.center.x === 0.0 && params.center.y === 0.0;
                if ($18) {
                    return {
                        x: params.base.width / 2.0,
                        y: params.base.height / 2.0
                    };
                };
                return params.center;
            })();
            return {
                x: center.x,
                y: center.y,
                vx: $$Math.cos(angle) * speed * 20.0,
                vy: $$Math.sin(angle) * speed * 20.0
            };
        };
    };
};
var gridPosition = function (fp) {
    return function (index) {
        return function (numPoints) {
            var cols = Data_Int.ceil($$Math.sqrt(Data_Int.toNumber(numPoints)));
            var row = div1(index)(cols);
            var y = ((Data_Int.toNumber(row) + 0.5) / Data_Int.toNumber(cols)) * fp.height * 0.8 + fp.height * 0.1;
            var col = mod(index)(cols);
            var x = ((Data_Int.toNumber(col) + 0.5) / Data_Int.toNumber(cols)) * fp.width * 0.8 + fp.width * 0.1;
            return {
                x: x,
                y: y
            };
        };
    };
};
var eqMorphShape = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Grid && y instanceof Grid) {
                return true;
            };
            if (x instanceof Circle && y instanceof Circle) {
                return true;
            };
            if (x instanceof Random && y instanceof Random) {
                return true;
            };
            return false;
        };
    }
};
var eqMorphEasing = {
    eq: function (x) {
        return function (y) {
            if (x instanceof EaseIn && y instanceof EaseIn) {
                return true;
            };
            if (x instanceof EaseOut && y instanceof EaseOut) {
                return true;
            };
            if (x instanceof EaseInOut && y instanceof EaseInOut) {
                return true;
            };
            return false;
        };
    }
};
var cohesionForce = function (params) {
    return function (particle) {
        return function (cx) {
            return function (cy) {
                var fy = (cy - particle.y) * params.cohesion;
                var fx = (cx - particle.x) * params.cohesion;
                return {
                    fx: fx,
                    fy: fy
                };
            };
        };
    };
};
var clampVelocity = function (vx) {
    return function (vy) {
        return function (maxSpeed) {
            var speed = $$Math.sqrt(vx * vx + vy * vy);
            var $23 = speed > maxSpeed;
            if ($23) {
                return {
                    vx: (vx / speed) * maxSpeed,
                    vy: (vy / speed) * maxSpeed
                };
            };
            return {
                vx: vx,
                vy: vy
            };
        };
    };
};
var clampPoint = function (p) {
    return function (minX) {
        return function (minY) {
            return function (maxX) {
                return function (maxY) {
                    return {
                        x: $$Math.max(minX)($$Math.min(maxX)(p.x)),
                        y: $$Math.max(minY)($$Math.min(maxY)(p.y))
                    };
                };
            };
        };
    };
};
var riverPosition = function (params) {
    return function (t) {
        return function (startX) {
            return function (laneOffset) {
                return function (speed) {
                    return function (pointIndex) {
                        return function (frameIndex) {
                            var riverWidth = (function () {
                                var $24 = params.riverWidth === 0.0;
                                if ($24) {
                                    return params.base.height * 0.3;
                                };
                                return params.riverWidth;
                            })();
                            var x = startX + t * params.base.width * speed * 1.3;
                            var noise = Lattice_Services_Noise_SimplexNoise.simplexNoise2D(x * 1.0e-2)(Data_Int.toNumber(frameIndex) * 5.0e-2 + Data_Int.toNumber(pointIndex) * 0.1)(params.base.seed);
                            var visible = x >= 0.0 && x <= params.base.width;
                            var baseY = riverPath(params)(x);
                            var y = baseY + laneOffset + (noise - 0.5) * riverWidth * params.turbulence * 2.0;
                            var pos = clampPoint({
                                x: x,
                                y: y
                            })(0.0)(0.0)(params.base.width)(params.base.height);
                            return {
                                pos: pos,
                                visible: visible
                            };
                        };
                    };
                };
            };
        };
    };
};
var spiralPosition = function (params) {
    return function (t) {
        return function (armOffset) {
            return function (radiusOffset) {
                return function (phaseOffset) {
                    return function (center) {
                        return function (maxRadius) {
                            return function (pointIndex) {
                                return function (frameIndex) {
                                    var noise = Lattice_Services_Noise_SimplexNoise.simplexNoise2D(Data_Int.toNumber(pointIndex) * 0.1)(Data_Int.toNumber(frameIndex) * 5.0e-2)(params.base.seed);
                                    var effectiveT = t + phaseOffset;
                                    var radius = (radiusOffset + effectiveT * params.expansion) * maxRadius;
                                    var noisedRadius = radius * (1.0 + (noise - 0.5) * params.base.noiseStrength * 2.0);
                                    var angle = armOffset + effectiveT * $$Math.pi * 2.0 * params.turns;
                                    var x = center.x + $$Math.cos(angle) * noisedRadius;
                                    var y = center.y + $$Math.sin(angle) * noisedRadius;
                                    return clampPoint({
                                        x: x,
                                        y: y
                                    })(0.0)(0.0)(params.base.width)(params.base.height);
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
var stepExplosionParticle = function (params) {
    return function (state) {
        return function (pointIndex) {
            return function (frameIndex) {
                var newVy = state.vy * params.decay;
                var newVx = state.vx * params.decay;
                var noiseX = (Lattice_Services_Noise_SimplexNoise.simplexNoise2D(Data_Int.toNumber(pointIndex) * 0.1)(Data_Int.toNumber(frameIndex) * 0.1)(params.base.seed) - 0.5) * params.base.noiseStrength * 50.0;
                var newX = state.x + state.vx + noiseX;
                var noiseY = (Lattice_Services_Noise_SimplexNoise.simplexNoise2D(Data_Int.toNumber(pointIndex) * 0.1 + 100.0)(Data_Int.toNumber(frameIndex) * 0.1)(params.base.seed) - 0.5) * params.base.noiseStrength * 50.0;
                var newY = state.y + state.vy + noiseY;
                var newState = {
                    x: newX,
                    y: newY,
                    vx: newVx,
                    vy: newVy
                };
                var pos = clampPoint({
                    x: newX,
                    y: newY
                })(0.0)(0.0)(params.base.width)(params.base.height);
                var visible = newX >= 0.0 && (newX <= params.base.width && (newY >= 0.0 && newY <= params.base.height));
                return {
                    state: newState,
                    pos: pos,
                    visible: visible
                };
            };
        };
    };
};
var stepVortexParticle = function (params) {
    return function (state) {
        var newRadius = $$Math.max(10.0)(state.radius - state.radius * 1.0e-2 * params.strength);
        var maxRadius = (function () {
            var $25 = params.maxRadius === 0.0;
            if ($25) {
                return $$Math.min(params.base.width)(params.base.height) * 0.4;
            };
            return params.maxRadius;
        })();
        var noise = Lattice_Services_Noise_SimplexNoise.simplexNoise2D(state.angle)(state.radius * 1.0e-2)(params.base.seed);
        var noisedRadius = newRadius * (1.0 + (noise - 0.5) * params.base.noiseStrength);
        var center = (function () {
            var $26 = params.center.x === 0.0 && params.center.y === 0.0;
            if ($26) {
                return {
                    x: params.base.width / 2.0,
                    y: params.base.height / 2.0
                };
            };
            return params.center;
        })();
        var angularSpeed = params.strength * (1.0 + ((maxRadius - state.radius) / maxRadius) * 2.0);
        var newAngle = state.angle + angularSpeed;
        var newState = {
            angle: newAngle,
            radius: newRadius
        };
        var x = center.x + $$Math.cos(newAngle) * noisedRadius;
        var y = center.y + $$Math.sin(newAngle) * noisedRadius;
        var pos = clampPoint({
            x: x,
            y: y
        })(0.0)(0.0)(params.base.width)(params.base.height);
        return {
            state: newState,
            pos: pos
        };
    };
};
var updateSwarmParticle = function (params) {
    return function (particle) {
        return function (fx) {
            return function (fy) {
                var newVy = particle.vy + fy;
                var newVx = particle.vx + fx;
                var clamped = clampVelocity(newVx)(newVy)(params.maxSpeed);
                var newX = particle.x + clamped.vx;
                var newY = particle.y + clamped.vy;
                var newParticle = {
                    x: newX,
                    y: newY,
                    vx: clamped.vx,
                    vy: clamped.vy
                };
                var pos = clampPoint({
                    x: newX,
                    y: newY
                })(0.0)(0.0)(params.base.width)(params.base.height);
                return {
                    particle: newParticle,
                    pos: pos
                };
            };
        };
    };
};
var wavePosition = function (params) {
    return function (t) {
        return function (startX) {
            return function (layerY) {
                return function (phaseOffset) {
                    return function (amplitudeVar) {
                        return function (layer) {
                            return function (pointIndex) {
                                return function (frameIndex) {
                                    var fmod = function (a) {
                                        return function (b) {
                                            return a - Data_Int.toNumber(Data_Int.floor(a / b)) * b;
                                        };
                                    };
                                    var rawX = startX + t * params.base.width * params.speed * 10.0;
                                    var x = fmod(rawX)(params.base.width * 1.2) - params.base.width * 0.1;
                                    var noise = Lattice_Services_Noise_SimplexNoise.simplexNoise2D(x * 1.0e-2)(Data_Int.toNumber(frameIndex) * 5.0e-2 + Data_Int.toNumber(layer))(params.base.seed);
                                    var visible = x >= 0.0 && x <= params.base.width;
                                    var waveAngle = (x / params.base.width) * $$Math.pi * 2.0 * params.frequency + phaseOffset + t * $$Math.pi * 4.0;
                                    var wave = $$Math.sin(waveAngle);
                                    var amplitude = (function () {
                                        var $27 = params.amplitude === 0.0;
                                        if ($27) {
                                            return params.base.height * 0.15;
                                        };
                                        return params.amplitude;
                                    })();
                                    var y = layerY + wave * amplitude * amplitudeVar;
                                    var noisedY = y + (noise - 0.5) * amplitude * params.base.noiseStrength * 4.0;
                                    var pos = clampPoint({
                                        x: x,
                                        y: noisedY
                                    })(0.0)(0.0)(params.base.width)(params.base.height);
                                    return {
                                        pos: pos,
                                        visible: visible
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
var circlePosition = function (fp) {
    return function (index) {
        return function (numPoints) {
            var radius = $$Math.min(fp.width)(fp.height) * 0.35;
            var angle = (Data_Int.toNumber(index) / Data_Int.toNumber(numPoints)) * $$Math.pi * 2.0;
            var x = fp.width / 2.0 + $$Math.cos(angle) * radius;
            var y = fp.height / 2.0 + $$Math.sin(angle) * radius;
            return {
                x: x,
                y: y
            };
        };
    };
};
var boundaryForce = function (params) {
    return function (particle) {
        var fy1 = (function () {
            var $28 = particle.y < 50.0;
            if ($28) {
                return (50.0 - particle.y) * 0.1;
            };
            return 0.0;
        })();
        var fx1 = (function () {
            var $29 = particle.x < 50.0;
            if ($29) {
                return (50.0 - particle.x) * 0.1;
            };
            return 0.0;
        })();
        var fx2 = (function () {
            var $30 = particle.x > params.base.width - 50.0;
            if ($30) {
                return -(particle.x - (params.base.width - 50.0)) * 0.1;
            };
            return 0.0;
        })();
        var fy2 = (function () {
            var $31 = particle.y > params.base.height - 50.0;
            if ($31) {
                return -(particle.y - (params.base.height - 50.0)) * 0.1;
            };
            return 0.0;
        })();
        return {
            fx: fx1 + fx2,
            fy: fy1 + fy2
        };
    };
};
var applyMorphEasing = function (easing) {
    return function (t) {
        if (easing instanceof EaseIn) {
            return t * t;
        };
        if (easing instanceof EaseOut) {
            return 1.0 - (1.0 - t) * (1.0 - t);
        };
        if (easing instanceof EaseInOut) {
            var $33 = t < 0.5;
            if ($33) {
                return 2.0 * t * t;
            };
            return 1.0 - ((-2.0 * t + 2.0) * (-2.0 * t + 2.0)) / 2.0;
        };
        throw new Error("Failed pattern match at Lattice.Services.Flow.Patterns (line 300, column 29 - line 305, column 59): " + [ easing.constructor.name ]);
    };
};
var morphPosition = function (params) {
    return function (t) {
        return function (source) {
            return function (target) {
                return function (pointIndex) {
                    return function (frameIndex) {
                        var noise = Lattice_Services_Noise_SimplexNoise.simplexNoise2D(Data_Int.toNumber(pointIndex) * 0.1)(Data_Int.toNumber(frameIndex) * 2.0e-2)(params.base.seed);
                        var noiseOffset = (noise - 0.5) * 20.0 * (1.0 - $$Math.abs(t - 0.5) * 2.0);
                        var easedT = applyMorphEasing(params.easing)(t);
                        var x = source.x + (target.x - source.x) * easedT + noiseOffset;
                        var y = source.y + (target.y - source.y) * easedT + noiseOffset;
                        return clampPoint({
                            x: x,
                            y: y
                        })(0.0)(0.0)(params.base.width)(params.base.height);
                    };
                };
            };
        };
    };
};
export {
    spiralPosition,
    wavePosition,
    initExplosionParticle,
    stepExplosionParticle,
    initVortexParticle,
    stepVortexParticle,
    riverPath,
    riverPosition,
    Grid,
    Circle,
    Random,
    EaseIn,
    EaseOut,
    EaseInOut,
    applyMorphEasing,
    gridPosition,
    circlePosition,
    morphPosition,
    cohesionForce,
    separationForce,
    boundaryForce,
    clampVelocity,
    updateSwarmParticle,
    eqMorphShape,
    eqMorphEasing
};
//# sourceMappingURL=index.js.map
