// Generated by purs version 0.15.15
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var CircleShape = /* #__PURE__ */ (function () {
    function CircleShape() {

    };
    CircleShape.value = new CircleShape();
    return CircleShape;
})();
var BoxShape = /* #__PURE__ */ (function () {
    function BoxShape() {

    };
    BoxShape.value = new BoxShape();
    return BoxShape;
})();
var CapsuleShape = /* #__PURE__ */ (function () {
    function CapsuleShape() {

    };
    CapsuleShape.value = new CapsuleShape();
    return CapsuleShape;
})();
var positionCorrection = function (depth) {
    return function (slop) {
        return function (bias) {
            return function (invMassSum) {
                var $9 = invMassSum < 1.0e-4;
                if ($9) {
                    return 0.0;
                };
                var correctionDepth = $$Math.max(0.0)(depth - slop);
                return (correctionDepth * bias) / invMassSum;
            };
        };
    };
};
var momentOfInertiaCircle = function (mass) {
    return function (radius) {
        return (mass * radius * radius) / 2.0;
    };
};
var momentOfInertiaCapsule = function (mass) {
    return function (radius) {
        return function (len) {
            var totalLength = len + $$Math.pi * radius;
            var rectMass = (mass * len) / totalLength;
            var rectI = (rectMass * (len * len + 4.0 * radius * radius)) / 12.0;
            var circleMass = mass - rectMass;
            var circleI = (circleMass * radius * radius) / 2.0;
            return rectI + circleI;
        };
    };
};
var momentOfInertiaBox = function (mass) {
    return function (width) {
        return function (height) {
            return (mass * (width * width + height * height)) / 12.0;
        };
    };
};
var momentOfInertia = function (shapeType) {
    return function (mass) {
        return function (param1) {
            return function (param2) {
                if (shapeType instanceof CircleShape) {
                    return momentOfInertiaCircle(mass)(param1);
                };
                if (shapeType instanceof BoxShape) {
                    return momentOfInertiaBox(mass)(param1)(param2);
                };
                if (shapeType instanceof CapsuleShape) {
                    return momentOfInertiaCapsule(mass)(param1)(param2);
                };
                throw new Error("Failed pattern match at Lattice.Services.Physics.RigidBody (line 89, column 48 - line 92, column 60): " + [ shapeType.constructor.name ]);
            };
        };
    };
};
var integrateVelocity = function (vel) {
    return function (accel) {
        return function (damping) {
            return function (dt) {
                var newVel = vel + accel * dt;
                return newVel * (1.0 - damping * dt);
            };
        };
    };
};
var integratePosition = function (pos) {
    return function (vel) {
        return function (dt) {
            return pos + vel * dt;
        };
    };
};
var integrateBody = function (state) {
    return function (forceX) {
        return function (forceY) {
            return function (torque) {
                return function (linearDamping) {
                    return function (angularDamping) {
                        return function (dt) {
                            var angAccel = torque * state.inverseInertia;
                            var newAngVel = integrateVelocity(state.angularVelocity)(angAccel)(angularDamping)(dt);
                            var newAngle = integratePosition(state.angle)(newAngVel)(dt);
                            var accelY = forceY * state.inverseMass;
                            var newVelY = integrateVelocity(state.velY)(accelY)(linearDamping)(dt);
                            var newPosY = integratePosition(state.posY)(newVelY)(dt);
                            var accelX = forceX * state.inverseMass;
                            var newVelX = integrateVelocity(state.velX)(accelX)(linearDamping)(dt);
                            var newPosX = integratePosition(state.posX)(newVelX)(dt);
                            return {
                                inverseMass: state.inverseMass,
                                inverseInertia: state.inverseInertia,
                                posX: newPosX,
                                posY: newPosY,
                                velX: newVelX,
                                velY: newVelY,
                                angle: newAngle,
                                angularVelocity: newAngVel
                            };
                        };
                    };
                };
            };
        };
    };
};
var eqShapeType = {
    eq: function (x) {
        return function (y) {
            if (x instanceof CircleShape && y instanceof CircleShape) {
                return true;
            };
            if (x instanceof BoxShape && y instanceof BoxShape) {
                return true;
            };
            if (x instanceof CapsuleShape && y instanceof CapsuleShape) {
                return true;
            };
            return false;
        };
    }
};
var calculateImpulseMagnitude = function (normalVelocity) {
    return function (restitution) {
        return function (invMassSum) {
            return function (angularTerm) {
                var denominator = invMassSum + angularTerm;
                var $13 = denominator < 1.0e-4;
                if ($13) {
                    return 0.0;
                };
                return (-(1.0 + restitution) * normalVelocity) / denominator;
            };
        };
    };
};
var calculateFrictionImpulse = function (tangentVelocity) {
    return function (invMassSum) {
        return function (normalImpulse) {
            return function (friction) {
                var $14 = invMassSum < 1.0e-4;
                if ($14) {
                    return 0.0;
                };
                var maxFriction = normalImpulse * friction;
                var jt = -tangentVelocity / invMassSum;
                return $$Math.max(-maxFriction)($$Math.min(maxFriction)(jt));
            };
        };
    };
};
var applyImpulse = function (velX) {
    return function (velY) {
        return function (angVel) {
            return function (impulseX) {
                return function (impulseY) {
                    return function (rx) {
                        return function (ry) {
                            return function (inverseMass) {
                                return function (inverseInertia) {
                                    return function (sign) {
                                        var rCrossI = rx * impulseY - ry * impulseX;
                                        var newVelY = velY + sign * impulseY * inverseMass;
                                        var newVelX = velX + sign * impulseX * inverseMass;
                                        var newAngVel = angVel + sign * rCrossI * inverseInertia;
                                        return new Data_Tuple.Tuple(new Data_Tuple.Tuple(newVelX, newVelY), newAngVel);
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
var angularImpulseTerm = function (rx) {
    return function (ry) {
        return function (nx) {
            return function (ny) {
                return function (inverseInertia) {
                    var rCrossN = rx * ny - ry * nx;
                    return rCrossN * rCrossN * inverseInertia;
                };
            };
        };
    };
};
export {
    CircleShape,
    BoxShape,
    CapsuleShape,
    momentOfInertiaCircle,
    momentOfInertiaBox,
    momentOfInertiaCapsule,
    momentOfInertia,
    integrateVelocity,
    integratePosition,
    integrateBody,
    calculateImpulseMagnitude,
    angularImpulseTerm,
    calculateFrictionImpulse,
    positionCorrection,
    applyImpulse,
    eqShapeType
};
//# sourceMappingURL=index.js.map
