// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Map_Internal from "../Data.Map.Internal/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showNumber);
var div = /* #__PURE__ */ Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt);
var lookup = /* #__PURE__ */ Data_Map_Internal.lookup(Data_Ord.ordString);
var insert = /* #__PURE__ */ Data_Map_Internal.insert(Data_Ord.ordString);
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_Foldable.foldableArray);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var vertexKey = function (vertex) {
    return show(vertex.x) + ("," + (show(vertex.y) + ("," + show(vertex.z))));
};
var simplificationStats = function (originalVertexCount) {
    return function (simplified) {
        var newCount = div(Data_Array.length(simplified.positions))(3);
        var reduction = (function () {
            var $20 = originalVertexCount > 0;
            if ($20) {
                return (1.0 - Data_Int.toNumber(newCount) / Data_Int.toNumber(originalVertexCount)) * 100.0;
            };
            return 0.0;
        })();
        return new Data_Tuple.Tuple(newCount, reduction);
    };
};
var roundToTolerance = function (v) {
    return function (tolerance) {
        if (tolerance <= 0.0) {
            return v;
        };
        if (Data_Boolean.otherwise) {
            return Data_Int.toNumber(Data_Int.round(v / tolerance)) * tolerance;
        };
        throw new Error("Failed pattern match at Lattice.Services.SVGExtrusion.Simplify (line 59, column 1 - line 59, column 47): " + [ v.constructor.name, tolerance.constructor.name ]);
    };
};
var roundVertex = function (vertex) {
    return function (tolerance) {
        return {
            x: roundToTolerance(vertex.x)(tolerance),
            y: roundToTolerance(vertex.y)(tolerance),
            z: roundToTolerance(vertex.z)(tolerance)
        };
    };
};
var weldVertices = function (vertices) {
    return function (tolerance) {
        var processVertex = function (state) {
            return function (vertex) {
                var rounded = roundVertex(vertex)(tolerance);
                var key = vertexKey(rounded);
                var v = lookup(key)(state.seenKeys);
                if (v instanceof Data_Maybe.Just) {
                    return {
                        positions: state.positions,
                        seenKeys: state.seenKeys,
                        nextIndex: state.nextIndex,
                        indexMap: Data_Array.snoc(state.indexMap)(v.value0)
                    };
                };
                if (v instanceof Data_Maybe.Nothing) {
                    var newPositions = Data_Array.snoc(Data_Array.snoc(Data_Array.snoc(state.positions)(rounded.x))(rounded.y))(rounded.z);
                    var newSeenKeys = insert(key)(state.nextIndex)(state.seenKeys);
                    return {
                        positions: newPositions,
                        seenKeys: newSeenKeys,
                        indexMap: Data_Array.snoc(state.indexMap)(state.nextIndex),
                        nextIndex: state.nextIndex + 1 | 0
                    };
                };
                throw new Error("Failed pattern match at Lattice.Services.SVGExtrusion.Simplify (line 104, column 12 - line 115, column 17): " + [ v.constructor.name ]);
            };
        };
        var initialState = {
            positions: [  ],
            seenKeys: Data_Map_Internal.empty,
            indexMap: [  ],
            nextIndex: 0
        };
        var finalState = foldl(processVertex)(initialState)(vertices);
        return {
            positions: finalState.positions,
            indices: [  ],
            originalToNew: finalState.indexMap
        };
    };
};
var remapIndices = function (originalIndices) {
    return function (indexMap) {
        var remap = function (oldIdx) {
            return Data_Maybe.fromMaybe(oldIdx)(Data_Array.index(indexMap)(oldIdx));
        };
        return map(remap)(originalIndices);
    };
};
var isDegenerateTriangle = function (i0) {
    return function (i1) {
        return function (i2) {
            return i0 === i1 || (i1 === i2 || i0 === i2);
        };
    };
};
var removeDegenerateTriangles = function (indices) {
    var triCount = div(Data_Array.length(indices))(3);
    var process = function ($copy_i) {
        return function ($copy_acc) {
            var $tco_var_i = $copy_i;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(i, acc) {
                if (i >= triCount) {
                    $tco_done = true;
                    return acc;
                };
                if (Data_Boolean.otherwise) {
                    var base = i * 3 | 0;
                    var i0 = Data_Maybe.fromMaybe(0)(Data_Array.index(indices)(base));
                    var i11 = Data_Maybe.fromMaybe(0)(Data_Array.index(indices)(base + 1 | 0));
                    var i2 = Data_Maybe.fromMaybe(0)(Data_Array.index(indices)(base + 2 | 0));
                    var $27 = isDegenerateTriangle(i0)(i11)(i2);
                    if ($27) {
                        $tco_var_i = i + 1 | 0;
                        $copy_acc = acc;
                        return;
                    };
                    $tco_var_i = i + 1 | 0;
                    $copy_acc = Data_Array.snoc(Data_Array.snoc(Data_Array.snoc(acc)(i0))(i11))(i2);
                    return;
                };
                throw new Error("Failed pattern match at Lattice.Services.SVGExtrusion.Simplify (line 145, column 7 - line 145, column 47): " + [ i.constructor.name, acc.constructor.name ]);
            };
            while (!$tco_done) {
                $tco_result = $tco_loop($tco_var_i, $copy_acc);
            };
            return $tco_result;
        };
    };
    return process(0)([  ]);
};
var simplifyGeometry = function (vertices) {
    return function (indices) {
        return function (tolerance) {
            var welded = weldVertices(vertices)(tolerance);
            var remappedIndices = remapIndices(indices)(welded.originalToNew);
            var cleanIndices = removeDegenerateTriangles(remappedIndices);
            return {
                positions: welded.positions,
                originalToNew: welded.originalToNew,
                indices: cleanIndices
            };
        };
    };
};
export {
    roundToTolerance,
    roundVertex,
    vertexKey,
    weldVertices,
    remapIndices,
    isDegenerateTriangle,
    removeDegenerateTriangles,
    simplifyGeometry,
    simplificationStats
};
//# sourceMappingURL=index.js.map
