// Generated by purs version 0.15.15
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Identity from "../Data.Identity/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Effect_Aff from "../Effect.Aff/index.js";
import * as $$Math from "../Math/index.js";
import * as Test_Lattice_TestHelpers from "../Test.Lattice.TestHelpers/index.js";
import * as Test_Spec from "../Test.Spec/index.js";
import * as Test_Spec_Assertions from "../Test.Spec.Assertions/index.js";
var describe = /* #__PURE__ */ Test_Spec.describe(Data_Identity.monadIdentity);
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit);
var discard1 = /* #__PURE__ */ discard(/* #__PURE__ */ Test_Spec.bindSpecT(Data_Identity.bindIdentity));
var it = /* #__PURE__ */ Test_Spec.it(Data_Identity.monadIdentity)(Test_Spec.exampleMUnit);
var shouldEqual = /* #__PURE__ */ Test_Spec_Assertions.shouldEqual(Effect_Aff.monadThrowAff);
var shouldEqual1 = /* #__PURE__ */ shouldEqual(Data_Show.showBoolean)(Data_Eq.eqBoolean);
var shouldEqual2 = /* #__PURE__ */ shouldEqual(Data_Show.showNumber)(Data_Eq.eqNumber);
var discard2 = /* #__PURE__ */ discard(Effect_Aff.bindAff);
var shouldEqual3 = /* #__PURE__ */ shouldEqual(Data_Show.showString)(Data_Eq.eqString);
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_Foldable.foldableArray);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var shouldEqual4 = /* #__PURE__ */ shouldEqual(Data_Show.showInt)(Data_Eq.eqInt);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var shouldEqual5 = /* #__PURE__ */ shouldEqual(/* #__PURE__ */ Data_Show.showArray(Data_Show.showNumber))(/* #__PURE__ */ Data_Eq.eqArray(Data_Eq.eqNumber));
var tutorial04Tests = /* #__PURE__ */ describe("Tutorial 04 Speed Graph Steps")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("Speed Graph view exists in Curve Editor")(/* #__PURE__ */ (function () {
    var viewModes = [ "value", "speed" ];
    return shouldEqual1(Data_Foldable.elem(Data_Foldable.foldableArray)(Data_Eq.eqString)("speed")(viewModes))(true);
})()))(function () {
    return discard1(it("Speed Graph shows derivative of property values")((function () {
        var deltaValue = 100.0 - 0.0;
        var deltaTime = 1.0 / 30.0;
        var speed = $$Math.abs(deltaValue / deltaTime);
        return shouldEqual2(speed)(3000.0);
    })()))(function () {
        return discard1(it("Speed Graph creates bell curve for ease animations")(shouldEqual1(true)(true)))(function () {
            return it("Speed Graph Y axis shows velocity units")(discard2(shouldEqual3("px/sec")("px/sec"))(function () {
                return shouldEqual3("deg/sec")("deg/sec");
            }));
        });
    });
}));
var speedGraphValueRangeTests = /* #__PURE__ */ describe("Speed Graph Value Range")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("computes max speed across all curves")(/* #__PURE__ */ (function () {
    var curve2Speeds = [ 20.0, 100.0, 40.0 ];
    var curve1Speeds = [ 10.0, 50.0, 30.0 ];
    var allSpeeds = Data_Semigroup.append(Data_Semigroup.semigroupArray)(curve1Speeds)(curve2Speeds);
    var maxSpeed = foldl(max)(0.0)(allSpeeds);
    return shouldEqual2(maxSpeed)(100.0);
})()))(function () {
    return discard1(it("adds padding to max speed")((function () {
        var rangeMax = 100.0 * 1.2;
        return shouldEqual2(rangeMax)(120.0);
    })()))(function () {
        return it("defaults to 100 for minimum max speed")((function () {
            var speeds = [ 5.0, 10.0, 15.0 ];
            var computedMax = foldl(max)(0.0)(speeds);
            var rangeMax = max(100.0)(computedMax * 1.2);
            return shouldEqual2(rangeMax)(100.0);
        })());
    });
}));
var speedGraphUITests = /* #__PURE__ */ describe("Speed Graph UI")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("graph mode can be set to speed")(/* #__PURE__ */ shouldEqual3("speed")("speed")))(function () {
    return discard1(it("graph mode can be set to value")(shouldEqual3("value")("value")))(function () {
        return discard1(it("Y axis units for position speed")(shouldEqual3("px/sec")("px/sec")))(function () {
            return discard1(it("Y axis units for rotation speed")(shouldEqual3("deg/sec")("deg/sec")))(function () {
                return discard1(it("speed range starts at 0")((function () {
                    var speedRange = {
                        min: 0.0,
                        max: 100.0
                    };
                    return shouldEqual2(speedRange.min)(0.0);
                })()))(function () {
                    return it("speed range auto-scales to max speed")((function () {
                        var speeds = [ 10.0, 50.0, 120.0, 80.0, 30.0 ];
                        var maxSpeed = foldl(max)(0.0)(speeds);
                        var paddedMax = maxSpeed * 1.2;
                        return shouldEqual2(paddedMax)(144.0);
                    })());
                });
            });
        });
    });
}));
var speedGraphRenderingTests = /* #__PURE__ */ describe("Speed Graph Rendering")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("speed curve samples at sub-frame resolution")(/* #__PURE__ */ (function () {
    var expectedSamples = $$Math.ceil(10.0 / 0.5);
    return shouldEqual2(expectedSamples)(20.0);
})()))(function () {
    return it("speed curve uses two-pass rendering")(discard2(shouldEqual4(2)(2))(function () {
        return discard2(shouldEqual3("#000")("#000"))(function () {
            return shouldEqual1(4.0 > 2.0)(true);
        });
    }));
}));
var speedCalculationTests = /* #__PURE__ */ describe("Speed Calculation Logic")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("constant speed for linear interpolation")(/* #__PURE__ */ (function () {
    var timeInSeconds = 30.0 / 30.0;
    var expectedSpeed = $$Math.abs(100.0 - 0.0) / timeInSeconds;
    return shouldEqual2(expectedSpeed)(100.0);
})()))(function () {
    return discard1(it("zero speed at hold keyframes")(shouldEqual2(0.0)(0.0)))(function () {
        return discard1(it("variable speed for bezier interpolation")(discard2(shouldEqual1(100.0 > 0.0)(true))(function () {
            return discard2(shouldEqual1(100.0 > 0.0)(true))(function () {
                return discard2(shouldEqual1(50.0 > 0.0)(true))(function () {
                    return shouldEqual1(50.0 < 100.0)(true);
                });
            });
        })))(function () {
            return it("speed graph derivative formula")((function () {
                var valueAtT = function (x) {
                    return 100.0 * x;
                };
                var v1 = valueAtT(0.5);
                var epsilon = 1.0 / 30.0;
                var v2 = valueAtT(0.5 + epsilon);
                var speed = $$Math.abs(v2 - v1) / epsilon;
                return Test_Lattice_TestHelpers.assertCloseTo(0.1)(100.0)(speed);
            })());
        });
    });
}));
var cubicBezierValue = function (p0) {
    return function (p1) {
        return function (p2) {
            return function (p3) {
                return function (t) {
                    var mt = 1.0 - t;
                    return mt * mt * mt * p0 + 3.0 * mt * mt * t * p1 + 3.0 * mt * t * t * p2 + t * t * t * p3;
                };
            };
        };
    };
};
var cubicBezierSpeed = function (p0) {
    return function (p1) {
        return function (p2) {
            return function (p3) {
                return function (t) {
                    return function (fps) {
                        var v1 = cubicBezierValue(p0)(p1)(p2)(p3)(t);
                        var epsilon = 1.0 / fps;
                        var v2 = cubicBezierValue(p0)(p1)(p2)(p3)(min(1.0)(t + epsilon));
                        return $$Math.abs(v2 - v1) * fps;
                    };
                };
            };
        };
    };
};
var cubicBezierSpeedTests = /* #__PURE__ */ describe("Cubic Bezier Speed")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("ease-in-out creates bell curve speed")(/* #__PURE__ */ (function () {
    var speedEnd = cubicBezierSpeed(0.0)(0.0)(100.0)(100.0)(0.95)(30.0);
    var speedMid = cubicBezierSpeed(0.0)(0.0)(100.0)(100.0)(0.5)(30.0);
    var speedStart = cubicBezierSpeed(0.0)(0.0)(100.0)(100.0)(0.0)(30.0);
    return discard2(shouldEqual1(speedMid > speedStart)(true))(function () {
        return shouldEqual1(speedMid > speedEnd)(true);
    });
})()))(function () {
    return discard1(it("linear bezier has constant speed")((function () {
        var speed1 = cubicBezierSpeed(0.0)(33.33)(66.67)(100.0)(0.25)(30.0);
        var speed2 = cubicBezierSpeed(0.0)(33.33)(66.67)(100.0)(0.5)(30.0);
        var speed3 = cubicBezierSpeed(0.0)(33.33)(66.67)(100.0)(0.75)(30.0);
        return discard2(shouldEqual1($$Math.abs(speed1 - speed2) < 50.0)(true))(function () {
            return shouldEqual1($$Math.abs(speed2 - speed3) < 50.0)(true);
        });
    })()))(function () {
        return discard1(it("ease-in starts slow then accelerates")((function () {
            var speedEnd = cubicBezierSpeed(0.0)(0.0)(0.0)(100.0)(0.9)(30.0);
            var speedStart = cubicBezierSpeed(0.0)(0.0)(0.0)(100.0)(0.1)(30.0);
            return shouldEqual1(speedEnd > speedStart)(true);
        })()))(function () {
            return it("ease-out starts fast then decelerates")((function () {
                var speedEnd = cubicBezierSpeed(0.0)(100.0)(100.0)(100.0)(0.9)(30.0);
                var speedStart = cubicBezierSpeed(0.0)(100.0)(100.0)(100.0)(0.1)(30.0);
                return shouldEqual1(speedStart > speedEnd)(true);
            })());
        });
    });
}));
var calculateSpeedCurve = function (keyframes) {
    return function (fps) {
        return Data_Array.zipWith(function (x1) {
            return function (x2) {
                return $$Math.abs(x2 - x1) * fps;
            };
        })(keyframes)(Data_Array.drop(1)(keyframes));
    };
};
var determinismTests = /* #__PURE__ */ describe("Determinism")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("speed calculation is deterministic")(/* #__PURE__ */ (function () {
    var calculateSpeed = function (v1) {
        return function (v2) {
            return function (fps) {
                return $$Math.abs(v2 - v1) * fps;
            };
        };
    };
    var result1 = calculateSpeed(0.0)(100.0)(30.0);
    var result2 = calculateSpeed(0.0)(100.0)(30.0);
    var result3 = calculateSpeed(0.0)(100.0)(30.0);
    return discard2(shouldEqual2(result1)(result2))(function () {
        return shouldEqual2(result2)(result3);
    });
})()))(function () {
    return it("speed graph same at any playhead position")((function () {
        var keyframes = [ 0.0, 50.0, 100.0 ];
        var speeds1 = calculateSpeedCurve(keyframes)(30.0);
        var speeds2 = calculateSpeedCurve(keyframes)(30.0);
        return shouldEqual5(speeds1)(speeds2);
    })());
}));
var spec = /* #__PURE__ */ describe("Speed Graph")(/* #__PURE__ */ discard1(speedCalculationTests)(function () {
    return discard1(speedGraphUITests)(function () {
        return discard1(speedGraphRenderingTests)(function () {
            return discard1(cubicBezierSpeedTests)(function () {
                return discard1(speedGraphValueRangeTests)(function () {
                    return discard1(tutorial04Tests)(function () {
                        return determinismTests;
                    });
                });
            });
        });
    });
}));
export {
    spec
};
//# sourceMappingURL=index.js.map
