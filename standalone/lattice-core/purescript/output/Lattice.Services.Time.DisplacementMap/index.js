// Generated by purs version 0.15.15
import * as Data_Int from "../Data.Int/index.js";
import * as $$Math from "../Math/index.js";
var GradientH = /* #__PURE__ */ (function () {
    function GradientH() {

    };
    GradientH.value = new GradientH();
    return GradientH;
})();
var GradientV = /* #__PURE__ */ (function () {
    function GradientV() {

    };
    GradientV.value = new GradientV();
    return GradientV;
})();
var Radial = /* #__PURE__ */ (function () {
    function Radial() {

    };
    Radial.value = new Radial();
    return Radial;
})();
var SineH = /* #__PURE__ */ (function () {
    function SineH() {

    };
    SineH.value = new SineH();
    return SineH;
})();
var SineV = /* #__PURE__ */ (function () {
    function SineV() {

    };
    SineV.value = new SineV();
    return SineV;
})();
var Diagonal = /* #__PURE__ */ (function () {
    function Diagonal() {

    };
    Diagonal.value = new Diagonal();
    return Diagonal;
})();
var CenterOut = /* #__PURE__ */ (function () {
    function CenterOut() {

    };
    CenterOut.value = new CenterOut();
    return CenterOut;
})();
var toFrameOffset = function (biasedValue) {
    return function (maxDisplacement) {
        return Data_Int.round((biasedValue - 0.5) * 2.0 * maxDisplacement);
    };
};
var sineV = function (v) {
    return function (v1) {
        return function (v2) {
            if (v1 === 0) {
                return 0.5;
            };
            var normalizedY = Data_Int.toNumber(v) / Data_Int.toNumber(v1);
            return 0.5 + 0.5 * $$Math.sin(normalizedY * $$Math.pi * 2.0 * v2);
        };
    };
};
var sineH = function (v) {
    return function (v1) {
        return function (v2) {
            if (v1 === 0) {
                return 0.5;
            };
            var normalizedX = Data_Int.toNumber(v) / Data_Int.toNumber(v1);
            return 0.5 + 0.5 * $$Math.sin(normalizedX * $$Math.pi * 2.0 * v2);
        };
    };
};
var radialDistance = function (v) {
    return function (v1) {
        return function (v2) {
            return function (v3) {
                if (v2 === 0) {
                    return 0.5;
                };
                if (v3 === 0) {
                    return 0.5;
                };
                var cy = Data_Int.toNumber(v3) / 2.0;
                var dy = Data_Int.toNumber(v1) - cy;
                var cx = Data_Int.toNumber(v2) / 2.0;
                var dx = Data_Int.toNumber(v) - cx;
                var dist = $$Math.sqrt(dx * dx + dy * dy);
                var maxDist = $$Math.sqrt(cx * cx + cy * cy);
                var $32 = maxDist < 1.0e-4;
                if ($32) {
                    return 0.0;
                };
                return dist / maxDist;
            };
        };
    };
};
var radial = radialDistance;
var gradientV = function (v) {
    return function (v1) {
        if (v1 === 0) {
            return 0.5;
        };
        return Data_Int.toNumber(v) / Data_Int.toNumber(v1);
    };
};
var gradientH = function (v) {
    return function (v1) {
        if (v1 === 0) {
            return 0.5;
        };
        return Data_Int.toNumber(v) / Data_Int.toNumber(v1);
    };
};
var eqMapType = {
    eq: function (x) {
        return function (y) {
            if (x instanceof GradientH && y instanceof GradientH) {
                return true;
            };
            if (x instanceof GradientV && y instanceof GradientV) {
                return true;
            };
            if (x instanceof Radial && y instanceof Radial) {
                return true;
            };
            if (x instanceof SineH && y instanceof SineH) {
                return true;
            };
            if (x instanceof SineV && y instanceof SineV) {
                return true;
            };
            if (x instanceof Diagonal && y instanceof Diagonal) {
                return true;
            };
            if (x instanceof CenterOut && y instanceof CenterOut) {
                return true;
            };
            return false;
        };
    }
};
var diagonal = function (x) {
    return function (y) {
        return function (width) {
            return function (height) {
                return (gradientH(x)(width) + gradientV(y)(height)) / 2.0;
            };
        };
    };
};
var centerOut = function (x) {
    return function (y) {
        return function (width) {
            return function (height) {
                return 1.0 - radialDistance(x)(y)(width)(height);
            };
        };
    };
};
var getDisplacementValue = function (mapType) {
    return function (x) {
        return function (y) {
            return function (width) {
                return function (height) {
                    return function (scale) {
                        if (mapType instanceof GradientH) {
                            return gradientH(x)(width);
                        };
                        if (mapType instanceof GradientV) {
                            return gradientV(y)(height);
                        };
                        if (mapType instanceof Radial) {
                            return radial(x)(y)(width)(height);
                        };
                        if (mapType instanceof SineH) {
                            return sineH(x)(width)(scale);
                        };
                        if (mapType instanceof SineV) {
                            return sineV(y)(height)(scale);
                        };
                        if (mapType instanceof Diagonal) {
                            return diagonal(x)(y)(width)(height);
                        };
                        if (mapType instanceof CenterOut) {
                            return centerOut(x)(y)(width)(height);
                        };
                        throw new Error("Failed pattern match at Lattice.Services.Time.DisplacementMap (line 121, column 55 - line 128, column 42): " + [ mapType.constructor.name ]);
                    };
                };
            };
        };
    };
};
var applyBias = function (dispValue) {
    return function (bias) {
        return dispValue + bias;
    };
};
var calculateTargetFrame = function (currentFrame) {
    return function (dispValue) {
        return function (bias) {
            return function (maxDisplacement) {
                var biased = applyBias(dispValue)(bias);
                var offset = toFrameOffset(biased)(maxDisplacement);
                return currentFrame + offset | 0;
            };
        };
    };
};
export {
    gradientH,
    gradientV,
    diagonal,
    radialDistance,
    radial,
    centerOut,
    sineH,
    sineV,
    GradientH,
    GradientV,
    Radial,
    SineH,
    SineV,
    Diagonal,
    CenterOut,
    getDisplacementValue,
    applyBias,
    toFrameOffset,
    calculateTargetFrame,
    eqMapType
};
//# sourceMappingURL=index.js.map
