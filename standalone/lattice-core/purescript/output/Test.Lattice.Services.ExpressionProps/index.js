// Generated by purs version 0.15.15
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Identity from "../Data.Identity/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Effect_Aff from "../Effect.Aff/index.js";
import * as $$Math from "../Math/index.js";
import * as Test_Lattice_TestHelpers from "../Test.Lattice.TestHelpers/index.js";
import * as Test_Spec from "../Test.Spec/index.js";
import * as Test_Spec_Assertions from "../Test.Spec.Assertions/index.js";
var describe = /* #__PURE__ */ Test_Spec.describe(Data_Identity.monadIdentity);
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit);
var discard1 = /* #__PURE__ */ discard(/* #__PURE__ */ Test_Spec.bindSpecT(Data_Identity.bindIdentity));
var it = /* #__PURE__ */ Test_Spec.it(Data_Identity.monadIdentity)(Test_Spec.exampleMUnit);
var for_ = /* #__PURE__ */ Data_Foldable.for_(Effect_Aff.applicativeAff)(Data_Foldable.foldableArray);
var pure = /* #__PURE__ */ Control_Applicative.pure(Effect_Aff.applicativeAff);
var fail = /* #__PURE__ */ Test_Spec_Assertions.fail(Effect_Aff.monadThrowAff);
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showNumber);
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var shouldEqual = /* #__PURE__ */ Test_Spec_Assertions.shouldEqual(Effect_Aff.monadThrowAff)(Data_Show.showNumber)(Data_Eq.eqNumber);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var discard2 = /* #__PURE__ */ discard(Effect_Aff.bindAff);
var timeRamp = function (startTime) {
    return function (endTime) {
        return function (startValue) {
            return function (endValue) {
                return function (time) {
                    if (time <= startTime) {
                        return startValue;
                    };
                    if (time >= endTime) {
                        return endValue;
                    };
                    if (Data_Boolean.otherwise) {
                        var t = (time - startTime) / (endTime - startTime);
                        return startValue + (endValue - startValue) * t;
                    };
                    throw new Error("Failed pattern match at Test.Lattice.Services.ExpressionProps (line 94, column 1 - line 94, column 69): " + [ startTime.constructor.name, endTime.constructor.name, startValue.constructor.name, endValue.constructor.name, time.constructor.name ]);
                };
            };
        };
    };
};
var squareWave = function (time) {
    return function (frequency) {
        return function (amplitude) {
            var period = 1.0 / frequency;
            var phase = time / period - $$Math.floor(time / period);
            var $42 = phase < 0.5;
            if ($42) {
                return amplitude;
            };
            return -amplitude;
        };
    };
};
var squareProperties = /* #__PURE__ */ describe("timeExpressions.square")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("square only produces +amplitude or -amplitude")(/* #__PURE__ */ for_([ 1.0, 5.0, 100.0 ])(function (amplitude) {
    return for_([ 0.1, 0.25, 0.3, 0.6, 0.75, 0.9 ])(function (time) {
        var result = squareWave(time)(1.0)(amplitude);
        var isPositive = $$Math.abs(result - amplitude) < 1.0e-6;
        var isNegative = $$Math.abs(result + amplitude) < 1.0e-6;
        var $43 = isPositive || isNegative;
        if ($43) {
            return pure(Data_Unit.unit);
        };
        return fail("square(" + (show(time) + (") = " + (show(result) + (", expected \xb1" + show(amplitude))))));
    });
})))(function () {
    return it("square is periodic")(for_([ 0.1, 0.3 ])(function (time) {
        return for_([ 1.0, 10.0 ])(function (amplitude) {
            var period = 1.0 / 1.0;
            var t1 = time + 1.0e-2;
            var t2 = t1 + period * 2.0;
            var result1 = squareWave(t1)(1.0)(amplitude);
            var result2 = squareWave(t2)(1.0)(amplitude);
            return Test_Lattice_TestHelpers.assertCloseTo(1.0e-4)(result1)(result2);
        });
    }));
}));
var sineWave = function (time) {
    return function (frequency) {
        return function (amplitude) {
            return function (phase) {
                return amplitude * $$Math.sin(2.0 * $$Math.pi * frequency * time + phase);
            };
        };
    };
};
var sineProperties = /* #__PURE__ */ describe("timeExpressions.sine")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("sine is bounded by amplitude")(/* #__PURE__ */ for_([ 1.0, 5.0, 100.0 ])(function (amplitude) {
    return for_([ 0.0, 0.25, 0.5, 0.75, 1.0, 2.0 ])(function (time) {
        var result = sineWave(time)(1.0)(amplitude)(0.0);
        return Test_Lattice_TestHelpers.assertInRange(-amplitude - 1.0e-10)(amplitude + 1.0e-10)(result);
    });
})))(function () {
    return discard1(it("sine(0, f, a, 0) = 0")(for_([ 1.0, 10.0, 50.0 ])(function (amplitude) {
        return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(0.0)(sineWave(0.0)(1.0)(amplitude)(0.0));
    })))(function () {
        return it("sine is periodic: sine(t) = sine(t + period)")(for_([ 0.1, 0.25, 0.5, 0.7 ])(function (time) {
            return for_([ 1.0, 10.0, 50.0 ])(function (amplitude) {
                var period = 1.0 / 1.0;
                var result1 = sineWave(time)(1.0)(amplitude)(0.0);
                var result2 = sineWave(time + period)(1.0)(amplitude)(0.0);
                return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(result1)(result2);
            });
        }));
    });
}));
var seedRandom = function (seed) {
    var s1 = mod((seed * 16807 | 0) + 1 | 0)(2147483647);
    var normalized = Data_Int.toNumber((function () {
        var $44 = s1 < 0;
        if ($44) {
            return -s1 | 0;
        };
        return s1;
    })()) / 2.147483647e9;
    return normalized;
};
var seedRandomBounded = function (seed) {
    return function (lo) {
        return function (hi) {
            var base = seedRandom(seed);
            return lo + base * (hi - lo);
        };
    };
};
var seedRandomProperties = /* #__PURE__ */ describe("mathExpressions.seedRandom")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("seedRandom is deterministic (same seed = same result)")(/* #__PURE__ */ for_([ 0, 1, 42, 12345, 999999 ])(function (seed) {
    var result1 = seedRandom(seed);
    var result2 = seedRandom(seed);
    return shouldEqual(result1)(result2);
})))(function () {
    return discard1(it("seedRandom respects min/max bounds")(for_([ 0, 1, 42, 999 ])(function (seed) {
        return for_([ {
            lo: 0.0,
            hi: 100.0
        }, {
            lo: -50.0,
            hi: 50.0
        }, {
            lo: 10.0,
            hi: 20.0
        } ])(function (v) {
            var result = seedRandomBounded(seed)(v.lo)(v.hi);
            return Test_Lattice_TestHelpers.assertInRange(v.lo - 1.0e-10)(v.hi + 1.0e-10)(result);
        });
    })))(function () {
        return it("seedRandom always returns finite")(for_([ 0, 1, 42, 12345, 999999 ])(function (seed) {
            return Test_Lattice_TestHelpers.assertFinite(seedRandom(seed));
        }));
    });
}));
var sawtoothWave = function (time) {
    return function (frequency) {
        return function (amplitude) {
            var period = 1.0 / frequency;
            var phase = time / period - $$Math.floor(time / period);
            return amplitude * (2.0 * phase - 1.0);
        };
    };
};
var sawtoothProperties = /* #__PURE__ */ describe("timeExpressions.sawtooth")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("sawtooth is bounded by amplitude")(/* #__PURE__ */ for_([ 1.0, 5.0, 100.0 ])(function (amplitude) {
    return for_([ 1.0e-2, 0.25, 0.5, 0.75, 0.99, 1.5, 2.3 ])(function (time) {
        var result = sawtoothWave(time)(1.0)(amplitude);
        return Test_Lattice_TestHelpers.assertInRange(-amplitude - 1.0e-6)(amplitude + 1.0e-6)(result);
    });
})))(function () {
    return it("sawtooth is periodic")(for_([ 0.1, 0.3, 0.7 ])(function (time) {
        return for_([ 1.0, 10.0 ])(function (amplitude) {
            var period = 1.0 / 1.0;
            var t2 = time + period * 3.0;
            var result1 = sawtoothWave(time)(1.0)(amplitude);
            var result2 = sawtoothWave(t2)(1.0)(amplitude);
            return Test_Lattice_TestHelpers.assertCloseTo(1.0e-4)(result1)(result2);
        });
    }));
}));
var sampleValues = /* #__PURE__ */ (function () {
    return [ -100.0, -10.0, -1.0, 0.0, 1.0, 10.0, 100.0 ];
})();
var timeRampProperties = /* #__PURE__ */ describe("timeExpressions.timeRamp")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("timeRamp at startTime returns startValue")(/* #__PURE__ */ for_(sampleValues)(function (startValue) {
    return for_(sampleValues)(function (endValue) {
        return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(startValue)(timeRamp(0.0)(10.0)(startValue)(endValue)(0.0));
    });
})))(function () {
    return discard1(it("timeRamp at endTime returns endValue")(for_(sampleValues)(function (startValue) {
        return for_(sampleValues)(function (endValue) {
            return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(endValue)(timeRamp(0.0)(10.0)(startValue)(endValue)(10.0));
        });
    })))(function () {
        return discard1(it("timeRamp before startTime returns startValue")(for_(sampleValues)(function (startValue) {
            return for_(sampleValues)(function (endValue) {
                return shouldEqual(timeRamp(10.0)(20.0)(startValue)(endValue)(5.0))(startValue);
            });
        })))(function () {
            return it("timeRamp after endTime returns endValue")(for_(sampleValues)(function (startValue) {
                return for_(sampleValues)(function (endValue) {
                    return shouldEqual(timeRamp(10.0)(20.0)(startValue)(endValue)(25.0))(endValue);
                });
            }));
        });
    });
}));
var samplePairs = /* #__PURE__ */ (function () {
    return [ {
        x1: 0.0,
        y1: 0.0,
        x2: 3.0,
        y2: 4.0
    }, {
        x1: -5.0,
        y1: 10.0,
        x2: 5.0,
        y2: -10.0
    }, {
        x1: 100.0,
        y1: 100.0,
        x2: -100.0,
        y2: -100.0
    }, {
        x1: 0.0,
        y1: 0.0,
        x2: 0.0,
        y2: 0.0
    }, {
        x1: 1.0,
        y1: 0.0,
        x2: 0.0,
        y2: 1.0
    } ];
})();
var radiansToDegrees = function (rad) {
    return (rad * 180.0) / $$Math.pi;
};
var mapRange = function (value) {
    return function (inMin) {
        return function (inMax) {
            return function (outMin) {
                return function (outMax) {
                    var inRange = inMax - inMin;
                    var $48 = inRange === 0.0;
                    if ($48) {
                        return outMin;
                    };
                    var normalized = (value - inMin) / inRange;
                    return outMin + normalized * (outMax - outMin);
                };
            };
        };
    };
};
var mapProperties = /* #__PURE__ */ (function () {
    return describe("mathExpressions.map")(discard1(it("map(inMin, inMin, inMax, outMin, outMax) = outMin")(for_([ 0.0, -10.0, 50.0 ])(function (inMin) {
        return for_([ 100.0, 200.0 ])(function (inMax) {
            return for_([ 0.0, -50.0 ])(function (outMin) {
                return for_([ 100.0, 300.0 ])(function (outMax) {
                    return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(outMin)(mapRange(inMin)(inMin)(inMax)(outMin)(outMax));
                });
            });
        });
    })))(function () {
        return discard1(it("map(inMax, inMin, inMax, outMin, outMax) = outMax")(for_([ 0.0, -10.0 ])(function (inMin) {
            return for_([ 100.0, 200.0 ])(function (inMax) {
                return for_([ 0.0, -50.0 ])(function (outMin) {
                    return for_([ 100.0, 300.0 ])(function (outMax) {
                        return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(outMax)(mapRange(inMax)(inMin)(inMax)(outMin)(outMax));
                    });
                });
            });
        })))(function () {
            return it("map preserves midpoint")(for_([ 0.0, -100.0, 50.0 ])(function (inMin) {
                return for_([ 0.0, -200.0, 100.0 ])(function (outMin) {
                    var inMax = inMin + 100.0;
                    var outMax = outMin + 200.0;
                    var midIn = (inMin + inMax) / 2.0;
                    var expectedMidOut = (outMin + outMax) / 2.0;
                    return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(expectedMidOut)(mapRange(midIn)(inMin)(inMax)(outMin)(outMax));
                });
            }));
        });
    }));
})();
var lerp = function (a) {
    return function (b) {
        return function (t) {
            return a + (b - a) * t;
        };
    };
};
var lerpProperties = /* #__PURE__ */ describe("mathExpressions.lerp")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("lerp(a, b, 0) = a")(/* #__PURE__ */ for_(sampleValues)(function (a) {
    return for_(sampleValues)(function (b) {
        return Test_Lattice_TestHelpers.assertCloseTo(1.0e-10)(a)(lerp(a)(b)(0.0));
    });
})))(function () {
    return discard1(it("lerp(a, b, 1) = b")(for_(sampleValues)(function (a) {
        return for_(sampleValues)(function (b) {
            var result = lerp(a)(b)(1.0);
            var tolerance = max($$Math.abs(b) * 1.0e-9)(1.0e-10);
            return Test_Lattice_TestHelpers.assertCloseTo(tolerance)(b)(result);
        });
    })))(function () {
        return discard1(it("lerp(a, b, 0.5) = midpoint")(for_(sampleValues)(function (a) {
            return for_(sampleValues)(function (b) {
                var result = lerp(a)(b)(0.5);
                var expected = (a + b) / 2.0;
                var tolerance = max($$Math.abs(expected) * 1.0e-9)(1.0e-9);
                return Test_Lattice_TestHelpers.assertCloseTo(tolerance)(expected)(result);
            });
        })))(function () {
            return discard1(it("lerp(a, a, t) = a (same endpoints)")(for_(sampleValues)(function (a) {
                return for_([ 0.0, 0.25, 0.5, 0.75, 1.0 ])(function (t) {
                    return Test_Lattice_TestHelpers.assertCloseTo(1.0e-10)(a)(lerp(a)(a)(t));
                });
            })))(function () {
                return it("lerp result is bounded between a and b")(for_([ 0.0, 10.0, 50.0, 100.0 ])(function (a) {
                    return for_([ 101.0, 150.0, 200.0 ])(function (b) {
                        return for_([ 0.0, 0.25, 0.5, 0.75, 1.0 ])(function (t) {
                            var result = lerp(a)(b)(t);
                            return Test_Lattice_TestHelpers.assertInRange(min(a)(b) - 1.0e-10)(max(a)(b) + 1.0e-10)(result);
                        });
                    });
                }));
            });
        });
    });
}));
var distance = function (x1) {
    return function (y1) {
        return function (x2) {
            return function (y2) {
                var dy = y2 - y1;
                var dx = x2 - x1;
                return $$Math.sqrt(dx * dx + dy * dy);
            };
        };
    };
};
var distanceProperties = /* #__PURE__ */ describe("mathExpressions.distance")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("distance from point to itself is 0")(/* #__PURE__ */ for_(sampleValues)(function (x) {
    return for_(sampleValues)(function (y) {
        return shouldEqual(distance(x)(y)(x)(y))(0.0);
    });
})))(function () {
    return discard1(it("distance is symmetric: d(A,B) = d(B,A)")(for_(samplePairs)(function (v) {
        var d1 = distance(v.x1)(v.y1)(v.x2)(v.y2);
        var d2 = distance(v.x2)(v.y2)(v.x1)(v.y1);
        return Test_Lattice_TestHelpers.assertCloseTo(1.0e-10)(d1)(d2);
    })))(function () {
        return discard1(it("distance is always non-negative")(for_(samplePairs)(function (v) {
            var d = distance(v.x1)(v.y1)(v.x2)(v.y2);
            var $55 = d >= 0.0;
            if ($55) {
                return pure(Data_Unit.unit);
            };
            return fail("distance was negative: " + show(d));
        })))(function () {
            return it("distance matches known values")(discard2(Test_Lattice_TestHelpers.assertCloseTo(1.0e-10)(5.0)(distance(0.0)(0.0)(3.0)(4.0)))(function () {
                return discard2(Test_Lattice_TestHelpers.assertCloseTo(1.0e-10)(10.0)(distance(0.0)(0.0)(10.0)(0.0)))(function () {
                    return Test_Lattice_TestHelpers.assertCloseTo(1.0e-10)(7.0)(distance(0.0)(0.0)(0.0)(7.0));
                });
            }));
        });
    });
}));
var degreesToRadians = function (deg) {
    return (deg * $$Math.pi) / 180.0;
};
var degreeRadianProperties = /* #__PURE__ */ describe("degreesToRadians / radiansToDegrees")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("degreesToRadians -> radiansToDegrees roundtrip")(/* #__PURE__ */ for_(sampleValues)(function (deg) {
    var rad = degreesToRadians(deg);
    var back = radiansToDegrees(rad);
    return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(deg)(back);
})))(function () {
    return discard1(it("90 degrees = PI/2 radians")(Test_Lattice_TestHelpers.assertCloseTo(1.0e-10)($$Math.pi / 2.0)(degreesToRadians(90.0))))(function () {
        return discard1(it("180 degrees = PI radians")(Test_Lattice_TestHelpers.assertCloseTo(1.0e-10)($$Math.pi)(degreesToRadians(180.0))))(function () {
            return it("360 degrees = 2*PI radians")(Test_Lattice_TestHelpers.assertCloseTo(1.0e-10)(2.0 * $$Math.pi)(degreesToRadians(360.0)));
        });
    });
}));
var clamp = function (value) {
    return function (lo) {
        return function (hi) {
            if (value < lo) {
                return lo;
            };
            if (value > hi) {
                return hi;
            };
            if (Data_Boolean.otherwise) {
                return value;
            };
            throw new Error("Failed pattern match at Test.Lattice.Services.ExpressionProps (line 28, column 1 - line 28, column 46): " + [ value.constructor.name, lo.constructor.name, hi.constructor.name ]);
        };
    };
};
var clampProperties = /* #__PURE__ */ describe("mathExpressions.clamp")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("clamp result is always within [min, max]")(/* #__PURE__ */ for_(sampleValues)(function (value) {
    return for_(sampleValues)(function (a) {
        return for_(sampleValues)(function (b) {
            var lo = min(a)(b);
            var hi = max(a)(b);
            var result = clamp(value)(lo)(hi);
            return Test_Lattice_TestHelpers.assertInRange(lo)(hi)(result);
        });
    });
})))(function () {
    return discard1(it("clamp(value, min, max) = value when min <= value <= max")(for_([ 50.0, 75.0, 100.0 ])(function (value) {
        var result = clamp(value)(0.0)(150.0);
        return shouldEqual(result)(value);
    })))(function () {
        return it("clamp(value, min, min) = min")(for_(sampleValues)(function (lo) {
            var result = clamp(lo + 100.0)(lo)(lo);
            return shouldEqual(result)(lo);
        }));
    });
}));
var expressionEase = function (time) {
    return function (tMin) {
        return function (tMax) {
            return function (vMin) {
                return function (vMax) {
                    var t = clamp((time - tMin) / (tMax - tMin))(0.0)(1.0);
                    var eased = t * t * (3.0 - 2.0 * t);
                    return vMin + (vMax - vMin) * eased;
                };
            };
        };
    };
};
var expressionEaseIn = function (time) {
    return function (tMin) {
        return function (tMax) {
            return function (vMin) {
                return function (vMax) {
                    var t = clamp((time - tMin) / (tMax - tMin))(0.0)(1.0);
                    var eased = t * t;
                    return vMin + (vMax - vMin) * eased;
                };
            };
        };
    };
};
var expressionEaseOut = function (time) {
    return function (tMin) {
        return function (tMax) {
            return function (vMin) {
                return function (vMax) {
                    var t = clamp((time - tMin) / (tMax - tMin))(0.0)(1.0);
                    var eased = t * (2.0 - t);
                    return vMin + (vMax - vMin) * eased;
                };
            };
        };
    };
};
var easeProperties = /* #__PURE__ */ describe("expressionEase")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("ease at tMin returns vMin")(/* #__PURE__ */ for_(sampleValues)(function (vMin) {
    return for_(sampleValues)(function (vMax) {
        return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(vMin)(expressionEase(0.0)(0.0)(10.0)(vMin)(vMax));
    });
})))(function () {
    return discard1(it("ease at tMax returns vMax")(for_(sampleValues)(function (vMin) {
        return for_(sampleValues)(function (vMax) {
            return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(vMax)(expressionEase(10.0)(0.0)(10.0)(vMin)(vMax));
        });
    })))(function () {
        return discard1(it("easeIn at tMin returns vMin")(for_(sampleValues)(function (vMin) {
            return for_(sampleValues)(function (vMax) {
                return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(vMin)(expressionEaseIn(0.0)(0.0)(10.0)(vMin)(vMax));
            });
        })))(function () {
            return it("easeOut at tMax returns vMax")(for_(sampleValues)(function (vMin) {
                return for_(sampleValues)(function (vMax) {
                    return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(vMax)(expressionEaseOut(10.0)(0.0)(10.0)(vMin)(vMax));
                });
            }));
        });
    });
}));
var smoothstep = function (edge0) {
    return function (edge1) {
        return function (x) {
            var range = edge1 - edge0;
            var $63 = range === 0.0;
            if ($63) {
                return 0.0;
            };
            var t = clamp((x - edge0) / range)(0.0)(1.0);
            return t * t * (3.0 - 2.0 * t);
        };
    };
};
var smoothstepProperties = /* #__PURE__ */ (function () {
    return describe("mathExpressions.smoothstep")(discard1(it("smoothstep(edge0, edge1, edge0) = 0")(for_([ 0.0, -10.0, 50.0 ])(function (edge0) {
        return for_([ 100.0, 200.0, 500.0 ])(function (edge1) {
            return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(0.0)(smoothstep(edge0)(edge1)(edge0));
        });
    })))(function () {
        return discard1(it("smoothstep(edge0, edge1, edge1) = 1")(for_([ 0.0, -10.0, 50.0 ])(function (edge0) {
            return for_([ 100.0, 200.0, 500.0 ])(function (edge1) {
                return Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(1.0)(smoothstep(edge0)(edge1)(edge1));
            });
        })))(function () {
            return discard1(it("smoothstep is bounded in [0, 1]")(for_(sampleValues)(function (x) {
                var result = smoothstep(0.0)(100.0)(x);
                return Test_Lattice_TestHelpers.assertInRange(-1.0e-10)(1.0 + 1.0e-10)(result);
            })))(function () {
                return it("smoothstep(0, 1, 0.5) = 0.5")(Test_Lattice_TestHelpers.assertCloseTo(1.0e-6)(0.5)(smoothstep(0.0)(1.0)(0.5)));
            });
        });
    }));
})();
var spec = /* #__PURE__ */ describe("EXPRESSION Properties")(/* #__PURE__ */ discard1(lerpProperties)(function () {
    return discard1(clampProperties)(function () {
        return discard1(mapProperties)(function () {
            return discard1(smoothstepProperties)(function () {
                return discard1(seedRandomProperties)(function () {
                    return discard1(sineProperties)(function () {
                        return discard1(sawtoothProperties)(function () {
                            return discard1(squareProperties)(function () {
                                return discard1(timeRampProperties)(function () {
                                    return discard1(easeProperties)(function () {
                                        return discard1(degreeRadianProperties)(function () {
                                            return distanceProperties;
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
}));
export {
    spec
};
//# sourceMappingURL=index.js.map
