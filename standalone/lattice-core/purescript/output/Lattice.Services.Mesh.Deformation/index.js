// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var append = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var add1 = /* #__PURE__ */ Data_Semiring.add(Data_Semiring.semiringNumber);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var Point2D = function (x) {
    return x;
};
var range = function (start) {
    return function (end) {
        if (start > end) {
            return [  ];
        };
        if (Data_Boolean.otherwise) {
            return append([ start ])(range(start + 1 | 0)(end));
        };
        throw new Error("Failed pattern match at Lattice.Services.Mesh.Deformation (line 262, column 1 - line 262, column 33): " + [ start.constructor.name, end.constructor.name ]);
    };
};
var p2dY = function (v) {
    return v.y;
};
var p2dX = function (v) {
    return v.x;
};
var mkWeightOptions = function (falloffPower) {
    return function (minWeight) {
        return function (normalize) {
            return {
                falloffPower: falloffPower,
                minWeight: minWeight,
                normalize: normalize
            };
        };
    };
};
var mkPoint2D = function (x) {
    return function (y) {
        return {
            x: x,
            y: y
        };
    };
};
var rotatePoint = function (point) {
    return function (origin) {
        return function (angleDegrees) {
            var dy = p2dY(point) - p2dY(origin);
            var dx = p2dX(point) - p2dX(origin);
            var angleRadians = (angleDegrees * $$Math.pi) / 180.0;
            var cosA = $$Math.cos(angleRadians);
            var sinA = $$Math.sin(angleRadians);
            return mkPoint2D((p2dX(origin) + dx * cosA) - dy * sinA)(p2dY(origin) + dx * sinA + dy * cosA);
        };
    };
};
var scalePoint = function (point) {
    return function (origin) {
        return function (scale) {
            return mkPoint2D(p2dX(origin) + (p2dX(point) - p2dX(origin)) * scale)(p2dY(origin) + (p2dY(point) - p2dY(origin)) * scale);
        };
    };
};
var translatePoint = function (point) {
    return function (delta) {
        return mkPoint2D(p2dX(point) + p2dX(delta))(p2dY(point) + p2dY(delta));
    };
};
var mkPinState = function (position) {
    return function (rotation) {
        return function (scale) {
            return function (delta) {
                return {
                    position: position,
                    rotation: rotation,
                    scale: scale,
                    delta: delta
                };
            };
        };
    };
};
var mkPinRestState = function (position) {
    return function (rotation) {
        return function (scale) {
            return function (radius) {
                return function (stiffness) {
                    return {
                        position: position,
                        rotation: rotation,
                        scale: scale,
                        radius: radius,
                        stiffness: stiffness
                    };
                };
            };
        };
    };
};
var lerpPoint = function (a) {
    return function (b) {
        return function (t) {
            var tc = max(0.0)(min(1.0)(t));
            return mkPoint2D(p2dX(a) + (p2dX(b) - p2dX(a)) * tc)(p2dY(a) + (p2dY(b) - p2dY(a)) * tc);
        };
    };
};
var lerp = function (a) {
    return function (b) {
        return function (t) {
            return a + (b - a) * max(0.0)(min(1.0)(t));
        };
    };
};
var eqPoint2D = {
    eq: function (x) {
        return function (y) {
            return x.x === y.x && x.y === y.y;
        };
    }
};
var distance = function (a) {
    return function (b) {
        var dy = p2dY(b) - p2dY(a);
        var dx = p2dX(b) - p2dX(a);
        return $$Math.sqrt(dx * dx + dy * dy);
    };
};
var defaultWeightOptions = {
    falloffPower: 2.0,
    minWeight: 1.0e-3,
    normalize: true
};
var defaultPinRestState = function (pos) {
    return {
        position: pos,
        rotation: 0.0,
        scale: 1.0,
        radius: 100.0,
        stiffness: 0.0
    };
};
var createPinState = function (position) {
    return function (rotation) {
        return function (scale) {
            return function (restPosition) {
                return {
                    position: position,
                    rotation: rotation,
                    scale: scale,
                    delta: mkPoint2D(p2dX(position) - p2dX(restPosition))(p2dY(position) - p2dY(restPosition))
                };
            };
        };
    };
};
var calculatePinWeight = function (vertex) {
    return function (pinPos) {
        return function (radius) {
            return function (stiffness) {
                return function (options) {
                    var dist = distance(vertex)(pinPos);
                    var weight = (function () {
                        if (dist < 1.0e-3) {
                            return 1000.0;
                        };
                        if (dist > radius * 3.0) {
                            return 0.0;
                        };
                        if (Data_Boolean.otherwise) {
                            var normalizedDist = dist / radius;
                            var baseWeight = $$Math.pow(1.0 / (1.0 + normalizedDist))(options.falloffPower);
                            var $31 = stiffness > 0.0;
                            if ($31) {
                                return baseWeight * (1.0 - stiffness * 0.5);
                            };
                            return baseWeight;
                        };
                        throw new Error("Failed pattern match at Lattice.Services.Mesh.Deformation (line 165, column 7 - line 173, column 31): " + [  ]);
                    })();
                    var $32 = weight < options.minWeight;
                    if ($32) {
                        return 0.0;
                    };
                    return weight;
                };
            };
        };
    };
};
var calculateWeights = function (vertices) {
    return function (pinRestStates) {
        return function (options) {
            if (Data_Array.length(pinRestStates) === 0) {
                return [  ];
            };
            if (Data_Boolean.otherwise) {
                var processVertex = function (vertex) {
                    var vertexWeights = map(function (pin) {
                        return calculatePinWeight(vertex)(pin.position)(pin.radius)(pin.stiffness)(options);
                    })(pinRestStates);
                    var totalWeight = Data_Array.foldl(add1)(0.0)(vertexWeights);
                    var normalizedWeights = (function () {
                        var $36 = options.normalize && totalWeight > 0.0;
                        if ($36) {
                            return map(function (w) {
                                return w / totalWeight;
                            })(vertexWeights);
                        };
                        return vertexWeights;
                    })();
                    return normalizedWeights;
                };
                var pinCount = Data_Array.length(pinRestStates);
                return Data_Array.foldl(function (acc) {
                    return function (v) {
                        return append(acc)(processVertex(v));
                    };
                })([  ])(vertices);
            };
            throw new Error("Failed pattern match at Lattice.Services.Mesh.Deformation (line 179, column 1 - line 179, column 89): " + [ vertices.constructor.name, pinRestStates.constructor.name, options.constructor.name ]);
        };
    };
};
var applyPinTransform = function (vertex) {
    return function (pinState) {
        return function (restState) {
            return function (applyTranslation) {
                return function (applyRotation) {
                    return function (applyScale) {
                        var v1 = (function () {
                            if (applyTranslation) {
                                return translatePoint(vertex)(pinState.delta);
                            };
                            return vertex;
                        })();
                        var v2 = (function () {
                            if (applyRotation) {
                                var rotationDelta = pinState.rotation - restState.rotation;
                                var $39 = $$Math.abs(rotationDelta) > 1.0e-3;
                                if ($39) {
                                    return rotatePoint(v1)(pinState.position)(rotationDelta);
                                };
                                return v1;
                            };
                            return v1;
                        })();
                        var v3 = (function () {
                            if (applyScale) {
                                var $41 = $$Math.abs(pinState.scale - restState.scale) > 1.0e-3;
                                if ($41) {
                                    var scaleDelta = pinState.scale / restState.scale;
                                    return scalePoint(v2)(pinState.position)(scaleDelta);
                                };
                                return v2;
                            };
                            return v2;
                        })();
                        return v3;
                    };
                };
            };
        };
    };
};
var deformVertex = function (vertex) {
    return function (vertexIndex) {
        return function (pinStates) {
            return function (pinRestStates) {
                return function (weights) {
                    if (Data_Array.length(pinStates) === 0) {
                        return vertex;
                    };
                    if (Data_Boolean.otherwise) {
                        var pinCount = Data_Array.length(pinStates);
                        var result = Data_Array.foldl(function (acc) {
                            return function (p) {
                                var weight = Data_Maybe.fromMaybe(0.0)(Data_Array.index(weights)((vertexIndex * pinCount | 0) + p | 0));
                                var $47 = weight <= 0.0;
                                if ($47) {
                                    return acc;
                                };
                                var v = new Data_Tuple.Tuple(Data_Array.index(pinStates)(p), Data_Array.index(pinRestStates)(p));
                                if (v.value0 instanceof Data_Maybe.Just && v.value1 instanceof Data_Maybe.Just) {
                                    var deformed = applyPinTransform(vertex)(v.value0.value0)(v.value1.value0)(true)(true)(true);
                                    return {
                                        totalX: acc.totalX + p2dX(deformed) * weight,
                                        totalY: acc.totalY + p2dY(deformed) * weight,
                                        totalWeight: acc.totalWeight + weight
                                    };
                                };
                                return acc;
                            };
                        })({
                            totalX: 0.0,
                            totalY: 0.0,
                            totalWeight: 0.0
                        })(range(0)(pinCount - 1 | 0));
                        var $53 = result.totalWeight > 0.0;
                        if ($53) {
                            return mkPoint2D(result.totalX / result.totalWeight)(result.totalY / result.totalWeight);
                        };
                        return vertex;
                    };
                    throw new Error("Failed pattern match at Lattice.Services.Mesh.Deformation (line 234, column 1 - line 235, column 40): " + [ vertex.constructor.name, vertexIndex.constructor.name, pinStates.constructor.name, pinRestStates.constructor.name, weights.constructor.name ]);
                };
            };
        };
    };
};
var deformMesh = function (vertices) {
    return function (pinStates) {
        return function (pinRestStates) {
            return function (weights) {
                return Data_Array.mapWithIndex(function (i) {
                    return function (vertex) {
                        return deformVertex(vertex)(i)(pinStates)(pinRestStates)(weights);
                    };
                })(vertices);
            };
        };
    };
};
export {
    mkPoint2D,
    p2dX,
    p2dY,
    mkWeightOptions,
    defaultWeightOptions,
    mkPinState,
    mkPinRestState,
    distance,
    rotatePoint,
    scalePoint,
    translatePoint,
    calculatePinWeight,
    calculateWeights,
    applyPinTransform,
    deformVertex,
    deformMesh,
    createPinState,
    lerpPoint,
    lerp,
    eqPoint2D
};
//# sourceMappingURL=index.js.map
