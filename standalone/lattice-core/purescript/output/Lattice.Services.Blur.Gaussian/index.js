// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
import * as $$Math from "../Math/index.js";
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var sum = /* #__PURE__ */ Data_Foldable.sum(Data_Foldable.foldableArray)(Data_Semiring.semiringNumber);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var sigmaFromRadius = function (radius) {
    return max(radius / 2.0)(1.0);
};
var kernelSize = function (radius) {
    return (radius * 2 | 0) + 1 | 0;
};
var isValidSeparableBlur = function (radiusX) {
    return function (radiusY) {
        return radiusX >= 0.0 && radiusY >= 0.0;
    };
};
var gaussianWeight = function (x) {
    return function (sigma) {
        if (sigma < 1.0e-4) {
            var $18 = x === 0.0;
            if ($18) {
                return 1.0;
            };
            return 0.0;
        };
        if (Data_Boolean.otherwise) {
            var twoSigmaSquared = 2.0 * sigma * sigma;
            return $$Math.exp(-(x * x) / twoSigmaSquared);
        };
        throw new Error("Failed pattern match at Lattice.Services.Blur.Gaussian (line 39, column 1 - line 39, column 45): " + [ x.constructor.name, sigma.constructor.name ]);
    };
};
var gaussianWeightSum = function (radius) {
    return function (sigma) {
        var r = Data_Int.toNumber(radius);
        var indices = Data_Array.range(0)(radius * 2 | 0);
        var weights = map(function (i) {
            return gaussianWeight(Data_Int.toNumber(i) - r)(sigma);
        })(indices);
        return sum(weights);
    };
};
var normalizedGaussianWeight = function (x) {
    return function (sigma) {
        return function (totalWeight) {
            if (totalWeight < 1.0e-4) {
                return 0.0;
            };
            if (Data_Boolean.otherwise) {
                return gaussianWeight(x)(sigma) / totalWeight;
            };
            throw new Error("Failed pattern match at Lattice.Services.Blur.Gaussian (line 65, column 1 - line 65, column 65): " + [ x.constructor.name, sigma.constructor.name, totalWeight.constructor.name ]);
        };
    };
};
var generateKernel1D = function (radius) {
    return function (sigma) {
        var totalWeight = gaussianWeightSum(radius)(sigma);
        var r = Data_Int.toNumber(radius);
        var indices = Data_Array.range(0)(radius * 2 | 0);
        return Data_Array.mapWithIndex(function (i) {
            return function (v) {
                var x = Data_Int.toNumber(i) - r;
                return normalizedGaussianWeight(x)(sigma)(totalWeight);
            };
        })(indices);
    };
};
var estimateQuality = function (radius) {
    return function (sigma) {
        var idealSigma = Data_Int.toNumber(radius) / 3.0;
        var $22 = sigma < 1.0e-4;
        if ($22) {
            return 0.0;
        };
        return min(1.0)(sigma / idealSigma);
    };
};
export {
    gaussianWeight,
    sigmaFromRadius,
    gaussianWeightSum,
    normalizedGaussianWeight,
    generateKernel1D,
    isValidSeparableBlur,
    kernelSize,
    estimateQuality
};
//# sourceMappingURL=index.js.map
