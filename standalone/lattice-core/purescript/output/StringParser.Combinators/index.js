// Generated by purs version 0.15.15
import * as Control_Alt from "../Control.Alt/index.js";
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Apply from "../Control.Apply/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Control_Lazy from "../Control.Lazy/index.js";
import * as Control_Monad_Rec_Class from "../Control.Monad.Rec.Class/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_List from "../Data.List/index.js";
import * as Data_List_NonEmpty from "../Data.List.NonEmpty/index.js";
import * as Data_List_Types from "../Data.List.Types/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_NonEmpty from "../Data.NonEmpty/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as StringParser_Parser from "../StringParser.Parser/index.js";
var alt = /* #__PURE__ */ Control_Alt.alt(StringParser_Parser.altParser);
var bind = /* #__PURE__ */ Control_Bind.bind(StringParser_Parser.bindParser);
var pure = /* #__PURE__ */ Control_Applicative.pure(StringParser_Parser.applicativeParser);
var map = /* #__PURE__ */ Data_Functor.map(StringParser_Parser.functorParser);
var mapFlipped = /* #__PURE__ */ Data_Functor.mapFlipped(StringParser_Parser.functorParser);
var voidLeft = /* #__PURE__ */ Data_Functor.voidLeft(StringParser_Parser.functorParser);
var applyFirst = /* #__PURE__ */ Control_Apply.applyFirst(StringParser_Parser.applyParser);
var applySecond = /* #__PURE__ */ Control_Apply.applySecond(StringParser_Parser.applyParser);
var apply = /* #__PURE__ */ Control_Apply.apply(StringParser_Parser.applyParser);
var tailRecM = /* #__PURE__ */ Control_Monad_Rec_Class.tailRecM(StringParser_Parser.monadRecParser);
var pure1 = /* #__PURE__ */ Control_Applicative.pure(Data_List_Types.applicativeNonEmptyList);
var withError = function (p) {
    return function (msg) {
        return alt(p)(StringParser_Parser.fail(msg));
    };
};
var $$try = function (v) {
    return function (s) {
        var v1 = v(s);
        if (v1 instanceof Data_Either.Left) {
            return new Data_Either.Left({
                pos: s.position,
                error: v1.value0.error
            });
        };
        return v1;
    };
};
var optional = function (p) {
    return alt(bind(p)(function (v) {
        return pure(Data_Unit.unit);
    }))(pure(Data_Unit.unit));
};
var option = function (a) {
    return function (p) {
        return alt(p)(pure(a));
    };
};
var optionMaybe = function (p) {
    return option(Data_Maybe.Nothing.value)(map(Data_Maybe.Just.create)(p));
};
var lookAhead = function (v) {
    return function (s) {
        var v1 = v(s);
        if (v1 instanceof Data_Either.Right) {
            return new Data_Either.Right({
                result: v1.value0.result,
                suffix: s
            });
        };
        return v1;
    };
};
var tryAhead = function ($36) {
    return $$try(lookAhead($36));
};
var cons$prime = function (h) {
    return function (t) {
        return new Data_NonEmpty.NonEmpty(h, t);
    };
};
var sepEndBy1 = function (p) {
    return function (sep) {
        return bind(p)(function (a) {
            return alt(bind(sep)(function () {
                return bind(sepEndBy(p)(sep))(function (as) {
                    return pure(cons$prime(a)(as));
                });
            }))(pure(Data_List_NonEmpty.singleton(a)));
        });
    };
};
var sepEndBy = function (p) {
    return function (sep) {
        return alt(mapFlipped(sepEndBy1(p)(sep))(Data_List_NonEmpty.toList))(alt(voidLeft(sep)(Data_List_Types.Nil.value))(pure(Data_List_Types.Nil.value)));
    };
};
var choice = function (dictFoldable) {
    return Data_Foldable.foldl(dictFoldable)(alt)(StringParser_Parser.fail("Nothing to parse"));
};
var chainr1$prime = function (p) {
    return function (f) {
        return function (a) {
            return alt(bind(f)(function (f$prime) {
                return bind(chainr1(p)(f))(function (a$prime) {
                    return pure(f$prime(a)(a$prime));
                });
            }))(pure(a));
        };
    };
};
var chainr1 = function (p) {
    return function (f) {
        return bind(p)(function (a) {
            return chainr1$prime(p)(f)(a);
        });
    };
};
var chainr = function (p) {
    return function (f) {
        return function (a) {
            return alt(chainr1(p)(f))(pure(a));
        };
    };
};
var chainl1$prime = function (p) {
    return function (f) {
        return function (a) {
            return alt(bind(f)(function (f$prime) {
                return bind(p)(function (a$prime) {
                    return chainl1$prime(p)(f)(f$prime(a)(a$prime));
                });
            }))(pure(a));
        };
    };
};
var chainl1 = function (p) {
    return function (f) {
        return bind(p)(function (a) {
            return chainl1$prime(p)(f)(a);
        });
    };
};
var chainl = function (p) {
    return function (f) {
        return function (a) {
            return alt(chainl1(p)(f))(pure(a));
        };
    };
};
var between = function (open) {
    return function (close) {
        return function (p) {
            return applyFirst(applySecond(open)(p))(close);
        };
    };
};
var assertConsume = function (v) {
    return function (s) {
        var v1 = v(s);
        if (v1 instanceof Data_Either.Right) {
            var $34 = s.position < v1.value0.suffix.position;
            if ($34) {
                return new Data_Either.Right(v1.value0);
            };
            return new Data_Either.Left({
                pos: s.position,
                error: "Consumed no input."
            });
        };
        return v1;
    };
};
var many = /* #__PURE__ */ (function () {
    var $37 = Data_List.manyRec(StringParser_Parser.monadRecParser)(StringParser_Parser.alternativeParser);
    return function ($38) {
        return $37(assertConsume($38));
    };
})();
var many1 = function (p) {
    return apply(map(cons$prime)(p))(many(p));
};
var endBy1 = function (p) {
    return function (sep) {
        return many1(applyFirst(p)(sep));
    };
};
var endBy = function (p) {
    return function (sep) {
        return alt(mapFlipped(endBy1(p)(sep))(Data_List_NonEmpty.toList))(voidLeft(sep)(Data_List_Types.Nil.value));
    };
};
var sepBy1 = function (p) {
    return function (sep) {
        return bind(p)(function (a) {
            return bind(many(applySecond(sep)(p)))(function (as) {
                return pure(cons$prime(a)(as));
            });
        });
    };
};
var sepBy = function (p) {
    return function (sep) {
        return alt(map(Data_List_NonEmpty.toList)(sepBy1(p)(sep)))(pure(Data_List_Types.Nil.value));
    };
};
var many1Till = function (p) {
    return function (end) {
        var ending = function (acc) {
            return bind(end)(function () {
                return pure(new Control_Monad_Rec_Class.Done(Data_List_NonEmpty.reverse(acc)));
            });
        };
        var $$continue = function (acc) {
            return bind(assertConsume(p))(function (c) {
                return pure(new Control_Monad_Rec_Class.Loop(Data_List_NonEmpty.cons(c)(acc)));
            });
        };
        var inner = function (acc) {
            return alt(ending(acc))($$continue(acc));
        };
        return bind(p)(function (x) {
            return tailRecM(inner)(pure1(x));
        });
    };
};
var manyTill = function (p) {
    return function (end) {
        return alt(applySecond(end)(pure(Data_List_Types.Nil.value)))(map(Data_List_NonEmpty.toList)(many1Till(p)(end)));
    };
};
export {
    $$try as try,
    lookAhead,
    tryAhead,
    many,
    many1,
    manyTill,
    many1Till,
    assertConsume,
    withError,
    between,
    option,
    optional,
    optionMaybe,
    sepBy,
    sepBy1,
    sepEndBy,
    sepEndBy1,
    endBy1,
    endBy,
    chainr,
    chainl,
    chainl1,
    chainr1,
    choice
};
export {
    fix
} from "../Control.Lazy/index.js";
//# sourceMappingURL=index.js.map
