// Generated by purs version 0.15.15
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var div1 = /* #__PURE__ */ Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt);
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var structuralRestLength = function (spacing) {
    return spacing;
};
var solveConstraintInner = function (p1) {
    return function (p2) {
        return function (restLength) {
            return function (stiffness) {
                return function (dx) {
                    return function (dy) {
                        return function (distance) {
                            var totalInvMass = p1.invMass + p2.invMass;
                            var $17 = distance < 1.0e-4 || totalInvMass < 1.0e-4;
                            if ($17) {
                                return {
                                    particle1PosX: p1.posX,
                                    particle1PosY: p1.posY,
                                    particle2PosX: p2.posX,
                                    particle2PosY: p2.posY,
                                    broken: false
                                };
                            };
                            var ratio2 = p2.invMass / totalInvMass;
                            var ratio1 = p1.invMass / totalInvMass;
                            var err = (distance - restLength) / distance;
                            var corrY = dy * err * stiffness * 0.5;
                            var corrX = dx * err * stiffness * 0.5;
                            return {
                                particle1PosX: p1.posX + corrX * ratio1,
                                particle1PosY: p1.posY + corrY * ratio1,
                                particle2PosX: p2.posX - corrX * ratio2,
                                particle2PosY: p2.posY - corrY * ratio2,
                                broken: false
                            };
                        };
                    };
                };
            };
        };
    };
};
var solveConstraint = function (p1) {
    return function (p2) {
        return function (constraint) {
            var dy = p2.posY - p1.posY;
            var dx = p2.posX - p1.posX;
            var distance = $$Math.sqrt(dx * dx + dy * dy);
            if (constraint.breakThreshold instanceof Data_Maybe.Just && distance > constraint.restLength * constraint.breakThreshold.value0) {
                return {
                    particle1PosX: p1.posX,
                    particle1PosY: p1.posY,
                    particle2PosX: p2.posX,
                    particle2PosY: p2.posY,
                    broken: true
                };
            };
            return solveConstraintInner(p1)(p2)(constraint.restLength)(constraint.stiffness)(dx)(dy)(distance);
        };
    };
};
var shearRestLength = function (spacing) {
    return spacing * $$Math.sqrt(2.0);
};
var setVelocity = function (state) {
    return function (velX) {
        return function (velY) {
            return {
                posX: state.posX,
                posY: state.posY,
                accelX: state.accelX,
                accelY: state.accelY,
                invMass: state.invMass,
                prevX: state.posX - velX,
                prevY: state.posY - velY
            };
        };
    };
};
var integrateParticle = function (state) {
    return function (damping) {
        return function (dt) {
            var $20 = state.invMass === 0.0;
            if ($20) {
                return state;
            };
            var velY = state.posY - state.prevY;
            var velX = state.posX - state.prevX;
            var dtSq = dt * dt;
            var dampedVelY = velY * damping;
            var newPosY = state.posY + dampedVelY + state.accelY * dtSq;
            var dampedVelX = velX * damping;
            var newPosX = state.posX + dampedVelX + state.accelX * dtSq;
            return {
                invMass: state.invMass,
                posX: newPosX,
                posY: newPosY,
                prevX: state.posX,
                prevY: state.posY,
                accelX: 0.0,
                accelY: 0.0
            };
        };
    };
};
var gridRowCol = function (index) {
    return function (width) {
        return new Data_Tuple.Tuple(div1(index)(width), mod(index)(width));
    };
};
var gridIndex = function (row) {
    return function (col) {
        return function (width) {
            return (row * width | 0) + col | 0;
        };
    };
};
var getVelocity = function (state) {
    return new Data_Tuple.Tuple(state.posX - state.prevX, state.posY - state.prevY);
};
var constrainToBounds = function (posX) {
    return function (posY) {
        return function (prevX) {
            return function (prevY) {
                return function (minX) {
                    return function (minY) {
                        return function (maxX) {
                            return function (maxY) {
                                return function (restitution) {
                                    var v = (function () {
                                        var $21 = posX < minX;
                                        if ($21) {
                                            var pen = minX - posX;
                                            return {
                                                newPosX: minX + pen * restitution,
                                                newPrevX: posX + (posX - prevX) * restitution
                                            };
                                        };
                                        var $22 = posX > maxX;
                                        if ($22) {
                                            var pen = posX - maxX;
                                            return {
                                                newPosX: maxX - pen * restitution,
                                                newPrevX: posX + (posX - prevX) * restitution
                                            };
                                        };
                                        return {
                                            newPosX: posX,
                                            newPrevX: prevX
                                        };
                                    })();
                                    var v1 = (function () {
                                        var $24 = posY < minY;
                                        if ($24) {
                                            var pen = minY - posY;
                                            return {
                                                newPosY: minY + pen * restitution,
                                                newPrevY: posY + (posY - prevY) * restitution
                                            };
                                        };
                                        var $25 = posY > maxY;
                                        if ($25) {
                                            var pen = posY - maxY;
                                            return {
                                                newPosY: maxY - pen * restitution,
                                                newPrevY: posY + (posY - prevY) * restitution
                                            };
                                        };
                                        return {
                                            newPosY: posY,
                                            newPrevY: prevY
                                        };
                                    })();
                                    return {
                                        posX: v.newPosX,
                                        posY: v1.newPosY,
                                        prevX: v.newPrevX,
                                        prevY: v1.newPrevY
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
var collideWithGround = function (posX) {
    return function (posY) {
        return function (prevX) {
            return function (prevY) {
                return function (groundY) {
                    return function (restitution) {
                        return function (friction) {
                            var $31 = posY >= groundY;
                            if ($31) {
                                return {
                                    posX: posX,
                                    posY: posY,
                                    prevX: prevX,
                                    prevY: prevY
                                };
                            };
                            var velY = posY - prevY;
                            var velX = posX - prevX;
                            var penetration = groundY - posY;
                            var newPrevX = posX - velX * (1.0 - friction);
                            var newPosY = groundY + penetration * restitution;
                            var newPrevY = newPosY + velY * restitution;
                            return {
                                posX: posX,
                                posY: newPosY,
                                prevX: newPrevX,
                                prevY: newPrevY
                            };
                        };
                    };
                };
            };
        };
    };
};
var bendRestLength = function (spacing) {
    return spacing * 2.0;
};
export {
    integrateParticle,
    getVelocity,
    setVelocity,
    solveConstraint,
    structuralRestLength,
    shearRestLength,
    bendRestLength,
    gridIndex,
    gridRowCol,
    collideWithGround,
    constrainToBounds
};
//# sourceMappingURL=index.js.map
