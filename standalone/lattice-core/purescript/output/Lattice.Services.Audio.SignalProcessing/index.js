// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Ring from "../Data.Ring/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var add = /* #__PURE__ */ Data_Semiring.add(Data_Semiring.semiringNumber);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordInt);
var min1 = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var abs = /* #__PURE__ */ Data_Ord.abs(Data_Ord.ordInt)(Data_Ring.ringInt);
var append = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var compare = /* #__PURE__ */ Data_Ord.compare(Data_Ord.ordInt);
var max1 = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var div1 = /* #__PURE__ */ Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt);
var CurveLinear = /* #__PURE__ */ (function () {
    function CurveLinear() {

    };
    CurveLinear.value = new CurveLinear();
    return CurveLinear;
})();
var CurveExponential = /* #__PURE__ */ (function () {
    function CurveExponential() {

    };
    CurveExponential.value = new CurveExponential();
    return CurveExponential;
})();
var CurveLogarithmic = /* #__PURE__ */ (function () {
    function CurveLogarithmic() {

    };
    CurveLogarithmic.value = new CurveLogarithmic();
    return CurveLogarithmic;
})();
var CurveSmoothstep = /* #__PURE__ */ (function () {
    function CurveSmoothstep() {

    };
    CurveSmoothstep.value = new CurveSmoothstep();
    return CurveSmoothstep;
})();
var updateAt = function (idx) {
    return function (val) {
        return function (arr) {
            return Data_Array.mapWithIndex(function (i) {
                return function (x) {
                    var $41 = i === idx;
                    if ($41) {
                        return val;
                    };
                    return x;
                };
            })(arr);
        };
    };
};
var toNumber = function (n) {
    var toNumberPos = function (v) {
        if (v === 0) {
            return 0.0;
        };
        return 1.0 + toNumberPos(v - 1 | 0);
    };
    var $43 = n < 0;
    if ($43) {
        return -toNumberPos(-n | 0);
    };
    return toNumberPos(n);
};
var zeroCrossingRate = function (samples) {
    if (Data_Array.length(samples) <= 1) {
        return 0.0;
    };
    if (Data_Boolean.otherwise) {
        var n = Data_Array.length(samples);
        var crossings = Data_Array.foldl(function (acc) {
            return function (i) {
                var prev = Data_Maybe.fromMaybe(0.0)(Data_Array.index(samples)(i));
                var curr = Data_Maybe.fromMaybe(0.0)(Data_Array.index(samples)(i + 1 | 0));
                var $45 = curr >= 0.0 && prev < 0.0 || curr < 0.0 && prev >= 0.0;
                if ($45) {
                    return acc + 1.0;
                };
                return acc;
            };
        })(0.0)(Data_Array.range(0)(n - 2 | 0));
        return crossings / toNumber(n - 1 | 0);
    };
    throw new Error("Failed pattern match at Lattice.Services.Audio.SignalProcessing (line 163, column 1 - line 163, column 43): " + [ samples.constructor.name ]);
};
var toInt = function (n) {
    var toIntImpl = function ($copy_x) {
        return function ($copy_acc) {
            var $tco_var_x = $copy_x;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(x, acc) {
                if (x < 1.0) {
                    $tco_done = true;
                    return acc;
                };
                if (Data_Boolean.otherwise) {
                    $tco_var_x = x - 1.0;
                    $copy_acc = acc + 1 | 0;
                    return;
                };
                throw new Error("Failed pattern match at Lattice.Services.Audio.SignalProcessing (line 398, column 5 - line 398, column 38): " + [ x.constructor.name, acc.constructor.name ]);
            };
            while (!$tco_done) {
                $tco_result = $tco_loop($tco_var_x, $copy_acc);
            };
            return $tco_result;
        };
    };
    return toIntImpl(n)(0);
};
var spectralRolloff = function (magnitudes) {
    return function (rolloffPercent) {
        return function (binFrequency) {
            var totalEnergy = Data_Array.foldl(add)(0.0)(magnitudes);
            var threshold = totalEnergy * rolloffPercent;
            var result = Data_Array.foldl(function (acc) {
                return function (mag) {
                    var $48 = acc.cumulative >= threshold;
                    if ($48) {
                        return acc;
                    };
                    return {
                        cumulative: acc.cumulative + mag,
                        bin: acc.bin + 1 | 0
                    };
                };
            })({
                cumulative: 0.0,
                bin: 0
            })(magnitudes);
            return toNumber(result.bin) * binFrequency;
        };
    };
};
var spectralFlux = function (currentSpectrum) {
    return function (prevSpectrum) {
        var minLen = min(Data_Array.length(currentSpectrum))(Data_Array.length(prevSpectrum));
        return Data_Array.foldl(function (acc) {
            return function (k) {
                var prev = Data_Maybe.fromMaybe(0.0)(Data_Array.index(prevSpectrum)(k));
                var curr = Data_Maybe.fromMaybe(0.0)(Data_Array.index(currentSpectrum)(k));
                var diff = curr - prev;
                var $49 = diff > 0.0;
                if ($49) {
                    return acc + diff;
                };
                return acc;
            };
        })(0.0)(Data_Array.range(0)(minLen - 1 | 0));
    };
};
var spectralFlatness = function (magnitudes) {
    var nonZero = Data_Array.filter(function (v) {
        return v > 1.0e-10;
    })(magnitudes);
    var n = Data_Array.length(nonZero);
    var $50 = n === 0;
    if ($50) {
        return 0.0;
    };
    var nf = toNumber(n);
    var logSum = Data_Array.foldl(function (acc) {
        return function (m) {
            return acc + $$Math.log(m);
        };
    })(0.0)(nonZero);
    var geometricMean = $$Math.exp(logSum / nf);
    var arithmeticMean = Data_Array.foldl(add)(0.0)(nonZero) / nf;
    var $51 = arithmeticMean > 0.0;
    if ($51) {
        return geometricMean / arithmeticMean;
    };
    return 0.0;
};
var pitchClassNames = [ "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B" ];
var normalizeArray = function (values) {
    return function (minOut) {
        return function (maxOut) {
            if (Data_Array.length(values) === 0) {
                return [  ];
            };
            if (Data_Boolean.otherwise) {
                var outRange = maxOut - minOut;
                var minVal = Data_Array.foldl(min1)(Data_Maybe.fromMaybe(0.0)(Data_Array.index(values)(0)))(values);
                var maxVal = Data_Array.foldl(max)(Data_Maybe.fromMaybe(0.0)(Data_Array.index(values)(0)))(values);
                var rangeVal = (function () {
                    var $55 = maxVal === minVal;
                    if ($55) {
                        return 1.0;
                    };
                    return maxVal - minVal;
                })();
                return map(function (v) {
                    return minOut + ((v - minVal) / rangeVal) * outRange;
                })(values);
            };
            throw new Error("Failed pattern match at Lattice.Services.Audio.SignalProcessing (line 266, column 1 - line 266, column 67): " + [ values.constructor.name, minOut.constructor.name, maxOut.constructor.name ]);
        };
    };
};
var normalize01 = function (values) {
    return normalizeArray(values)(0.0)(1.0);
};
var midiToHz = function (midi) {
    return 440.0 * $$Math.exp(((midi - 69.0) / 12.0) * $$Math.log(2.0));
};
var melToHz = function (mel) {
    return 700.0 * ($$Math.exp((mel / 2595.0) * $$Math.log(10.0)) - 1.0);
};
var hzToMidi = function (hz) {
    if (hz <= 0.0) {
        return 0.0;
    };
    if (Data_Boolean.otherwise) {
        return 69.0 + (12.0 * $$Math.log(hz / 440.0)) / $$Math.log(2.0);
    };
    throw new Error("Failed pattern match at Lattice.Services.Audio.SignalProcessing (line 201, column 1 - line 201, column 29): " + [ hz.constructor.name ]);
};
var hzToPitchClass = function (hz) {
    var midi = hzToMidi(hz);
    var rounded = toInt(midi);
    return mod(rounded)(12);
};
var hzToMel = function (hz) {
    return (2595.0 * $$Math.log(1.0 + hz / 700.0)) / $$Math.log(10.0);
};
var hanningCoeff = function (i) {
    return function (n) {
        if (n <= 1) {
            return 1.0;
        };
        if (Data_Boolean.otherwise) {
            return 0.5 * (1.0 - $$Math.cos((2.0 * $$Math.pi * toNumber(i)) / toNumber(n - 1 | 0)));
        };
        throw new Error("Failed pattern match at Lattice.Services.Audio.SignalProcessing (line 63, column 1 - line 63, column 37): " + [ i.constructor.name, n.constructor.name ]);
    };
};
var foldlWithIndex = function (f) {
    return function (init) {
        return function (arr) {
            var result = Data_Array.foldl(function (acc) {
                return function (x) {
                    return {
                        val: f(acc.val)(acc.idx)(x),
                        idx: acc.idx + 1 | 0
                    };
                };
            })({
                val: init,
                idx: 0
            })(arr);
            return result.val;
        };
    };
};
var spectralCentroid = function (magnitudes) {
    return function (binFrequency) {
        var result = foldlWithIndex(function (acc) {
            return function (idx) {
                return function (mag) {
                    var freq = toNumber(idx) * binFrequency;
                    return {
                        ws: acc.ws + freq * mag,
                        tm: acc.tm + mag
                    };
                };
            };
        })({
            ws: 0.0,
            tm: 0.0
        })(magnitudes);
        var $59 = result.tm > 0.0;
        if ($59) {
            return result.ws / result.tm;
        };
        return 0.0;
    };
};
var eqFeatureCurve = {
    eq: function (x) {
        return function (y) {
            if (x instanceof CurveLinear && y instanceof CurveLinear) {
                return true;
            };
            if (x instanceof CurveExponential && y instanceof CurveExponential) {
                return true;
            };
            if (x instanceof CurveLogarithmic && y instanceof CurveLogarithmic) {
                return true;
            };
            if (x instanceof CurveSmoothstep && y instanceof CurveSmoothstep) {
                return true;
            };
            return false;
        };
    }
};
var enforceMinPeakDistance = function (peaks) {
    return function (minDistance) {
        var addPeak = function (filtered) {
            return function (v) {
                var conflict = Data_Array.filter(function (v1) {
                    return abs(v1.value0 - v.value0 | 0) < minDistance;
                })(filtered);
                if (conflict.length === 0) {
                    return append(filtered)([ new Data_Tuple.Tuple(v.value0, v.value1) ]);
                };
                var v1 = Data_Array.index(conflict)(0);
                if (v1 instanceof Data_Maybe.Just) {
                    var $69 = v.value1 > v1.value0.value1;
                    if ($69) {
                        return append(Data_Array.filter(function (v2) {
                            return v2.value0 !== v1.value0.value0;
                        })(filtered))([ new Data_Tuple.Tuple(v.value0, v.value1) ]);
                    };
                    return filtered;
                };
                if (v1 instanceof Data_Maybe.Nothing) {
                    return filtered;
                };
                throw new Error("Failed pattern match at Lattice.Services.Audio.SignalProcessing (line 351, column 14 - line 356, column 35): " + [ v1.constructor.name ]);
            };
        };
        var sorted = Data_Array.sortBy(function (v) {
            return function (v1) {
                return compare(v.value0)(v1.value0);
            };
        })(peaks);
        return Data_Array.foldl(addPeak)([  ])(sorted);
    };
};
var detectLocalMaxima = function (values) {
    return function (threshold) {
        if (Data_Array.length(values) <= 2) {
            return [  ];
        };
        if (Data_Boolean.otherwise) {
            return Data_Array.foldl(function (acc) {
                return function (i) {
                    var prev = Data_Maybe.fromMaybe(0.0)(Data_Array.index(values)(i));
                    var next = Data_Maybe.fromMaybe(0.0)(Data_Array.index(values)(i + 2 | 0));
                    var curr = Data_Maybe.fromMaybe(0.0)(Data_Array.index(values)(i + 1 | 0));
                    var $86 = curr > prev && (curr > next && curr >= threshold);
                    if ($86) {
                        return append(acc)([ new Data_Tuple.Tuple(i + 1 | 0, curr) ]);
                    };
                    return acc;
                };
            })([  ])(Data_Array.range(0)(Data_Array.length(values) - 3 | 0));
        };
        throw new Error("Failed pattern match at Lattice.Services.Audio.SignalProcessing (line 327, column 1 - line 327, column 72): " + [ values.constructor.name, threshold.constructor.name ]);
    };
};
var dctCoeff = function (logMelEnergies) {
    return function (c) {
        if (Data_Array.length(logMelEnergies) === 0) {
            return 0.0;
        };
        if (Data_Boolean.otherwise) {
            var n = Data_Array.length(logMelEnergies);
            var nf = toNumber(n);
            return foldlWithIndex(function (acc) {
                return function (m) {
                    return function (energy) {
                        var angle = ($$Math.pi * toNumber(c) * (toNumber(m) + 0.5)) / nf;
                        return acc + energy * $$Math.cos(angle);
                    };
                };
            })(0.0)(logMelEnergies);
        };
        throw new Error("Failed pattern match at Lattice.Services.Audio.SignalProcessing (line 222, column 1 - line 222, column 42): " + [ logMelEnergies.constructor.name, c.constructor.name ]);
    };
};
var computeMFCC = function (logMelEnergies) {
    return function (numCoeffs) {
        return map(dctCoeff(logMelEnergies))(Data_Array.range(0)(numCoeffs - 1 | 0));
    };
};
var computeChroma = function (magnitudes) {
    return function (binFrequency) {
        var initChroma = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ];
        var result = foldlWithIndex(function (acc) {
            return function (bin) {
                return function (mag) {
                    var freq = toNumber(bin) * binFrequency;
                    var $89 = freq < 27.5 || freq > 4186.0;
                    if ($89) {
                        return acc;
                    };
                    var pc = hzToPitchClass(freq);
                    var current = Data_Maybe.fromMaybe(0.0)(Data_Array.index(acc)(pc));
                    return updateAt(pc)(current + mag)(acc);
                };
            };
        })(initChroma)(magnitudes);
        return result;
    };
};
var computeBinMagnitude = function (samples) {
    return function (k) {
        var n = Data_Array.length(samples);
        var $90 = n === 0;
        if ($90) {
            return 0.0;
        };
        var angleCoeff = (2.0 * $$Math.pi * toNumber(k)) / toNumber(n);
        var result = foldlWithIndex(function (acc) {
            return function (t) {
                return function (sample) {
                    var angle = angleCoeff * toNumber(t);
                    var i = acc.imag - sample * $$Math.sin(angle);
                    var r = acc.real + sample * $$Math.cos(angle);
                    return {
                        real: r,
                        imag: i
                    };
                };
            };
        })({
            real: 0.0,
            imag: 0.0
        })(samples);
        return $$Math.sqrt(result.real * result.real + result.imag * result.imag) / toNumber(n);
    };
};
var calculateAdaptiveThreshold = function (flux) {
    return function (windowSize) {
        return function (sensitivityFactor) {
            var computeThreshold = function (i) {
                return function (v) {
                    var start = max1(0)(i - windowSize | 0);
                    var endIdx = min(Data_Array.length(flux))((i + windowSize | 0) + 1 | 0);
                    var window = map(function (j) {
                        return Data_Maybe.fromMaybe(0.0)(Data_Array.index(flux)(j));
                    })(Data_Array.range(start)(endIdx - 1 | 0));
                    var n = Data_Array.length(window);
                    var $91 = n === 0;
                    if ($91) {
                        return 0.0;
                    };
                    var sumVal = Data_Array.foldl(add)(0.0)(window);
                    var nf = toNumber(n);
                    var mean = sumVal / nf;
                    var sqDiffSum = Data_Array.foldl(function (acc) {
                        return function (v1) {
                            return acc + (v1 - mean) * (v1 - mean);
                        };
                    })(0.0)(window);
                    var std = $$Math.sqrt(sqDiffSum / nf);
                    return mean + sensitivityFactor * std;
                };
            };
            return Data_Array.mapWithIndex(computeThreshold)(flux);
        };
    };
};
var applyHanningWindow = function (samples) {
    var n = Data_Array.length(samples);
    return Data_Array.mapWithIndex(function (i) {
        return function (s) {
            return s * hanningCoeff(i)(n);
        };
    })(samples);
};
var simpleDFT = function (samples) {
    var windowed = applyHanningWindow(samples);
    var n = Data_Array.length(samples);
    var halfN = div1(n)(2);
    return map(computeBinMagnitude(windowed))(Data_Array.range(0)(halfN - 1 | 0));
};
var applyFeatureCurve = function (value) {
    return function (curve) {
        var clamped = max(0.0)(min1(1.0)(value));
        if (curve instanceof CurveLinear) {
            return clamped;
        };
        if (curve instanceof CurveExponential) {
            return clamped * clamped;
        };
        if (curve instanceof CurveLogarithmic) {
            return $$Math.sqrt(clamped);
        };
        if (curve instanceof CurveSmoothstep) {
            return clamped * clamped * (3.0 - 2.0 * clamped);
        };
        throw new Error("Failed pattern match at Lattice.Services.Audio.SignalProcessing (line 255, column 6 - line 259, column 69): " + [ curve.constructor.name ]);
    };
};
var applyEnvelopeFollower = function (samples) {
    return function (smoothing) {
        if (Data_Array.length(samples) === 0) {
            return [  ];
        };
        if (Data_Boolean.otherwise) {
            var s = max(0.0)(min1(1.0)(smoothing));
            var step = function (env) {
                return function (sample) {
                    var $95 = sample > env;
                    if ($95) {
                        return sample;
                    };
                    return env * (1.0 - s) + sample * s;
                };
            };
            var result = Data_Array.foldl(function (acc) {
                return function (sample) {
                    var newEnv = step(acc.env)(sample);
                    return {
                        result: append(acc.result)([ newEnv ]),
                        env: newEnv
                    };
                };
            })({
                result: [  ],
                env: 0.0
            })(samples);
            return result.result;
        };
        throw new Error("Failed pattern match at Lattice.Services.Audio.SignalProcessing (line 285, column 1 - line 285, column 64): " + [ samples.constructor.name, smoothing.constructor.name ]);
    };
};
export {
    CurveLinear,
    CurveExponential,
    CurveLogarithmic,
    CurveSmoothstep,
    hanningCoeff,
    applyHanningWindow,
    computeBinMagnitude,
    simpleDFT,
    spectralCentroid,
    spectralFlux,
    spectralRolloff,
    spectralFlatness,
    zeroCrossingRate,
    hzToMel,
    melToHz,
    midiToHz,
    hzToMidi,
    hzToPitchClass,
    dctCoeff,
    computeMFCC,
    applyFeatureCurve,
    normalizeArray,
    normalize01,
    applyEnvelopeFollower,
    calculateAdaptiveThreshold,
    detectLocalMaxima,
    enforceMinPeakDistance,
    pitchClassNames,
    computeChroma,
    eqFeatureCurve
};
//# sourceMappingURL=index.js.map
