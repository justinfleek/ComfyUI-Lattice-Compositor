// Generated by purs version 0.15.15
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Identity from "../Data.Identity/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Effect_Aff from "../Effect.Aff/index.js";
import * as $$Math from "../Math/index.js";
import * as Test_Lattice_TestHelpers from "../Test.Lattice.TestHelpers/index.js";
import * as Test_Spec from "../Test.Spec/index.js";
import * as Test_Spec_Assertions from "../Test.Spec.Assertions/index.js";
var describe = /* #__PURE__ */ Test_Spec.describe(Data_Identity.monadIdentity);
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit);
var discard1 = /* #__PURE__ */ discard(/* #__PURE__ */ Test_Spec.bindSpecT(Data_Identity.bindIdentity));
var it = /* #__PURE__ */ Test_Spec.it(Data_Identity.monadIdentity)(Test_Spec.exampleMUnit);
var discard2 = /* #__PURE__ */ discard(Effect_Aff.bindAff);
var shouldEqual = /* #__PURE__ */ Test_Spec_Assertions.shouldEqual(Effect_Aff.monadThrowAff)(Data_Show.showNumber)(Data_Eq.eqNumber);
var calculateExponentialMotion = function (startValue) {
    return function (endValue) {
        return function (easedT) {
            if (startValue === 0.0) {
                return endValue * easedT;
            };
            if (Data_Boolean.otherwise) {
                var ratio = endValue / startValue;
                return startValue * $$Math.pow(ratio)(easedT);
            };
            throw new Error("Failed pattern match at Test.Lattice.Services.Depthflow (line 18, column 1 - line 18, column 67): " + [ startValue.constructor.name, endValue.constructor.name, easedT.constructor.name ]);
        };
    };
};
var spec = /* #__PURE__ */ describe("Depthflow motion calculations")(/* #__PURE__ */ describe("exponential motion")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("calculates exponential growth correctly")(/* #__PURE__ */ discard2(/* #__PURE__ */ shouldEqual(/* #__PURE__ */ calculateExponentialMotion(1.0)(100.0)(0.0))(1.0))(function () {
    return discard2(shouldEqual(calculateExponentialMotion(1.0)(100.0)(1.0))(100.0))(function () {
        return Test_Lattice_TestHelpers.assertCloseTo(0.1)(10.0)(calculateExponentialMotion(1.0)(100.0)(0.5));
    });
})))(function () {
    return discard1(it("handles decay (shrinking values)")(discard2(shouldEqual(calculateExponentialMotion(100.0)(1.0)(0.0))(100.0))(function () {
        return discard2(shouldEqual(calculateExponentialMotion(100.0)(1.0)(1.0))(1.0))(function () {
            return Test_Lattice_TestHelpers.assertCloseTo(0.1)(10.0)(calculateExponentialMotion(100.0)(1.0)(0.5));
        });
    })))(function () {
        return discard1(it("BUG #4 FIXED: startValue=0 returns linear interpolation instead of NaN")(discard2(shouldEqual(calculateExponentialMotion(0.0)(100.0)(0.0))(0.0))(function () {
            return discard2(shouldEqual(calculateExponentialMotion(0.0)(100.0)(0.5))(50.0))(function () {
                return discard2(shouldEqual(calculateExponentialMotion(0.0)(100.0)(1.0))(100.0))(function () {
                    return discard2(Test_Lattice_TestHelpers.assertFinite(calculateExponentialMotion(0.0)(100.0)(0.0)))(function () {
                        return discard2(Test_Lattice_TestHelpers.assertFinite(calculateExponentialMotion(0.0)(100.0)(0.5)))(function () {
                            return Test_Lattice_TestHelpers.assertFinite(calculateExponentialMotion(0.0)(100.0)(1.0));
                        });
                    });
                });
            });
        })))(function () {
            return discard1(it("BUG #4 FIXED: startValue=0 with negative endValue")(discard2(shouldEqual(calculateExponentialMotion(0.0)(-100.0)(0.5))(-50.0))(function () {
                return Test_Lattice_TestHelpers.assertFinite(calculateExponentialMotion(0.0)(-100.0)(0.5));
            })))(function () {
                return it("BUG #4 FIXED: both values 0 returns 0")(discard2(shouldEqual(calculateExponentialMotion(0.0)(0.0)(0.5))(0.0))(function () {
                    return Test_Lattice_TestHelpers.assertFinite(calculateExponentialMotion(0.0)(0.0)(0.5));
                }));
            });
        });
    });
})));
export {
    spec
};
//# sourceMappingURL=index.js.map
