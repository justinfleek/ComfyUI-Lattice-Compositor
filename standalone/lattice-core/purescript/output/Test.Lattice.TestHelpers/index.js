// Generated by purs version 0.15.15
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Effect_Aff from "../Effect.Aff/index.js";
import * as Lattice_Services_Math3D_Vec3 from "../Lattice.Services.Math3D.Vec3/index.js";
import * as Test_QuickCheck_Gen from "../Test.QuickCheck.Gen/index.js";
import * as Test_Spec_Assertions from "../Test.Spec.Assertions/index.js";
var bind = /* #__PURE__ */ Control_Bind.bind(Test_QuickCheck_Gen.bindGen);
var pure = /* #__PURE__ */ Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen);
var pure1 = /* #__PURE__ */ Control_Applicative.pure(Effect_Aff.applicativeAff);
var fail = /* #__PURE__ */ Test_Spec_Assertions.fail(Effect_Aff.monadThrowAff);
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showNumber);
var genVec3 = /* #__PURE__ */ (function () {
    return bind(Test_QuickCheck_Gen.choose(-1000.0)(1000.0))(function (x) {
        return bind(Test_QuickCheck_Gen.choose(-1000.0)(1000.0))(function (y) {
            return bind(Test_QuickCheck_Gen.choose(-1000.0)(1000.0))(function (z) {
                return pure(Lattice_Services_Math3D_Vec3.vec3(x)(y)(z));
            });
        });
    });
})();
var genPositiveNumber = /* #__PURE__ */ Test_QuickCheck_Gen.choose(1.0e-3)(1000.0);
var genNormalized = /* #__PURE__ */ Test_QuickCheck_Gen.choose(0.0)(1.0);
var genBoundedNumber = function (lo) {
    return function (hi) {
        return Test_QuickCheck_Gen.choose(lo)(hi);
    };
};
var genAngle = /* #__PURE__ */ (function () {
    return Test_QuickCheck_Gen.choose(-6.283185307)(6.283185307);
})();
var epsilon = 1.0e-6;
var assertInRange = function (lo) {
    return function (hi) {
        return function (actual) {
            var $11 = actual >= lo && actual <= hi;
            if ($11) {
                return pure1(Data_Unit.unit);
            };
            return fail("Expected " + (show(actual) + (" to be in range [" + (show(lo) + (", " + (show(hi) + "]"))))));
        };
    };
};
var assertFinite = function (n) {
    var $12 = Data_Number["isFinite"](n);
    if ($12) {
        return pure1(Data_Unit.unit);
    };
    return fail("Expected finite number, got: " + show(n));
};
var assertCloseTo = function (tolerance) {
    return function (expected) {
        return function (actual) {
            var $13 = Data_Number.abs(actual - expected) <= tolerance;
            if ($13) {
                return pure1(Data_Unit.unit);
            };
            return fail("Expected " + (show(actual) + (" to be close to " + (show(expected) + (" (tolerance: " + (show(tolerance) + (")" + (", diff: " + show(Data_Number.abs(actual - expected))))))))));
        };
    };
};
export {
    assertCloseTo,
    assertInRange,
    assertFinite,
    genBoundedNumber,
    genNormalized,
    genPositiveNumber,
    genAngle,
    genVec3,
    epsilon
};
//# sourceMappingURL=index.js.map
