// Generated by purs version 0.15.15
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var wipeProjection = function (uvX) {
    return function (uvY) {
        return function (angleDeg) {
            var relY = uvY - 0.5;
            var relX = uvX - 0.5;
            var rad = (angleDeg * $$Math.pi) / 180.0;
            var dirY = $$Math.sin(rad);
            var dirX = $$Math.cos(rad);
            return relX * dirX + relY * dirY + 0.5;
        };
    };
};
var radialDistance = function (uvX) {
    return function (uvY) {
        return function (centerX) {
            return function (centerY) {
                var dy = uvY - centerY;
                var dx = uvX - centerX;
                return $$Math.sqrt(dx * dx + dy * dy);
            };
        };
    };
};
var lerp = function (a) {
    return function (b) {
        return function (t) {
            return a + (b - a) * t;
        };
    };
};
var lerpColor = function (r1) {
    return function (g1) {
        return function (b1) {
            return function (r2) {
                return function (g2) {
                    return function (b2) {
                        return function (t) {
                            return new Data_Tuple.Tuple(lerp(r1)(r2)(t), new Data_Tuple.Tuple(lerp(g1)(g2)(t), lerp(b1)(b2)(t)));
                        };
                    };
                };
            };
        };
    };
};
var lerpColorAlpha = function (r1) {
    return function (g1) {
        return function (b1) {
            return function (a1) {
                return function (r2) {
                    return function (g2) {
                        return function (b2) {
                            return function (a2) {
                                return function (t) {
                                    return new Data_Tuple.Tuple(lerp(r1)(r2)(t), new Data_Tuple.Tuple(lerp(g1)(g2)(t), new Data_Tuple.Tuple(lerp(b1)(b2)(t), lerp(a1)(a2)(t))));
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
var clamp01 = function (x) {
    if (x < 0.0) {
        return 0.0;
    };
    if (x > 1.0) {
        return 1.0;
    };
    if (Data_Boolean.otherwise) {
        return x;
    };
    throw new Error("Failed pattern match at Lattice.Services.Shader.Transition (line 39, column 1 - line 39, column 28): " + [ x.constructor.name ]);
};
var smoothstep = function (edge0) {
    return function (edge1) {
        return function (x) {
            if (edge1 <= edge0) {
                var $11 = x < edge0;
                if ($11) {
                    return 0.0;
                };
                return 1.0;
            };
            if (Data_Boolean.otherwise) {
                var t = clamp01((x - edge0) / (edge1 - edge0));
                return t * t * (3.0 - 2.0 * t);
            };
            throw new Error("Failed pattern match at Lattice.Services.Shader.Transition (line 46, column 1 - line 46, column 51): " + [ edge0.constructor.name, edge1.constructor.name, x.constructor.name ]);
        };
    };
};
var dissolveEdge = function (noiseValue) {
    return function (progress) {
        return function (softness) {
            return smoothstep(progress - softness)(progress + softness)(noiseValue);
        };
    };
};
var dissolveBlend = dissolveEdge;
var radialWipeEdge = function (uvX) {
    return function (uvY) {
        return function (centerX) {
            return function (centerY) {
                return function (progress) {
                    return function (softness) {
                        return function (maxRadius) {
                            return function (invert) {
                                var threshold = (function () {
                                    if (invert) {
                                        return 1.0 - progress;
                                    };
                                    return progress;
                                })();
                                var dist = radialDistance(uvX)(uvY)(centerX)(centerY);
                                var normalizedDist = dist / maxRadius;
                                return smoothstep(threshold - softness)(threshold + softness)(normalizedDist);
                            };
                        };
                    };
                };
            };
        };
    };
};
var wipeEdge = function (uvX) {
    return function (uvY) {
        return function (angleDeg) {
            return function (progress) {
                return function (softness) {
                    var d = wipeProjection(uvX)(uvY)(angleDeg);
                    return smoothstep(progress - softness)(progress + softness)(d);
                };
            };
        };
    };
};
var wipeBlend = wipeEdge;
var angleFromCenter = function (uvX) {
    return function (uvY) {
        return function (centerX) {
            return function (centerY) {
                var dy = uvY - centerY;
                var dx = uvX - centerX;
                return $$Math.atan2(dy)(dx);
            };
        };
    };
};
var clockWipeEdge = function (uvX) {
    return function (uvY) {
        return function (centerX) {
            return function (centerY) {
                return function (startAngleDeg) {
                    return function (progress) {
                        return function (softness) {
                            return function (clockwise) {
                                var twoPi = 2.0 * $$Math.pi;
                                var startRad = (startAngleDeg * $$Math.pi) / 180.0;
                                var angle = angleFromCenter(uvX)(uvY)(centerX)(centerY);
                                var relAngle = angle - startRad;
                                var wrapped = relAngle - twoPi * $$Math.floor(relAngle / twoPi);
                                var normalizedAngle = wrapped / twoPi;
                                var directedAngle = (function () {
                                    if (clockwise) {
                                        return 1.0 - normalizedAngle;
                                    };
                                    return normalizedAngle;
                                })();
                                return smoothstep(progress - softness)(progress + softness)(directedAngle);
                            };
                        };
                    };
                };
            };
        };
    };
};
export {
    clamp01,
    smoothstep,
    dissolveEdge,
    dissolveBlend,
    wipeProjection,
    wipeEdge,
    wipeBlend,
    radialDistance,
    radialWipeEdge,
    angleFromCenter,
    clockWipeEdge,
    lerp,
    lerpColor,
    lerpColorAlpha
};
//# sourceMappingURL=index.js.map
