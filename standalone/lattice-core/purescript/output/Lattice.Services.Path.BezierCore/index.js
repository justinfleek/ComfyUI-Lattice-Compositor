// Generated by purs version 0.15.15
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as $$Math from "../Math/index.js";
var bind = /* #__PURE__ */ Control_Bind.bind(Data_Maybe.bindMaybe);
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var pure = /* #__PURE__ */ Control_Applicative.pure(Data_Maybe.applicativeMaybe);
var append = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var zeroPoint = {
    x: 0.0,
    y: 0.0
};
var subPoints = function (a) {
    return function (b) {
        return {
            x: a.x - b.x,
            y: a.y - b.y
        };
    };
};
var scalePoint = function (p) {
    return function (s) {
        return {
            x: p.x * s,
            y: p.y * s
        };
    };
};
var pointDistance = function (a) {
    return function (b) {
        var dy = b.y - a.y;
        var dx = b.x - a.x;
        return $$Math.sqrt(dx * dx + dy * dy);
    };
};
var lerp = function (a) {
    return function (b) {
        return function (t) {
            return a + (b - a) * t;
        };
    };
};
var lerpPoint = function (a) {
    return function (b) {
        return function (t) {
            return {
                x: lerp(a.x)(b.x)(t),
                y: lerp(a.y)(b.y)(t)
            };
        };
    };
};
var lerpVertex = function (v1) {
    return function (v2) {
        return function (t) {
            return {
                point: lerpPoint(v1.point)(v2.point)(t),
                inHandle: lerpPoint(v1.inHandle)(v2.inHandle)(t),
                outHandle: lerpPoint(v1.outHandle)(v2.outHandle)(t)
            };
        };
    };
};
var splitCubicBezier = function (p0) {
    return function (p1) {
        return function (p2) {
            return function (p3) {
                return function (t) {
                    var q2 = lerpPoint(p2)(p3)(t);
                    var q1 = lerpPoint(p1)(p2)(t);
                    var r1 = lerpPoint(q1)(q2)(t);
                    var q0 = lerpPoint(p0)(p1)(t);
                    var r0 = lerpPoint(q0)(q1)(t);
                    var s = lerpPoint(r0)(r1)(t);
                    var right = {
                        p0: s,
                        p1: r1,
                        p2: q2,
                        p3: p3
                    };
                    var left = {
                        p0: p0,
                        p1: q0,
                        p2: r0,
                        p3: s
                    };
                    return {
                        left: left,
                        right: right
                    };
                };
            };
        };
    };
};
var cubicBezierPoint = function (p0) {
    return function (p1) {
        return function (p2) {
            return function (p3) {
                return function (t) {
                    var t2 = t * t;
                    var t3 = t2 * t;
                    var mt = 1.0 - t;
                    var mt2 = mt * mt;
                    var mt3 = mt2 * mt;
                    var x = mt3 * p0.x + 3.0 * mt2 * t * p1.x + 3.0 * mt * t2 * p2.x + t3 * p3.x;
                    var y = mt3 * p0.y + 3.0 * mt2 * t * p1.y + 3.0 * mt * t2 * p2.y + t3 * p3.y;
                    return {
                        x: x,
                        y: y
                    };
                };
            };
        };
    };
};
var estimateSegmentLength = function (p0) {
    return function (p1) {
        return function (p2) {
            return function (p3) {
                return function (samples) {
                    if (samples <= 0) {
                        return 0.0;
                    };
                    if (Data_Boolean.otherwise) {
                        var go = function ($copy_i) {
                            return function ($copy_prev) {
                                return function ($copy_acc) {
                                    var $tco_var_i = $copy_i;
                                    var $tco_var_prev = $copy_prev;
                                    var $tco_done = false;
                                    var $tco_result;
                                    function $tco_loop(i, prev, acc) {
                                        if (i > samples) {
                                            $tco_done = true;
                                            return acc;
                                        };
                                        if (Data_Boolean.otherwise) {
                                            var t = Data_Int.toNumber(i) / Data_Int.toNumber(samples);
                                            var curr = cubicBezierPoint(p0)(p1)(p2)(p3)(t);
                                            var dist = pointDistance(prev)(curr);
                                            $tco_var_i = i + 1 | 0;
                                            $tco_var_prev = curr;
                                            $copy_acc = acc + dist;
                                            return;
                                        };
                                        throw new Error("Failed pattern match at Lattice.Services.Path.BezierCore (line 191, column 5 - line 197, column 42): " + [ i.constructor.name, prev.constructor.name, acc.constructor.name ]);
                                    };
                                    while (!$tco_done) {
                                        $tco_result = $tco_loop($tco_var_i, $tco_var_prev, $copy_acc);
                                    };
                                    return $tco_result;
                                };
                            };
                        };
                        return go(1)(p0)(0.0);
                    };
                    throw new Error("Failed pattern match at Lattice.Services.Path.BezierCore (line 186, column 1 - line 186, column 83): " + [ p0.constructor.name, p1.constructor.name, p2.constructor.name, p3.constructor.name, samples.constructor.name ]);
                };
            };
        };
    };
};
var cubicBezierDerivative = function (p0) {
    return function (p1) {
        return function (p2) {
            return function (p3) {
                return function (t) {
                    var t2 = t * t;
                    var mt = 1.0 - t;
                    var mt2 = mt * mt;
                    var d23 = subPoints(p3)(p2);
                    var d12 = subPoints(p2)(p1);
                    var d01 = subPoints(p1)(p0);
                    var x = 3.0 * mt2 * d01.x + 6.0 * mt * t * d12.x + 3.0 * t2 * d23.x;
                    var y = 3.0 * mt2 * d01.y + 6.0 * mt * t * d12.y + 3.0 * t2 * d23.y;
                    return {
                        x: x,
                        y: y
                    };
                };
            };
        };
    };
};
var clonePoint = function (p) {
    return {
        x: p.x,
        y: p.y
    };
};
var cloneVertex = function (v) {
    return {
        point: clonePoint(v.point),
        inHandle: clonePoint(v.inHandle),
        outHandle: clonePoint(v.outHandle)
    };
};
var addPoints = function (a) {
    return function (b) {
        return {
            x: a.x + b.x,
            y: a.y + b.y
        };
    };
};
var inHandleAbsolute = function (v) {
    return addPoints(v.point)(v.inHandle);
};
var outHandleAbsolute = function (v) {
    return addPoints(v.point)(v.outHandle);
};
var getSegmentControlPoints = function (path) {
    return function (segmentIndex) {
        if (Data_Array.length(path.vertices) === 0) {
            return Data_Maybe.Nothing.value;
        };
        if (segmentIndex < 0 || segmentIndex >= Data_Array.length(path.vertices)) {
            return Data_Maybe.Nothing.value;
        };
        if (Data_Boolean.otherwise) {
            return bind(Data_Array.index(path.vertices)(segmentIndex))(function (v0) {
                var n = Data_Array.length(path.vertices);
                var nextIdx = mod(segmentIndex + 1 | 0)(n);
                return bind(Data_Array.index(path.vertices)(nextIdx))(function (v1) {
                    var p2 = inHandleAbsolute(v1);
                    var p1 = outHandleAbsolute(v0);
                    return pure({
                        p0: v0.point,
                        p1: p1,
                        p2: p2,
                        p3: v1.point
                    });
                });
            });
        };
        throw new Error("Failed pattern match at Lattice.Services.Path.BezierCore (line 200, column 1 - line 201, column 95): " + [ path.constructor.name, segmentIndex.constructor.name ]);
    };
};
var getPathLength = function (path) {
    return function (samplesPerSegment) {
        if (Data_Array.length(path.vertices) === 0) {
            return 0.0;
        };
        if (Data_Boolean.otherwise) {
            var numSegments = (function () {
                if (path.closed) {
                    return Data_Array.length(path.vertices);
                };
                return Data_Array.length(path.vertices) - 1 | 0;
            })();
            var go = function ($copy_i) {
                return function ($copy_acc) {
                    var $tco_var_i = $copy_i;
                    var $tco_done = false;
                    var $tco_result;
                    function $tco_loop(i, acc) {
                        if (i >= numSegments) {
                            $tco_done = true;
                            return acc;
                        };
                        if (Data_Boolean.otherwise) {
                            var v = getSegmentControlPoints(path)(i);
                            if (v instanceof Data_Maybe.Just) {
                                var len = estimateSegmentLength(v.value0.p0)(v.value0.p1)(v.value0.p2)(v.value0.p3)(samplesPerSegment);
                                $tco_var_i = i + 1 | 0;
                                $copy_acc = acc + len;
                                return;
                            };
                            if (v instanceof Data_Maybe.Nothing) {
                                $tco_done = true;
                                return acc;
                            };
                            throw new Error("Failed pattern match at Lattice.Services.Path.BezierCore (line 227, column 21 - line 231, column 25): " + [ v.constructor.name ]);
                        };
                        throw new Error("Failed pattern match at Lattice.Services.Path.BezierCore (line 225, column 5 - line 231, column 25): " + [ i.constructor.name, acc.constructor.name ]);
                    };
                    while (!$tco_done) {
                        $tco_result = $tco_loop($tco_var_i, $copy_acc);
                    };
                    return $tco_result;
                };
            };
            return go(0)(0.0);
        };
        throw new Error("Failed pattern match at Lattice.Services.Path.BezierCore (line 217, column 1 - line 217, column 45): " + [ path.constructor.name, samplesPerSegment.constructor.name ]);
    };
};
var getSegmentLengths = function (path) {
    return function (samplesPerSegment) {
        if (Data_Array.length(path.vertices) === 0) {
            return [  ];
        };
        if (Data_Boolean.otherwise) {
            var numSegments = (function () {
                if (path.closed) {
                    return Data_Array.length(path.vertices);
                };
                return Data_Array.length(path.vertices) - 1 | 0;
            })();
            var go = function ($copy_i) {
                return function ($copy_acc) {
                    var $tco_var_i = $copy_i;
                    var $tco_done = false;
                    var $tco_result;
                    function $tco_loop(i, acc) {
                        if (i >= numSegments) {
                            $tco_done = true;
                            return acc;
                        };
                        if (Data_Boolean.otherwise) {
                            var v = getSegmentControlPoints(path)(i);
                            if (v instanceof Data_Maybe.Just) {
                                var len = estimateSegmentLength(v.value0.p0)(v.value0.p1)(v.value0.p2)(v.value0.p3)(samplesPerSegment);
                                $tco_var_i = i + 1 | 0;
                                $copy_acc = append(acc)([ len ]);
                                return;
                            };
                            if (v instanceof Data_Maybe.Nothing) {
                                $tco_var_i = i + 1 | 0;
                                $copy_acc = acc;
                                return;
                            };
                            throw new Error("Failed pattern match at Lattice.Services.Path.BezierCore (line 244, column 21 - line 248, column 36): " + [ v.constructor.name ]);
                        };
                        throw new Error("Failed pattern match at Lattice.Services.Path.BezierCore (line 242, column 5 - line 248, column 36): " + [ i.constructor.name, acc.constructor.name ]);
                    };
                    while (!$tco_done) {
                        $tco_result = $tco_loop($tco_var_i, $copy_acc);
                    };
                    return $tco_result;
                };
            };
            return go(0)([  ]);
        };
        throw new Error("Failed pattern match at Lattice.Services.Path.BezierCore (line 234, column 1 - line 234, column 55): " + [ path.constructor.name, samplesPerSegment.constructor.name ]);
    };
};
export {
    zeroPoint,
    clonePoint,
    addPoints,
    subPoints,
    scalePoint,
    pointDistance,
    lerp,
    lerpPoint,
    cloneVertex,
    inHandleAbsolute,
    outHandleAbsolute,
    lerpVertex,
    cubicBezierPoint,
    cubicBezierDerivative,
    splitCubicBezier,
    estimateSegmentLength,
    getSegmentControlPoints,
    getPathLength,
    getSegmentLengths
};
//# sourceMappingURL=index.js.map
