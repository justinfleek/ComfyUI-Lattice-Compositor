// Generated by purs version 0.15.15
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var ShapeSquare = /* #__PURE__ */ (function () {
    function ShapeSquare() {

    };
    ShapeSquare.value = new ShapeSquare();
    return ShapeSquare;
})();
var ShapeRampUp = /* #__PURE__ */ (function () {
    function ShapeRampUp() {

    };
    ShapeRampUp.value = new ShapeRampUp();
    return ShapeRampUp;
})();
var ShapeRampDown = /* #__PURE__ */ (function () {
    function ShapeRampDown() {

    };
    ShapeRampDown.value = new ShapeRampDown();
    return ShapeRampDown;
})();
var ShapeTriangle = /* #__PURE__ */ (function () {
    function ShapeTriangle() {

    };
    ShapeTriangle.value = new ShapeTriangle();
    return ShapeTriangle;
})();
var ShapeRound = /* #__PURE__ */ (function () {
    function ShapeRound() {

    };
    ShapeRound.value = new ShapeRound();
    return ShapeRound;
})();
var ShapeSmooth = /* #__PURE__ */ (function () {
    function ShapeSmooth() {

    };
    ShapeSmooth.value = new ShapeSmooth();
    return ShapeSmooth;
})();
var ModeAdd = /* #__PURE__ */ (function () {
    function ModeAdd() {

    };
    ModeAdd.value = new ModeAdd();
    return ModeAdd;
})();
var ModeSubtract = /* #__PURE__ */ (function () {
    function ModeSubtract() {

    };
    ModeSubtract.value = new ModeSubtract();
    return ModeSubtract;
})();
var ModeIntersect = /* #__PURE__ */ (function () {
    function ModeIntersect() {

    };
    ModeIntersect.value = new ModeIntersect();
    return ModeIntersect;
})();
var ModeMin = /* #__PURE__ */ (function () {
    function ModeMin() {

    };
    ModeMin.value = new ModeMin();
    return ModeMin;
})();
var ModeMax = /* #__PURE__ */ (function () {
    function ModeMax() {

    };
    ModeMax.value = new ModeMax();
    return ModeMax;
})();
var ModeDifference = /* #__PURE__ */ (function () {
    function ModeDifference() {

    };
    ModeDifference.value = new ModeDifference();
    return ModeDifference;
})();
var wrapTo100 = function (val) {
    var mod$prime = function (a) {
        return function (b) {
            return a - b * $$Math.floor(a / b);
        };
    };
    var modVal = mod$prime(mod$prime(val)(100.0) + 100.0)(100.0);
    var $24 = modVal === 0.0 && val !== 0.0;
    if ($24) {
        return 100.0;
    };
    return modVal;
};
var wigglyInfluenceFromPhase = function (phase) {
    return function (minAmount) {
        return function (maxAmount) {
            var wiggleValue = $$Math.sin(phase);
            var range = maxAmount - minAmount;
            var amount = minAmount + ((wiggleValue + 1.0) / 2.0) * range;
            return amount / 100.0;
        };
    };
};
var toNumber = function (n) {
    var toNumberPos = function (v) {
        if (v === 0) {
            return 0.0;
        };
        return 1.0 + toNumberPos(v - 1 | 0);
    };
    var $26 = n < 0;
    if ($26) {
        return -toNumberPos(-n | 0);
    };
    return toNumberPos(n);
};
var isInRange = function (charPosition) {
    return function (effectiveStart) {
        return function (effectiveEnd) {
            return function (rangeWraps) {
                if (rangeWraps) {
                    var $31 = charPosition >= effectiveStart;
                    if ($31) {
                        var upperSegmentSize = 100.0 - effectiveStart;
                        var totalRangeSize = upperSegmentSize + effectiveEnd;
                        var posInRange = (function () {
                            var $32 = totalRangeSize > 0.0;
                            if ($32) {
                                return (charPosition - effectiveStart) / totalRangeSize;
                            };
                            return 0.0;
                        })();
                        return new Data_Tuple.Tuple(true, posInRange);
                    };
                    var $33 = charPosition <= effectiveEnd;
                    if ($33) {
                        var upperSegmentSize = 100.0 - effectiveStart;
                        var totalRangeSize = upperSegmentSize + effectiveEnd;
                        var posInRange = (function () {
                            var $34 = totalRangeSize > 0.0;
                            if ($34) {
                                return (upperSegmentSize + charPosition) / totalRangeSize;
                            };
                            return 1.0;
                        })();
                        return new Data_Tuple.Tuple(true, posInRange);
                    };
                    return new Data_Tuple.Tuple(false, 0.0);
                };
                if (Data_Boolean.otherwise) {
                    var normalizedStart = min(effectiveStart)(effectiveEnd);
                    var normalizedEnd = max(effectiveStart)(effectiveEnd);
                    var $35 = charPosition < normalizedStart || charPosition > normalizedEnd;
                    if ($35) {
                        return new Data_Tuple.Tuple(false, 0.0);
                    };
                    var rangeSize = normalizedEnd - normalizedStart;
                    var posInRange = (function () {
                        var $36 = rangeSize > 0.0;
                        if ($36) {
                            return (charPosition - normalizedStart) / rangeSize;
                        };
                        return 0.5;
                    })();
                    return new Data_Tuple.Tuple(true, posInRange);
                };
                throw new Error("Failed pattern match at Lattice.Services.TextAnimator.Selectors (line 152, column 1 - line 152, column 75): " + [ charPosition.constructor.name, effectiveStart.constructor.name, effectiveEnd.constructor.name, rangeWraps.constructor.name ]);
            };
        };
    };
};
var eqSelectorShape = {
    eq: function (x) {
        return function (y) {
            if (x instanceof ShapeSquare && y instanceof ShapeSquare) {
                return true;
            };
            if (x instanceof ShapeRampUp && y instanceof ShapeRampUp) {
                return true;
            };
            if (x instanceof ShapeRampDown && y instanceof ShapeRampDown) {
                return true;
            };
            if (x instanceof ShapeTriangle && y instanceof ShapeTriangle) {
                return true;
            };
            if (x instanceof ShapeRound && y instanceof ShapeRound) {
                return true;
            };
            if (x instanceof ShapeSmooth && y instanceof ShapeSmooth) {
                return true;
            };
            return false;
        };
    }
};
var eqSelectorMode = {
    eq: function (x) {
        return function (y) {
            if (x instanceof ModeAdd && y instanceof ModeAdd) {
                return true;
            };
            if (x instanceof ModeSubtract && y instanceof ModeSubtract) {
                return true;
            };
            if (x instanceof ModeIntersect && y instanceof ModeIntersect) {
                return true;
            };
            if (x instanceof ModeMin && y instanceof ModeMin) {
                return true;
            };
            if (x instanceof ModeMax && y instanceof ModeMax) {
                return true;
            };
            if (x instanceof ModeDifference && y instanceof ModeDifference) {
                return true;
            };
            return false;
        };
    }
};
var defaultWigglyConfig = {
    wigglesPerSecond: 2.0,
    correlation: 50.0,
    minAmount: 0.0,
    maxAmount: 100.0,
    lockDimensions: false
};
var defaultEaseConfig = {
    high: 100.0,
    low: 0.0
};
var combineSelectorValues = function (baseValue) {
    return function (newValue) {
        return function (mode) {
            if (mode instanceof ModeAdd) {
                return min(1.0)(baseValue + newValue);
            };
            if (mode instanceof ModeSubtract) {
                return max(0.0)(baseValue - newValue);
            };
            if (mode instanceof ModeIntersect) {
                return baseValue * newValue;
            };
            if (mode instanceof ModeMin) {
                return min(baseValue)(newValue);
            };
            if (mode instanceof ModeMax) {
                return max(baseValue)(newValue);
            };
            if (mode instanceof ModeDifference) {
                return $$Math.abs(baseValue - newValue);
            };
            throw new Error("Failed pattern match at Lattice.Services.TextAnimator.Selectors (line 130, column 49 - line 136, column 47): " + [ mode.constructor.name ]);
        };
    };
};
var characterPosition = function (charIndex) {
    return function (totalChars) {
        if (totalChars <= 1) {
            return 0.0;
        };
        if (Data_Boolean.otherwise) {
            return (toNumber(charIndex) / toNumber(totalChars - 1 | 0)) * 100.0;
        };
        throw new Error("Failed pattern match at Lattice.Services.TextAnimator.Selectors (line 143, column 1 - line 143, column 42): " + [ charIndex.constructor.name, totalChars.constructor.name ]);
    };
};
var calculateWigglyPhase = function (time) {
    return function (wigglesPerSecond) {
        return function (baseRandom) {
            return function (correlation) {
                var wigglePhase = time * wigglesPerSecond * $$Math.pi * 2.0;
                var individualPhase = wigglePhase + baseRandom * $$Math.pi * 2.0;
                var correlationFactor = correlation / 100.0;
                return individualPhase * (1.0 - correlationFactor) + wigglePhase * correlationFactor;
            };
        };
    };
};
var calculateWigglyOffset = function (time) {
    return function (config) {
        return function (baseRandomX) {
            return function (baseRandomY) {
                var wigglePhase = time * config.wigglesPerSecond * $$Math.pi * 2.0;
                var individualPhaseY = $$Math.sin(wigglePhase + baseRandomY * $$Math.pi * 2.0);
                var individualPhaseX = $$Math.sin(wigglePhase + baseRandomX * $$Math.pi * 2.0);
                var groupPhaseX = $$Math.sin(wigglePhase);
                var groupPhaseY = (function () {
                    if (config.lockDimensions) {
                        return groupPhaseX;
                    };
                    return $$Math.cos(wigglePhase);
                })();
                var correlationFactor = config.correlation / 100.0;
                var x = individualPhaseX * (1.0 - correlationFactor) + groupPhaseX * correlationFactor;
                var y = individualPhaseY * (1.0 - correlationFactor) + groupPhaseY * correlationFactor;
                var amount = (config.maxAmount + config.minAmount) / 2.0 / 100.0;
                return new Data_Tuple.Tuple(x * amount, y * amount);
            };
        };
    };
};
var applySmoothness = function (influence) {
    return function (smoothness) {
        if (smoothness >= 100.0) {
            return influence;
        };
        if (Data_Boolean.otherwise) {
            var smoothFactor = smoothness / 100.0;
            return influence * smoothFactor + 0.5 * (1.0 - smoothFactor);
        };
        throw new Error("Failed pattern match at Lattice.Services.TextAnimator.Selectors (line 242, column 1 - line 242, column 46): " + [ influence.constructor.name, smoothness.constructor.name ]);
    };
};
var applyShapeRaw = function (t) {
    return function (shape) {
        if (shape instanceof ShapeSquare) {
            return 1.0;
        };
        if (shape instanceof ShapeRampUp) {
            return t;
        };
        if (shape instanceof ShapeRampDown) {
            return 1.0 - t;
        };
        if (shape instanceof ShapeTriangle) {
            return 1.0 - $$Math.abs(2.0 * t - 1.0);
        };
        if (shape instanceof ShapeRound) {
            return $$Math.sin(t * $$Math.pi);
        };
        if (shape instanceof ShapeSmooth) {
            return t * t * (3.0 - 2.0 * t);
        };
        throw new Error("Failed pattern match at Lattice.Services.TextAnimator.Selectors (line 105, column 25 - line 111, column 43): " + [ shape.constructor.name ]);
    };
};
var applyShape = function (t) {
    return function (shape) {
        return function (ease) {
            var value = applyShapeRaw(t)(shape);
            var easeRange = (ease.high - ease.low) / 100.0;
            return ease.low / 100.0 + value * easeRange;
        };
    };
};
var applyOffset = function (startValue) {
    return function (endValue) {
        return function (offset) {
            return new Data_Tuple.Tuple(wrapTo100(startValue + offset), wrapTo100(endValue + offset));
        };
    };
};
export {
    ShapeSquare,
    ShapeRampUp,
    ShapeRampDown,
    ShapeTriangle,
    ShapeRound,
    ShapeSmooth,
    ModeAdd,
    ModeSubtract,
    ModeIntersect,
    ModeMin,
    ModeMax,
    ModeDifference,
    defaultEaseConfig,
    defaultWigglyConfig,
    applyShapeRaw,
    applyShape,
    combineSelectorValues,
    characterPosition,
    isInRange,
    calculateWigglyPhase,
    wigglyInfluenceFromPhase,
    calculateWigglyOffset,
    applySmoothness,
    wrapTo100,
    applyOffset,
    eqSelectorShape,
    eqSelectorMode
};
//# sourceMappingURL=index.js.map
