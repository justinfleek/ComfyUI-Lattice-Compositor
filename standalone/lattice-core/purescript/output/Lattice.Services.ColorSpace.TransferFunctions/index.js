// Generated by purs version 0.15.15
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as $$Math from "../Math/index.js";
var Linear = /* #__PURE__ */ (function () {
    function Linear() {

    };
    Linear.value = new Linear();
    return Linear;
})();
var SRGB = /* #__PURE__ */ (function () {
    function SRGB() {

    };
    SRGB.value = new SRGB();
    return SRGB;
})();
var Power = /* #__PURE__ */ (function () {
    function Power(value0) {
        this.value0 = value0;
    };
    Power.create = function (value0) {
        return new Power(value0);
    };
    return Power;
})();
var srgbScale = 1.055;
var srgbOffset = 5.5e-2;
var srgbLinearThreshold = 3.1308e-3;
var srgbLinearScale = 12.92;
var srgbGamma = 2.4;
var srgbDecodeThreshold = 4.045e-2;
var sRGBToLinear = function (value) {
    if (value <= srgbDecodeThreshold) {
        return value / srgbLinearScale;
    };
    if (Data_Boolean.otherwise) {
        return $$Math.pow((value + srgbOffset) / srgbScale)(srgbGamma);
    };
    throw new Error("Failed pattern match at Lattice.Services.ColorSpace.TransferFunctions (line 87, column 1 - line 87, column 33): " + [ value.constructor.name ]);
};
var mapRGB = function (f) {
    return function (rgb) {
        return {
            r: f(rgb.r),
            g: f(rgb.g),
            b: f(rgb.b)
        };
    };
};
var linearToSRGB = function (value) {
    if (value <= srgbLinearThreshold) {
        return value * srgbLinearScale;
    };
    if (Data_Boolean.otherwise) {
        return srgbScale * $$Math.pow(value)(1.0 / srgbGamma) - srgbOffset;
    };
    throw new Error("Failed pattern match at Lattice.Services.ColorSpace.TransferFunctions (line 95, column 1 - line 95, column 33): " + [ value.constructor.name ]);
};
var linearToGamma = function (value) {
    return function (gamma) {
        if (gamma === 0.0) {
            return value;
        };
        if (Data_Boolean.otherwise) {
            return $$Math.pow($$Math.max(0.0)(value))(1.0 / gamma);
        };
        throw new Error("Failed pattern match at Lattice.Services.ColorSpace.TransferFunctions (line 113, column 1 - line 113, column 44): " + [ value.constructor.name, gamma.constructor.name ]);
    };
};
var gammaWideGamut = /* #__PURE__ */ (function () {
    return new Power(2.2);
})();
var gammaToLinear = function (value) {
    return function (gamma) {
        return $$Math.pow($$Math.max(0.0)(value))(gamma);
    };
};
var linearizeRGB = function (rgb) {
    return function (gammaType) {
        if (gammaType instanceof Linear) {
            return rgb;
        };
        if (gammaType instanceof SRGB) {
            return mapRGB(sRGBToLinear)(rgb);
        };
        if (gammaType instanceof Power) {
            return mapRGB(function (v) {
                return gammaToLinear(v)(gammaType.value0);
            })(rgb);
        };
        throw new Error("Failed pattern match at Lattice.Services.ColorSpace.TransferFunctions (line 128, column 30 - line 131, column 50): " + [ gammaType.constructor.name ]);
    };
};
var gammaSRGB = /* #__PURE__ */ (function () {
    return SRGB.value;
})();
var gammaRec709 = /* #__PURE__ */ (function () {
    return new Power(2.4);
})();
var gammaRec2020 = /* #__PURE__ */ (function () {
    return new Power(2.4);
})();
var gammaProPhoto = /* #__PURE__ */ (function () {
    return new Power(1.8);
})();
var gammaLinear = /* #__PURE__ */ (function () {
    return Linear.value;
})();
var from8bit = function (v) {
    return Data_Int.toNumber(v) / 255.0;
};
var rgb8 = function (r) {
    return function (g) {
        return function (b) {
            return {
                r: from8bit(r),
                g: from8bit(g),
                b: from8bit(b)
            };
        };
    };
};
var eqGammaType = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Linear && y instanceof Linear) {
                return true;
            };
            if (x instanceof SRGB && y instanceof SRGB) {
                return true;
            };
            if (x instanceof Power && y instanceof Power) {
                return x.value0 === y.value0;
            };
            return false;
        };
    }
};
var clamp01 = function (v) {
    return $$Math.max(0.0)($$Math.min(1.0)(v));
};
var clampRGB = /* #__PURE__ */ mapRGB(clamp01);
var to8bit = function (v) {
    return Data_Int.round(clamp01(v) * 255.0);
};
var toRGB8 = function (rgb) {
    return {
        r: to8bit(rgb.r),
        g: to8bit(rgb.g),
        b: to8bit(rgb.b)
    };
};
var applyGammaRGB = function (rgb) {
    return function (gammaType) {
        if (gammaType instanceof Linear) {
            return rgb;
        };
        if (gammaType instanceof SRGB) {
            return mapRGB(linearToSRGB)(rgb);
        };
        if (gammaType instanceof Power) {
            return mapRGB(function (v) {
                return linearToGamma(v)(gammaType.value0);
            })(rgb);
        };
        throw new Error("Failed pattern match at Lattice.Services.ColorSpace.TransferFunctions (line 135, column 31 - line 138, column 50): " + [ gammaType.constructor.name ]);
    };
};
export {
    Linear,
    SRGB,
    Power,
    sRGBToLinear,
    linearToSRGB,
    gammaToLinear,
    linearToGamma,
    mapRGB,
    linearizeRGB,
    applyGammaRGB,
    gammaSRGB,
    gammaLinear,
    gammaWideGamut,
    gammaProPhoto,
    gammaRec709,
    gammaRec2020,
    clamp01,
    clampRGB,
    from8bit,
    to8bit,
    rgb8,
    toRGB8,
    eqGammaType
};
//# sourceMappingURL=index.js.map
