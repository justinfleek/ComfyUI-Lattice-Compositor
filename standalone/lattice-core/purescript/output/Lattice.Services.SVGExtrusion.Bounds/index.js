// Generated by purs version 0.15.15
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as $$Math from "../Math/index.js";
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_Foldable.foldableArray);
var width = function (bounds) {
    return bounds.maxX - bounds.minX;
};
var translate = function (bounds) {
    return function (dx) {
        return function (dy) {
            return {
                minX: bounds.minX + dx,
                minY: bounds.minY + dy,
                maxX: bounds.maxX + dx,
                maxY: bounds.maxY + dy
            };
        };
    };
};
var merge = function (a) {
    return function (b) {
        return {
            minX: min(a.minX)(b.minX),
            minY: min(a.minY)(b.minY),
            maxX: max(a.maxX)(b.maxX),
            maxY: max(a.maxY)(b.maxY)
        };
    };
};
var isValid = function (bounds) {
    return bounds.maxX >= bounds.minX && bounds.maxY >= bounds.minY;
};
var includePoint = function (bounds) {
    return function (x) {
        return function (y) {
            return {
                minX: min(bounds.minX)(x),
                minY: min(bounds.minY)(y),
                maxX: max(bounds.maxX)(x),
                maxY: max(bounds.maxY)(y)
            };
        };
    };
};
var height = function (bounds) {
    return bounds.maxY - bounds.minY;
};
var withMetrics = function (bounds) {
    var w = width(bounds);
    var h = height(bounds);
    return {
        minX: bounds.minX,
        minY: bounds.minY,
        maxX: bounds.maxX,
        maxY: bounds.maxY,
        width: w,
        height: h,
        centerX: bounds.minX + w / 2.0,
        centerY: bounds.minY + h / 2.0
    };
};
var expand = function (bounds) {
    return function (margin) {
        return {
            minX: bounds.minX - margin,
            minY: bounds.minY - margin,
            maxX: bounds.maxX + margin,
            maxY: bounds.maxY + margin
        };
    };
};
var emptyBounds = /* #__PURE__ */ (function () {
    return {
        minX: 1.0e38,
        minY: 1.0e38,
        maxX: -1.0e38,
        maxY: -1.0e38
    };
})();
var fromPoints = /* #__PURE__ */ foldl(function (acc) {
    return function (pt) {
        return includePoint(acc)(pt.x)(pt.y);
    };
})(emptyBounds);
var mergeAll = /* #__PURE__ */ foldl(merge)(emptyBounds);
var diagonal = function (bounds) {
    var w = width(bounds);
    var h = height(bounds);
    return $$Math.sqrt(w * w + h * h);
};
var containsPoint = function (bounds) {
    return function (x) {
        return function (y) {
            return x >= bounds.minX && (x <= bounds.maxX && (y >= bounds.minY && y <= bounds.maxY));
        };
    };
};
var centerY = function (bounds) {
    return bounds.minY + height(bounds) / 2.0;
};
var centerX = function (bounds) {
    return bounds.minX + width(bounds) / 2.0;
};
var scale = function (bounds) {
    return function (scaleFactor) {
        var hw = (width(bounds) / 2.0) * scaleFactor;
        var hh = (height(bounds) / 2.0) * scaleFactor;
        var cy = centerY(bounds);
        var cx = centerX(bounds);
        return {
            minX: cx - hw,
            minY: cy - hh,
            maxX: cx + hw,
            maxY: cy + hh
        };
    };
};
var area = function (bounds) {
    return width(bounds) * height(bounds);
};
export {
    emptyBounds,
    includePoint,
    fromPoints,
    width,
    height,
    centerX,
    centerY,
    withMetrics,
    merge,
    mergeAll,
    containsPoint,
    isValid,
    area,
    diagonal,
    expand,
    scale,
    translate
};
//# sourceMappingURL=index.js.map
