// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Lattice_Services_ShapeOperations_Point2D from "../Lattice.Services.ShapeOperations.Point2D/index.js";
import * as $$Math from "../Math/index.js";
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var max1 = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var split = function (curve) {
    return function (t) {
        var q2 = Lattice_Services_ShapeOperations_Point2D.lerp(curve.p2)(curve.p3)(t);
        var q1 = Lattice_Services_ShapeOperations_Point2D.lerp(curve.p1)(curve.p2)(t);
        var r1 = Lattice_Services_ShapeOperations_Point2D.lerp(q1)(q2)(t);
        var q0 = Lattice_Services_ShapeOperations_Point2D.lerp(curve.p0)(curve.p1)(t);
        var r0 = Lattice_Services_ShapeOperations_Point2D.lerp(q0)(q1)(t);
        var s = Lattice_Services_ShapeOperations_Point2D.lerp(r0)(r1)(t);
        var right = {
            p0: s,
            p1: r1,
            p2: q2,
            p3: curve.p3
        };
        var left = {
            p0: curve.p0,
            p1: q0,
            p2: r0,
            p3: s
        };
        return new Data_Tuple.Tuple(left, right);
    };
};
var splitCubicBezier = function (p0) {
    return function (p1) {
        return function (p2) {
            return function (p3) {
                return function (t) {
                    var v = split({
                        p0: p0,
                        p1: p1,
                        p2: p2,
                        p3: p3
                    })(t);
                    return new Data_Tuple.Tuple([ v.value0.p0, v.value0.p1, v.value0.p2, v.value0.p3 ], [ v.value1.p0, v.value1.p1, v.value1.p2, v.value1.p3 ]);
                };
            };
        };
    };
};
var mkCubicBezier = function (p0) {
    return function (p1) {
        return function (p2) {
            return function (p3) {
                return {
                    p0: p0,
                    p1: p1,
                    p2: p2,
                    p3: p3
                };
            };
        };
    };
};
var mkBoundingBox = function (minX) {
    return function (minY) {
        return function (maxX) {
            return function (maxY) {
                return {
                    minX: minX,
                    minY: minY,
                    maxX: maxX,
                    maxY: maxY
                };
            };
        };
    };
};
var evalPoint = function (curve) {
    return function (t) {
        var t2 = t * t;
        var t3 = t2 * t;
        var mt = 1.0 - t;
        var mt2 = mt * mt;
        var mt3 = mt2 * mt;
        var x = mt3 * curve.p0.x + 3.0 * mt2 * t * curve.p1.x + 3.0 * mt * t2 * curve.p2.x + t3 * curve.p3.x;
        var y = mt3 * curve.p0.y + 3.0 * mt2 * t * curve.p1.y + 3.0 * mt * t2 * curve.p2.y + t3 * curve.p3.y;
        return {
            x: x,
            y: y
        };
    };
};
var flatten = function (curve) {
    return function (segments) {
        var n = max(2)(segments);
        return map(function (i) {
            return evalPoint(curve)(Data_Int.toNumber(i) / Data_Int.toNumber(n));
        })(Data_Array.range(0)(n));
    };
};
var evalDerivative = function (curve) {
    return function (t) {
        var t2 = t * t;
        var mt = 1.0 - t;
        var mt2 = mt * mt;
        var dy = 3.0 * mt2 * (curve.p1.y - curve.p0.y) + 6.0 * mt * t * (curve.p2.y - curve.p1.y) + 3.0 * t2 * (curve.p3.y - curve.p2.y);
        var dx = 3.0 * mt2 * (curve.p1.x - curve.p0.x) + 6.0 * mt * t * (curve.p2.x - curve.p1.x) + 3.0 * t2 * (curve.p3.x - curve.p2.x);
        return {
            x: dx,
            y: dy
        };
    };
};
var evalTangent = function (curve) {
    return function (t) {
        return Lattice_Services_ShapeOperations_Point2D.normalize(evalDerivative(curve)(t));
    };
};
var evalNormal = function (curve) {
    return function (t) {
        return Lattice_Services_ShapeOperations_Point2D.perpendicular(evalTangent(curve)(t));
    };
};
var curvature = function (curve) {
    return function (t) {
        var d1 = evalDerivative(curve)(t);
        var speed = Lattice_Services_ShapeOperations_Point2D.len(d1);
        var $24 = speed < 1.0e-4;
        if ($24) {
            return 0.0;
        };
        var mt = 1.0 - t;
        var d2y = 6.0 * mt * ((curve.p2.y - 2.0 * curve.p1.y) + curve.p0.y) + 6.0 * t * ((curve.p3.y - 2.0 * curve.p2.y) + curve.p1.y);
        var d2x = 6.0 * mt * ((curve.p2.x - 2.0 * curve.p1.x) + curve.p0.x) + 6.0 * t * ((curve.p3.x - 2.0 * curve.p2.x) + curve.p1.x);
        var crossMag = $$Math.abs(d1.x * d2y - d1.y * d2x);
        return crossMag / (speed * speed * speed);
    };
};
var cubicBezierPoint = function (p0) {
    return function (p1) {
        return function (p2) {
            return function (p3) {
                return function (t) {
                    return evalPoint({
                        p0: p0,
                        p1: p1,
                        p2: p2,
                        p3: p3
                    })(t);
                };
            };
        };
    };
};
var boundingBox = function (curve) {
    var updateBoundsY = function (acc) {
        return function (t) {
            var pt = evalPoint(curve)(t);
            return {
                mn: min(acc.mn)(pt.y),
                mx: max1(acc.mx)(pt.y)
            };
        };
    };
    var updateBoundsX = function (acc) {
        return function (t) {
            var pt = evalPoint(curve)(t);
            return {
                mn: min(acc.mn)(pt.x),
                mx: max1(acc.mx)(pt.x)
            };
        };
    };
    var solveQuadratic = function (a) {
        return function (b) {
            return function (c) {
                if ($$Math.abs(a) < 1.0e-4) {
                    var $28 = $$Math.abs(b) < 1.0e-4;
                    if ($28) {
                        return [  ];
                    };
                    var t = -c / b;
                    var $29 = t > 0.0 && t < 1.0;
                    if ($29) {
                        return [ t ];
                    };
                    return [  ];
                };
                if (Data_Boolean.otherwise) {
                    var disc = b * b - 4.0 * a * c;
                    var $30 = disc < 0.0;
                    if ($30) {
                        return [  ];
                    };
                    var valid = function (t) {
                        return t > 0.0 && t < 1.0;
                    };
                    var sqrtDisc = $$Math.sqrt(disc);
                    var t1 = (-b + sqrtDisc) / (2.0 * a);
                    var t2 = (-b - sqrtDisc) / (2.0 * a);
                    return Data_Array.filter(valid)((function () {
                        var $31 = t1 === t2;
                        if ($31) {
                            return [ t1 ];
                        };
                        return [ t1, t2 ];
                    })());
                };
                throw new Error("Failed pattern match at Lattice.Services.ShapeOperations.Bezier (line 224, column 7 - line 236, column 74): " + [ a.constructor.name, b.constructor.name, c.constructor.name ]);
            };
        };
    };
    var minY0 = min(curve.p0.y)(curve.p3.y);
    var minX0 = min(curve.p0.x)(curve.p3.x);
    var maxY0 = max1(curve.p0.y)(curve.p3.y);
    var maxX0 = max1(curve.p0.x)(curve.p3.x);
    var cy = 3.0 * (curve.p1.y - curve.p0.y);
    var cx = 3.0 * (curve.p1.x - curve.p0.x);
    var by = 6.0 * ((curve.p0.y - 2.0 * curve.p1.y) + curve.p2.y);
    var bx = 6.0 * ((curve.p0.x - 2.0 * curve.p1.x) + curve.p2.x);
    var ay = 3.0 * (((-curve.p0.y + 3.0 * curve.p1.y) - 3.0 * curve.p2.y) + curve.p3.y);
    var yRoots = solveQuadratic(ay)(by)(cy);
    var yBounds = Data_Array.foldl(updateBoundsY)({
        mn: minY0,
        mx: maxY0
    })(yRoots);
    var ax = 3.0 * (((-curve.p0.x + 3.0 * curve.p1.x) - 3.0 * curve.p2.x) + curve.p3.x);
    var xRoots = solveQuadratic(ax)(bx)(cx);
    var xBounds = Data_Array.foldl(updateBoundsX)({
        mn: minX0,
        mx: maxX0
    })(xRoots);
    return {
        minX: xBounds.mn,
        minY: yBounds.mn,
        maxX: xBounds.mx,
        maxY: yBounds.mx
    };
};
var arcLength = function (curve) {
    return function (subdivisions) {
        var n = max(1)(subdivisions);
        var accumulate = function ($copy_i) {
            return function ($copy_prev) {
                return function ($copy_accLen) {
                    var $tco_var_i = $copy_i;
                    var $tco_var_prev = $copy_prev;
                    var $tco_done = false;
                    var $tco_result;
                    function $tco_loop(i, prev, accLen) {
                        if (i > n) {
                            $tco_done = true;
                            return accLen;
                        };
                        if (Data_Boolean.otherwise) {
                            var t = Data_Int.toNumber(i) / Data_Int.toNumber(n);
                            var curr = evalPoint(curve)(t);
                            var segLen = Lattice_Services_ShapeOperations_Point2D.distance(prev)(curr);
                            $tco_var_i = i + 1 | 0;
                            $tco_var_prev = curr;
                            $copy_accLen = accLen + segLen;
                            return;
                        };
                        throw new Error("Failed pattern match at Lattice.Services.ShapeOperations.Bezier (line 163, column 7 - line 169, column 57): " + [ i.constructor.name, prev.constructor.name, accLen.constructor.name ]);
                    };
                    while (!$tco_done) {
                        $tco_result = $tco_loop($tco_var_i, $tco_var_prev, $copy_accLen);
                    };
                    return $tco_result;
                };
            };
        };
        return accumulate(1)(evalPoint(curve)(0.0))(0.0);
    };
};
var cubicBezierLength = function (p0) {
    return function (p1) {
        return function (p2) {
            return function (p3) {
                return function (subdivisions) {
                    return arcLength({
                        p0: p0,
                        p1: p1,
                        p2: p2,
                        p3: p3
                    })(subdivisions);
                };
            };
        };
    };
};
var parameterAtArcLength = function (curve) {
    return function (targetDistance) {
        return function (totalLength) {
            return function (tolerance) {
                var total = (function () {
                    var $35 = totalLength > 0.0;
                    if ($35) {
                        return totalLength;
                    };
                    return arcLength(curve)(32);
                })();
                var $36 = total < tolerance;
                if ($36) {
                    return 0.0;
                };
                var $37 = targetDistance <= 0.0;
                if ($37) {
                    return 0.0;
                };
                var $38 = targetDistance >= total;
                if ($38) {
                    return 1.0;
                };
                var search = function ($copy_lo) {
                    return function ($copy_hi) {
                        return function ($copy_fuel) {
                            var $tco_var_lo = $copy_lo;
                            var $tco_var_hi = $copy_hi;
                            var $tco_done = false;
                            var $tco_result;
                            function $tco_loop(lo, hi, fuel) {
                                if (fuel <= 0) {
                                    $tco_done = true;
                                    return (lo + hi) / 2.0;
                                };
                                if (hi - lo < tolerance) {
                                    $tco_done = true;
                                    return (lo + hi) / 2.0;
                                };
                                if (Data_Boolean.otherwise) {
                                    var mid = (lo + hi) / 2.0;
                                    var v = split(curve)(mid);
                                    var leftLen = arcLength(v.value0)(16);
                                    var $43 = leftLen < targetDistance;
                                    if ($43) {
                                        $tco_var_lo = mid;
                                        $tco_var_hi = hi;
                                        $copy_fuel = fuel - 1 | 0;
                                        return;
                                    };
                                    $tco_var_lo = lo;
                                    $tco_var_hi = mid;
                                    $copy_fuel = fuel - 1 | 0;
                                    return;
                                };
                                throw new Error("Failed pattern match at Lattice.Services.ShapeOperations.Bezier (line 189, column 12 - line 198, column 50): " + [ lo.constructor.name, hi.constructor.name, fuel.constructor.name ]);
                            };
                            while (!$tco_done) {
                                $tco_result = $tco_loop($tco_var_lo, $tco_var_hi, $copy_fuel);
                            };
                            return $tco_result;
                        };
                    };
                };
                return search(0.0)(1.0)(50);
            };
        };
    };
};
export {
    mkCubicBezier,
    mkBoundingBox,
    evalPoint,
    cubicBezierPoint,
    evalDerivative,
    evalTangent,
    evalNormal,
    split,
    splitCubicBezier,
    arcLength,
    cubicBezierLength,
    parameterAtArcLength,
    boundingBox,
    flatten,
    curvature
};
//# sourceMappingURL=index.js.map
