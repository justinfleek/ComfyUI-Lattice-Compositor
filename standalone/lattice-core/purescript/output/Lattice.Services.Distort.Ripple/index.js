// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var unitDirection = function (dx) {
    return function (dy) {
        return function (dist) {
            if (dist < 1.0e-4) {
                return new Data_Tuple.Tuple(0.0, 0.0);
            };
            if (Data_Boolean.otherwise) {
                return new Data_Tuple.Tuple(dx / dist, dy / dist);
            };
            throw new Error("Failed pattern match at Lattice.Services.Distort.Ripple (line 123, column 1 - line 123, column 67): " + [ dx.constructor.name, dy.constructor.name, dist.constructor.name ]);
        };
    };
};
var smoothFalloff = function (dist) {
    return function (radius) {
        if (radius <= 0.0) {
            return 0.0;
        };
        if (Data_Boolean.otherwise) {
            var t = max(0.0)(min(1.0)(1.0 - dist / radius));
            return t * t * (3.0 - 2.0 * t);
        };
        throw new Error("Failed pattern match at Lattice.Services.Distort.Ripple (line 106, column 1 - line 106, column 44): " + [ dist.constructor.name, radius.constructor.name ]);
    };
};
var rippleWave = function (dist) {
    return function (wavelength) {
        return function (phase) {
            if (wavelength < 1.0e-4) {
                return 0.0;
            };
            if (Data_Boolean.otherwise) {
                return $$Math.sin((dist / wavelength) * 2.0 * $$Math.pi + phase);
            };
            throw new Error("Failed pattern match at Lattice.Services.Distort.Ripple (line 68, column 1 - line 68, column 51): " + [ dist.constructor.name, wavelength.constructor.name, phase.constructor.name ]);
        };
    };
};
var radialDisplace = function (x) {
    return function (y) {
        return function (nx) {
            return function (ny) {
                return function (displacement) {
                    return new Data_Tuple.Tuple(x - nx * displacement, y - ny * displacement);
                };
            };
        };
    };
};
var phaseToRadians = function (degrees) {
    return (degrees * $$Math.pi) / 180.0;
};
var linearFalloff = function (dist) {
    return function (radius) {
        if (radius <= 0.0) {
            return 0.0;
        };
        if (Data_Boolean.otherwise) {
            return max(0.0)(1.0 - dist / radius);
        };
        throw new Error("Failed pattern match at Lattice.Services.Distort.Ripple (line 96, column 1 - line 96, column 44): " + [ dist.constructor.name, radius.constructor.name ]);
    };
};
var decayFactor = function (dist) {
    return function (radius) {
        return function (decayExp) {
            if (radius <= 0.0) {
                return 0.0;
            };
            if (dist >= radius) {
                return 0.0;
            };
            if (Data_Boolean.otherwise) {
                return $$Math.pow(1.0 - dist / radius)(decayExp);
            };
            throw new Error("Failed pattern match at Lattice.Services.Distort.Ripple (line 85, column 1 - line 85, column 52): " + [ dist.constructor.name, radius.constructor.name, decayExp.constructor.name ]);
        };
    };
};
var calculateRipple = function (x) {
    return function (y) {
        return function (config) {
            return function (width) {
                return function (height) {
                    var centerYPixels = config.centerY * height;
                    var dy = y - centerYPixels;
                    var centerXPixels = config.centerX * width;
                    var dx = x - centerXPixels;
                    var dist = $$Math.sqrt(dx * dx + dy * dy);
                    var $26 = dist <= 0.0;
                    if ($26) {
                        return {
                            srcX: x,
                            srcY: y,
                            inEffect: false
                        };
                    };
                    var $27 = dist >= config.radius;
                    if ($27) {
                        return {
                            srcX: x,
                            srcY: y,
                            inEffect: false
                        };
                    };
                    var wave = rippleWave(dist)(config.wavelength)(config.phase);
                    var falloff = decayFactor(dist)(config.radius)(config.decay);
                    var displacement = wave * config.amplitude * falloff;
                    var v = unitDirection(dx)(dy)(dist);
                    var v1 = radialDisplace(x)(y)(v.value0)(v.value1)(displacement);
                    return {
                        srcX: v1.value0,
                        srcY: v1.value1,
                        inEffect: true
                    };
                };
            };
        };
    };
};
var combineRipples = function (x) {
    return function (y) {
        return function (configs) {
            return function (width) {
                return function (height) {
                    var accumDisplacement = function (v) {
                        return function (config) {
                            var result = calculateRipple(x)(y)(config)(width)(height);
                            if (result.inEffect) {
                                return new Data_Tuple.Tuple(v.value0 + (x - result.srcX), v.value1 + (y - result.srcY));
                            };
                            return new Data_Tuple.Tuple(v.value0, v.value1);
                        };
                    };
                    var v = Data_Array.foldl(accumDisplacement)(new Data_Tuple.Tuple(0.0, 0.0))(configs);
                    return new Data_Tuple.Tuple(x - v.value0, y - v.value1);
                };
            };
        };
    };
};
var animatedPhase = function (time) {
    return function (loops) {
        return time * Data_Int.toNumber(loops) * 2.0 * $$Math.pi;
    };
};
export {
    rippleWave,
    decayFactor,
    linearFalloff,
    smoothFalloff,
    unitDirection,
    radialDisplace,
    calculateRipple,
    combineRipples,
    phaseToRadians,
    animatedPhase
};
//# sourceMappingURL=index.js.map
