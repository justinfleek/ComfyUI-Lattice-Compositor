// Generated by purs version 0.15.15
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Identity from "../Data.Identity/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Effect_Aff from "../Effect.Aff/index.js";
import * as $$Math from "../Math/index.js";
import * as Test_Lattice_TestHelpers from "../Test.Lattice.TestHelpers/index.js";
import * as Test_Spec from "../Test.Spec/index.js";
import * as Test_Spec_Assertions from "../Test.Spec.Assertions/index.js";
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordInt);
var div = /* #__PURE__ */ Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_Foldable.foldableArray);
var map1 = /* #__PURE__ */ Data_Functor.map(Data_Maybe.functorMaybe);
var min1 = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var max1 = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var sum = /* #__PURE__ */ Data_Foldable.sum(Data_Foldable.foldableArray)(Data_Semiring.semiringNumber);
var append = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var describe = /* #__PURE__ */ Test_Spec.describe(Data_Identity.monadIdentity);
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit);
var discard1 = /* #__PURE__ */ discard(/* #__PURE__ */ Test_Spec.bindSpecT(Data_Identity.bindIdentity));
var it = /* #__PURE__ */ Test_Spec.it(Data_Identity.monadIdentity)(Test_Spec.exampleMUnit);
var fail = /* #__PURE__ */ Test_Spec_Assertions.fail(Effect_Aff.monadThrowAff);
var discard2 = /* #__PURE__ */ discard(Effect_Aff.bindAff);
var shouldEqual = /* #__PURE__ */ Test_Spec_Assertions.shouldEqual(Effect_Aff.monadThrowAff);
var shouldEqual1 = /* #__PURE__ */ shouldEqual(Data_Show.showInt)(Data_Eq.eqInt);
var for_ = /* #__PURE__ */ Data_Foldable.for_(Effect_Aff.applicativeAff)(Data_Foldable.foldableArray);
var shouldEqual2 = /* #__PURE__ */ shouldEqual(Data_Show.showNumber)(Data_Eq.eqNumber);
var pure = /* #__PURE__ */ Control_Applicative.pure(Effect_Aff.applicativeAff);
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showInt);
var takeN = function (n) {
    return function (arr) {
        return map(function (i) {
            return Data_Maybe.fromMaybe({
                time: 0.0,
                x: 0.0,
                y: 0.0
            })(Data_Array.index(arr)(i));
        })(Data_Array.range(0)(min(n - 1 | 0)(Data_Array.length(arr) - 1 | 0)));
    };
};
var smoothMotionMovingAverage = function (motion) {
    return function (windowSize) {
        var n = Data_Array.length(motion.samples);
        var half = div(windowSize)(2);
        var smoothSample = function (i) {
            return function (sample) {
                var lo = max(0)(i - half | 0);
                var hi = min(n - 1 | 0)(i + half | 0);
                var windowIndices = Data_Array.range(lo)(hi);
                var sumX = foldl(function (acc) {
                    return function (j) {
                        return acc + Data_Maybe.fromMaybe(0.0)(map1(function (v) {
                            return v.x;
                        })(Data_Array.index(motion.samples)(j)));
                    };
                })(0.0)(windowIndices);
                var sumY = foldl(function (acc) {
                    return function (j) {
                        return acc + Data_Maybe.fromMaybe(0.0)(map1(function (v) {
                            return v.y;
                        })(Data_Array.index(motion.samples)(j)));
                    };
                })(0.0)(windowIndices);
                var windowCount = Data_Array.length(windowIndices);
                return {
                    time: sample.time,
                    x: sumX / Data_Int.toNumber(windowCount),
                    y: sumY / Data_Int.toNumber(windowCount)
                };
            };
        };
        var smoothed = Data_Array.mapWithIndex(smoothSample)(motion.samples);
        return {
            pinId: motion.pinId,
            recordingSpeed: motion.recordingSpeed,
            samples: smoothed
        };
    };
};
var getMotionBounds = function (motion) {
    if (motion.samples.length === 0) {
        return {
            minX: 0.0,
            maxX: 0.0,
            minY: 0.0,
            maxY: 0.0,
            width: 0.0,
            height: 0.0
        };
    };
    var ys = map(function (v) {
        return v.y;
    })(motion.samples);
    var xs = map(function (v) {
        return v.x;
    })(motion.samples);
    var minY = foldl(min1)(1.0e99)(ys);
    var minX = foldl(min1)(1.0e99)(xs);
    var maxY = foldl(max1)(-1.0e99)(ys);
    var maxX = foldl(max1)(-1.0e99)(xs);
    return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY,
        width: maxX - minX,
        height: maxY - minY
    };
};
var dropN = function (n) {
    return function (arr) {
        var len = Data_Array.length(arr);
        var $53 = n >= len;
        if ($53) {
            return [  ];
        };
        return map(function (i) {
            return Data_Maybe.fromMaybe({
                time: 0.0,
                x: 0.0,
                y: 0.0
            })(Data_Array.index(arr)(i));
        })(Data_Array.range(n)(len - 1 | 0));
    };
};
var dist = function (x1) {
    return function (y1) {
        return function (x2) {
            return function (y2) {
                var dy = y2 - y1;
                var dx = x2 - x1;
                return $$Math.sqrt(dx * dx + dy * dy);
            };
        };
    };
};
var getMotionPathLength = function (motion) {
    var segments = Data_Array.zipWith(function (a) {
        return function (b) {
            return dist(a.x)(a.y)(b.x)(b.y);
        };
    })(motion.samples)(Data_Array.drop(1)(motion.samples));
    return sum(segments);
};
var getMotionAverageSpeed = function (motion) {
    var n = Data_Array.length(motion.samples);
    var $54 = n < 2;
    if ($54) {
        return 0.0;
    };
    var pathLength = getMotionPathLength(motion);
    var lastTime = Data_Maybe.fromMaybe(0.0)(map1(function (v) {
        return v.time;
    })(Data_Array.index(motion.samples)(n - 1 | 0)));
    var firstTime = Data_Maybe.fromMaybe(0.0)(map1(function (v) {
        return v.time;
    })(Data_Array.index(motion.samples)(0)));
    var durationSec = (lastTime - firstTime) / 1000.0;
    var $55 = durationSec <= 0.0;
    if ($55) {
        return 0.0;
    };
    return pathLength / durationSec;
};
var perpendicularDistance = function (point) {
    return function (lineStart) {
        return function (lineEnd) {
            var dy = lineEnd.y - lineStart.y;
            var dx = lineEnd.x - lineStart.x;
            var lineLenSq = dx * dx + dy * dy;
            var $56 = lineLenSq === 0.0;
            if ($56) {
                return dist(point.x)(point.y)(lineStart.x)(lineStart.y);
            };
            var t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLenSq;
            var projY = lineStart.y + t * dy;
            var projX = lineStart.x + t * dx;
            return dist(point.x)(point.y)(projX)(projY);
        };
    };
};
var simplifyDouglasPeucker = function (samples) {
    return function (tolerance) {
        var n = Data_Array.length(samples);
        var $57 = n <= 2;
        if ($57) {
            return samples;
        };
        var last = Data_Maybe.fromMaybe({
            time: 0.0,
            x: 0.0,
            y: 0.0
        })(Data_Array.index(samples)(n - 1 | 0));
        var first = Data_Maybe.fromMaybe({
            time: 0.0,
            x: 0.0,
            y: 0.0
        })(Data_Array.index(samples)(0));
        var findMax = foldl(function (acc) {
            return function (i) {
                var v = Data_Array.index(samples)(i);
                if (v instanceof Data_Maybe.Nothing) {
                    return acc;
                };
                if (v instanceof Data_Maybe.Just) {
                    var d = perpendicularDistance(v.value0)(first)(last);
                    var $59 = d > acc.maxDist;
                    if ($59) {
                        return {
                            maxDist: d,
                            maxIdx: i
                        };
                    };
                    return acc;
                };
                throw new Error("Failed pattern match at Test.Lattice.Services.MotionRecording (line 159, column 14 - line 165, column 31): " + [ v.constructor.name ]);
            };
        })({
            maxDist: 0.0,
            maxIdx: 0
        })(Data_Array.range(1)(n - 2 | 0));
        var $61 = findMax.maxDist > tolerance;
        if ($61) {
            var rightSlice = dropN(findMax.maxIdx)(samples);
            var rightSimplified = simplifyDouglasPeucker(rightSlice)(tolerance);
            var leftSlice = takeN(findMax.maxIdx + 1 | 0)(samples);
            var leftSimplified = simplifyDouglasPeucker(leftSlice)(tolerance);
            return append(leftSimplified)(Data_Array.drop(1)(rightSimplified));
        };
        return [ first, last ];
    };
};
var createLinearMotion = function (pinId) {
    return function (start) {
        return function (end) {
            return function (durationMs) {
                return function (sampleCount) {
                    var samples = map(function (i) {
                        var t = Data_Int.toNumber(i) / Data_Int.toNumber(sampleCount - 1 | 0);
                        return {
                            time: t * durationMs,
                            x: start.x + (end.x - start.x) * t,
                            y: start.y + (end.y - start.y) * t
                        };
                    })(Data_Array.range(0)(sampleCount - 1 | 0));
                    return {
                        pinId: pinId,
                        samples: samples,
                        recordingSpeed: 1.0
                    };
                };
            };
        };
    };
};
var movingAverageTests = /* #__PURE__ */ describe("smoothMotionMovingAverage")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("applies moving average correctly")(/* #__PURE__ */ (function () {
    var motion = {
        pinId: "pin1",
        samples: [ {
            time: 0.0,
            x: 0.0,
            y: 0.0
        }, {
            time: 100.0,
            x: 10.0,
            y: 10.0
        }, {
            time: 200.0,
            x: 20.0,
            y: 20.0
        }, {
            time: 300.0,
            x: 30.0,
            y: 30.0
        }, {
            time: 400.0,
            x: 40.0,
            y: 40.0
        } ],
        recordingSpeed: 1.0
    };
    var smoothed = smoothMotionMovingAverage(motion)(3);
    var v = Data_Array.index(smoothed.samples)(2);
    if (v instanceof Data_Maybe.Nothing) {
        return fail("Expected sample at index 2");
    };
    if (v instanceof Data_Maybe.Just) {
        return discard2(Test_Lattice_TestHelpers.assertCloseTo(1.0)(20.0)(v.value0.x))(function () {
            return Test_Lattice_TestHelpers.assertCloseTo(1.0)(20.0)(v.value0.y);
        });
    };
    throw new Error("Failed pattern match at Test.Lattice.Services.MotionRecording (line 224, column 7 - line 229, column 37): " + [ v.constructor.name ]);
})()))(function () {
    return discard1(it("preserves sample count after smoothing")((function () {
        var motion = createLinearMotion("pin1")({
            x: 0.0,
            y: 0.0
        })({
            x: 100.0,
            y: 100.0
        })(1000.0)(20);
        var smoothed = smoothMotionMovingAverage(motion)(5);
        return shouldEqual1(Data_Array.length(smoothed.samples))(Data_Array.length(motion.samples));
    })()))(function () {
        return it("preserves timestamps after smoothing")((function () {
            var motion = createLinearMotion("pin1")({
                x: 0.0,
                y: 0.0
            })({
                x: 100.0,
                y: 100.0
            })(1000.0)(10);
            var smoothed = smoothMotionMovingAverage(motion)(3);
            return for_(Data_Array.range(0)(Data_Array.length(motion.samples) - 1 | 0))(function (i) {
                var $64 = {
                    orig: Data_Array.index(motion.samples)(i),
                    sm: Data_Array.index(smoothed.samples)(i)
                };
                if ($64.orig instanceof Data_Maybe.Just && $64.sm instanceof Data_Maybe.Just) {
                    return shouldEqual2($64.sm.value0.time)($64.orig.value0.time);
                };
                return pure(Data_Unit.unit);
            });
        })());
    });
}));
var pathLengthTests = /* #__PURE__ */ describe("getMotionPathLength")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("calculates correct path length for straight horizontal line")(/* #__PURE__ */ (function () {
    var motion = createLinearMotion("pin1")({
        x: 0.0,
        y: 0.0
    })({
        x: 100.0,
        y: 0.0
    })(1000.0)(10);
    return Test_Lattice_TestHelpers.assertCloseTo(1.0)(100.0)(getMotionPathLength(motion));
})()))(function () {
    return discard1(it("calculates correct path length for diagonal (3-4-5)")((function () {
        var motion = createLinearMotion("pin1")({
            x: 0.0,
            y: 0.0
        })({
            x: 30.0,
            y: 40.0
        })(1000.0)(10);
        return Test_Lattice_TestHelpers.assertCloseTo(1.0)(50.0)(getMotionPathLength(motion));
    })()))(function () {
        return discard1(it("handles single sample")((function () {
            var motion = {
                pinId: "pin1",
                samples: [ {
                    time: 0.0,
                    x: 0.0,
                    y: 0.0
                } ],
                recordingSpeed: 1.0
            };
            return shouldEqual2(getMotionPathLength(motion))(0.0);
        })()))(function () {
            return it("handles empty motion")((function () {
                var motion = {
                    pinId: "pin1",
                    samples: [  ],
                    recordingSpeed: 1.0
                };
                return shouldEqual2(getMotionPathLength(motion))(0.0);
            })());
        });
    });
}));
var createCircularMotion = function (pinId) {
    return function (center) {
        return function (radius) {
            return function (durationMs) {
                return function (sampleCount) {
                    var samples = map(function (i) {
                        var t = Data_Int.toNumber(i) / Data_Int.toNumber(sampleCount - 1 | 0);
                        var angle = t * 2.0 * $$Math.pi;
                        return {
                            time: t * durationMs,
                            x: center.x + $$Math.cos(angle) * radius,
                            y: center.y + $$Math.sin(angle) * radius
                        };
                    })(Data_Array.range(0)(sampleCount - 1 | 0));
                    return {
                        pinId: pinId,
                        samples: samples,
                        recordingSpeed: 1.0
                    };
                };
            };
        };
    };
};
var douglasPeuckerTests = /* #__PURE__ */ describe("simplifyDouglasPeucker")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("reduces linear motion to 2 points")(/* #__PURE__ */ (function () {
    var motion = createLinearMotion("pin1")({
        x: 0.0,
        y: 0.0
    })({
        x: 100.0,
        y: 100.0
    })(1000.0)(50);
    var simplified = simplifyDouglasPeucker(motion.samples)(1.0);
    return shouldEqual1(Data_Array.length(simplified))(2);
})()))(function () {
    return discard1(it("preserves endpoints")((function () {
        var motion = createLinearMotion("pin1")({
            x: 0.0,
            y: 0.0
        })({
            x: 100.0,
            y: 100.0
        })(1000.0)(20);
        var simplified = simplifyDouglasPeucker(motion.samples)(5.0);
        var $69 = {
            first: Data_Array.index(simplified)(0),
            last: Data_Array.index(simplified)(Data_Array.length(simplified) - 1 | 0)
        };
        if ($69.first instanceof Data_Maybe.Just && $69.last instanceof Data_Maybe.Just) {
            return discard2(Test_Lattice_TestHelpers.assertCloseTo(1.0e-2)(0.0)($69.first.value0.x))(function () {
                return discard2(Test_Lattice_TestHelpers.assertCloseTo(1.0e-2)(0.0)($69.first.value0.y))(function () {
                    return discard2(Test_Lattice_TestHelpers.assertCloseTo(1.0e-2)(100.0)($69.last.value0.x))(function () {
                        return Test_Lattice_TestHelpers.assertCloseTo(1.0e-2)(100.0)($69.last.value0.y);
                    });
                });
            });
        };
        return fail("Expected at least 2 points");
    })()))(function () {
        return discard1(it("preserves sharp turns")((function () {
            var samples = [ {
                time: 0.0,
                x: 0.0,
                y: 0.0
            }, {
                time: 100.0,
                x: 25.0,
                y: 0.0
            }, {
                time: 200.0,
                x: 50.0,
                y: 0.0
            }, {
                time: 300.0,
                x: 50.0,
                y: 25.0
            }, {
                time: 400.0,
                x: 50.0,
                y: 50.0
            } ];
            var simplified = simplifyDouglasPeucker(samples)(1.0);
            var $74 = Data_Array.length(simplified) > 2;
            if ($74) {
                return pure(Data_Unit.unit);
            };
            return fail("Expected turn point to be preserved");
        })()))(function () {
            return discard1(it("handles 2 points unchanged")((function () {
                var samples = [ {
                    time: 0.0,
                    x: 0.0,
                    y: 0.0
                }, {
                    time: 100.0,
                    x: 100.0,
                    y: 100.0
                } ];
                var simplified = simplifyDouglasPeucker(samples)(5.0);
                return shouldEqual1(Data_Array.length(simplified))(2);
            })()))(function () {
                return discard1(it("circular motion keeps multiple points")((function () {
                    var motion = createCircularMotion("pin1")({
                        x: 50.0,
                        y: 50.0
                    })(30.0)(1000.0)(50);
                    var simplified = simplifyDouglasPeucker(motion.samples)(2.0);
                    var $75 = Data_Array.length(simplified) > 4;
                    if ($75) {
                        return pure(Data_Unit.unit);
                    };
                    return fail("Expected >4 points for circle, got " + show(Data_Array.length(simplified)));
                })()))(function () {
                    return it("higher tolerance produces fewer points")((function () {
                        var motion = createCircularMotion("pin1")({
                            x: 50.0,
                            y: 50.0
                        })(30.0)(1000.0)(50);
                        var lowTol = simplifyDouglasPeucker(motion.samples)(1.0);
                        var highTol = simplifyDouglasPeucker(motion.samples)(10.0);
                        var $76 = Data_Array.length(highTol) <= Data_Array.length(lowTol);
                        if ($76) {
                            return pure(Data_Unit.unit);
                        };
                        return fail("Expected high tolerance to produce fewer points: " + (show(Data_Array.length(highTol)) + (" vs " + show(Data_Array.length(lowTol)))));
                    })());
                });
            });
        });
    });
}));
var boundsTests = /* #__PURE__ */ describe("getMotionBounds")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("calculates correct bounds")(/* #__PURE__ */ (function () {
    var motion = {
        pinId: "pin1",
        samples: [ {
            time: 0.0,
            x: 10.0,
            y: 20.0
        }, {
            time: 100.0,
            x: 50.0,
            y: 60.0
        }, {
            time: 200.0,
            x: 30.0,
            y: 40.0
        } ],
        recordingSpeed: 1.0
    };
    var bounds = getMotionBounds(motion);
    return discard2(shouldEqual2(bounds.minX)(10.0))(function () {
        return discard2(shouldEqual2(bounds.maxX)(50.0))(function () {
            return discard2(shouldEqual2(bounds.minY)(20.0))(function () {
                return discard2(shouldEqual2(bounds.maxY)(60.0))(function () {
                    return discard2(shouldEqual2(bounds.width)(40.0))(function () {
                        return shouldEqual2(bounds.height)(40.0);
                    });
                });
            });
        });
    });
})()))(function () {
    return discard1(it("handles empty motion")((function () {
        var motion = {
            pinId: "pin1",
            samples: [  ],
            recordingSpeed: 1.0
        };
        var bounds = getMotionBounds(motion);
        return discard2(shouldEqual2(bounds.width)(0.0))(function () {
            return shouldEqual2(bounds.height)(0.0);
        });
    })()))(function () {
        return it("handles single point")((function () {
            var motion = {
                pinId: "pin1",
                samples: [ {
                    time: 0.0,
                    x: 50.0,
                    y: 75.0
                } ],
                recordingSpeed: 1.0
            };
            var bounds = getMotionBounds(motion);
            return discard2(shouldEqual2(bounds.minX)(50.0))(function () {
                return discard2(shouldEqual2(bounds.maxX)(50.0))(function () {
                    return discard2(shouldEqual2(bounds.width)(0.0))(function () {
                        return shouldEqual2(bounds.height)(0.0);
                    });
                });
            });
        })());
    });
}));
var averageSpeedTests = /* #__PURE__ */ describe("getMotionAverageSpeed")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("calculates correct average speed")(/* #__PURE__ */ (function () {
    var motion = createLinearMotion("pin1")({
        x: 0.0,
        y: 0.0
    })({
        x: 100.0,
        y: 0.0
    })(1000.0)(10);
    return Test_Lattice_TestHelpers.assertCloseTo(1.0)(100.0)(getMotionAverageSpeed(motion));
})()))(function () {
    return discard1(it("handles empty motion")((function () {
        var motion = {
            pinId: "pin1",
            samples: [  ],
            recordingSpeed: 1.0
        };
        return shouldEqual2(getMotionAverageSpeed(motion))(0.0);
    })()))(function () {
        return it("handles diagonal motion (3-4-5)")((function () {
            var motion = createLinearMotion("pin1")({
                x: 0.0,
                y: 0.0
            })({
                x: 30.0,
                y: 40.0
            })(1000.0)(10);
            return Test_Lattice_TestHelpers.assertCloseTo(1.0)(50.0)(getMotionAverageSpeed(motion));
        })());
    });
}));
var spec = /* #__PURE__ */ describe("MotionRecording")(/* #__PURE__ */ discard1(movingAverageTests)(function () {
    return discard1(pathLengthTests)(function () {
        return discard1(boundsTests)(function () {
            return discard1(averageSpeedTests)(function () {
                return douglasPeuckerTests;
            });
        });
    });
}));
export {
    spec
};
//# sourceMappingURL=index.js.map
