// Generated by purs version 0.15.15
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var vecLengthSq = function (x) {
    return function (y) {
        return x * x + y * y;
    };
};
var projectBoxOnAxis = function (cx) {
    return function (cy) {
        return function (hw) {
            return function (hh) {
                return function (angle) {
                    return function (axisX) {
                        return function (axisY) {
                            var sinA = $$Math.sin(angle);
                            var cosA = $$Math.cos(angle);
                            var corner4Y = (cy + hw * sinA) - hh * cosA;
                            var corner4X = cx + hw * cosA + hh * sinA;
                            var p4 = corner4X * axisX + corner4Y * axisY;
                            var corner3Y = cy - hw * sinA - hh * cosA;
                            var corner3X = (cx - hw * cosA) + hh * sinA;
                            var p3 = corner3X * axisX + corner3Y * axisY;
                            var corner2Y = (cy - hw * sinA) + hh * cosA;
                            var corner2X = cx - hw * cosA - hh * sinA;
                            var p2 = corner2X * axisX + corner2Y * axisY;
                            var corner1Y = cy + hw * sinA + hh * cosA;
                            var corner1X = (cx + hw * cosA) - hh * sinA;
                            var p1 = corner1X * axisX + corner1Y * axisY;
                            var maxP = $$Math.max($$Math.max(p1)(p2))($$Math.max(p3)(p4));
                            var minP = $$Math.min($$Math.min(p1)(p2))($$Math.min(p3)(p4));
                            return new Data_Tuple.Tuple(minP, maxP);
                        };
                    };
                };
            };
        };
    };
};
var circleVsCircle = function (x1) {
    return function (y1) {
        return function (r1) {
            return function (x2) {
                return function (y2) {
                    return function (r2) {
                        var minDist = r1 + r2;
                        var dy = y2 - y1;
                        var dx = x2 - x1;
                        var distSq = vecLengthSq(dx)(dy);
                        var $16 = distSq >= minDist * minDist;
                        if ($16) {
                            return Data_Maybe.Nothing.value;
                        };
                        var dist = $$Math.sqrt(distSq);
                        var v = (function () {
                            var $17 = dist > 1.0e-4;
                            if ($17) {
                                return new Data_Tuple.Tuple(dx / dist, dy / dist);
                            };
                            return new Data_Tuple.Tuple(1.0, 0.0);
                        })();
                        var depth = minDist - dist;
                        var contactY = y1 + v.value1 * r1;
                        var contactX = x1 + v.value0 * r1;
                        return new Data_Maybe.Just({
                            normalX: v.value0,
                            normalY: v.value1,
                            depth: depth,
                            contactX: contactX,
                            contactY: contactY
                        });
                    };
                };
            };
        };
    };
};
var circleVsBox = function (cx) {
    return function (cy) {
        return function (cr) {
            return function (bx) {
                return function (by) {
                    return function (bw) {
                        return function (bh) {
                            return function (boxAngle) {
                                var sinA = $$Math.sin(-boxAngle);
                                var dy = cy - by;
                                var dx = cx - bx;
                                var cosA = $$Math.cos(-boxAngle);
                                var localX = dx * cosA - dy * sinA;
                                var localY = dx * sinA + dy * cosA;
                                var closestY = $$Math.max(-bh)($$Math.min(bh)(localY));
                                var diffY = localY - closestY;
                                var closestX = $$Math.max(-bw)($$Math.min(bw)(localX));
                                var diffX = localX - closestX;
                                var distSq = vecLengthSq(diffX)(diffY);
                                var isInside = localX === closestX && localY === closestY;
                                if (isInside) {
                                    var dyEdge = bh - $$Math.abs(localY);
                                    var dxEdge = bw - $$Math.abs(localX);
                                    var v = (function () {
                                        var $22 = dxEdge < dyEdge;
                                        if ($22) {
                                            return {
                                                localNX: (function () {
                                                    var $23 = localX > 0.0;
                                                    if ($23) {
                                                        return 1.0;
                                                    };
                                                    return -1.0;
                                                })(),
                                                localNY: 0.0,
                                                dist: dxEdge
                                            };
                                        };
                                        return {
                                            localNX: 0.0,
                                            localNY: (function () {
                                                var $24 = localY > 0.0;
                                                if ($24) {
                                                    return 1.0;
                                                };
                                                return -1.0;
                                            })(),
                                            dist: dyEdge
                                        };
                                    })();
                                    var worldNY = v.localNX * $$Math.sin(boxAngle) + v.localNY * $$Math.cos(boxAngle);
                                    var worldNX = v.localNX * $$Math.cos(boxAngle) - v.localNY * $$Math.sin(boxAngle);
                                    var depth = cr + v.dist;
                                    var contactY = cy - worldNY * cr;
                                    var contactX = cx - worldNX * cr;
                                    return new Data_Maybe.Just({
                                        normalX: -worldNX,
                                        normalY: -worldNY,
                                        depth: depth,
                                        contactX: contactX,
                                        contactY: contactY
                                    });
                                };
                                var $29 = distSq < cr * cr;
                                if ($29) {
                                    var dist = $$Math.sqrt(distSq);
                                    var v = (function () {
                                        var $30 = dist > 1.0e-4;
                                        if ($30) {
                                            return new Data_Tuple.Tuple(diffX / dist, diffY / dist);
                                        };
                                        return new Data_Tuple.Tuple(1.0, 0.0);
                                    })();
                                    var worldNY = v.value0 * $$Math.sin(boxAngle) + v.value1 * $$Math.cos(boxAngle);
                                    var worldNX = v.value0 * $$Math.cos(boxAngle) - v.value1 * $$Math.sin(boxAngle);
                                    var depth = cr - dist;
                                    var contactY = cy - worldNY * cr;
                                    var contactX = cx - worldNX * cr;
                                    return new Data_Maybe.Just({
                                        normalX: worldNX,
                                        normalY: worldNY,
                                        depth: depth,
                                        contactX: contactX,
                                        contactY: contactY
                                    });
                                };
                                return Data_Maybe.Nothing.value;
                            };
                        };
                    };
                };
            };
        };
    };
};
var boxVsBox = function (x1) {
    return function (y1) {
        return function (w1) {
            return function (h1) {
                return function (x2) {
                    return function (y2) {
                        return function (w2) {
                            return function (h2) {
                                var dy = y2 - y1;
                                var overlapY = (h1 + h2) - $$Math.abs(dy);
                                var dx = x2 - x1;
                                var overlapX = (w1 + w2) - $$Math.abs(dx);
                                var $34 = overlapX <= 0.0 || overlapY <= 0.0;
                                if ($34) {
                                    return Data_Maybe.Nothing.value;
                                };
                                var v = (function () {
                                    var $35 = overlapX < overlapY;
                                    if ($35) {
                                        return {
                                            nx: (function () {
                                                var $36 = dx > 0.0;
                                                if ($36) {
                                                    return 1.0;
                                                };
                                                return -1.0;
                                            })(),
                                            ny: 0.0,
                                            depth: overlapX
                                        };
                                    };
                                    return {
                                        nx: 0.0,
                                        ny: (function () {
                                            var $37 = dy > 0.0;
                                            if ($37) {
                                                return 1.0;
                                            };
                                            return -1.0;
                                        })(),
                                        depth: overlapY
                                    };
                                })();
                                var contactY = y1 + v.ny * h1;
                                var contactX = x1 + v.nx * w1;
                                return new Data_Maybe.Just({
                                    normalX: v.nx,
                                    normalY: v.ny,
                                    depth: v.depth,
                                    contactX: contactX,
                                    contactY: contactY
                                });
                            };
                        };
                    };
                };
            };
        };
    };
};
export {
    circleVsCircle,
    circleVsBox,
    boxVsBox,
    projectBoxOnAxis
};
//# sourceMappingURL=index.js.map
