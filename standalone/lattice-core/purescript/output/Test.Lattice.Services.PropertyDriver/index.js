// Generated by purs version 0.15.15
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Identity from "../Data.Identity/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Effect_Aff from "../Effect.Aff/index.js";
import * as Test_Lattice_TestHelpers from "../Test.Lattice.TestHelpers/index.js";
import * as Test_Spec from "../Test.Spec/index.js";
import * as Test_Spec_Assertions from "../Test.Spec.Assertions/index.js";
var describe = /* #__PURE__ */ Test_Spec.describe(Data_Identity.monadIdentity);
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit);
var discard1 = /* #__PURE__ */ discard(/* #__PURE__ */ Test_Spec.bindSpecT(Data_Identity.bindIdentity));
var it = /* #__PURE__ */ Test_Spec.it(Data_Identity.monadIdentity)(Test_Spec.exampleMUnit);
var discard2 = /* #__PURE__ */ discard(Effect_Aff.bindAff);
var shouldEqual = /* #__PURE__ */ Test_Spec_Assertions.shouldEqual(Effect_Aff.monadThrowAff)(Data_Show.showNumber)(Data_Eq.eqNumber);
var applyRemap = function (value) {
    return function (inMin) {
        return function (inMax) {
            return function (outMin) {
                return function (outMax) {
                    var inRange = inMax - inMin;
                    var $16 = inRange === 0.0;
                    if ($16) {
                        return (outMin + outMax) / 2.0;
                    };
                    var normalized = (value - inMin) / inRange;
                    return outMin + normalized * (outMax - outMin);
                };
            };
        };
    };
};
var spec = /* #__PURE__ */ describe("PropertyDriver transforms")(/* #__PURE__ */ describe("remap transform")(/* #__PURE__ */ discard1(/* #__PURE__ */ it("remaps value from one range to another")(/* #__PURE__ */ discard2(/* #__PURE__ */ shouldEqual(/* #__PURE__ */ applyRemap(0.5)(0.0)(1.0)(0.0)(100.0))(50.0))(function () {
    return discard2(shouldEqual(applyRemap(0.0)(0.0)(1.0)(0.0)(100.0))(0.0))(function () {
        return shouldEqual(applyRemap(1.0)(0.0)(1.0)(0.0)(100.0))(100.0);
    });
})))(function () {
    return discard1(it("handles inverted output range")(shouldEqual(applyRemap(0.5)(0.0)(1.0)(100.0)(0.0))(50.0)))(function () {
        return discard1(it("handles values outside input range")(discard2(shouldEqual(applyRemap(-0.5)(0.0)(1.0)(0.0)(100.0))(-50.0))(function () {
            return shouldEqual(applyRemap(1.5)(0.0)(1.0)(0.0)(100.0))(150.0);
        })))(function () {
            return discard1(it("BUG #3 FIXED: inMin === inMax returns output midpoint instead of NaN")(discard2(shouldEqual(applyRemap(0.25)(0.5)(0.5)(0.0)(100.0))(50.0))(function () {
                return discard2(shouldEqual(applyRemap(0.5)(0.5)(0.5)(0.0)(100.0))(50.0))(function () {
                    return discard2(shouldEqual(applyRemap(0.75)(0.5)(0.5)(0.0)(100.0))(50.0))(function () {
                        return discard2(Test_Lattice_TestHelpers.assertFinite(applyRemap(0.25)(0.5)(0.5)(0.0)(100.0)))(function () {
                            return discard2(Test_Lattice_TestHelpers.assertFinite(applyRemap(0.5)(0.5)(0.5)(0.0)(100.0)))(function () {
                                return Test_Lattice_TestHelpers.assertFinite(applyRemap(0.75)(0.5)(0.5)(0.0)(100.0));
                            });
                        });
                    });
                });
            })))(function () {
                return it("BUG #3 FIXED: works with any zero-range input")(discard2(shouldEqual(applyRemap(0.0)(0.0)(0.0)(0.0)(100.0))(50.0))(function () {
                    return discard2(shouldEqual(applyRemap(100.0)(100.0)(100.0)(0.0)(200.0))(100.0))(function () {
                        return shouldEqual(applyRemap(5.0)(5.0)(5.0)(10.0)(30.0))(20.0);
                    });
                }));
            });
        });
    });
})));
export {
    spec
};
//# sourceMappingURL=index.js.map
