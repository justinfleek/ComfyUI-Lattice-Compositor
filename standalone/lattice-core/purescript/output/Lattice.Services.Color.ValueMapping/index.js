// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
import * as $$Math from "../Math/index.js";
var add = /* #__PURE__ */ Data_Semiring.add(Data_Semiring.semiringNumber);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var pixelDifference = function (r1) {
    return function (g1) {
        return function (b1) {
            return function (r2) {
                return function (g2) {
                    return function (b2) {
                        var dr = $$Math.abs(r1 - r2);
                        var dg = $$Math.abs(g1 - g2);
                        var db = $$Math.abs(b1 - b2);
                        return (dr + dg + db) / 3.0;
                    };
                };
            };
        };
    };
};
var mapToRange = function (value) {
    return function (minVal) {
        return function (maxVal) {
            return minVal + value * (maxVal - minVal);
        };
    };
};
var gradientMagnitude = function (dx) {
    return function (dy) {
        return $$Math.sqrt(dx * dx + dy * dy);
    };
};
var findMin = function (values) {
    return Data_Array.foldl($$Math.min)(1.0 / 0.0)(values);
};
var findMax = function (values) {
    return Data_Array.foldl($$Math.max)(-1.0 / 0.0)(values);
};
var defaultValueMappingConfig = {
    sensitivity: 1.0,
    smoothing: 0.0,
    min: 0.0,
    max: 1.0,
    invert: false
};
var defaultDepthMappingConfig = {
    nearPlane: 0.0,
    farPlane: 1.0,
    sensitivity: 1.0,
    smoothing: 0.0,
    min: 0.0,
    max: 1.0,
    invert: false
};
var clamp01 = function (x) {
    return $$Math.max(0.0)($$Math.min(1.0)(x));
};
var normalizeDepth = function (depthValue) {
    return function (nearPlane) {
        return function (farPlane) {
            var range = farPlane - nearPlane;
            var $9 = range <= 0.0;
            if ($9) {
                return depthValue;
            };
            return clamp01((depthValue - nearPlane) / range);
        };
    };
};
var calculateVariance = function (values) {
    var n = Data_Array.length(values);
    var $10 = n === 0;
    if ($10) {
        return 0.0;
    };
    var sum = Data_Array.foldl(add)(0.0)(values);
    var mean = sum / Data_Int.toNumber(n);
    var squaredDiffs = map(function (v) {
        return (v - mean) * (v - mean);
    })(values);
    var sumSquaredDiffs = Data_Array.foldl(add)(0.0)(squaredDiffs);
    return sumSquaredDiffs / Data_Int.toNumber(n);
};
var calculateStdDev = function (values) {
    return $$Math.sqrt(calculateVariance(values));
};
var calculateMean = function (values) {
    var n = Data_Array.length(values);
    var $11 = n === 0;
    if ($11) {
        return 0.0;
    };
    return Data_Array.foldl(add)(0.0)(values) / Data_Int.toNumber(n);
};
var calculateGradient = function (left) {
    return function (right) {
        return function (top) {
            return function (bottom) {
                var dy = bottom - top;
                var dx = right - left;
                return gradientMagnitude(dx)(dy);
            };
        };
    };
};
var applySmoothing = function (currentValue) {
    return function (previousValue) {
        return function (smoothing) {
            var $12 = smoothing <= 0.0;
            if ($12) {
                return currentValue;
            };
            return previousValue * smoothing + currentValue * (1.0 - smoothing);
        };
    };
};
var mapMotionValue = function (motionValue) {
    return function (sensitivity) {
        return function (minVal) {
            return function (maxVal) {
                return function (mPreviousValue) {
                    return function (smoothing) {
                        var scaled = clamp01(motionValue * sensitivity);
                        var mapped = mapToRange(scaled)(minVal)(maxVal);
                        if (mPreviousValue instanceof Data_Maybe.Nothing) {
                            return mapped;
                        };
                        if (mPreviousValue instanceof Data_Maybe.Just) {
                            return applySmoothing(mapped)(mPreviousValue.value0)(smoothing);
                        };
                        throw new Error("Failed pattern match at Lattice.Services.Color.ValueMapping (line 224, column 6 - line 226, column 57): " + [ mPreviousValue.constructor.name ]);
                    };
                };
            };
        };
    };
};
var applySensitivity = function (rawValue) {
    return function (sensitivity) {
        return clamp01(rawValue * sensitivity);
    };
};
var applyMotionThreshold = function (difference) {
    return function (threshold) {
        var $15 = difference > threshold;
        if ($15) {
            return difference;
        };
        return 0.0;
    };
};
var applyInversion = function (value) {
    return function (invert) {
        if (invert) {
            return 1.0 - value;
        };
        return value;
    };
};
var mapDepthValue = function (depthValue) {
    return function (config) {
        return function (mPreviousValue) {
            var normalized = normalizeDepth(depthValue)(config.nearPlane)(config.farPlane);
            var scaled = applySensitivity(normalized)(config.sensitivity);
            var inverted = applyInversion(scaled)(config.invert);
            var mapped = mapToRange(inverted)(config.min)(config.max);
            if (mPreviousValue instanceof Data_Maybe.Nothing) {
                return mapped;
            };
            if (mPreviousValue instanceof Data_Maybe.Just) {
                return applySmoothing(mapped)(mPreviousValue.value0)(config.smoothing);
            };
            throw new Error("Failed pattern match at Lattice.Services.Color.ValueMapping (line 187, column 6 - line 189, column 64): " + [ mPreviousValue.constructor.name ]);
        };
    };
};
var mapValue = function (rawValue) {
    return function (config) {
        return function (mPreviousValue) {
            var scaled = applySensitivity(rawValue)(config.sensitivity);
            var inverted = applyInversion(scaled)(config.invert);
            var mapped = mapToRange(inverted)(config.min)(config.max);
            if (mPreviousValue instanceof Data_Maybe.Nothing) {
                return mapped;
            };
            if (mPreviousValue instanceof Data_Maybe.Just) {
                return applySmoothing(mapped)(mPreviousValue.value0)(config.smoothing);
            };
            throw new Error("Failed pattern match at Lattice.Services.Color.ValueMapping (line 141, column 6 - line 143, column 64): " + [ mPreviousValue.constructor.name ]);
        };
    };
};
var mapValueSimple = function (rawValue) {
    return function (config) {
        return mapValue(rawValue)(config)(Data_Maybe.Nothing.value);
    };
};
export {
    defaultValueMappingConfig,
    defaultDepthMappingConfig,
    clamp01,
    applySensitivity,
    applyInversion,
    mapToRange,
    applySmoothing,
    mapValue,
    mapValueSimple,
    normalizeDepth,
    mapDepthValue,
    pixelDifference,
    applyMotionThreshold,
    mapMotionValue,
    gradientMagnitude,
    calculateGradient,
    calculateVariance,
    calculateStdDev,
    calculateMean,
    findMin,
    findMax
};
//# sourceMappingURL=index.js.map
