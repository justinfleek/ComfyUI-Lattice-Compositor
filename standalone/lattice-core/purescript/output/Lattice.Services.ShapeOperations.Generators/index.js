// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Lattice_Services_ShapeOperations_Point2D from "../Lattice.Services.ShapeOperations.Point2D/index.js";
import * as $$Math from "../Math/index.js";
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var Clockwise = /* #__PURE__ */ (function () {
    function Clockwise() {

    };
    Clockwise.value = new Clockwise();
    return Clockwise;
})();
var CounterClockwise = /* #__PURE__ */ (function () {
    function CounterClockwise() {

    };
    CounterClockwise.value = new CounterClockwise();
    return CounterClockwise;
})();
var smoothVertex = function (p) {
    return function (handleDir) {
        return function (handleLen) {
            var h = Lattice_Services_ShapeOperations_Point2D.scale(Lattice_Services_ShapeOperations_Point2D.normalize(handleDir))(handleLen);
            return {
                point: p,
                inHandle: Lattice_Services_ShapeOperations_Point2D.neg(h),
                outHandle: h
            };
        };
    };
};
var smoothPathFromPoints = function (points) {
    return function (closed) {
        return function (tension) {
            if (Data_Array.length(points) < 2) {
                return {
                    vertices: [  ],
                    closed: closed
                };
            };
            if (Data_Boolean.otherwise) {
                var safeGet = function (i) {
                    return Data_Maybe.fromMaybe(Lattice_Services_ShapeOperations_Point2D.origin)(Data_Array.index(points)(i));
                };
                var n = Data_Array.length(points);
                var mkVertex = function (i) {
                    var prev = safeGet(mod((i + n | 0) - 1 | 0)(n));
                    var next = safeGet(mod(i + 1 | 0)(n));
                    var tangent = Lattice_Services_ShapeOperations_Point2D.scale(Lattice_Services_ShapeOperations_Point2D.sub(next)(prev))(tension / 2.0);
                    var curr = safeGet(i);
                    var distNext = Lattice_Services_ShapeOperations_Point2D.distance(curr)(next);
                    var distPrev = Lattice_Services_ShapeOperations_Point2D.distance(curr)(prev);
                    var avgDist = (distPrev + distNext) / 2.0;
                    var handleIn = Lattice_Services_ShapeOperations_Point2D.scale(Lattice_Services_ShapeOperations_Point2D.neg(Lattice_Services_ShapeOperations_Point2D.normalize(tangent)))(avgDist * 0.25);
                    var handleOut = Lattice_Services_ShapeOperations_Point2D.scale(Lattice_Services_ShapeOperations_Point2D.normalize(tangent))(avgDist * 0.25);
                    return {
                        point: curr,
                        inHandle: handleIn,
                        outHandle: handleOut
                    };
                };
                var vertices = Data_Array.mapWithIndex(function (i) {
                    return function (v) {
                        return mkVertex(i);
                    };
                })(points);
                return {
                    vertices: vertices,
                    closed: closed
                };
            };
            throw new Error("Failed pattern match at Lattice.Services.ShapeOperations.Generators (line 297, column 1 - line 297, column 77): " + [ points.constructor.name, closed.constructor.name, tension.constructor.name ]);
        };
    };
};
var mkBezierVertex = function (point) {
    return function (inHandle) {
        return function (outHandle) {
            return {
                point: point,
                inHandle: inHandle,
                outHandle: outHandle
            };
        };
    };
};
var mkBezierPath = function (vertices) {
    return function (closed) {
        return {
            vertices: vertices,
            closed: closed
        };
    };
};
var kappa = 0.5522847498;
var generateEllipse = function (position) {
    return function (size) {
        return function (direction) {
            var swapHandles = function (v) {
                return {
                    point: v.point,
                    inHandle: v.outHandle,
                    outHandle: v.inHandle
                };
            };
            var ry = size.y / 2.0;
            var rx = size.x / 2.0;
            var ky = ry * kappa;
            var left = {
                point: {
                    x: position.x - rx,
                    y: position.y
                },
                inHandle: {
                    x: 0.0,
                    y: ky
                },
                outHandle: {
                    x: 0.0,
                    y: -ky
                }
            };
            var right = {
                point: {
                    x: position.x + rx,
                    y: position.y
                },
                inHandle: {
                    x: 0.0,
                    y: -ky
                },
                outHandle: {
                    x: 0.0,
                    y: ky
                }
            };
            var kx = rx * kappa;
            var top = {
                point: {
                    x: position.x,
                    y: position.y - ry
                },
                inHandle: {
                    x: -kx,
                    y: 0.0
                },
                outHandle: {
                    x: kx,
                    y: 0.0
                }
            };
            var bottom = {
                point: {
                    x: position.x,
                    y: position.y + ry
                },
                inHandle: {
                    x: kx,
                    y: 0.0
                },
                outHandle: {
                    x: -kx,
                    y: 0.0
                }
            };
            var vertices = (function () {
                if (direction instanceof Clockwise) {
                    return [ top, right, bottom, left ];
                };
                if (direction instanceof CounterClockwise) {
                    return map(swapHandles)([ top, left, bottom, right ]);
                };
                throw new Error("Failed pattern match at Lattice.Services.ShapeOperations.Generators (line 195, column 18 - line 197, column 71): " + [ direction.constructor.name ]);
            })();
            return {
                vertices: vertices,
                closed: true
            };
        };
    };
};
var eqWindingDirection = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Clockwise && y instanceof Clockwise) {
                return true;
            };
            if (x instanceof CounterClockwise && y instanceof CounterClockwise) {
                return true;
            };
            return false;
        };
    }
};
var degToRad = function (deg) {
    return (deg * $$Math.pi) / 180.0;
};
var cornerVertex = function (p) {
    return {
        point: p,
        inHandle: Lattice_Services_ShapeOperations_Point2D.origin,
        outHandle: Lattice_Services_ShapeOperations_Point2D.origin
    };
};
var generatePolygon = function (position) {
    return function (points) {
        return function (radius) {
            return function (roundness) {
                return function (rotation) {
                    return function (direction) {
                        var startAngle = degToRad(rotation - 90.0);
                        var numPoints = max(3)(points);
                        var dirMult = (function () {
                            if (direction instanceof Clockwise) {
                                return 1.0;
                            };
                            if (direction instanceof CounterClockwise) {
                                return -1.0;
                            };
                            throw new Error("Failed pattern match at Lattice.Services.ShapeOperations.Generators (line 212, column 17 - line 214, column 33): " + [ direction.constructor.name ]);
                        })();
                        var angleStep = ($$Math.pi * 2.0) / Data_Int.toNumber(numPoints);
                        var mkVertex = function (i) {
                            var idx = (function () {
                                if (direction instanceof Clockwise) {
                                    return i;
                                };
                                if (direction instanceof CounterClockwise) {
                                    return (numPoints - 1 | 0) - i | 0;
                                };
                                throw new Error("Failed pattern match at Lattice.Services.ShapeOperations.Generators (line 217, column 19 - line 219, column 52): " + [ direction.constructor.name ]);
                            })();
                            var angle = startAngle + angleStep * Data_Int.toNumber(idx) * dirMult;
                            var pt = {
                                x: position.x + $$Math.cos(angle) * radius,
                                y: position.y + $$Math.sin(angle) * radius
                            };
                            var $27 = roundness > 0.0;
                            if ($27) {
                                var tangentAngle = angle + ($$Math.pi / 2.0) * dirMult;
                                var tangent = {
                                    x: $$Math.cos(tangentAngle),
                                    y: $$Math.sin(tangentAngle)
                                };
                                var handleLength = radius * (roundness / 100.0) * 0.5;
                                return {
                                    point: pt,
                                    inHandle: Lattice_Services_ShapeOperations_Point2D.scale(tangent)(handleLength),
                                    outHandle: Lattice_Services_ShapeOperations_Point2D.scale(tangent)(-handleLength)
                                };
                            };
                            return cornerVertex(pt);
                        };
                        var vertices = map(mkVertex)(Data_Array.range(0)(numPoints - 1 | 0));
                        return {
                            vertices: vertices,
                            closed: true
                        };
                    };
                };
            };
        };
    };
};
var generateRectangle = function (position) {
    return function (size) {
        return function (roundness) {
            return function (direction) {
                var hw = size.x / 2.0;
                var hh = size.y / 2.0;
                var r = min(roundness)(min(hw)(hh));
                var tl = {
                    x: position.x - hw,
                    y: position.y - hh
                };
                var tr = {
                    x: position.x + hw,
                    y: position.y - hh
                };
                var br = {
                    x: position.x + hw,
                    y: position.y + hh
                };
                var bl = {
                    x: position.x - hw,
                    y: position.y + hh
                };
                var corners = (function () {
                    if (direction instanceof Clockwise) {
                        return [ tl, tr, br, bl ];
                    };
                    if (direction instanceof CounterClockwise) {
                        return [ tl, bl, br, tr ];
                    };
                    throw new Error("Failed pattern match at Lattice.Services.ShapeOperations.Generators (line 123, column 17 - line 125, column 45): " + [ direction.constructor.name ]);
                })();
                var $29 = r < 1.0e-2;
                if ($29) {
                    return {
                        vertices: map(cornerVertex)(corners),
                        closed: true
                    };
                };
                var k = kappa * r;
                var mkRoundedCorner = function (corner) {
                    return function (prevDir) {
                        return function (nextDir) {
                            var startPt = Lattice_Services_ShapeOperations_Point2D.add(corner)(Lattice_Services_ShapeOperations_Point2D.scale(Lattice_Services_ShapeOperations_Point2D.normalize(prevDir))(r));
                            var endPt = Lattice_Services_ShapeOperations_Point2D.add(corner)(Lattice_Services_ShapeOperations_Point2D.scale(Lattice_Services_ShapeOperations_Point2D.normalize(nextDir))(r));
                            return [ {
                                point: startPt,
                                inHandle: Lattice_Services_ShapeOperations_Point2D.scale(Lattice_Services_ShapeOperations_Point2D.normalize(prevDir))(-k),
                                outHandle: Lattice_Services_ShapeOperations_Point2D.origin
                            }, {
                                point: endPt,
                                inHandle: Lattice_Services_ShapeOperations_Point2D.origin,
                                outHandle: Lattice_Services_ShapeOperations_Point2D.scale(Lattice_Services_ShapeOperations_Point2D.normalize(nextDir))(-k)
                            } ];
                        };
                    };
                };
                var vertices = (function () {
                    if (direction instanceof Clockwise) {
                        return Data_Array.concat([ mkRoundedCorner(tl)({
                            x: 0.0,
                            y: 1.0
                        })({
                            x: 1.0,
                            y: 0.0
                        }), mkRoundedCorner(tr)({
                            x: -1.0,
                            y: 0.0
                        })({
                            x: 0.0,
                            y: 1.0
                        }), mkRoundedCorner(br)({
                            x: 0.0,
                            y: -1.0
                        })({
                            x: -1.0,
                            y: 0.0
                        }), mkRoundedCorner(bl)({
                            x: 1.0,
                            y: 0.0
                        })({
                            x: 0.0,
                            y: -1.0
                        }) ]);
                    };
                    if (direction instanceof CounterClockwise) {
                        return Data_Array.concat([ mkRoundedCorner(tl)({
                            x: 1.0,
                            y: 0.0
                        })({
                            x: 0.0,
                            y: 1.0
                        }), mkRoundedCorner(bl)({
                            x: 0.0,
                            y: -1.0
                        })({
                            x: 1.0,
                            y: 0.0
                        }), mkRoundedCorner(br)({
                            x: -1.0,
                            y: 0.0
                        })({
                            x: 0.0,
                            y: -1.0
                        }), mkRoundedCorner(tr)({
                            x: 0.0,
                            y: 1.0
                        })({
                            x: -1.0,
                            y: 0.0
                        }) ]);
                    };
                    throw new Error("Failed pattern match at Lattice.Services.ShapeOperations.Generators (line 145, column 23 - line 157, column 17): " + [ direction.constructor.name ]);
                })();
                return {
                    vertices: vertices,
                    closed: true
                };
            };
        };
    };
};
var generateStar = function (position) {
    return function (points) {
        return function (outerRadius) {
            return function (innerRadius) {
                return function (outerRoundness) {
                    return function (innerRoundness) {
                        return function (rotation) {
                            return function (direction) {
                                var startAngle = degToRad(rotation - 90.0);
                                var numPoints = max(3)(points);
                                var totalVertices = numPoints * 2 | 0;
                                var dirMult = (function () {
                                    if (direction instanceof Clockwise) {
                                        return 1.0;
                                    };
                                    if (direction instanceof CounterClockwise) {
                                        return -1.0;
                                    };
                                    throw new Error("Failed pattern match at Lattice.Services.ShapeOperations.Generators (line 255, column 17 - line 257, column 33): " + [ direction.constructor.name ]);
                                })();
                                var angleStep = $$Math.pi / Data_Int.toNumber(numPoints);
                                var mkVertex = function (i) {
                                    var idx = (function () {
                                        if (direction instanceof Clockwise) {
                                            return i;
                                        };
                                        if (direction instanceof CounterClockwise) {
                                            return (totalVertices - 1 | 0) - i | 0;
                                        };
                                        throw new Error("Failed pattern match at Lattice.Services.ShapeOperations.Generators (line 260, column 19 - line 262, column 56): " + [ direction.constructor.name ]);
                                    })();
                                    var isOuter = mod(idx)(2) === 0;
                                    var radius = (function () {
                                        if (isOuter) {
                                            return outerRadius;
                                        };
                                        return innerRadius;
                                    })();
                                    var roundness = (function () {
                                        if (isOuter) {
                                            return outerRoundness;
                                        };
                                        return innerRoundness;
                                    })();
                                    var angle = startAngle + angleStep * Data_Int.toNumber(idx) * dirMult;
                                    var pt = {
                                        x: position.x + $$Math.cos(angle) * radius,
                                        y: position.y + $$Math.sin(angle) * radius
                                    };
                                    var $35 = roundness > 0.0;
                                    if ($35) {
                                        var tangentAngle = angle + ($$Math.pi / 2.0) * dirMult;
                                        var tangent = {
                                            x: $$Math.cos(tangentAngle),
                                            y: $$Math.sin(tangentAngle)
                                        };
                                        var handleLength = radius * (roundness / 100.0) * 0.3;
                                        return {
                                            point: pt,
                                            inHandle: Lattice_Services_ShapeOperations_Point2D.scale(tangent)(handleLength),
                                            outHandle: Lattice_Services_ShapeOperations_Point2D.scale(tangent)(-handleLength)
                                        };
                                    };
                                    return cornerVertex(pt);
                                };
                                var vertices = map(mkVertex)(Data_Array.range(0)(totalVertices - 1 | 0));
                                return {
                                    vertices: vertices,
                                    closed: true
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
var pathFromPoints = function (points) {
    return function (closed) {
        return {
            vertices: map(cornerVertex)(points),
            closed: closed
        };
    };
};
var cloneVertex = function (v) {
    return {
        point: Lattice_Services_ShapeOperations_Point2D.clone(v.point),
        inHandle: Lattice_Services_ShapeOperations_Point2D.clone(v.inHandle),
        outHandle: Lattice_Services_ShapeOperations_Point2D.clone(v.outHandle)
    };
};
var clonePath = function (p) {
    return {
        vertices: map(cloneVertex)(p.vertices),
        closed: p.closed
    };
};
export {
    Clockwise,
    CounterClockwise,
    mkBezierVertex,
    mkBezierPath,
    kappa,
    cornerVertex,
    smoothVertex,
    cloneVertex,
    clonePath,
    generateRectangle,
    generateEllipse,
    generatePolygon,
    generateStar,
    pathFromPoints,
    smoothPathFromPoints,
    eqWindingDirection
};
//# sourceMappingURL=index.js.map
