// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as $$Math from "../Math/index.js";
var FalloffConstant = /* #__PURE__ */ (function () {
    function FalloffConstant() {

    };
    FalloffConstant.value = new FalloffConstant();
    return FalloffConstant;
})();
var FalloffLinear = /* #__PURE__ */ (function () {
    function FalloffLinear() {

    };
    FalloffLinear.value = new FalloffLinear();
    return FalloffLinear;
})();
var FalloffQuadratic = /* #__PURE__ */ (function () {
    function FalloffQuadratic() {

    };
    FalloffQuadratic.value = new FalloffQuadratic();
    return FalloffQuadratic;
})();
var windForce = function (direction) {
    return function (strength) {
        return function (deltaTime) {
            var radians = (direction * $$Math.pi) / 180.0;
            var windX = $$Math.cos(radians) * strength * 1.0e-3;
            var windY = $$Math.sin(radians) * strength * 1.0e-3;
            return {
                x: windX * deltaTime,
                y: windY * deltaTime
            };
        };
    };
};
var vecScale = function (v) {
    return function (s) {
        return {
            x: v.x * s,
            y: v.y * s
        };
    };
};
var vecAdd = function (a) {
    return function (b) {
        return {
            x: a.x + b.x,
            y: a.y + b.y
        };
    };
};
var vortexForce = function (px) {
    return function (py) {
        return function (vortex) {
            return function (deltaTime) {
                var dy = vortex.y - py;
                var dx = vortex.x - px;
                var dist = $$Math.sqrt(dx * dx + dy * dy);
                var $11 = dist >= vortex.radius || dist <= 1.0e-3;
                if ($11) {
                    return {
                        x: 0.0,
                        y: 0.0
                    };
                };
                var ny = dy / dist;
                var perpX = -ny;
                var nx = dx / dist;
                var influence = 1.0 - dist / vortex.radius;
                var inwardStrength = vortex.inwardPull * 1.0e-4 * influence;
                var inwardForce = {
                    x: nx * inwardStrength * deltaTime,
                    y: ny * inwardStrength * deltaTime
                };
                var tangentialStrength = vortex.strength * 1.0e-4 * influence;
                var tangentForce = {
                    x: perpX * tangentialStrength * deltaTime,
                    y: nx * tangentialStrength * deltaTime
                };
                return vecAdd(tangentForce)(inwardForce);
            };
        };
    };
};
var normalize = function (dx) {
    return function (dy) {
        var mag = $$Math.sqrt(dx * dx + dy * dy);
        var $12 = mag > 1.0e-4;
        if ($12) {
            return {
                x: dx / mag,
                y: dy / mag
            };
        };
        return {
            x: 0.0,
            y: 0.0
        };
    };
};
var lorenzForce = function (px) {
    return function (py) {
        return function (attractor) {
            return function (deltaTime) {
                var dy = py - attractor.y;
                var dx = px - attractor.x;
                var dist = $$Math.sqrt(dx * dx + dy * dy);
                var $13 = dist >= attractor.radius || dist <= 1.0e-3;
                if ($13) {
                    return {
                        x: 0.0,
                        y: 0.0
                    };
                };
                var pseudoZ = dist * 0.1;
                var ldy = dx * (attractor.rho - pseudoZ) - dy;
                var ldx = attractor.sigma * (dy - dx);
                var influence = 1.0 - dist / attractor.radius;
                var forceStrength = attractor.strength * 1.0e-3 * influence;
                return {
                    x: ldx * forceStrength * deltaTime,
                    y: ldy * forceStrength * deltaTime
                };
            };
        };
    };
};
var gravityForce = function (gravity) {
    return function (deltaTime) {
        return {
            x: 0.0,
            y: gravity * 1.0e-3 * deltaTime
        };
    };
};
var eqFalloffType = {
    eq: function (x) {
        return function (y) {
            if (x instanceof FalloffConstant && y instanceof FalloffConstant) {
                return true;
            };
            if (x instanceof FalloffLinear && y instanceof FalloffLinear) {
                return true;
            };
            if (x instanceof FalloffQuadratic && y instanceof FalloffQuadratic) {
                return true;
            };
            return false;
        };
    }
};
var distance = function (x1) {
    return function (y1) {
        return function (x2) {
            return function (y2) {
                var dy = y2 - y1;
                var dx = x2 - x1;
                return $$Math.sqrt(dx * dx + dy * dy);
            };
        };
    };
};
var applyVortices = function (px) {
    return function (py) {
        return function (vortices) {
            return function (deltaTime) {
                return Data_Array.foldl(function (acc) {
                    return function (v) {
                        return vecAdd(acc)(vortexForce(px)(py)(v)(deltaTime));
                    };
                })({
                    x: 0.0,
                    y: 0.0
                })(vortices);
            };
        };
    };
};
var applyLorenzAttractors = function (px) {
    return function (py) {
        return function (attractors) {
            return function (deltaTime) {
                return Data_Array.foldl(function (acc) {
                    return function (a) {
                        return vecAdd(acc)(lorenzForce(px)(py)(a)(deltaTime));
                    };
                })({
                    x: 0.0,
                    y: 0.0
                })(attractors);
            };
        };
    };
};
var applyFriction = function (vxIn) {
    return function (vyIn) {
        return function (friction) {
            var factor = 1.0 - $$Math.max(0.0)($$Math.min(1.0)(friction));
            return {
                x: vxIn * factor,
                y: vyIn * factor
            };
        };
    };
};
var applyFalloff = function (distRatio) {
    return function (falloff) {
        if (falloff instanceof FalloffConstant) {
            return 1.0;
        };
        if (falloff instanceof FalloffLinear) {
            return 1.0 - distRatio;
        };
        if (falloff instanceof FalloffQuadratic) {
            return (1.0 - distRatio) * (1.0 - distRatio);
        };
        throw new Error("Failed pattern match at Lattice.Services.Particles.Forces (line 122, column 34 - line 125, column 60): " + [ falloff.constructor.name ]);
    };
};
var gravityWellForce = function (px) {
    return function (py) {
        return function (well) {
            return function (deltaTime) {
                var dy = well.y - py;
                var dx = well.x - px;
                var dist = $$Math.sqrt(dx * dx + dy * dy);
                var $17 = dist >= well.radius || dist <= 1.0e-3;
                if ($17) {
                    return {
                        x: 0.0,
                        y: 0.0
                    };
                };
                var ny = dy / dist;
                var nx = dx / dist;
                var distRatio = dist / well.radius;
                var falloffFactor = applyFalloff(distRatio)(well.falloff);
                var force = well.strength * 1.0e-4 * falloffFactor;
                return {
                    x: nx * force * deltaTime,
                    y: ny * force * deltaTime
                };
            };
        };
    };
};
var applyGravityWells = function (px) {
    return function (py) {
        return function (wells) {
            return function (deltaTime) {
                return Data_Array.foldl(function (acc) {
                    return function (w) {
                        return vecAdd(acc)(gravityWellForce(px)(py)(w)(deltaTime));
                    };
                })({
                    x: 0.0,
                    y: 0.0
                })(wells);
            };
        };
    };
};
export {
    FalloffConstant,
    FalloffLinear,
    FalloffQuadratic,
    distance,
    normalize,
    vecAdd,
    vecScale,
    applyFalloff,
    gravityWellForce,
    vortexForce,
    lorenzForce,
    windForce,
    gravityForce,
    applyFriction,
    applyGravityWells,
    applyVortices,
    applyLorenzAttractors,
    eqFalloffType
};
//# sourceMappingURL=index.js.map
