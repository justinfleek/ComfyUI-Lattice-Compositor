// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as $$Math from "../Math/index.js";
var append = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var elem = /* #__PURE__ */ Data_Array.elem(Data_Eq.eqInt);
var Triangle = function (x) {
    return x;
};
var Point2D = function (x) {
    return x;
};
var Edge = function (x) {
    return x;
};
var triangleCount = Data_Array.length;
var triC = function (v) {
    return v.c;
};
var triB = function (v) {
    return v.b;
};
var triA = function (v) {
    return v.a;
};
var p2dY = function (v) {
    return v.y;
};
var p2dX = function (v) {
    return v.x;
};
var mkTriangle = function (a) {
    return function (b) {
        return function (c) {
            return {
                a: a,
                b: b,
                c: c
            };
        };
    };
};
var mkPoint2D = function (x) {
    return function (y) {
        return {
            x: x,
            y: y
        };
    };
};
var sub = function (a) {
    return function (b) {
        return mkPoint2D(p2dX(a) - p2dX(b))(p2dY(a) - p2dY(b));
    };
};
var mkEdge = function (a) {
    return function (b) {
        return {
            a: a,
            b: b
        };
    };
};
var triangleEdges = function (tri) {
    return [ mkEdge(triA(tri))(triB(tri)), mkEdge(triB(tri))(triC(tri)), mkEdge(triC(tri))(triA(tri)) ];
};
var isPointInCircumcircle = function (point) {
    return function (a) {
        return function (b) {
            return function (c) {
                var orientation = (p2dX(b) - p2dX(a)) * (p2dY(c) - p2dY(a)) - (p2dY(b) - p2dY(a)) * (p2dX(c) - p2dX(a));
                var cy = p2dY(c) - p2dY(point);
                var cx = p2dX(c) - p2dX(point);
                var by = p2dY(b) - p2dY(point);
                var bx = p2dX(b) - p2dX(point);
                var ay = p2dY(a) - p2dY(point);
                var ax = p2dX(a) - p2dX(point);
                var det = ((ax * ax + ay * ay) * (bx * cy - cx * by) - (bx * bx + by * by) * (ax * cy - cx * ay)) + (cx * cx + cy * cy) * (ax * by - bx * ay);
                var $46 = orientation > 0.0;
                if ($46) {
                    return det > 0.0;
                };
                return det < 0.0;
            };
        };
    };
};
var flattenTriangles = /* #__PURE__ */ Data_Array.foldl(function (acc) {
    return function (tri) {
        return append(acc)([ triA(tri), triB(tri), triC(tri) ]);
    };
})([  ]);
var findBadTriangles = function (point) {
    return function (triangles) {
        return function (allPoints) {
            var isBad = function (tri) {
                var pc = Data_Maybe.fromMaybe(mkPoint2D(0.0)(0.0))(Data_Array.index(allPoints)(triC(tri)));
                var pb = Data_Maybe.fromMaybe(mkPoint2D(0.0)(0.0))(Data_Array.index(allPoints)(triB(tri)));
                var pa = Data_Maybe.fromMaybe(mkPoint2D(0.0)(0.0))(Data_Array.index(allPoints)(triA(tri)));
                return isPointInCircumcircle(point)(pa)(pb)(pc);
            };
            return Data_Array.filter(isBad)(triangles);
        };
    };
};
var eqTriangle = {
    eq: function (x) {
        return function (y) {
            return x.a === y.a && x.b === y.b && x.c === y.c;
        };
    }
};
var elem1 = /* #__PURE__ */ Data_Array.elem(eqTriangle);
var eqPoint2D = {
    eq: function (x) {
        return function (y) {
            return x.x === y.x && x.y === y.y;
        };
    }
};
var eqEdge = {
    eq: function (x) {
        return function (y) {
            return x.a === y.a && x.b === y.b;
        };
    }
};
var edgeB = function (v) {
    return v.b;
};
var edgeA = function (v) {
    return v.a;
};
var edgeEquals = function (e1) {
    return function (e2) {
        return edgeA(e1) === edgeA(e2) && edgeB(e1) === edgeB(e2) || edgeA(e1) === edgeB(e2) && edgeB(e1) === edgeA(e2);
    };
};
var findPolygonBoundary = function (badTriangles) {
    var allEdges = Data_Array.foldl(function (acc) {
        return function (tri) {
            return append(acc)(triangleEdges(tri));
        };
    })([  ])(badTriangles);
    var countEdge = function (edge) {
        return Data_Array.foldl(function (acc) {
            return function (e) {
                var $55 = edgeEquals(edge)(e);
                if ($55) {
                    return acc + 1 | 0;
                };
                return acc;
            };
        })(0)(allEdges);
    };
    return Data_Array.filter(function (edge) {
        return countEdge(edge) === 1;
    })(allEdges);
};
var distance = function (a) {
    return function (b) {
        var dy = p2dY(b) - p2dY(a);
        var dx = p2dX(b) - p2dX(a);
        return $$Math.sqrt(dx * dx + dy * dy);
    };
};
var delaunayTriangulateAux = function ($copy_points) {
    return function ($copy_fuel) {
        return function ($copy_triangles) {
            return function ($copy_allPoints) {
                return function ($copy_currentIdx) {
                    var $tco_var_points = $copy_points;
                    var $tco_var_fuel = $copy_fuel;
                    var $tco_var_triangles = $copy_triangles;
                    var $tco_var_allPoints = $copy_allPoints;
                    var $tco_done = false;
                    var $tco_result;
                    function $tco_loop(points, fuel, triangles, allPoints, currentIdx) {
                        if (fuel === 0 || currentIdx >= Data_Array.length(points)) {
                            $tco_done = true;
                            return triangles;
                        };
                        if (Data_Boolean.otherwise) {
                            var point = Data_Maybe.fromMaybe(mkPoint2D(0.0)(0.0))(Data_Array.index(points)(currentIdx));
                            var badTriangles = findBadTriangles(point)(triangles)(allPoints);
                            var polygon = findPolygonBoundary(badTriangles);
                            var newTriangles = map(function (edge) {
                                return mkTriangle(edgeA(edge))(edgeB(edge))(currentIdx);
                            })(polygon);
                            var triangles$prime = Data_Array.filter(function (t) {
                                return !elem1(t)(badTriangles);
                            })(triangles);
                            $tco_var_points = points;
                            $tco_var_fuel = fuel - 1 | 0;
                            $tco_var_triangles = append(triangles$prime)(newTriangles);
                            $tco_var_allPoints = allPoints;
                            $copy_currentIdx = currentIdx + 1 | 0;
                            return;
                        };
                        throw new Error("Failed pattern match at Lattice.Services.Mesh.Delaunay (line 212, column 1 - line 213, column 48): " + [ points.constructor.name, fuel.constructor.name, triangles.constructor.name, allPoints.constructor.name, currentIdx.constructor.name ]);
                    };
                    while (!$tco_done) {
                        $tco_result = $tco_loop($tco_var_points, $tco_var_fuel, $tco_var_triangles, $tco_var_allPoints, $copy_currentIdx);
                    };
                    return $tco_result;
                };
            };
        };
    };
};
var createSuperTriangle = function (points) {
    if (Data_Array.length(points) === 0) {
        return {
            a: mkPoint2D(0.0)(0.0),
            b: mkPoint2D(1.0)(0.0),
            c: mkPoint2D(0.5)(1.0)
        };
    };
    if (Data_Boolean.otherwise) {
        var negInf = -1.0e308;
        var maxY = Data_Array.foldl(function (acc) {
            return function (p) {
                return max(acc)(p2dY(p));
            };
        })(negInf)(points);
        var maxX = Data_Array.foldl(function (acc) {
            return function (p) {
                return max(acc)(p2dX(p));
            };
        })(negInf)(points);
        var minX = Data_Array.foldl(function (acc) {
            return function (p) {
                return min(acc)(p2dX(p));
            };
        })(1.0e308)(points);
        var minY = Data_Array.foldl(function (acc) {
            return function (p) {
                return min(acc)(p2dY(p));
            };
        })(1.0e308)(points);
        var dy = maxY - minY;
        var dx = maxX - minX;
        var deltaMax = max(dx)(dy) * 2.0;
        var superA = mkPoint2D(minX - deltaMax)(minY - deltaMax);
        var superB = mkPoint2D(minX + deltaMax * 2.0)(minY - deltaMax);
        var superC = mkPoint2D(minX + deltaMax / 2.0)(maxY + deltaMax * 2.0);
        return {
            a: superA,
            b: superB,
            c: superC
        };
    };
    throw new Error("Failed pattern match at Lattice.Services.Mesh.Delaunay (line 152, column 1 - line 152, column 85): " + [ points.constructor.name ]);
};
var delaunayTriangulate = function (points) {
    if (Data_Array.length(points) < 3) {
        return [  ];
    };
    if (Data_Boolean.otherwise) {
        var $$super = createSuperTriangle(points);
        var n = Data_Array.length(points);
        var superIndices = [ n, n + 1 | 0, n + 2 | 0 ];
        var isSuperVertex = function (v) {
            return elem(v)(superIndices);
        };
        var initialTriangles = [ mkTriangle(n)(n + 1 | 0)(n + 2 | 0) ];
        var allPoints = append(points)([ $$super.a, $$super.b, $$super.c ]);
        var triangles = delaunayTriangulateAux(points)(n)(initialTriangles)(allPoints)(0);
        return Data_Array.filter(function (t) {
            return !(isSuperVertex(triA(t)) || (isSuperVertex(triB(t)) || isSuperVertex(triC(t))));
        })(triangles);
    };
    throw new Error("Failed pattern match at Lattice.Services.Mesh.Delaunay (line 238, column 1 - line 238, column 55): " + [ points.constructor.name ]);
};
export {
    mkPoint2D,
    p2dX,
    p2dY,
    mkTriangle,
    triA,
    triB,
    triC,
    mkEdge,
    edgeA,
    edgeB,
    distance,
    sub,
    isPointInCircumcircle,
    createSuperTriangle,
    delaunayTriangulate,
    flattenTriangles,
    triangleCount,
    eqPoint2D,
    eqTriangle,
    eqEdge
};
//# sourceMappingURL=index.js.map
