// Generated by purs version 0.15.15
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
import * as Lattice_Services_Path_BezierCore from "../Lattice.Services.Path.BezierCore/index.js";
import * as $$Math from "../Math/index.js";
var bind = /* #__PURE__ */ Control_Bind.bind(Data_Maybe.bindMaybe);
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var append = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var pure = /* #__PURE__ */ Control_Applicative.pure(Data_Maybe.applicativeMaybe);
var map = /* #__PURE__ */ Data_Functor.map(Data_Maybe.functorMaybe);
var add1 = /* #__PURE__ */ Data_Semiring.add(Data_Semiring.semiringNumber);
var map1 = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var SubdivideShorter = /* #__PURE__ */ (function () {
    function SubdivideShorter() {

    };
    SubdivideShorter.value = new SubdivideShorter();
    return SubdivideShorter;
})();
var SubdivideBoth = /* #__PURE__ */ (function () {
    function SubdivideBoth() {

    };
    SubdivideBoth.value = new SubdivideBoth();
    return SubdivideBoth;
})();
var Resample = /* #__PURE__ */ (function () {
    function Resample() {

    };
    Resample.value = new Resample();
    return Resample;
})();
var IndexCorrespondence = /* #__PURE__ */ (function () {
    function IndexCorrespondence() {

    };
    IndexCorrespondence.value = new IndexCorrespondence();
    return IndexCorrespondence;
})();
var NearestRotation = /* #__PURE__ */ (function () {
    function NearestRotation() {

    };
    NearestRotation.value = new NearestRotation();
    return NearestRotation;
})();
var NearestDistance = /* #__PURE__ */ (function () {
    function NearestDistance() {

    };
    NearestDistance.value = new NearestDistance();
    return NearestDistance;
})();
var ManualCorrespondence = /* #__PURE__ */ (function () {
    function ManualCorrespondence() {

    };
    ManualCorrespondence.value = new ManualCorrespondence();
    return ManualCorrespondence;
})();
var subdivideSegmentAt = function (path) {
    return function (segmentIndex) {
        return function (t) {
            var n = Data_Array.length(path.vertices);
            var $35 = Data_Array.length(path.vertices) === 0 || segmentIndex >= n;
            if ($35) {
                return path;
            };
            return Data_Maybe.fromMaybe(path)(bind(Data_Array.index(path.vertices)(segmentIndex))(function (v0) {
                var nextIdx = mod(segmentIndex + 1 | 0)(n);
                return bind(Data_Array.index(path.vertices)(nextIdx))(function (v1) {
                    var p2 = Lattice_Services_Path_BezierCore.inHandleAbsolute(v1);
                    var p1 = Lattice_Services_Path_BezierCore.outHandleAbsolute(v0);
                    var result = Lattice_Services_Path_BezierCore.splitCubicBezier(v0.point)(p1)(p2)(v1.point)(t);
                    var v0$prime = {
                        inHandle: v0.inHandle,
                        point: v0.point,
                        outHandle: Lattice_Services_Path_BezierCore.subPoints(result.left.p1)(result.left.p0)
                    };
                    var v1$prime = {
                        outHandle: v1.outHandle,
                        point: v1.point,
                        inHandle: Lattice_Services_Path_BezierCore.subPoints(result.right.p2)(result.right.p3)
                    };
                    var newVertex = {
                        point: Lattice_Services_Path_BezierCore.clonePoint(result.left.p3),
                        inHandle: Lattice_Services_Path_BezierCore.subPoints(result.left.p2)(result.left.p3),
                        outHandle: Lattice_Services_Path_BezierCore.subPoints(result.right.p1)(result.right.p0)
                    };
                    var before = Data_Array.take(segmentIndex)(path.vertices);
                    var after = Data_Array.drop(nextIdx + 1 | 0)(path.vertices);
                    var newVertices = append(before)(append([ v0$prime, newVertex, v1$prime ])(after));
                    return pure({
                        vertices: newVertices,
                        closed: path.closed
                    });
                });
            }));
        };
    };
};
var rotateVertices = function (path) {
    return function (offset) {
        return function (reverse) {
            if (Data_Array.length(path.vertices) === 0) {
                return path;
            };
            if (Data_Boolean.otherwise) {
                var n = Data_Array.length(path.vertices);
                var mapWithIndex = function (f) {
                    return function (arr) {
                        var go = function ($copy_i) {
                            return function ($copy_acc) {
                                var $tco_var_i = $copy_i;
                                var $tco_done = false;
                                var $tco_result;
                                function $tco_loop(i, acc) {
                                    if (i >= Data_Array.length(arr)) {
                                        $tco_done = true;
                                        return acc;
                                    };
                                    if (Data_Boolean.otherwise) {
                                        $tco_var_i = i + 1 | 0;
                                        $copy_acc = Data_Array.snoc(acc)(f(i));
                                        return;
                                    };
                                    throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 151, column 9 - line 153, column 52): " + [ i.constructor.name, acc.constructor.name ]);
                                };
                                while (!$tco_done) {
                                    $tco_result = $tco_loop($tco_var_i, $copy_acc);
                                };
                                return $tco_result;
                            };
                        };
                        return go(0)([  ]);
                    };
                };
                var defaultVertex = {
                    point: Lattice_Services_Path_BezierCore.zeroPoint,
                    inHandle: Lattice_Services_Path_BezierCore.zeroPoint,
                    outHandle: Lattice_Services_Path_BezierCore.zeroPoint
                };
                var makeVertex = function (i) {
                    var srcIdx = (function () {
                        if (reverse) {
                            return mod((((n - 1 | 0) - i | 0) + offset | 0) + n | 0)(n);
                        };
                        return mod(i + offset | 0)(n);
                    })();
                    var srcVertex = Data_Maybe.fromMaybe(defaultVertex)(Data_Array.index(path.vertices)(srcIdx));
                    if (reverse) {
                        return {
                            point: Lattice_Services_Path_BezierCore.clonePoint(srcVertex.point),
                            inHandle: Lattice_Services_Path_BezierCore.clonePoint(srcVertex.outHandle),
                            outHandle: Lattice_Services_Path_BezierCore.clonePoint(srcVertex.inHandle)
                        };
                    };
                    return Lattice_Services_Path_BezierCore.cloneVertex(srcVertex);
                };
                return {
                    vertices: mapWithIndex(makeVertex)(path.vertices),
                    closed: path.closed
                };
            };
            throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 140, column 1 - line 140, column 61): " + [ path.constructor.name, offset.constructor.name, reverse.constructor.name ]);
        };
    };
};
var getPointAtArcLength = function (path) {
    return function (targetLength) {
        return function (segmentLengths) {
            if (Data_Array.length(segmentLengths) === 0 || Data_Array.length(path.vertices) === 0) {
                return Lattice_Services_Path_BezierCore.zeroPoint;
            };
            if (Data_Boolean.otherwise) {
                var go = function ($copy_i) {
                    return function ($copy_accumulated) {
                        var $tco_var_i = $copy_i;
                        var $tco_done = false;
                        var $tco_result;
                        function $tco_loop(i, accumulated) {
                            if (i >= Data_Array.length(segmentLengths)) {
                                $tco_done = true;
                                return Data_Maybe.fromMaybe(Lattice_Services_Path_BezierCore.zeroPoint)(map(function (v) {
                                    return v.point;
                                })(Data_Array.index(path.vertices)(Data_Array.length(path.vertices) - 1 | 0)));
                            };
                            if (Data_Boolean.otherwise) {
                                var segLen = Data_Maybe.fromMaybe(0.0)(Data_Array.index(segmentLengths)(i));
                                var $48 = accumulated + segLen >= targetLength || i === (Data_Array.length(segmentLengths) - 1 | 0);
                                if ($48) {
                                    var localT = (function () {
                                        var $49 = segLen > 0.0;
                                        if ($49) {
                                            return (targetLength - accumulated) / segLen;
                                        };
                                        return 0.0;
                                    })();
                                    var clampedT = $$Math.max(0.0)($$Math.min(1.0)(localT));
                                    var v = Lattice_Services_Path_BezierCore.getSegmentControlPoints(path)(i);
                                    if (v instanceof Data_Maybe.Just) {
                                        $tco_done = true;
                                        return Lattice_Services_Path_BezierCore.cubicBezierPoint(v.value0.p0)(v.value0.p1)(v.value0.p2)(v.value0.p3)(clampedT);
                                    };
                                    if (v instanceof Data_Maybe.Nothing) {
                                        $tco_done = true;
                                        return Data_Maybe.fromMaybe(Lattice_Services_Path_BezierCore.zeroPoint)(map(function (v1) {
                                            return v1.point;
                                        })(Data_Array.index(path.vertices)(i)));
                                    };
                                    throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 244, column 22 - line 246, column 89): " + [ v.constructor.name ]);
                                };
                                $tco_var_i = i + 1 | 0;
                                $copy_accumulated = accumulated + segLen;
                                return;
                            };
                            throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 234, column 5 - line 247, column 52): " + [ i.constructor.name, accumulated.constructor.name ]);
                        };
                        while (!$tco_done) {
                            $tco_result = $tco_loop($tco_var_i, $copy_accumulated);
                        };
                        return $tco_result;
                    };
                };
                return go(0)(0.0);
            };
            throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 229, column 1 - line 229, column 71): " + [ path.constructor.name, targetLength.constructor.name, segmentLengths.constructor.name ]);
        };
    };
};
var findLongestSegment = function (lengths) {
    if (Data_Array.length(lengths) === 0) {
        return 0;
    };
    if (Data_Boolean.otherwise) {
        var go = function ($copy_i) {
            return function ($copy_maxIdx) {
                return function ($copy_maxLen) {
                    var $tco_var_i = $copy_i;
                    var $tco_var_maxIdx = $copy_maxIdx;
                    var $tco_done = false;
                    var $tco_result;
                    function $tco_loop(i, maxIdx, maxLen) {
                        if (i >= Data_Array.length(lengths)) {
                            $tco_done = true;
                            return maxIdx;
                        };
                        if (Data_Boolean.otherwise) {
                            var len = Data_Maybe.fromMaybe(0.0)(Data_Array.index(lengths)(i));
                            var $56 = len > maxLen;
                            if ($56) {
                                $tco_var_i = i + 1 | 0;
                                $tco_var_maxIdx = i;
                                $copy_maxLen = len;
                                return;
                            };
                            $tco_var_i = i + 1 | 0;
                            $tco_var_maxIdx = maxIdx;
                            $copy_maxLen = maxLen;
                            return;
                        };
                        throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 179, column 5 - line 185, column 43): " + [ i.constructor.name, maxIdx.constructor.name, maxLen.constructor.name ]);
                    };
                    while (!$tco_done) {
                        $tco_result = $tco_loop($tco_var_i, $tco_var_maxIdx, $copy_maxLen);
                    };
                    return $tco_result;
                };
            };
        };
        return go(0)(0)(0.0);
    };
    throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 174, column 1 - line 174, column 42): " + [ lengths.constructor.name ]);
};
var subdivideToVertexCount = function ($copy_path) {
    return function ($copy_targetCount) {
        var $tco_var_path = $copy_path;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(path, targetCount) {
            if (Data_Array.length(path.vertices) >= targetCount) {
                $tco_done = true;
                return path;
            };
            if (Data_Boolean.otherwise) {
                var lengths = Lattice_Services_Path_BezierCore.getSegmentLengths(path)(10);
                var maxIdx = findLongestSegment(lengths);
                var newPath = subdivideSegmentAt(path)(maxIdx)(0.5);
                $tco_var_path = newPath;
                $copy_targetCount = targetCount;
                return;
            };
            throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 215, column 1 - line 215, column 58): " + [ path.constructor.name, targetCount.constructor.name ]);
        };
        while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_path, $copy_targetCount);
        };
        return $tco_result;
    };
};
var eqPointMatchingStrategy = {
    eq: function (x) {
        return function (y) {
            if (x instanceof SubdivideShorter && y instanceof SubdivideShorter) {
                return true;
            };
            if (x instanceof SubdivideBoth && y instanceof SubdivideBoth) {
                return true;
            };
            if (x instanceof Resample && y instanceof Resample) {
                return true;
            };
            return false;
        };
    }
};
var eqCorrespondenceMethod = {
    eq: function (x) {
        return function (y) {
            if (x instanceof IndexCorrespondence && y instanceof IndexCorrespondence) {
                return true;
            };
            if (x instanceof NearestRotation && y instanceof NearestRotation) {
                return true;
            };
            if (x instanceof NearestDistance && y instanceof NearestDistance) {
                return true;
            };
            if (x instanceof ManualCorrespondence && y instanceof ManualCorrespondence) {
                return true;
            };
            return false;
        };
    }
};
var defaultMorphConfig = /* #__PURE__ */ (function () {
    return {
        pointMatchingStrategy: SubdivideShorter.value,
        correspondenceMethod: NearestRotation.value,
        resampleCount: Data_Maybe.Nothing.value
    };
})();
var clonePath = function (path) {
    return {
        vertices: map1(Lattice_Services_Path_BezierCore.cloneVertex)(path.vertices),
        closed: path.closed
    };
};
var morphPaths = function (source) {
    return function (target) {
        return function (t) {
            var clampedT = $$Math.max(0.0)($$Math.min(1.0)(t));
            var $63 = clampedT === 0.0;
            if ($63) {
                return clonePath(source);
            };
            var $64 = clampedT === 1.0;
            if ($64) {
                return clonePath(target);
            };
            return {
                vertices: Data_Array.zipWith(function (v1) {
                    return function (v2) {
                        return Lattice_Services_Path_BezierCore.lerpVertex(v1)(v2)(clampedT);
                    };
                })(source.vertices)(target.vertices),
                closed: source.closed
            };
        };
    };
};
var resamplePath = function (path) {
    return function (vertexCount) {
        if (vertexCount < 2 || Data_Array.length(path.vertices) === 0) {
            return clonePath(path);
        };
        if (Data_Boolean.otherwise) {
            var segmentLengths = Lattice_Services_Path_BezierCore.getSegmentLengths(path)(10);
            var totalLength = Data_Array.foldl(add1)(0.0)(segmentLengths);
            var $67 = totalLength === 0.0;
            if ($67) {
                return clonePath(path);
            };
            var spacing = totalLength / (function () {
                if (path.closed) {
                    return Data_Int.toNumber(vertexCount);
                };
                return Data_Int.toNumber(vertexCount - 1 | 0);
            })();
            var mapRange = function (start) {
                return function (end) {
                    return function (f) {
                        if (start >= end) {
                            return [  ];
                        };
                        if (Data_Boolean.otherwise) {
                            return append([ f(start) ])(mapRange(start + 1 | 0)(end)(f));
                        };
                        throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 261, column 16 - line 263, column 71): " + [ start.constructor.name, end.constructor.name, f.constructor.name ]);
                    };
                };
            };
            var makeVertex = function (i) {
                var targetLen = Data_Int.toNumber(i) * spacing;
                var prevLength = $$Math.max(0.0)(targetLen - spacing * 0.33);
                var prevPoint = getPointAtArcLength(path)(prevLength)(segmentLengths);
                var point = getPointAtArcLength(path)(targetLen)(segmentLengths);
                var nextLength = $$Math.min(totalLength)(targetLen + spacing * 0.33);
                var nextPoint = getPointAtArcLength(path)(nextLength)(segmentLengths);
                var tangent = Lattice_Services_Path_BezierCore.scalePoint(Lattice_Services_Path_BezierCore.subPoints(nextPoint)(prevPoint))(0.5);
                return {
                    point: Lattice_Services_Path_BezierCore.clonePoint(point),
                    inHandle: Lattice_Services_Path_BezierCore.scalePoint(tangent)(-0.33),
                    outHandle: Lattice_Services_Path_BezierCore.scalePoint(tangent)(0.33)
                };
            };
            return {
                vertices: mapRange(0)(vertexCount)(makeVertex),
                closed: path.closed
            };
        };
        throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 250, column 1 - line 250, column 48): " + [ path.constructor.name, vertexCount.constructor.name ]);
    };
};
var calculateTravelDistance = function (source) {
    return function (target) {
        return function (rotationOffset) {
            return function (reversed) {
                var go = function ($copy_n) {
                    return function ($copy_i) {
                        return function ($copy_acc) {
                            var $tco_var_n = $copy_n;
                            var $tco_var_i = $copy_i;
                            var $tco_done = false;
                            var $tco_result;
                            function $tco_loop(n, i, acc) {
                                if (i >= n) {
                                    $tco_done = true;
                                    return acc;
                                };
                                if (Data_Boolean.otherwise) {
                                    var tgtIdx = (function () {
                                        if (reversed) {
                                            return mod((((n - 1 | 0) - i | 0) + rotationOffset | 0) + n | 0)(n);
                                        };
                                        return mod(i + rotationOffset | 0)(n);
                                    })();
                                    var tgtPoint = Data_Maybe.fromMaybe(Lattice_Services_Path_BezierCore.zeroPoint)(map(function (v) {
                                        return v.point;
                                    })(Data_Array.index(target.vertices)(tgtIdx)));
                                    var srcPoint = Data_Maybe.fromMaybe(Lattice_Services_Path_BezierCore.zeroPoint)(map(function (v) {
                                        return v.point;
                                    })(Data_Array.index(source.vertices)(i)));
                                    var dist = Lattice_Services_Path_BezierCore.pointDistance(srcPoint)(tgtPoint);
                                    $tco_var_n = n;
                                    $tco_var_i = i + 1 | 0;
                                    $copy_acc = acc + dist;
                                    return;
                                };
                                throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 103, column 5 - line 113, column 39): " + [ n.constructor.name, i.constructor.name, acc.constructor.name ]);
                            };
                            while (!$tco_done) {
                                $tco_result = $tco_loop($tco_var_n, $tco_var_i, $copy_acc);
                            };
                            return $tco_result;
                        };
                    };
                };
                var n = Data_Array.length(source.vertices);
                var $76 = Data_Array.length(source.vertices) === 0 || n !== Data_Array.length(target.vertices);
                if ($76) {
                    return 0.0;
                };
                return go(n)(0)(0.0);
            };
        };
    };
};
var findOptimalRotation = function (source) {
    return function (target) {
        if (Data_Array.length(source.vertices) === 0) {
            return {
                offset: 0,
                reversed: false
            };
        };
        if (Data_Boolean.otherwise) {
            var n = Data_Array.length(source.vertices);
            var infinity = 1.0 / 0.0;
            var findBest = function ($copy_offset) {
                return function ($copy_bestOffset) {
                    return function ($copy_bestReversed) {
                        return function ($copy_bestDist) {
                            var $tco_var_offset = $copy_offset;
                            var $tco_var_bestOffset = $copy_bestOffset;
                            var $tco_var_bestReversed = $copy_bestReversed;
                            var $tco_done = false;
                            var $tco_result;
                            function $tco_loop(offset, bestOffset, bestReversed, bestDist) {
                                if (offset >= n) {
                                    $tco_done = true;
                                    return {
                                        offset: bestOffset,
                                        reversed: bestReversed
                                    };
                                };
                                if (Data_Boolean.otherwise) {
                                    var dist = calculateTravelDistance(source)(target)(offset)(false);
                                    var r1 = (function () {
                                        var $83 = dist < bestDist;
                                        if ($83) {
                                            return {
                                                o: offset,
                                                r: false,
                                                d: dist
                                            };
                                        };
                                        return {
                                            o: bestOffset,
                                            r: bestReversed,
                                            d: bestDist
                                        };
                                    })();
                                    var r2 = (function () {
                                        var $84 = source.closed && target.closed;
                                        if ($84) {
                                            var distRev = calculateTravelDistance(source)(target)(offset)(true);
                                            var $85 = distRev < r1.d;
                                            if ($85) {
                                                return {
                                                    o: offset,
                                                    r: true,
                                                    d: distRev
                                                };
                                            };
                                            return r1;
                                        };
                                        return r1;
                                    })();
                                    $tco_var_offset = offset + 1 | 0;
                                    $tco_var_bestOffset = r2.o;
                                    $tco_var_bestReversed = r2.r;
                                    $copy_bestDist = r2.d;
                                    return;
                                };
                                throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 124, column 5 - line 137, column 50): " + [ offset.constructor.name, bestOffset.constructor.name, bestReversed.constructor.name, bestDist.constructor.name ]);
                            };
                            while (!$tco_done) {
                                $tco_result = $tco_loop($tco_var_offset, $tco_var_bestOffset, $tco_var_bestReversed, $copy_bestDist);
                            };
                            return $tco_result;
                        };
                    };
                };
            };
            return findBest(0)(0)(false)(infinity);
        };
        throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 116, column 1 - line 116, column 90): " + [ source.constructor.name, target.constructor.name ]);
    };
};
var prepareMorphPaths = function (source) {
    return function (target) {
        return function (config) {
            if (Data_Array.length(source.vertices) === 0 || Data_Array.length(target.vertices) === 0) {
                return {
                    source: clonePath(source),
                    target: clonePath(target),
                    rotationOffset: 0,
                    reversed: false
                };
            };
            if (Data_Boolean.otherwise) {
                var prepared = (function () {
                    var $89 = Data_Array.length(source.vertices) === Data_Array.length(target.vertices);
                    if ($89) {
                        return {
                            s: clonePath(source),
                            t: clonePath(target)
                        };
                    };
                    if (config.pointMatchingStrategy instanceof SubdivideShorter) {
                        var $91 = Data_Array.length(source.vertices) < Data_Array.length(target.vertices);
                        if ($91) {
                            return {
                                s: subdivideToVertexCount(source)(Data_Array.length(target.vertices)),
                                t: clonePath(target)
                            };
                        };
                        return {
                            s: clonePath(source),
                            t: subdivideToVertexCount(target)(Data_Array.length(source.vertices))
                        };
                    };
                    if (config.pointMatchingStrategy instanceof SubdivideBoth) {
                        var maxCount = max(Data_Array.length(source.vertices))(Data_Array.length(target.vertices));
                        return {
                            s: subdivideToVertexCount(source)(maxCount),
                            t: subdivideToVertexCount(target)(maxCount)
                        };
                    };
                    if (config.pointMatchingStrategy instanceof Resample) {
                        var count = Data_Maybe.fromMaybe(max(Data_Array.length(source.vertices))(Data_Array.length(target.vertices)))(config.resampleCount);
                        return {
                            s: resamplePath(source)(count),
                            t: resamplePath(target)(count)
                        };
                    };
                    throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 311, column 18 - line 326, column 82): " + [ config.pointMatchingStrategy.constructor.name ]);
                })();
                var correspondence = (function () {
                    var $92 = prepared.s.closed && prepared.t.closed;
                    if ($92) {
                        if (config.correspondenceMethod instanceof NearestRotation) {
                            return findOptimalRotation(prepared.s)(prepared.t);
                        };
                        if (config.correspondenceMethod instanceof NearestDistance) {
                            return findOptimalRotation(prepared.s)(prepared.t);
                        };
                        return {
                            offset: 0,
                            reversed: false
                        };
                    };
                    return {
                        offset: 0,
                        reversed: false
                    };
                })();
                var finalTarget = (function () {
                    var $94 = correspondence.offset !== 0 || correspondence.reversed;
                    if ($94) {
                        return rotateVertices(prepared.t)(correspondence.offset)(correspondence.reversed);
                    };
                    return prepared.t;
                })();
                return {
                    source: prepared.s,
                    target: finalTarget,
                    rotationOffset: correspondence.offset,
                    reversed: correspondence.reversed
                };
            };
            throw new Error("Failed pattern match at Lattice.Services.Path.Morphing (line 302, column 1 - line 302, column 83): " + [ source.constructor.name, target.constructor.name, config.constructor.name ]);
        };
    };
};
var morphPathsAuto = function (source) {
    return function (target) {
        return function (t) {
            return function (config) {
                var prepared = prepareMorphPaths(source)(target)(config);
                return morphPaths(prepared.source)(prepared.target)(t);
            };
        };
    };
};
export {
    SubdivideShorter,
    SubdivideBoth,
    Resample,
    IndexCorrespondence,
    NearestRotation,
    NearestDistance,
    ManualCorrespondence,
    defaultMorphConfig,
    calculateTravelDistance,
    findOptimalRotation,
    rotateVertices,
    subdivideSegmentAt,
    subdivideToVertexCount,
    findLongestSegment,
    getPointAtArcLength,
    resamplePath,
    morphPaths,
    prepareMorphPaths,
    morphPathsAuto,
    clonePath,
    eqPointMatchingStrategy,
    eqCorrespondenceMethod
};
//# sourceMappingURL=index.js.map
