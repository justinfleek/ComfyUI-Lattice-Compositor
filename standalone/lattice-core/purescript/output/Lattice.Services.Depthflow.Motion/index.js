// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var MotionLinear = /* #__PURE__ */ (function () {
    function MotionLinear() {

    };
    MotionLinear.value = new MotionLinear();
    return MotionLinear;
})();
var MotionExponential = /* #__PURE__ */ (function () {
    function MotionExponential() {

    };
    MotionExponential.value = new MotionExponential();
    return MotionExponential;
})();
var MotionSine = /* #__PURE__ */ (function () {
    function MotionSine() {

    };
    MotionSine.value = new MotionSine();
    return MotionSine;
})();
var MotionCosine = /* #__PURE__ */ (function () {
    function MotionCosine() {

    };
    MotionCosine.value = new MotionCosine();
    return MotionCosine;
})();
var MotionArc = /* #__PURE__ */ (function () {
    function MotionArc() {

    };
    MotionArc.value = new MotionArc();
    return MotionArc;
})();
var MotionSetTarget = /* #__PURE__ */ (function () {
    function MotionSetTarget() {

    };
    MotionSetTarget.value = new MotionSetTarget();
    return MotionSetTarget;
})();
var MotionBounce = /* #__PURE__ */ (function () {
    function MotionBounce() {

    };
    MotionBounce.value = new MotionBounce();
    return MotionBounce;
})();
var MotionElastic = /* #__PURE__ */ (function () {
    function MotionElastic() {

    };
    MotionElastic.value = new MotionElastic();
    return MotionElastic;
})();
var EasingLinear = /* #__PURE__ */ (function () {
    function EasingLinear() {

    };
    EasingLinear.value = new EasingLinear();
    return EasingLinear;
})();
var EasingEaseIn = /* #__PURE__ */ (function () {
    function EasingEaseIn() {

    };
    EasingEaseIn.value = new EasingEaseIn();
    return EasingEaseIn;
})();
var EasingEaseOut = /* #__PURE__ */ (function () {
    function EasingEaseOut() {

    };
    EasingEaseOut.value = new EasingEaseOut();
    return EasingEaseOut;
})();
var EasingEaseInOut = /* #__PURE__ */ (function () {
    function EasingEaseInOut() {

    };
    EasingEaseInOut.value = new EasingEaseInOut();
    return EasingEaseInOut;
})();
var EasingBounce = /* #__PURE__ */ (function () {
    function EasingBounce() {

    };
    EasingBounce.value = new EasingBounce();
    return EasingBounce;
})();
var EasingElastic = /* #__PURE__ */ (function () {
    function EasingElastic() {

    };
    EasingElastic.value = new EasingElastic();
    return EasingElastic;
})();
var EasingBack = /* #__PURE__ */ (function () {
    function EasingBack() {

    };
    EasingBack.value = new EasingBack();
    return EasingBack;
})();
var mkMotionComponent = function (motionType) {
    return function (startValue) {
        return function (endValue) {
            return function (startFrame) {
                return function (endFrame) {
                    return function (easing) {
                        return {
                            motionType: motionType,
                            startValue: startValue,
                            endValue: endValue,
                            startFrame: startFrame,
                            endFrame: endFrame,
                            easing: easing,
                            amplitude: 0.0,
                            frequency: 1.0,
                            loops: 1.0,
                            phase: 0.0,
                            enabled: true
                        };
                    };
                };
            };
        };
    };
};
var mkDepthflowParams = function (zoom) {
    return function (offsetX) {
        return function (offsetY) {
            return function (rotation) {
                return function (depthScale) {
                    return function (focusDepth) {
                        return {
                            zoom: zoom,
                            offsetX: offsetX,
                            offsetY: offsetY,
                            rotation: rotation,
                            depthScale: depthScale,
                            focusDepth: focusDepth
                        };
                    };
                };
            };
        };
    };
};
var evaluateSine = function (startValue) {
    return function (endValue) {
        return function (easedT) {
            return function (amplitude) {
                return function (frequency) {
                    return function (loops) {
                        return function (phase) {
                            var freq = (function () {
                                var $17 = frequency <= 0.0;
                                if ($17) {
                                    return 1.0;
                                };
                                return frequency;
                            })();
                            var baseValue = (startValue + endValue) / 2.0;
                            var amp = (function () {
                                var $18 = amplitude === 0.0;
                                if ($18) {
                                    return (endValue - startValue) / 2.0;
                                };
                                return amplitude;
                            })();
                            return baseValue + amp * $$Math.sin((easedT * loops + phase) * $$Math.pi * 2.0 * freq);
                        };
                    };
                };
            };
        };
    };
};
var evaluateLinear = function (startValue) {
    return function (endValue) {
        return function (easedT) {
            return startValue + (endValue - startValue) * easedT;
        };
    };
};
var evaluateExponential = function (startValue) {
    return function (endValue) {
        return function (easedT) {
            var $19 = startValue === 0.0;
            if ($19) {
                return endValue * easedT;
            };
            var ratio = endValue / startValue;
            return startValue * $$Math.pow(ratio)(easedT);
        };
    };
};
var evaluateElastic = function (startValue) {
    return function (endValue) {
        return function (easedT) {
            var baseValue = startValue + (endValue - startValue) * easedT;
            var $20 = easedT === 0.0 || easedT === 1.0;
            if ($20) {
                return baseValue;
            };
            var elasticDecay = $$Math.exp(-easedT * 3.0);
            var elastic = $$Math.sin(easedT * $$Math.pi * 6.0) * elasticDecay * 0.3;
            return baseValue * (1.0 + elastic);
        };
    };
};
var evaluateCosine = function (startValue) {
    return function (endValue) {
        return function (easedT) {
            return function (amplitude) {
                return function (frequency) {
                    return function (loops) {
                        return function (phase) {
                            var freq = (function () {
                                var $21 = frequency <= 0.0;
                                if ($21) {
                                    return 1.0;
                                };
                                return frequency;
                            })();
                            var baseValue = (startValue + endValue) / 2.0;
                            var amp = (function () {
                                var $22 = amplitude === 0.0;
                                if ($22) {
                                    return (endValue - startValue) / 2.0;
                                };
                                return amplitude;
                            })();
                            return baseValue + amp * $$Math.cos((easedT * loops + phase) * $$Math.pi * 2.0 * freq);
                        };
                    };
                };
            };
        };
    };
};
var evaluateBounce = function (startValue) {
    return function (endValue) {
        return function (easedT) {
            var bounceDecay = $$Math.exp(-easedT * 5.0);
            var bounce = $$Math.sin(easedT * $$Math.pi * 4.0) * bounceDecay * 0.2;
            var baseValue = startValue + (endValue - startValue) * easedT;
            return baseValue * (1.0 + bounce);
        };
    };
};
var evaluateArc = function (startValue) {
    return function (endValue) {
        return function (easedT) {
            return function (amplitude) {
                var range = endValue - startValue;
                var amp = (function () {
                    var $23 = amplitude < 0.0;
                    if ($23) {
                        return 1.0;
                    };
                    return amplitude;
                })();
                var arcOffset = amp * 4.0 * easedT * (1.0 - easedT);
                return startValue + range * easedT + arcOffset;
            };
        };
    };
};
var eqMotionType = {
    eq: function (x) {
        return function (y) {
            if (x instanceof MotionLinear && y instanceof MotionLinear) {
                return true;
            };
            if (x instanceof MotionExponential && y instanceof MotionExponential) {
                return true;
            };
            if (x instanceof MotionSine && y instanceof MotionSine) {
                return true;
            };
            if (x instanceof MotionCosine && y instanceof MotionCosine) {
                return true;
            };
            if (x instanceof MotionArc && y instanceof MotionArc) {
                return true;
            };
            if (x instanceof MotionSetTarget && y instanceof MotionSetTarget) {
                return true;
            };
            if (x instanceof MotionBounce && y instanceof MotionBounce) {
                return true;
            };
            if (x instanceof MotionElastic && y instanceof MotionElastic) {
                return true;
            };
            return false;
        };
    }
};
var eqEasingType = {
    eq: function (x) {
        return function (y) {
            if (x instanceof EasingLinear && y instanceof EasingLinear) {
                return true;
            };
            if (x instanceof EasingEaseIn && y instanceof EasingEaseIn) {
                return true;
            };
            if (x instanceof EasingEaseOut && y instanceof EasingEaseOut) {
                return true;
            };
            if (x instanceof EasingEaseInOut && y instanceof EasingEaseInOut) {
                return true;
            };
            if (x instanceof EasingBounce && y instanceof EasingBounce) {
                return true;
            };
            if (x instanceof EasingElastic && y instanceof EasingElastic) {
                return true;
            };
            if (x instanceof EasingBack && y instanceof EasingBack) {
                return true;
            };
            return false;
        };
    }
};
var defaultMotionComponent = /* #__PURE__ */ (function () {
    return {
        motionType: MotionLinear.value,
        startValue: 0.0,
        endValue: 1.0,
        startFrame: 0.0,
        endFrame: 30.0,
        easing: EasingLinear.value,
        amplitude: 0.0,
        frequency: 1.0,
        loops: 1.0,
        phase: 0.0,
        enabled: true
    };
})();
var defaultDepthflowParams = {
    zoom: 1.0,
    offsetX: 0.0,
    offsetY: 0.0,
    rotation: 0.0,
    depthScale: 1.0,
    focusDepth: 0.5
};
var calculateParallaxOffset = function (depth) {
    return function (focusDepth) {
        return function (depthScale) {
            return (depth - focusDepth) * depthScale;
        };
    };
};
var applyZoom = function (coord) {
    return function (zoom) {
        var $28 = zoom === 0.0;
        if ($28) {
            return coord;
        };
        return coord / zoom;
    };
};
var applyRotation = function (x) {
    return function (y) {
        return function (angleDegrees) {
            var angleRadians = (angleDegrees * $$Math.pi) / 180.0;
            var cosA = $$Math.cos(angleRadians);
            var sinA = $$Math.sin(angleRadians);
            return new Data_Tuple.Tuple(x * cosA - y * sinA, x * sinA + y * cosA);
        };
    };
};
var applyEasing = function (t) {
    return function (easing) {
        if (easing instanceof EasingLinear) {
            return t;
        };
        if (easing instanceof EasingEaseIn) {
            return t * t;
        };
        if (easing instanceof EasingEaseOut) {
            return 1.0 - (1.0 - t) * (1.0 - t);
        };
        if (easing instanceof EasingEaseInOut) {
            var $30 = t < 0.5;
            if ($30) {
                return 2.0 * t * t;
            };
            return 1.0 - $$Math.pow(-2.0 * t + 2.0)(2.0) / 2.0;
        };
        if (easing instanceof EasingBounce) {
            var $31 = t < 1.0 / 2.75;
            if ($31) {
                return 7.5625 * t * t;
            };
            var $32 = t < 2.0 / 2.75;
            if ($32) {
                var t$prime = t - 1.5 / 2.75;
                return 7.5625 * t$prime * t$prime + 0.75;
            };
            var $33 = t < 2.5 / 2.75;
            if ($33) {
                var t$prime = t - 2.25 / 2.75;
                return 7.5625 * t$prime * t$prime + 0.9375;
            };
            var t$prime = t - 2.625 / 2.75;
            return 7.5625 * t$prime * t$prime + 0.984375;
        };
        if (easing instanceof EasingElastic) {
            var c4 = (2.0 * $$Math.pi) / 3.0;
            var $34 = t === 0.0;
            if ($34) {
                return 0.0;
            };
            var $35 = t === 1.0;
            if ($35) {
                return 1.0;
            };
            return $$Math.pow(2.0)(-10.0 * t) * $$Math.sin((t * 10.0 - 0.75) * c4) + 1.0;
        };
        if (easing instanceof EasingBack) {
            var c3 = 1.70158 + 1.0;
            return 1.0 + c3 * $$Math.pow(t - 1.0)(3.0) + 1.70158 * $$Math.pow(t - 1.0)(2.0);
        };
        throw new Error("Failed pattern match at Lattice.Services.Depthflow.Motion (line 153, column 24 - line 185, column 65): " + [ easing.constructor.name ]);
    };
};
var evaluateMotionComponent = function (motion) {
    return function (frame) {
        if (!motion.enabled) {
            return Data_Maybe.Nothing.value;
        };
        if (frame < motion.startFrame) {
            return new Data_Maybe.Just(motion.startValue);
        };
        if (frame > motion.endFrame) {
            return new Data_Maybe.Just(motion.endValue);
        };
        if (Data_Boolean.otherwise) {
            var localFrame = frame - motion.startFrame;
            var duration = motion.endFrame - motion.startFrame;
            var t = (function () {
                var $38 = duration > 0.0;
                if ($38) {
                    return localFrame / duration;
                };
                return 1.0;
            })();
            var easedT = applyEasing(t)(motion.easing);
            return new Data_Maybe.Just((function () {
                if (motion.motionType instanceof MotionLinear) {
                    return evaluateLinear(motion.startValue)(motion.endValue)(easedT);
                };
                if (motion.motionType instanceof MotionExponential) {
                    return evaluateExponential(motion.startValue)(motion.endValue)(easedT);
                };
                if (motion.motionType instanceof MotionSine) {
                    return evaluateSine(motion.startValue)(motion.endValue)(easedT)(motion.amplitude)(motion.frequency)(motion.loops)(motion.phase);
                };
                if (motion.motionType instanceof MotionCosine) {
                    return evaluateCosine(motion.startValue)(motion.endValue)(easedT)(motion.amplitude)(motion.frequency)(motion.loops)(motion.phase);
                };
                if (motion.motionType instanceof MotionArc) {
                    return evaluateArc(motion.startValue)(motion.endValue)(easedT)(motion.amplitude);
                };
                if (motion.motionType instanceof MotionSetTarget) {
                    var $40 = frame >= motion.startFrame;
                    if ($40) {
                        return motion.endValue;
                    };
                    return motion.startValue;
                };
                if (motion.motionType instanceof MotionBounce) {
                    return evaluateBounce(motion.startValue)(motion.endValue)(easedT);
                };
                if (motion.motionType instanceof MotionElastic) {
                    return evaluateElastic(motion.startValue)(motion.endValue)(easedT);
                };
                throw new Error("Failed pattern match at Lattice.Services.Depthflow.Motion (line 263, column 17 - line 290, column 52): " + [ motion.motionType.constructor.name ]);
            })());
        };
        throw new Error("Failed pattern match at Lattice.Services.Depthflow.Motion (line 251, column 1 - line 251, column 69): " + [ motion.constructor.name, frame.constructor.name ]);
    };
};
var combineMotions = function (motions) {
    return function (frame) {
        return function (baseValue) {
            var addMotion = function (acc) {
                return function (motion) {
                    var v = evaluateMotionComponent(motion)(frame);
                    if (v instanceof Data_Maybe.Nothing) {
                        return acc;
                    };
                    if (v instanceof Data_Maybe.Just) {
                        var delta = v.value0 - motion.startValue;
                        return acc + delta;
                    };
                    throw new Error("Failed pattern match at Lattice.Services.Depthflow.Motion (line 304, column 7 - line 308, column 25): " + [ v.constructor.name ]);
                };
            };
            return Data_Array.foldl(addMotion)(baseValue)(motions);
        };
    };
};
var evaluateParams = function (zoomM) {
    return function (offsetXM) {
        return function (offsetYM) {
            return function (rotationM) {
                return function (depthScaleM) {
                    return function (focusDepthM) {
                        return function (frame) {
                            return function (base) {
                                return {
                                    zoom: combineMotions(zoomM)(frame)(base.zoom),
                                    offsetX: combineMotions(offsetXM)(frame)(base.offsetX),
                                    offsetY: combineMotions(offsetYM)(frame)(base.offsetY),
                                    rotation: combineMotions(rotationM)(frame)(base.rotation),
                                    depthScale: combineMotions(depthScaleM)(frame)(base.depthScale),
                                    focusDepth: combineMotions(focusDepthM)(frame)(base.focusDepth)
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
export {
    EasingLinear,
    EasingEaseIn,
    EasingEaseOut,
    EasingEaseInOut,
    EasingBounce,
    EasingElastic,
    EasingBack,
    MotionLinear,
    MotionExponential,
    MotionSine,
    MotionCosine,
    MotionArc,
    MotionSetTarget,
    MotionBounce,
    MotionElastic,
    mkMotionComponent,
    mkDepthflowParams,
    defaultMotionComponent,
    defaultDepthflowParams,
    applyEasing,
    evaluateLinear,
    evaluateExponential,
    evaluateSine,
    evaluateCosine,
    evaluateArc,
    evaluateBounce,
    evaluateElastic,
    evaluateMotionComponent,
    combineMotions,
    evaluateParams,
    calculateParallaxOffset,
    applyZoom,
    applyRotation,
    eqEasingType,
    eqMotionType
};
//# sourceMappingURL=index.js.map
