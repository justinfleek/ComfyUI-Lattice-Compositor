// Generated by purs version 0.15.15
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var max1 = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var bind = /* #__PURE__ */ Control_Bind.bind(Control_Bind.bindArray);
var pure = /* #__PURE__ */ Control_Applicative.pure(Control_Applicative.applicativeArray);
var min1 = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordInt);
var validateDepthRange = function (minDepth) {
    return function (maxDepth) {
        if (minDepth > maxDepth) {
            return new Data_Tuple.Tuple(maxDepth, minDepth);
        };
        if (Data_Boolean.otherwise) {
            return new Data_Tuple.Tuple(minDepth, maxDepth);
        };
        throw new Error("Failed pattern match at Lattice.Services.Depth.DepthFill (line 237, column 1 - line 237, column 62): " + [ minDepth.constructor.name, maxDepth.constructor.name ]);
    };
};
var updateDepthRange = function (currentMin) {
    return function (currentMax) {
        return function (writtenDepth) {
            return new Data_Tuple.Tuple(min(currentMin)(writtenDepth), max(currentMax)(writtenDepth));
        };
    };
};
var toFloat32Precision = function (value) {
    return value;
};
var shouldWriteDepth = function (newDepth) {
    return function (existingDepth) {
        return newDepth < existingDepth;
    };
};
var screenToBufferIndex = function (screenX) {
    return function (screenY) {
        return function (screenWidth) {
            return (screenY * screenWidth | 0) + screenX | 0;
        };
    };
};
var sampleToIndex = function (sampleX) {
    return function (sampleY) {
        return function (depthWidth) {
            return (sampleY * depthWidth | 0) + sampleX | 0;
        };
    };
};
var prepareClipValues = function (nearClip) {
    return function (farClip) {
        return new Data_Tuple.Tuple(toFloat32Precision(nearClip), toFloat32Precision(farClip));
    };
};
var particleScreenPosition = function (p) {
    return new Data_Tuple.Tuple(Data_Int.floor(p.x), Data_Int.floor(p.y));
};
var particleRelativeDepth = function (particleZ) {
    return function (cameraZ) {
        return $$Math.abs(particleZ - cameraZ);
    };
};
var particleRadius = function (size) {
    return max1(1)(Data_Int.floor(size / 2.0));
};
var normalizedToWorldDepth = function (normalized) {
    return function (nearClip) {
        return function (farClip) {
            return nearClip + normalized * (farClip - nearClip);
        };
    };
};
var normalizeUint8Depth = function (value) {
    return Data_Int.toNumber(value) / 255.0;
};
var isValidParticle = function (p) {
    return Data_Number["isFinite"](p.x) && (!Data_Number["isNaN"](p.x) && (Data_Number["isFinite"](p.y) && (!Data_Number["isNaN"](p.y) && (Data_Number["isFinite"](p.z) && !Data_Number["isNaN"](p.z)))));
};
var isOpaqueEnoughForDepth = function (opacity) {
    return opacity > 0.5;
};
var isInsideCircle = function (dx) {
    return function (dy) {
        return function (radius) {
            return ((dx * dx | 0) + (dy * dy | 0) | 0) <= (radius * radius | 0);
        };
    };
};
var isInScreenBounds = function (screenX) {
    return function (screenY) {
        return function (screenWidth) {
            return function (screenHeight) {
                return screenX >= 0 && (screenX < screenWidth && (screenY >= 0 && screenY < screenHeight));
            };
        };
    };
};
var initDepthValue = function (farClip) {
    return farClip;
};
var handleEmptyScene = function (minDepth) {
    return function (maxDepth) {
        return function (farClip) {
            if (!Data_Number["isFinite"](minDepth) || (Data_Number["isNaN"](minDepth) || (!Data_Number["isFinite"](maxDepth) || Data_Number["isNaN"](maxDepth)))) {
                return new Data_Tuple.Tuple(farClip, farClip);
            };
            if (Data_Boolean.otherwise) {
                return validateDepthRange(minDepth)(maxDepth);
            };
            throw new Error("Failed pattern match at Lattice.Services.Depth.DepthFill (line 243, column 1 - line 243, column 70): " + [ minDepth.constructor.name, maxDepth.constructor.name, farClip.constructor.name ]);
        };
    };
};
var generateSplatOffsets = function (radius) {
    return Data_Array.filter(function (v) {
        return isInsideCircle(v.value0)(v.value1)(radius);
    })(bind(Data_Array.range(-radius | 0)(radius))(function (dy) {
        return bind(Data_Array.range(-radius | 0)(radius))(function (dx) {
            return pure(new Data_Tuple.Tuple(dx, dy));
        });
    }));
};
var generateFillPixels = function (startX) {
    return function (startY) {
        return function (endX) {
            return function (endY) {
                return bind(Data_Array.range(startY)(endY - 1 | 0))(function (y) {
                    return bind(Data_Array.range(startX)(endX - 1 | 0))(function (x) {
                        return pure(new Data_Tuple.Tuple(x, y));
                    });
                });
            };
        };
    };
};
var clampDepthToClipRange = function (depth) {
    return function (nearClip) {
        return function (farClip) {
            return max(nearClip)(min(farClip)(depth));
        };
    };
};
var calculateSampleCoords = function (x) {
    return function (y) {
        return function (boundsWidth) {
            return function (boundsHeight) {
                return function (depthWidth) {
                    return function (depthHeight) {
                        var sampleY = Data_Int.floor((y / boundsHeight) * Data_Int.toNumber(depthHeight));
                        var sampleX = Data_Int.floor((x / boundsWidth) * Data_Int.toNumber(depthWidth));
                        return new Data_Tuple.Tuple(sampleX, sampleY);
                    };
                };
            };
        };
    };
};
var depthflowSamplePosition = function (localX) {
    return function (localY) {
        return function (params) {
            return calculateSampleCoords(localX)(localY)(params.bounds.width)(params.bounds.height)(params.depthWidth)(params.depthHeight);
        };
    };
};
var calculateFillRegion = function (bounds) {
    return function (screenWidth) {
        return function (screenHeight) {
            var startY = Data_Int.floor(bounds.y);
            var startX = Data_Int.floor(bounds.x);
            var endY = min1(screenHeight)(Data_Int.ceil(bounds.y + bounds.height));
            var endX = min1(screenWidth)(Data_Int.ceil(bounds.x + bounds.width));
            return {
                startX: startX,
                startY: startY,
                endX: endX,
                endY: endY
            };
        };
    };
};
var boundsToScreen = function (boundsX) {
    return function (boundsY) {
        return function (localX) {
            return function (localY) {
                return new Data_Tuple.Tuple(Data_Int.floor(boundsX + localX), Data_Int.floor(boundsY + localY));
            };
        };
    };
};
export {
    calculateSampleCoords,
    sampleToIndex,
    normalizeUint8Depth,
    normalizedToWorldDepth,
    isInScreenBounds,
    screenToBufferIndex,
    depthflowSamplePosition,
    boundsToScreen,
    shouldWriteDepth,
    particleRelativeDepth,
    clampDepthToClipRange,
    particleRadius,
    isInsideCircle,
    generateSplatOffsets,
    isValidParticle,
    particleScreenPosition,
    calculateFillRegion,
    isOpaqueEnoughForDepth,
    generateFillPixels,
    initDepthValue,
    updateDepthRange,
    validateDepthRange,
    handleEmptyScene,
    toFloat32Precision,
    prepareClipValues
};
//# sourceMappingURL=index.js.map
