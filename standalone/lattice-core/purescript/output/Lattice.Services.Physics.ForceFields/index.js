// Generated by purs version 0.15.15
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showNumber);
var ForceApplied = /* #__PURE__ */ (function () {
    function ForceApplied(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    ForceApplied.create = function (value0) {
        return function (value1) {
            return new ForceApplied(value0, value1);
        };
    };
    return ForceApplied;
})();
var ImpulseApplied = /* #__PURE__ */ (function () {
    function ImpulseApplied(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    ImpulseApplied.create = function (value0) {
        return function (value1) {
            return new ImpulseApplied(value0, value1);
        };
    };
    return ImpulseApplied;
})();
var NoForce = /* #__PURE__ */ (function () {
    function NoForce() {

    };
    NoForce.value = new NoForce();
    return NoForce;
})();
var FieldGravity = /* #__PURE__ */ (function () {
    function FieldGravity() {

    };
    FieldGravity.value = new FieldGravity();
    return FieldGravity;
})();
var FieldWind = /* #__PURE__ */ (function () {
    function FieldWind() {

    };
    FieldWind.value = new FieldWind();
    return FieldWind;
})();
var FieldAttraction = /* #__PURE__ */ (function () {
    function FieldAttraction() {

    };
    FieldAttraction.value = new FieldAttraction();
    return FieldAttraction;
})();
var FieldExplosion = /* #__PURE__ */ (function () {
    function FieldExplosion() {

    };
    FieldExplosion.value = new FieldExplosion();
    return FieldExplosion;
})();
var FieldBuoyancy = /* #__PURE__ */ (function () {
    function FieldBuoyancy() {

    };
    FieldBuoyancy.value = new FieldBuoyancy();
    return FieldBuoyancy;
})();
var FieldVortex = /* #__PURE__ */ (function () {
    function FieldVortex() {

    };
    FieldVortex.value = new FieldVortex();
    return FieldVortex;
})();
var FieldDrag = /* #__PURE__ */ (function () {
    function FieldDrag() {

    };
    FieldDrag.value = new FieldDrag();
    return FieldDrag;
})();
var showForceResult = {
    show: function (v) {
        if (v instanceof ForceApplied) {
            return "ForceApplied " + (show(v.value0) + (" " + show(v.value1)));
        };
        if (v instanceof ImpulseApplied) {
            return "ImpulseApplied " + (show(v.value0) + (" " + show(v.value1)));
        };
        if (v instanceof NoForce) {
            return "NoForce";
        };
        throw new Error("Failed pattern match at Lattice.Services.Physics.ForceFields (line 70, column 1 - line 73, column 27): " + [ v.constructor.name ]);
    }
};
var showForceFieldType = {
    show: function (v) {
        if (v instanceof FieldGravity) {
            return "FieldGravity";
        };
        if (v instanceof FieldWind) {
            return "FieldWind";
        };
        if (v instanceof FieldAttraction) {
            return "FieldAttraction";
        };
        if (v instanceof FieldExplosion) {
            return "FieldExplosion";
        };
        if (v instanceof FieldBuoyancy) {
            return "FieldBuoyancy";
        };
        if (v instanceof FieldVortex) {
            return "FieldVortex";
        };
        if (v instanceof FieldDrag) {
            return "FieldDrag";
        };
        throw new Error("Failed pattern match at Lattice.Services.Physics.ForceFields (line 53, column 1 - line 60, column 31): " + [ v.constructor.name ]);
    }
};
var inBoundsRadius = function (cx) {
    return function (cy) {
        return function (px) {
            return function (py) {
                return function (radius) {
                    var dy = py - cy;
                    var dx = px - cx;
                    return dx * dx + dy * dy <= radius * radius;
                };
            };
        };
    };
};
var falloffQuadratic = function (dist) {
    if (dist < 1.0) {
        return 1.0;
    };
    if (Data_Boolean.otherwise) {
        return 1.0 / (dist * dist);
    };
    throw new Error("Failed pattern match at Lattice.Services.Physics.ForceFields (line 236, column 1 - line 236, column 37): " + [ dist.constructor.name ]);
};
var falloffLinear = function (dist) {
    return function (radius) {
        if (radius <= 0.0) {
            return 1.0;
        };
        if (dist >= radius) {
            return 0.0;
        };
        if (Data_Boolean.otherwise) {
            return 1.0 - dist / radius;
        };
        throw new Error("Failed pattern match at Lattice.Services.Physics.ForceFields (line 229, column 1 - line 229, column 44): " + [ dist.constructor.name, radius.constructor.name ]);
    };
};
var eqForceResult = {
    eq: function (x) {
        return function (y) {
            if (x instanceof ForceApplied && y instanceof ForceApplied) {
                return x.value0 === y.value0 && x.value1 === y.value1;
            };
            if (x instanceof ImpulseApplied && y instanceof ImpulseApplied) {
                return x.value0 === y.value0 && x.value1 === y.value1;
            };
            if (x instanceof NoForce && y instanceof NoForce) {
                return true;
            };
            return false;
        };
    }
};
var eqForceFieldType = {
    eq: function (x) {
        return function (y) {
            if (x instanceof FieldGravity && y instanceof FieldGravity) {
                return true;
            };
            if (x instanceof FieldWind && y instanceof FieldWind) {
                return true;
            };
            if (x instanceof FieldAttraction && y instanceof FieldAttraction) {
                return true;
            };
            if (x instanceof FieldExplosion && y instanceof FieldExplosion) {
                return true;
            };
            if (x instanceof FieldBuoyancy && y instanceof FieldBuoyancy) {
                return true;
            };
            if (x instanceof FieldVortex && y instanceof FieldVortex) {
                return true;
            };
            if (x instanceof FieldDrag && y instanceof FieldDrag) {
                return true;
            };
            return false;
        };
    }
};
var calculateWind = function (baseX) {
    return function (baseY) {
        return function (noiseX) {
            return function (noiseY) {
                return function (turbulence) {
                    return new Data_Tuple.Tuple(baseX + noiseX * turbulence, baseY + noiseY * turbulence);
                };
            };
        };
    };
};
var calculateVortex = function (cx) {
    return function (cy) {
        return function (px) {
            return function (py) {
                return function (tangentialStrength) {
                    return function (inwardStrength) {
                        return function (radius) {
                            return function (mass) {
                                var dy = py - cy;
                                var dx = px - cx;
                                var dist = $$Math.sqrt(dx * dx + dy * dy);
                                var $49 = dist > radius || dist < 1.0;
                                if ($49) {
                                    return Data_Maybe.Nothing.value;
                                };
                                var ny = dy / dist;
                                var tx = -ny;
                                var nx = dx / dist;
                                var falloff = 1.0 - dist / radius;
                                var inwardX = -nx * inwardStrength * falloff * mass;
                                var inwardY = -ny * inwardStrength * falloff * mass;
                                var tangentialX = tx * tangentialStrength * falloff * mass;
                                var tangentialY = nx * tangentialStrength * falloff * mass;
                                return new Data_Maybe.Just(new Data_Tuple.Tuple(tangentialX + inwardX, tangentialY + inwardY));
                            };
                        };
                    };
                };
            };
        };
    };
};
var calculateGravity = function (gx) {
    return function (gy) {
        return function (mass) {
            return new Data_Tuple.Tuple(gx * mass, gy * mass);
        };
    };
};
var calculateExplosion = function (ex) {
    return function (ey) {
        return function (px) {
            return function (py) {
                return function (strength) {
                    return function (radius) {
                        var dy = py - ey;
                        var dx = px - ex;
                        var dist = $$Math.sqrt(dx * dx + dy * dy);
                        var $50 = dist > radius || dist < 1.0;
                        if ($50) {
                            return Data_Maybe.Nothing.value;
                        };
                        var ny = (function () {
                            var $51 = dist > 1.0e-4;
                            if ($51) {
                                return dy / dist;
                            };
                            return 0.0;
                        })();
                        var nx = (function () {
                            var $52 = dist > 1.0e-4;
                            if ($52) {
                                return dx / dist;
                            };
                            return 1.0;
                        })();
                        var falloff = 1.0 - dist / radius;
                        return new Data_Maybe.Just(new Data_Tuple.Tuple(nx * strength * falloff, ny * strength * falloff));
                    };
                };
            };
        };
    };
};
var calculateDrag = function (velX) {
    return function (velY) {
        return function (linear) {
            return function (quadratic) {
                var speed = $$Math.sqrt(velX * velX + velY * velY);
                var $53 = speed < 1.0e-2;
                if ($53) {
                    return Data_Maybe.Nothing.value;
                };
                var ny = velY / speed;
                var nx = velX / speed;
                var dragMag = linear * speed + quadratic * speed * speed;
                return new Data_Maybe.Just(new Data_Tuple.Tuple(-nx * dragMag, -ny * dragMag));
            };
        };
    };
};
var calculateBuoyancy = function (surfaceLevel) {
    return function (bodyY) {
        return function (density) {
            return function (mass) {
                return function (radius) {
                    return function (velX) {
                        return function (velY) {
                            return function (linearDrag) {
                                var submergedDepth = bodyY - surfaceLevel;
                                var $54 = submergedDepth <= 0.0;
                                if ($54) {
                                    return Data_Maybe.Nothing.value;
                                };
                                var submergedRatio = $$Math.min(1.0)(submergedDepth / (radius * 2.0));
                                var dragY = -linearDrag * velY * submergedRatio;
                                var dragX = -linearDrag * velX * submergedRatio;
                                var buoyancyForce = -density * submergedRatio * mass * 980.0;
                                return new Data_Maybe.Just(new Data_Tuple.Tuple(dragX, buoyancyForce + dragY));
                            };
                        };
                    };
                };
            };
        };
    };
};
var calculateAttraction = function (cx) {
    return function (cy) {
        return function (px) {
            return function (py) {
                return function (strength) {
                    return function (radius) {
                        return function (mass) {
                            return function (falloff) {
                                var dy = cy - py;
                                var dx = cx - px;
                                var distSq = dx * dx + dy * dy;
                                var dist = $$Math.sqrt(distSq);
                                var $55 = radius > 0.0 && dist > radius;
                                if ($55) {
                                    return Data_Maybe.Nothing.value;
                                };
                                var $56 = dist < 1.0;
                                if ($56) {
                                    return Data_Maybe.Nothing.value;
                                };
                                var forceMag = (function () {
                                    if (falloff === "linear") {
                                        var $58 = radius > 0.0;
                                        if ($58) {
                                            return (strength * (radius - dist)) / radius;
                                        };
                                        return strength;
                                    };
                                    if (falloff === "quadratic") {
                                        return strength / distSq;
                                    };
                                    return strength;
                                })();
                                var dirY = dy / dist;
                                var dirX = dx / dist;
                                return new Data_Maybe.Just(new Data_Tuple.Tuple(dirX * forceMag * mass, dirY * forceMag * mass));
                            };
                        };
                    };
                };
            };
        };
    };
};
export {
    FieldGravity,
    FieldWind,
    FieldAttraction,
    FieldExplosion,
    FieldBuoyancy,
    FieldVortex,
    FieldDrag,
    ForceApplied,
    ImpulseApplied,
    NoForce,
    calculateGravity,
    calculateWind,
    calculateAttraction,
    calculateExplosion,
    calculateBuoyancy,
    calculateVortex,
    calculateDrag,
    falloffLinear,
    falloffQuadratic,
    inBoundsRadius,
    eqForceFieldType,
    showForceFieldType,
    eqForceResult,
    showForceResult
};
//# sourceMappingURL=index.js.map
