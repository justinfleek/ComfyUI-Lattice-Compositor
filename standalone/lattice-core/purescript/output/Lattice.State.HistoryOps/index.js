// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
var mkHistoryState = function (initial) {
    return {
        stack: [ initial ],
        index: 0
    };
};
var maxHistorySize = 50;
var pushHistory = function (snapshot) {
    return function (state) {
        var truncated = Data_Array.take(state.index + 1 | 0)(state.stack);
        var withNew = Data_Array.snoc(truncated)(snapshot);
        var trimmed = (function () {
            var $7 = Data_Array.length(withNew) > maxHistorySize;
            if ($7) {
                return Data_Array.slice(Data_Array.length(withNew) - maxHistorySize | 0)(Data_Array.length(withNew))(withNew);
            };
            return withNew;
        })();
        return {
            stack: trimmed,
            index: Data_Array.length(trimmed) - 1 | 0
        };
    };
};
var historyLength = function (state) {
    return Data_Array.length(state.stack);
};
var clearHistory = function (state) {
    var v = Data_Array.index(state.stack)(state.index);
    if (v instanceof Data_Maybe.Just) {
        return mkHistoryState(v.value0);
    };
    if (v instanceof Data_Maybe.Nothing) {
        return state;
    };
    throw new Error("Failed pattern match at Lattice.State.HistoryOps (line 90, column 3 - line 92, column 21): " + [ v.constructor.name ]);
};
var canUndo = function (state) {
    return state.index > 0;
};
var undo = function (state) {
    var $10 = canUndo(state);
    if ($10) {
        var newIdx = state.index - 1 | 0;
        var newState = {
            stack: state.stack,
            index: newIdx
        };
        return {
            state: newState,
            snapshot: Data_Array.index(state.stack)(newIdx)
        };
    };
    return {
        state: state,
        snapshot: Data_Maybe.Nothing.value
    };
};
var canRedo = function (state) {
    return state.index < (Data_Array.length(state.stack) - 1 | 0);
};
var redo = function (state) {
    var $11 = canRedo(state);
    if ($11) {
        var newIdx = state.index + 1 | 0;
        var newState = {
            stack: state.stack,
            index: newIdx
        };
        return {
            state: newState,
            snapshot: Data_Array.index(state.stack)(newIdx)
        };
    };
    return {
        state: state,
        snapshot: Data_Maybe.Nothing.value
    };
};
export {
    mkHistoryState,
    pushHistory,
    undo,
    redo,
    canUndo,
    canRedo,
    clearHistory,
    historyLength,
    maxHistorySize
};
//# sourceMappingURL=index.js.map
