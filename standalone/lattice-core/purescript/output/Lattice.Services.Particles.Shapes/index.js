// Generated by purs version 0.15.15
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var TopEdge = /* #__PURE__ */ (function () {
    function TopEdge() {

    };
    TopEdge.value = new TopEdge();
    return TopEdge;
})();
var RightEdge = /* #__PURE__ */ (function () {
    function RightEdge() {

    };
    RightEdge.value = new RightEdge();
    return RightEdge;
})();
var BottomEdge = /* #__PURE__ */ (function () {
    function BottomEdge() {

    };
    BottomEdge.value = new BottomEdge();
    return BottomEdge;
})();
var LeftEdge = /* #__PURE__ */ (function () {
    function LeftEdge() {

    };
    LeftEdge.value = new LeftEdge();
    return LeftEdge;
})();
var separateParticles = function (p1x) {
    return function (p1y) {
        return function (p2x) {
            return function (p2y) {
                return function (minDist) {
                    var dy = p2y - p1y;
                    var dx = p2x - p1x;
                    var dist = $$Math.sqrt(dx * dx + dy * dy);
                    var $12 = dist >= minDist || dist < 1.0e-4;
                    if ($12) {
                        return new Data_Tuple.Tuple(new Data_Tuple.Tuple(p1x, p1y), new Data_Tuple.Tuple(p2x, p2y));
                    };
                    var overlap = minDist - dist;
                    var ny = dy / dist;
                    var nx = dx / dist;
                    var halfOverlap = overlap * 0.5;
                    return new Data_Tuple.Tuple(new Data_Tuple.Tuple(p1x - nx * halfOverlap, p1y - ny * halfOverlap), new Data_Tuple.Tuple(p2x + nx * halfOverlap, p2y + ny * halfOverlap));
                };
            };
        };
    };
};
var eqBoxEdge = {
    eq: function (x) {
        return function (y) {
            if (x instanceof TopEdge && y instanceof TopEdge) {
                return true;
            };
            if (x instanceof RightEdge && y instanceof RightEdge) {
                return true;
            };
            if (x instanceof BottomEdge && y instanceof BottomEdge) {
                return true;
            };
            if (x instanceof LeftEdge && y instanceof LeftEdge) {
                return true;
            };
            return false;
        };
    }
};
var emitSphereVolume = function (emitterX) {
    return function (emitterY) {
        return function (radius) {
            return function (unitX) {
                return function (unitY) {
                    return {
                        x: emitterX + unitX * radius,
                        y: emitterY + unitY * radius,
                        direction: Data_Maybe.Nothing.value
                    };
                };
            };
        };
    };
};
var emitSphereSurface = function (emitterX) {
    return function (emitterY) {
        return function (radius) {
            return function (randomTheta) {
                return function (randomPhi) {
                    var theta = randomTheta * $$Math.pi * 2.0;
                    var phi = $$Math.acos(2.0 * randomPhi - 1.0);
                    return {
                        x: emitterX + $$Math.sin(phi) * $$Math.cos(theta) * radius,
                        y: emitterY + $$Math.sin(phi) * $$Math.sin(theta) * radius,
                        direction: Data_Maybe.Nothing.value
                    };
                };
            };
        };
    };
};
var emitRing = function (emitterX) {
    return function (emitterY) {
        return function (innerRadius) {
            return function (outerRadius) {
                return function (randomAngle) {
                    return function (randomRadius) {
                        var outerSq = outerRadius * outerRadius;
                        var innerSq = innerRadius * innerRadius;
                        var r = $$Math.sqrt(randomRadius * (outerSq - innerSq) + innerSq);
                        var angle = randomAngle * $$Math.pi * 2.0;
                        return {
                            x: emitterX + $$Math.cos(angle) * r,
                            y: emitterY + $$Math.sin(angle) * r,
                            direction: Data_Maybe.Nothing.value
                        };
                    };
                };
            };
        };
    };
};
var emitPoint = function (emitterX) {
    return function (emitterY) {
        return {
            x: emitterX,
            y: emitterY,
            direction: Data_Maybe.Nothing.value
        };
    };
};
var emitLine = function (emitterX) {
    return function (emitterY) {
        return function (direction) {
            return function (halfWidth) {
                return function (t) {
                    var offset = (t - 0.5) * halfWidth * 2.0;
                    var dirRad = (direction * $$Math.pi) / 180.0;
                    var perpX = -$$Math.sin(dirRad);
                    var perpY = $$Math.cos(dirRad);
                    return {
                        x: emitterX + perpX * offset,
                        y: emitterY + perpY * offset,
                        direction: Data_Maybe.Nothing.value
                    };
                };
            };
        };
    };
};
var emitCone = function (emitterX) {
    return function (emitterY) {
        return function (direction) {
            return function (coneAngle) {
                return function (coneRadius) {
                    return function (coneLength) {
                        return function (randomT) {
                            return function (randomTheta) {
                                var theta = randomTheta * $$Math.pi * 2.0;
                                var localY = randomT * coneLength;
                                var dirRad = (direction * $$Math.pi) / 180.0;
                                var sinDir = $$Math.sin(dirRad);
                                var cosDir = $$Math.cos(dirRad);
                                var coneAngleRad = (coneAngle * $$Math.pi) / 180.0;
                                var radiusAtT = randomT * coneRadius * $$Math.tan(coneAngleRad);
                                var localX = $$Math.cos(theta) * radiusAtT;
                                return {
                                    x: (emitterX + localX * cosDir) - localY * sinDir,
                                    y: emitterY + localX * sinDir + localY * cosDir,
                                    direction: Data_Maybe.Nothing.value
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
var emitCircleFilled = function (emitterX) {
    return function (emitterY) {
        return function (radius) {
            return function (randomAngle) {
                return function (randomRadius) {
                    var r = radius * $$Math.sqrt(randomRadius);
                    var angle = randomAngle * $$Math.pi * 2.0;
                    return {
                        x: emitterX + $$Math.cos(angle) * r,
                        y: emitterY + $$Math.sin(angle) * r,
                        direction: Data_Maybe.Nothing.value
                    };
                };
            };
        };
    };
};
var emitCircleEdge = function (emitterX) {
    return function (emitterY) {
        return function (radius) {
            return function (randomAngle) {
                var angle = randomAngle * $$Math.pi * 2.0;
                return {
                    x: emitterX + $$Math.cos(angle) * radius,
                    y: emitterY + $$Math.sin(angle) * radius,
                    direction: Data_Maybe.Nothing.value
                };
            };
        };
    };
};
var emitBoxFilled = function (emitterX) {
    return function (emitterY) {
        return function (width) {
            return function (height) {
                return function (randomX) {
                    return function (randomY) {
                        return {
                            x: emitterX + (randomX - 0.5) * width,
                            y: emitterY + (randomY - 0.5) * height,
                            direction: Data_Maybe.Nothing.value
                        };
                    };
                };
            };
        };
    };
};
var elasticCollision = function (p1x) {
    return function (p1y) {
        return function (v1x) {
            return function (v1y) {
                return function (p2x) {
                    return function (p2y) {
                        return function (v2x) {
                            return function (v2y) {
                                return function (damping) {
                                    var dy = p2y - p1y;
                                    var dx = p2x - p1x;
                                    var dist = $$Math.sqrt(dx * dx + dy * dy);
                                    var $15 = dist < 1.0e-4;
                                    if ($15) {
                                        return new Data_Tuple.Tuple(new Data_Tuple.Tuple(v1x, v1y), new Data_Tuple.Tuple(v2x, v2y));
                                    };
                                    var ny = dy / dist;
                                    var nx = dx / dist;
                                    var dvy = v1y - v2y;
                                    var dvx = v1x - v2x;
                                    var dvDotN = dvx * nx + dvy * ny;
                                    var $16 = dvDotN <= 0.0;
                                    if ($16) {
                                        return new Data_Tuple.Tuple(new Data_Tuple.Tuple(v1x, v1y), new Data_Tuple.Tuple(v2x, v2y));
                                    };
                                    var impulseY = dvDotN * ny * damping;
                                    var impulseX = dvDotN * nx * damping;
                                    return new Data_Tuple.Tuple(new Data_Tuple.Tuple(v1x - impulseX, v1y - impulseY), new Data_Tuple.Tuple(v2x + impulseX, v2y + impulseY));
                                };
                            };
                        };
                    };
                };
            };
        };
    };
};
var boxEdgeFromT = function (t) {
    return function (width) {
        return function (height) {
            var perimeter = 2.0 * (width + height);
            var pos = t * perimeter;
            var $17 = pos < width;
            if ($17) {
                return new Data_Tuple.Tuple(TopEdge.value, pos);
            };
            var $18 = pos < width + height;
            if ($18) {
                return new Data_Tuple.Tuple(RightEdge.value, pos - width);
            };
            var $19 = pos < 2.0 * width + height;
            if ($19) {
                return new Data_Tuple.Tuple(BottomEdge.value, pos - width - height);
            };
            return new Data_Tuple.Tuple(LeftEdge.value, pos - 2.0 * width - height);
        };
    };
};
var emitBoxEdge = function (emitterX) {
    return function (emitterY) {
        return function (width) {
            return function (height) {
                return function (randomT) {
                    var halfW = width / 2.0;
                    var halfH = height / 2.0;
                    var v = boxEdgeFromT(randomT)(width)(height);
                    if (v.value0 instanceof TopEdge) {
                        return {
                            x: (emitterX - halfW) + v.value1,
                            y: emitterY - halfH,
                            direction: Data_Maybe.Nothing.value
                        };
                    };
                    if (v.value0 instanceof RightEdge) {
                        return {
                            x: emitterX + halfW,
                            y: (emitterY - halfH) + v.value1,
                            direction: Data_Maybe.Nothing.value
                        };
                    };
                    if (v.value0 instanceof BottomEdge) {
                        return {
                            x: (emitterX + halfW) - v.value1,
                            y: emitterY + halfH,
                            direction: Data_Maybe.Nothing.value
                        };
                    };
                    if (v.value0 instanceof LeftEdge) {
                        return {
                            x: emitterX - halfW,
                            y: (emitterY + halfH) - v.value1,
                            direction: Data_Maybe.Nothing.value
                        };
                    };
                    throw new Error("Failed pattern match at Lattice.Services.Particles.Shapes (line 143, column 6 - line 147, column 96): " + [ v.value0.constructor.name ]);
                };
            };
        };
    };
};
export {
    TopEdge,
    RightEdge,
    BottomEdge,
    LeftEdge,
    emitPoint,
    emitLine,
    emitCircleFilled,
    emitCircleEdge,
    emitRing,
    emitBoxFilled,
    emitBoxEdge,
    boxEdgeFromT,
    emitSphereSurface,
    emitSphereVolume,
    emitCone,
    elasticCollision,
    separateParticles,
    eqBoxEdge
};
//# sourceMappingURL=index.js.map
