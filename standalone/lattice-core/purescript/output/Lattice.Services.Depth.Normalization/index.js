// Generated by purs version 0.15.15
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Int from "../Data.Int/index.js";
var safeDepthRange = function (minDepth) {
    return function (maxDepth) {
        var range = maxDepth - minDepth;
        var $7 = range <= 0.0;
        if ($7) {
            return 1.0;
        };
        return range;
    };
};
var normalizeDepth = function (depth) {
    return function (minDepth) {
        return function (maxDepth) {
            var range = safeDepthRange(minDepth)(maxDepth);
            return (depth - minDepth) / range;
        };
    };
};
var isCloser = function (newDepth) {
    return function (currentDepth) {
        return newDepth < currentDepth;
    };
};
var fromUint8 = function (value) {
    return Data_Int.toNumber(value) / 255.0;
};
var fromUint16 = function (value) {
    return Data_Int.toNumber(value) / 65535.0;
};
var depthBufferUpdate = function (newDepth) {
    return function (currentDepth) {
        var $8 = isCloser(newDepth)(currentDepth);
        if ($8) {
            return newDepth;
        };
        return currentDepth;
    };
};
var clampNormalized = function (value) {
    if (value < 0.0) {
        return 0.0;
    };
    if (value > 1.0) {
        return 1.0;
    };
    if (Data_Boolean.otherwise) {
        return value;
    };
    throw new Error("Failed pattern match at Lattice.Services.Depth.Normalization (line 56, column 1 - line 56, column 36): " + [ value.constructor.name ]);
};
var fromWorldDepth = function (worldDepth) {
    return function (nearClip) {
        return function (farClip) {
            var $10 = farClip <= nearClip;
            if ($10) {
                return 0.0;
            };
            return clampNormalized((worldDepth - nearClip) / (farClip - nearClip));
        };
    };
};
var invertDepth = function (normalized) {
    return 1.0 - clampNormalized(normalized);
};
var scaleByFarClip = function (normalized) {
    return function (farClip) {
        return clampNormalized(normalized) * farClip;
    };
};
var toUint16 = function (normalized) {
    var clamped = clampNormalized(normalized);
    return Data_Int.round(clamped * 65535.0);
};
var toUint8 = function (normalized) {
    var clamped = clampNormalized(normalized);
    return Data_Int.round(clamped * 255.0);
};
var convertDepth = function (depth) {
    return function (minDepth) {
        return function (maxDepth) {
            return function (invert) {
                return function (bitDepth) {
                    var normalized = normalizeDepth(depth)(minDepth)(maxDepth);
                    var clamped = clampNormalized(normalized);
                    var inverted = (function () {
                        if (invert) {
                            return invertDepth(clamped);
                        };
                        return clamped;
                    })();
                    if (bitDepth === 8) {
                        return toUint8(inverted);
                    };
                    if (bitDepth === 16) {
                        return toUint16(inverted);
                    };
                    return toUint16(inverted);
                };
            };
        };
    };
};
var toWorldDepth = function (normalized) {
    return function (nearClip) {
        return function (farClip) {
            return nearClip + clampNormalized(normalized) * (farClip - nearClip);
        };
    };
};
export {
    safeDepthRange,
    normalizeDepth,
    clampNormalized,
    invertDepth,
    toUint8,
    toUint16,
    fromUint8,
    fromUint16,
    toWorldDepth,
    fromWorldDepth,
    scaleByFarClip,
    convertDepth,
    isCloser,
    depthBufferUpdate
};
//# sourceMappingURL=index.js.map
