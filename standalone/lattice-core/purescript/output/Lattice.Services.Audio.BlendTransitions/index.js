// Generated by purs version 0.15.15
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Function from "../Data.Function/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as $$Math from "../Math/index.js";
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var Step = /* #__PURE__ */ (function () {
    function Step() {

    };
    Step.value = new Step();
    return Step;
})();
var Linear = /* #__PURE__ */ (function () {
    function Linear() {

    };
    Linear.value = new Linear();
    return Linear;
})();
var Smooth = /* #__PURE__ */ (function () {
    function Smooth() {

    };
    Smooth.value = new Smooth();
    return Smooth;
})();
var twoImageWeights = function (blend) {
    return function (minWeight) {
        var next = $$Math.max(minWeight)(blend);
        var current = $$Math.max(minWeight)(1.0 - blend);
        return {
            current: current,
            next: next
        };
    };
};
var transitionProgress = function (currentFrame) {
    return function (transitionStartFrame) {
        return function (transitionLength) {
            if (transitionLength === 0) {
                return 1.0;
            };
            if (Data_Boolean.otherwise) {
                var elapsed = currentFrame - transitionStartFrame | 0;
                var progress = Data_Int.toNumber(elapsed) / Data_Int.toNumber(transitionLength);
                return $$Math.max(0.0)($$Math.min(1.0)(progress));
            };
            throw new Error("Failed pattern match at Lattice.Services.Audio.BlendTransitions (line 120, column 1 - line 120, column 50): " + [ currentFrame.constructor.name, transitionStartFrame.constructor.name, transitionLength.constructor.name ]);
        };
    };
};
var stepBlend = function (progress) {
    var $13 = progress >= 0.5;
    if ($13) {
        return 1.0;
    };
    return 0.0;
};
var smoothBlend = function (progress) {
    var t = $$Math.max(0.0)($$Math.min(1.0)(progress));
    return t * t * (3.0 - 2.0 * t);
};
var linearBlend = function (progress) {
    return $$Math.max(0.0)($$Math.min(1.0)(progress));
};
var isTransitionComplete = function (progress) {
    return progress >= 1.0;
};
var eqBlendMode = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Step && y instanceof Step) {
                return true;
            };
            if (x instanceof Linear && y instanceof Linear) {
                return true;
            };
            if (x instanceof Smooth && y instanceof Smooth) {
                return true;
            };
            return false;
        };
    }
};
var cycleBlendIndices = function (imageCount) {
    return function (progress) {
        if (imageCount === 0) {
            return {
                currentIndex: 0,
                nextIndex: 0,
                blendFactor: 0.0
            };
        };
        if (Data_Boolean.otherwise) {
            var current = mod(Data_Int.floor(progress))(imageCount);
            var next = mod(current + 1 | 0)(imageCount);
            var blend = progress - Data_Int.toNumber(Data_Int.floor(progress));
            return {
                currentIndex: current,
                nextIndex: next,
                blendFactor: blend
            };
        };
        throw new Error("Failed pattern match at Lattice.Services.Audio.BlendTransitions (line 100, column 1 - line 100, column 103): " + [ imageCount.constructor.name, progress.constructor.name ]);
    };
};
var applyBlendMode = function (progress) {
    return function (mode) {
        if (mode instanceof Step) {
            return stepBlend(progress);
        };
        if (mode instanceof Linear) {
            return linearBlend(progress);
        };
        if (mode instanceof Smooth) {
            return smoothBlend(progress);
        };
        throw new Error("Failed pattern match at Lattice.Services.Audio.BlendTransitions (line 73, column 32 - line 76, column 33): " + [ mode.constructor.name ]);
    };
};
var calculateIPAdapterWeights = function (currentFrame) {
    return function (transitionStartFrame) {
        return function (transitionLength) {
            return function (currentIndex) {
                return function (imageCount) {
                    return function (blendMode) {
                        return function (minWeight) {
                            if (imageCount === 0) {
                                return {
                                    getWeight: Data_Function["const"](0.0),
                                    newCurrentIndex: 0,
                                    isComplete: true
                                };
                            };
                            if (Data_Boolean.otherwise) {
                                var progress = transitionProgress(currentFrame)(transitionStartFrame)(transitionLength);
                                var nextIndex = mod(currentIndex + 1 | 0)(imageCount);
                                var complete = isTransitionComplete(progress);
                                var newIndex = (function () {
                                    if (complete) {
                                        return nextIndex;
                                    };
                                    return currentIndex;
                                })();
                                var blend = applyBlendMode(progress)(blendMode);
                                var weights = twoImageWeights(blend)(minWeight);
                                var getWeight = function (i) {
                                    if (i === currentIndex) {
                                        return weights.current;
                                    };
                                    if (i === nextIndex) {
                                        return weights.next;
                                    };
                                    if (Data_Boolean.otherwise) {
                                        return minWeight;
                                    };
                                    throw new Error("Failed pattern match at Lattice.Services.Audio.BlendTransitions (line 153, column 11 - line 156, column 36): " + [ i.constructor.name ]);
                                };
                                return {
                                    getWeight: getWeight,
                                    newCurrentIndex: newIndex,
                                    isComplete: complete
                                };
                            };
                            throw new Error("Failed pattern match at Lattice.Services.Audio.BlendTransitions (line 141, column 1 - line 142, column 106): " + [ currentFrame.constructor.name, transitionStartFrame.constructor.name, transitionLength.constructor.name, currentIndex.constructor.name, imageCount.constructor.name, blendMode.constructor.name, minWeight.constructor.name ]);
                        };
                    };
                };
            };
        };
    };
};
export {
    Step,
    Linear,
    Smooth,
    stepBlend,
    linearBlend,
    smoothBlend,
    applyBlendMode,
    twoImageWeights,
    cycleBlendIndices,
    transitionProgress,
    isTransitionComplete,
    calculateIPAdapterWeights,
    eqBlendMode
};
//# sourceMappingURL=index.js.map
