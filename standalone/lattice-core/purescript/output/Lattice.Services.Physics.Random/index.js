// Generated by purs version 0.15.15
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as $$Math from "../Math/index.js";
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var append = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var xorShift = function (x) {
    return function (n) {
        return x;
    };
};
var reset = function (rng) {
    return {
        initialSeed: rng.initialSeed,
        state: rng.initialSeed
    };
};
var mkPhysicsRandom = function (seed) {
    return {
        state: seed,
        initialSeed: seed
    };
};
var abs = function (n) {
    var $21 = n < 0;
    if ($21) {
        return -n | 0;
    };
    return n;
};
var next = function (rng) {
    var state0 = rng.state + 1831565813 | 0;
    var t1 = xorShift(state0 * 3 | 0)(15);
    var t2 = xorShift(t1 * 2 | 0)(7);
    var result = xorShift(t2)(14);
    var value = Data_Int.toNumber(mod(abs(result))(2147483647)) / 2.147483647e9;
    var newRng = {
        initialSeed: rng.initialSeed,
        state: state0
    };
    return new Data_Tuple.Tuple(value, newRng);
};
var nextGaussian = function (rng) {
    var v = next(rng);
    var v1 = next(v.value1);
    var safeU1 = $$Math.max(1.0e-6)(v.value0);
    var gaussian = $$Math.sqrt(-2.0 * $$Math.log(safeU1)) * $$Math.cos(2.0 * $$Math.pi * v1.value0);
    return new Data_Tuple.Tuple(gaussian, v1.value1);
};
var nextN = function (n) {
    return function (rng) {
        var go = function ($copy_v) {
            return function ($copy_v1) {
                return function ($copy_v2) {
                    var $tco_var_v = $copy_v;
                    var $tco_var_v1 = $copy_v1;
                    var $tco_done = false;
                    var $tco_result;
                    function $tco_loop(v, v1, v2) {
                        if (v === 0) {
                            $tco_done = true;
                            return new Data_Tuple.Tuple(v2, v1);
                        };
                        var v3 = next(v1);
                        $tco_var_v = v - 1 | 0;
                        $tco_var_v1 = v3.value1;
                        $copy_v2 = append(v2)([ v3.value0 ]);
                        return;
                    };
                    while (!$tco_done) {
                        $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
                    };
                    return $tco_result;
                };
            };
        };
        return go(n)(rng)([  ]);
    };
};
var nextRange = function (minVal) {
    return function (maxVal) {
        return function (rng) {
            var v = next(rng);
            var scaled = minVal + v.value0 * (maxVal - minVal);
            return new Data_Tuple.Tuple(scaled, v.value1);
        };
    };
};
export {
    mkPhysicsRandom,
    reset,
    next,
    nextRange,
    nextGaussian,
    nextN
};
//# sourceMappingURL=index.js.map
