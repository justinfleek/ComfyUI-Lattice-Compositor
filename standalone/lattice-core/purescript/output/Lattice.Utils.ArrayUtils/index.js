// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var add = /* #__PURE__ */ Data_Semiring.add(Data_Semiring.semiringNumber);
var mul = /* #__PURE__ */ Data_Semiring.mul(Data_Semiring.semiringNumber);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var zipWith$prime = function (f) {
    return function (xs) {
        return function (ys) {
            return map(function (v) {
                return f(v.value0)(v.value1);
            })(Data_Array.zip(xs)(ys));
        };
    };
};
var unique = function (dictEq) {
    return Data_Array.nubEq(dictEq);
};
var sumArray = /* #__PURE__ */ Data_Array.foldl(add)(0.0);
var range = function (start) {
    return function (endVal) {
        if (start >= endVal) {
            return [  ];
        };
        if (Data_Boolean.otherwise) {
            return Data_Array.range(start)(endVal - 1 | 0);
        };
        throw new Error("Failed pattern match at Lattice.Utils.ArrayUtils (line 178, column 1 - line 178, column 33): " + [ start.constructor.name, endVal.constructor.name ]);
    };
};
var productArray = /* #__PURE__ */ Data_Array.foldl(mul)(1.0);
var normalizeFinite = function (values) {
    var maxVal = Data_Array.foldl(max)(0.0)(values);
    var safeMax = (function () {
        var $23 = maxVal > 0.0;
        if ($23) {
            return maxVal;
        };
        return 1.0e-4;
    })();
    return map(function (x) {
        return max(0.0)(min(1.0)(x / safeMax));
    })(values);
};
var minArray = function (def) {
    return function (values) {
        if (Data_Array["null"](values)) {
            return def;
        };
        if (Data_Boolean.otherwise) {
            return Data_Array.foldl(min)(def)(values);
        };
        throw new Error("Failed pattern match at Lattice.Utils.ArrayUtils (line 77, column 1 - line 77, column 45): " + [ def.constructor.name, values.constructor.name ]);
    };
};
var mean = function (values) {
    if (Data_Array["null"](values)) {
        return 0.0;
    };
    if (Data_Boolean.otherwise) {
        return sumArray(values) / Data_Int.toNumber(Data_Array.length(values));
    };
    throw new Error("Failed pattern match at Lattice.Utils.ArrayUtils (line 65, column 1 - line 65, column 31): " + [ values.constructor.name ]);
};
var variance = function (values) {
    if (Data_Array["null"](values)) {
        return 0.0;
    };
    if (Data_Boolean.otherwise) {
        var m = mean(values);
        return mean(map(function (v) {
            return (v - m) * (v - m);
        })(values));
    };
    throw new Error("Failed pattern match at Lattice.Utils.ArrayUtils (line 151, column 1 - line 151, column 35): " + [ values.constructor.name ]);
};
var stdDev = function ($42) {
    return Data_Number.sqrt(variance($42));
};
var maxArray = function (def) {
    return function (values) {
        if (Data_Array["null"](values)) {
            return def;
        };
        if (Data_Boolean.otherwise) {
            return Data_Array.foldl(max)(def)(values);
        };
        throw new Error("Failed pattern match at Lattice.Utils.ArrayUtils (line 71, column 1 - line 71, column 45): " + [ def.constructor.name, values.constructor.name ]);
    };
};
var normalize = function (values) {
    return function (maxValueOpt) {
        var maxVal = (function () {
            if (maxValueOpt instanceof Data_Maybe.Just) {
                return maxValueOpt.value0;
            };
            if (maxValueOpt instanceof Data_Maybe.Nothing) {
                return maxArray(0.0)(values);
            };
            throw new Error("Failed pattern match at Lattice.Utils.ArrayUtils (line 85, column 16 - line 87, column 39): " + [ maxValueOpt.constructor.name ]);
        })();
        var safeMax = (function () {
            var $32 = Data_Number["isFinite"](maxVal) && maxVal > 0.0;
            if ($32) {
                return maxVal;
            };
            return 1.0e-4;
        })();
        return map(function (v) {
            return v / safeMax;
        })(values);
    };
};
var mapRange = function (value) {
    return function (inMin) {
        return function (inMax) {
            return function (outMin) {
                return function (outMax) {
                    var range$prime = inMax - inMin;
                    var normalized = (value - inMin) / range$prime;
                    var $33 = range$prime === 0.0;
                    if ($33) {
                        return outMin;
                    };
                    return outMin + normalized * (outMax - outMin);
                };
            };
        };
    };
};
var lerp = function (a) {
    return function (b) {
        return function (t) {
            return a + (b - a) * t;
        };
    };
};
var isFiniteNumber = function (x) {
    return Data_Number["isFinite"](x);
};
var lerpFinite = function (a) {
    return function (b) {
        return function (t) {
            var result = a + (b - a) * t;
            var $34 = isFiniteNumber(result);
            if ($34) {
                return result;
            };
            return a;
        };
    };
};
var mapRangeFinite = function (value) {
    return function (inMin) {
        return function (inMax) {
            return function (outMin) {
                return function (outMax) {
                    var range$prime = inMax - inMin;
                    var normalized = (value - inMin) / range$prime;
                    var result = outMin + normalized * (outMax - outMin);
                    var $35 = range$prime === 0.0;
                    if ($35) {
                        return outMin;
                    };
                    var $36 = isFiniteNumber(result);
                    if ($36) {
                        return result;
                    };
                    return outMin;
                };
            };
        };
    };
};
var meanFinite = function (values) {
    var $37 = Data_Array["null"](values);
    if ($37) {
        return 0.0;
    };
    var sumVal = Data_Array.foldl(add)(0.0)(values);
    var result = sumVal / Data_Int.toNumber(Data_Array.length(values));
    var $38 = isFiniteNumber(result);
    if ($38) {
        return result;
    };
    return 0.0;
};
var findIndex$prime = Data_Array.findIndex;
var countWhere = function (pred) {
    var $43 = Data_Array.filter(pred);
    return function ($44) {
        return Data_Array.length($43($44));
    };
};
var clampFinite = function (minVal) {
    return function (maxVal) {
        return function (value) {
            if (value < minVal) {
                return minVal;
            };
            if (value > maxVal) {
                return maxVal;
            };
            if (Data_Boolean.otherwise) {
                return value;
            };
            throw new Error("Failed pattern match at Lattice.Utils.ArrayUtils (line 100, column 1 - line 100, column 52): " + [ minVal.constructor.name, maxVal.constructor.name, value.constructor.name ]);
        };
    };
};
var clamp = function (minVal) {
    return function (maxVal) {
        return function (value) {
            return max(minVal)(min(maxVal)(value));
        };
    };
};
export {
    clamp,
    lerp,
    mapRange,
    mean,
    maxArray,
    minArray,
    normalize,
    clampFinite,
    lerpFinite,
    mapRangeFinite,
    meanFinite,
    normalizeFinite,
    sumArray,
    productArray,
    variance,
    stdDev,
    countWhere,
    findIndex$prime,
    unique,
    zipWith$prime,
    range
};
//# sourceMappingURL=index.js.map
