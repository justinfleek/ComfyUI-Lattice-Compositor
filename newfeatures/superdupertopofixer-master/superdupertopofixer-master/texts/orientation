orientation:
-orientation of a triangle can be thought of in at least two ways
    -intrinsic: this is when we specify an order on the vertices of a triangle, this orientation is then defined on the triangle itself
    -extrinsic: CW or CCW, this is an orientation from the perspective of an outside observer, whose world position has to be specified, and changes as the observer's position changes; the same intrinsic orientatin is CW from one half-space of a triangle, CCW from the other half-space of the triangle, and undefined from the plane of the triangle

side of a triangle:
-to define the notion of a triangle's side, we need to define two things:
    -a property that can be meaningfully defined on a triangle in two complementing variants, we choose use the intrinsic orientation of the triangle to be this property)
    -a side rule for which of the two half-spaces (i.e. sides) of the triangle is associated with which of the two variants of the property (i.e. with which of the two intrinsic orientations in our case), our code uses two approaches here

side rule choice:
-the side rule for which intrinsic orientation is associated with which half-space of a triangle can be defined in the following ways
    -intrinsic: as a hand rule (right/left), directly associating the positive normal direction to an intrinsic orientation, irregardless of any outside spectator
    -extrinsic: by specifying a point P in space and choosing one of the {CW,CCW} orientations on a triangle, as seen from P, to be turned towards P, and the other to be turned away from P

our input: 
-the vertices on a triangle T (as it is read from input file) define an intrinsic orientation for the triangle, we call this orientation the 0-orientation of T, and the other orientation on T the 1-orientation
-for each triangle T, we define two sets of HCs so that they represent the two possible intrinsic orientations on T, according to how they follow next pointers; in other words we define the two sets of HCs in a way that for any vertex V of the triangle, and either of the triangle's HCs at V, following the next pointer of this HC, taking the dual, and again following next will always end up back at V
-when loading an input obj file, we save the first three HCs on a triangle T so that their next pointers follow the 0-orientation on T, i.e. the same intrinsic orientation as the triangle vertices in the input file, and the last three HCs, so that they follow the 1-orientation on T, i.e. the opposite intrinsic orientation
-importantly, we store the reference HC of a triangle to be one of the first three HC, so that when we query a triangle for a HC and follow along next pointers, we follow the triangle's 0-orientation (vertices are in the same order in which they were read from the input obj file)

-materials are stored on a triangle in the order in which they are read from the input file (this is important)
-the first three HCs on a triangle (the ones following along 0-orientation) have a flag set that says they relate to their triangle's 0-th material, last three HCs on a triangle (the ones following along 1-orientation) have a flag set that they relate to their triangle's 1-st material
-at this point, every triangle has its 6 HCs, each HC knows which label it relates to (0th or 1st), and each HC is associated with one of the triangle's intrinsic orientations (0 or 1), therefore we have an association of intrinsic orientations to material labels, but different triangles are not connected to each other (no oppos pointers set yet), and there is no rule for which intrinsic orientation of a triangle relates to which half-space (i.e. side) of the triangle, and therefore also which material of the triangle lies on which of its sides
-it follows that flipping the orientations on a triangle (by for example permutating the order of its vertices in the input file), while also swapping the order of its materials (can again be done in the input file), produces the same mesh (eg. will be accepted as a valid input), since given that both are flipped, the same material is assigned to the same orientation before and after the flip

OpenGL:
-in order to render a triangle T, OpenGL uses two pieces of information that enable it to determine T's color
    -we draw T twice, once per each intrinsic orientation (remember that each intrinsic orientation has a material and thus a color associated to it), each call of drawing a triangle therefore has an intrinsic orientation associated to it
    -OpenGL assumes a global extrinsic side rule choice, namely a system centered at the camera, and taking the CCW orientation of T to be on the side that is towards the camera, while CW orientation of T is considered to be away from the camera (and therefore pruned if the correct OpenGL flag is set)
-As already discussed, an orientation plus a side rule can be combined to uniquely determine the side of a triangle, and therefore to know what color to draw T from each side as position of the camera changes: we execute the command to draw T with one 0-orientation and its associated material color, then execute the command to draw T with its 1-orientation and its associated material color. OpenGL then determines which of these two orientations is CCW from the perspective of the camera, and draws T using the color that corresponds to the CCW orientation, pruning the other one.
-It still holds, that flipping both the orientation of T and its material order in the input file doesn't change the rendered result. This is because flipping both leads to a state where each intrinsic orientation is again assigned to the same material before and after the flip. If such a flip occurs, then the 0- and 1-orientations of T will have flipped (i.e. asking T for a HC and following its next pointers will result in traversing along T in a different way), but from the perspective of OpenGL (which intrinsic orientation is CCW from the point of view of the camera, and what is the material color associated to this intrinsic orientation), everything is the same.

assigning opposites:
-The last thing necessary to do during mesh input, is to assign HC opposites. For this, we need to specify a side rule. We will use the right hand rule. This is because using the right hand rule results in the same assignment of orientations to triangle sideas as what OpenGL does for rendering - given a fixed point P and a triangle T, saying that the orientation of T that is turned towards P is the CCW one is equivalent to saying that following the CCW orientation on T, the right hand normal of T points into the half-space containing P.
-We will assign opposites to HCs, assuming that the side of T determined by 0-orientation and the right hand rule should have the triangle's 0-th material.
-It is important to note, that what we do is assume (!!) that the triangles and materials in the input mesh file (specifically their orientation and order) are structured in such a way that after assigning opposite pointers to HCs using the right hand rule, we end up with a consistent mesh. Because this structure on triangles and materials is an assumption we make, after assigning opposite pointers to HCs, we have to check that the resulting mesh is indeed consistent (HCs that are opposites of each other are associated with the same material label).

We will now look more closely at the process of assigning opposites:
    -The assignment of opposite corners is independent for each mesh edge, we will therefore just focus on a single edge E.
    -We collect all the triangles that contain E. We refer to the vertex of such a triangle which is not contained within E as an extending vertex of E, and the HCs at an extending vertex as extending HCs.
    -Next, we impose an arbitrary orientation on E. An orientation on an edge just means specifying a direction, meaning which of the two endpoints of E is the start, and which is the end. The way we do this in practice is that we have an integer index assignment for each mesh vertex, and we order E from the lower index endpoint to the higher index endpoint.
    -Note that specifying an orientation on E also specifies an orientation on any triangle T that contains E. We will call a triangle orientation tau and an edge orientation epsilon compatible if following T along tau causes us to follow E along epsilon (and vice versa). Otherwise we call tau and epsilon incompatible. If only the orientation tau on T is given, we say that it induces a compatible orientation epsilon on E, and vice versa, given an orientation epsilon on E, we say that it induces a compatible orientation tau on T.
    -Note that when we do an orientation preserving projection of E onto an orthogonal plane (so that conceptually the start of E is closer to us than the end of E), or in other words, if we look along E from its starting point towards its endpoint, for an extending vertex it makes sense to consider one extending HC to be on the CW side with respect the orientation preserving projection, and one extending HC to be on the CCW side with respect to the orientation preserving projection.
    -We iterate over triangles containing E, and store one extending HC per such a triangle T. The choice of which of the two extending HCs to store is important. Assuming an orientation epsilon on E, we aim to store the HC that is on the side of T which we get from taking the orientation on T induced by epsilon, together with the right hand rule. If epsilon is compatible with the 0-orientation on T, we store the HC at the extending vertex that is associated with the 0-orientation on T. Similarly, if epsilon is not compatible with the 0-orientation on T, we store the HC at the extending vertex that is associated with the 1-orientation on T. This is another way of saying that we assume that the designer of the input file meant for the 0-material of T to be on the side of T that we get when taking the 0-orientation of T with the right hand rule, and for the 1-material of T to be on the side of T that we get when taking the 1-orientation of T with the right hand rule (or equivalently, when we take the 0-orientation of T with the left hand rule).
    -What we end up with is a collection of all extending HCs of E that are on the CW side in the orientation preserving projection described above. We could have similarly chosen to store HCs that are on the CCW side, by saving dual HCs when choosing which of the two extending HCs to store. However, the fact that we chose to store HCs on the CW side is important for the subsequent opposite poitner association.
    -In the next step, we iterate over the stored extending HCs, and for each one we partition the remaining HCs into two groups - those that lie in the left half plane, and those that lie in the right half plane in the orientation preserving projection of E. For every extending HC HC_base one of the following two cases holds:
        -There exists exactly one other extending HC HC_candidate, such that HC_candidate is to the right of HC_base, and the intersection of the extending HCs to the right of HC_base and to the left of HC_candidate is empty.
        -There are no extending HC to the right of HC_base, and there exists exactly one other HC HC_candidate, such that there are no HC to the left of HC_candidate.
    -In both cases above, we assign the opposite of HC_base to be the dual of HC_candidate and vice versa.
    -Note that several of the choices we make here are crucial for ensuring that the opposites are correctly assigned:
        -the fact that for each extending HC we look for an opposite candidate in the set of extending HCs that are to its right,
        -the fact that we assign the *opposite of the stored* extending HC to be the *dual of the candidate* HC.
    -We could also have made different choices, namely look for an opposite candidate in the set of extending HCs that are to the left of a given HC, and assign dual of the given HC to the candidate HC. However, in order to maintain a consistent assignment, if we change one choice, we also have to change the other.
    -Note that in case we stored exactly two extending HCs of E (i.e. E is manifold), the assignment can be simplified: as soon as we correctly store the two extending HCs of E, we can immediately assign the opposite of one HC to the dual of the other stored HC.
    -Also note, that in the case of exactly two extending HC, the choices of which side of a given base HC to look at when searching for an opposite HC candidate, and whether to take the given base HC or its dual in the opposite assignment can be violated, and the assignment is still correct. This is the reason why some bugs only surfaced when assigning opposites across a non-manifold edge, with no error in the manifold case.
    -In the case of a manifold edge, we can take a completely different route, and just assign opposites so that materials on the opposite HCs match. This also works for valence 3 non-manifold edges, and in general for any edges where the number of distinct materials on triangles adjacent to this edge is equal to the valence of the edge (in orther words, each local volume around the edge has a different material). However, this approach is not advisable, as it could result in an undesirable situation - if we for example flipped the materials on a single triangle and used the assignment of opposites just described, the loading of the mesh would succeed, and all consistency checks would be passed. However, a visual inspection would reveal the triangle to have its material colors flipped. Indeed, to discover this inconsistency, some form of geometric test would be necessary (such as the one done by OpenGL). If we were certain that the input mesh is consistent (i.e. that the assignment of intrinsic orientations to material labels produces in conjunction with the right hand rule a mesh where neighboring triangles have the same label on the same side), we could use this method to acquire the correct opposite assignment of material labels.

-It still holds, that flipping both the orientation of T and its material order in the input file results in the same mesh corner table. This is because the same intrinsic orientation of a triangle is still associated to the same material, just the order in which we store T's orientations and materials is flipped. Therefore, taking the 0-orientation of a triangle, using the right hand rule to determine a triangle's side, and labeling it with 0-th material will end up assigning the same material to the same side of T as before the flip.

experiment:
-Note that the way that OpenGL renders the mesh, and the way that opposite assignments work is very similar, but has some degree of independence. As such, mesh that seems visually correct (the materials are rendered consistently) does not always posses correct opposites assignment.
-Let's explore a scenario, where the input file is generated assuming the right hand rule, i.e. the author assumes that the side of triangle T determined by 0-orientation and the right hand rule should have the triangle's 0-th material, but we use the left hand rule for assigning opposites instead. The OpenGL rendering will look exactly the same, since OpenGL doesn't care about assigning opposites. However, for the purpose of assigning opposite pointers, the sides of a triangle will be assumed to be flipped, i.e. we assign opposite pointers as if we expected the author of the input file to want us to interpret 0th material of triangle T to lie on the side we get by combining 0-orientation of T and the left hand rule. This would result in a state where determining the sides of a triangle for rendering, and determining the sides of a triangle for mesh connectivity would be unsynchronized. In a manifold mesh, this wouldn't crash the program, though it would cause some issues, such as obtaining different than expected grid vertex labels in the labeling step of the algorithm. However, in a non-manifold mesh, we would end up assigining as opposites HC with different associated materials (put a picture here). This would be caught as a critical error, and lies at the heart of the bug that we experienced in marching cubes reconstruction.
-We can derive a more general point from the experiment above: the fact that a side rule is necessary for determining which intrinsic orientation of a triangle corresponds to which of its half-spaces, and the fact that OpenGL assumes a side rule in a specific built-in way means, that in certain situations the way that the mesh is drawn, and the way that it is connected is might not correspond to each other. Consequently, a mesh that is rendered in a way that is visually correct, might not be correctly connected.

grid labeling:
-Next time we implicitly use the right hand rule assumption is during grid labeling. When a ray intersects a triangle T, we determine whether the right hand normal of the 0-orientation of T is aligned along or against the direction of the ray. If the normal is aligned against the ray, we decrease the material vector count of the 0th material of T, and increase the count of the 1st material of T. Similarly, if the normal is aligned along the ray, we decrease the material vector count of the 1st material of T, and decrease the count of the 0th material of T. This way we again assume that in order to specify the side of a triangle, we use the right hand rule in conjunction with one of the triangle's intrinsic orientations.

cell separation:
-Next step where new triangles are generated, and oppposite pointers assigned, is during cell separation. In order to make sure that the new triangles will be consistent with the rest of the mesh, we have to make sure of the following two properties:
    -The assignment between intrinsic orientations and material labels on the new triangles is done correctly. Every new triangle T_new shares at least one edge E with an existing triangle T_old, therefore we can induce the orientation on E from 0-orientation on T_old, then use this orientation on E to induce an intrinsic orientation on T_new and save it as the 0-orientation on T_new. In other words, we assume the 0-orientation on T_new to be *equivalent* to the 0-orientation on T_old, in that they traverse E in the same direction. In practice we specify the 0-orientation for T_new by how we order its vertices when generating T_new. Then, we assign material labels on T_new to be ordered in the same way as material labels on T_old. Doing this will ensure that the assignment between intrinsic orientations and labels on T_old and T_new is consistent. Note that assignment between intrinsic orientations and material labels influences OpenGL rendering, therefore if we do it incorrectly, we would notice a visual discrepancy.
    -The assignment of opposite pointers in the region where new triangles are generated is done correctly. Assuming the all the new triangles have their 0-orientation induced from the 0-orientation of the old triangle, and have the same material order as the old triangle, we are certain the the assignment of HCs as it existed with the T_old is corrrect. We make use of this, by formulating the following two rules:
        -If the number of materials on triangles around an edge is equal to the valence of the edge (therefore always in the manifold case, and always for en edge of valence 3), we can always just connect HC on neighboring extending vertices that have the same material label. This is because we know from when we originally loaded the mesh, that the opposite HCs are assigned according to the right hand rule, and the mesh is afterwards consistent. If construct the new triangles in the way described, then they will obey the logic of 0-orientation plus right hand rule points to the side that has 0th material assigned, which describes our method for determining opposites. Given that this is true, the only possible assignment of opposites that preserves materials on HCs also preserves the method for assiging intrinsic orientations to triangle sides.
        -Specifically, when subdividing a triangle, we can assign opposite HCs that are within T_old by matching 0-orientation HCs to 0-orientation HCs and 1-orientation HCs to 1-orientation HCs. This is again a consequence of how we assigned orientations and materials to the new triangles.
        -When assigning an opposite HC to an already existing triangle across a non-manifold edge E, such that the number of materials on triangles around E is strictly less than the valence of E, we have to be more careful. We know that the new triangle T_new inherits the intrinsic orientations and material labels (and therefore consistency using the right hand rule) from T_old. Let's call X the vertex of the HC whose opposite we want to assign, and Y the vertex at which the two candidate opposite corners lie. Then there must have been a vertex Z of T_old, such that exactly one HC HC_Y at Y had its opposite HC_Z at Z. We assign HC_Y as the opposite of one of the HCs at X, namely the one that induces the same orientation on E as HC_Y.