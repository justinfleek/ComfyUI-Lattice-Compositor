
/* ValueTransferrer.cpp
 *
 * Peter Synak, Chris Wojtan, Huidong Yang, Aleksei Kalinov, Malina Strugaru, Arian Etemadi 2023
 *
 * Header for classes that facilitate transferring of values between input and output meshes.
 *
 */

#pragma once

//------------------------------------------------------------
// includes
//------------------------------------------------------------

#include <deque>

#include "../datastructures/Grid3DInterface.h"
#include "../datastructures/Mesh3DInterface.h"
#include "../modules/MultiLabelMarchingCuber.h"
#include "../datastructures/Mesh3DVertex.h"
#include "../schemes/TopoFixerSettings.h"

//------------------------------------------------------------
// classes
//------------------------------------------------------------

// this class manages the flow of the value transfer code
class ValueTransferrer {
 public:
	// constructors
	ValueTransferrer(const TopoFixerSettings& settings);
	~ValueTransferrer() = default;

	// Function that facilitates interpolating values that are stored on mesh vertices onto grid
	// vertices, calls private functions for individual tasks.
	int meshToGridTransfer(Mesh3DInterface& mesh, Grid3DInterface& grid);

	// Function that facilitates interpolating values that are stored on grid vertices onto mesh
	// vertices before resolving mesh upkeep. This implies that mesh vertices generated by marching
	// cubes are located in spcific positions (such as grid cell, face, and edge centers), and mesh
	// vertices generated by cell separator are located on front faces. Calls private functions for
	// individual tasks.
	int gridToMeshTransferBeforeMeshUpkeep(Mesh3DInterface& mesh, Grid3DInterface& grid);

	// Function that facilitates interpolating values that are stored on grid vertices onto mesh
	// vertices after resolving mesh upkeep. This means that no mesh vertices have guaranteed
	// positions, and are therefore never assumed to be located on a grid face or edge. As such,
	// interpolation of values onto them is always done using the 8 grid vertices of the cell they are
	// located in. For each vertex it is also necessary to check that it is located inside of the grid
	// (this could have changed during mesh upkeep).
	int gridToMeshTransferAfterMeshUpkeep(Mesh3DInterface& mesh, Grid3DInterface& grid);

	//-------------------- data retrieval functions

	// get the map that assigns to a grid cell the set of value giving mesh vertices inside it
	absl::flat_hash_map<long long, absl::flat_hash_set<Mesh3DVertex*>>&
	getValueGivingMeshVerticesPerCell() {
		return value_giving_mesh_verts_per_cell;
	}

	// get the map that assigns to a grid vertex the interpolated vertex properties on this vertex
	absl::flat_hash_map<long long, VertexProperties>& getVertPropsOnAllGridVerts() {
		return vert_props_on_grid_verts;
	}

	// get the map that assigns to a grid vertex the interpolated vertex properties on this vertex
	VertexProperties getVertPropsOnOneGridVertex(long long grid_vertex) {
		return vert_props_on_grid_verts[grid_vertex];
	}

	// get the set of value taking mesh vertices
	absl::flat_hash_set<Mesh3DVertex*>& getValueTakingMeshVertices() {
		return value_taking_mesh_verts;
	}

	// check whether input `mesh_vertex` is value taking
	bool isMeshVertexValueTaking(Mesh3DVertex* mesh_vertex) const {
		return value_taking_mesh_verts.count(mesh_vertex);
	}

	// get the set of grid vertices that had values spread onto them
	absl::flat_hash_set<long long>& getSpreadGridVertices() { return spread_grid_verts; }

	// get the vector of initial mesh vertex positions and vertex properties
	std::vector<std::pair<Vec3d, VertexProperties>>& getInitialMeshPositionsAndVertProps() {
		return initial_mesh_positions_and_vert_props;
	}

 private:
	const TopoFixerSettings* settings;
	//----------------- mesh-to-grid transfer functions

	// Coordinates retrieval of and storage of `value_giving_mesh_verts_per_cell` by calling
	// function `retrieveValueGivingMeshVerticesInGridCells` with parameters determined by input
	// parameter `value_giving_mesh_vertices`.
	void collectValueGivingMeshVertices(Mesh3DInterface& mesh, const Grid3DInterface& grid);

	// Fills in the map `value_giving_mesh_verts_per_cell` by iterating over triangles that overlap
	// `grid_cells`; if `reject_vertices_outside_cell_region` is true, vertices of a triangle are
	// added to `value_giving_mesh_vertices` only if they also lie inside `grid_cells`, otherwise
	// vertices are added regardless of which grid cell they lie in (such grid cell can be
	// arbitrarily far from the nearest complex cell when given sufficiently large mesh triangles).
	// NUMERICS: computing which grid cell does a point belong to is done naively, however, arriving
	// at a slightly perturbed result shouldn't cause issues
	void retrieveValueGivingMeshVerticesInGridCells(const Grid3DInterface& grid,
	                                                const absl::flat_hash_set<long long>& grid_cells,
	                                                bool reject_vertices_outside_cell_region);

	// Calculates values on value giving mesh vertices that are to be interpolated onto grid
	// vertices (eg. for APIC or PolyPIC transfer). For now, this is just a placeholder for
	// potential future use.
	void calculateValuesToTransfer() const;

	// Performs interpolation of values from value giving mesh vertices onto grid vertices, based on
	// interpolation method specified by input parameter "mesh_to_grid_interpolation_method".
	void interpolateValuesOntoGridVertices(const Grid3DInterface& grid);

	// Performs normalization of values on grid vertices, based on the method specified by input
	// parameter "grid_value_normalization_method".
	void normalizeGridValues(const Grid3DInterface& grid);

	// Spreads values to grid vertices specified by input parameter
	// `spreading_values_on_grid_method` that haven't had values assigned during execution of
	// `interpolateValuesOntoGridVertices`.
	void spreadValuesThroughGrid(Grid3DInterface& grid);

	// Performs one step of spread flood-filling. Values are spread to grid vertices without values
	// on them from all their neighbor grid vertices with values on them. New values on grid
	// vertices are normalized by the number of contributing grid neighbors. Returns a vector of grid
	// vertices that will be iterated over in the next step of the flood-fill.
	std::vector<long long> performOneSpreadStep(Grid3DInterface& grid,
	                                            const std::vector<long long>& value_spread_batch,
	                                            const int spread_to_complex_region_only);

	//----------------- mesh-to-grid transfer functions

	// Interpolates values from grid vertices onto mesh vertices that were generated by marching
	// cubes. These mesh vertices are saved inside mesh corner table in three sets, depending on
	// whether they were generated at a grid cell center, grid face center, or grid edge center.
	// Values are interpolated onto them from the neigboring 8/4/2 grid vertices respectively. The
	// special position of these vertices in/on their respective grid elements implies that both the
	// `trilinear` and `average_on_cell_vertices` choices for `grid_to_mesh_interpolation_method` use
	// the same weights, and therefore give the same result.
	void interpolateValuesOntoMarchingCubesVerticesBeforeUpkeep(Grid3DInterface& grid);

	// Interpolates values from grid vertices onto mesh vertices in front faces. These mesh vertices
	// are retrieved by traversing front faces and front edges. Values are interpolated onto them from
	// the neighboring 4/2 grid vertices respectively. These vertices don't have pre-determined
	// positions on their grid elements, therefore `trilinear` and `average_on_cell_vertices`
	// interpolation methods yield different results.
	void interpolateValuesOntoFrontVertices(Grid3DInterface& grid);

	// Interpolates values from grid vertices onto mesh vertices in simple cells, using the
	// neighboring 8 grid vertices. These vertices don't have pre-determined positions within their
	// cells, therefore `trilinear` and `average_on_cell_vertices` interpolation methods yield
	// different results. As this is a rather obscure interpolation choice, the method of retrieving
	// mesh vertices in simple cells is not optimized.
	void interpolateValuesOntoSimpleRegion(Mesh3DInterface& mesh, const Grid3DInterface& grid);

	// Interpolates values from grid vertices onto mesh vertices after mesh upkeep. Consequently, all
	// mesh vertices might have been moved from the positions in which they were generated. As such,
	// we assume no mesh vertex to have a pre-defined position, and therefore interpolate values onto
	// each mesh vertex from the 8 grid vertices of the grid cell that the mesh vertex is located in.
	// We also need to check that the mesh vertex lies inside the grid, since it could have been moved
	// away from the grid during mesh upkeep. We set values of vertices that lie outside of the grid
	// to zero. Lastly, we save mesh vertices that get values interpolated onto them in the set
	// `value_taking_mesh_verts`.
	void interpolateValuesOntoMeshVerticesAfterUpkeep(const Grid3DInterface& grid,
	                                                  Mesh3DVertex* mesh_vertex,
	                                                  int interpolation_method);

	void interpolateValuesOntoMeshVertexOnGridEdgeTrilinear(const Grid3DInterface& grid,
	                                                        long long grid_edge,
	                                                        Mesh3DVertex* mesh_vertex);
	void interpolateValuesOntoMeshVertexOnGridEdgeAverage(const Grid3DInterface& grid,
	                                                      long long grid_edge,
	                                                      Mesh3DVertex* mesh_vertex);
	void interpolateValuesOntoMeshVertexOnGridFaceTrilinear(const Grid3DInterface& grid,
	                                                        long long grid_face,
	                                                        Mesh3DVertex* mesh_vertex);
	void interpolateValuesOntoMeshVertexOnGridFaceAverage(const Grid3DInterface& grid,
	                                                      long long grid_face,
	                                                      Mesh3DVertex* mesh_vertex);
	void interpolateValuesOntoMeshVertexInGridCellTrilinear(const Grid3DInterface& grid,
	                                                        long long grid_cell,
	                                                        Mesh3DVertex* mesh_vertex);
	void interpolateValuesOntoMeshVertexInGridCellAverage(const Grid3DInterface& grid,
	                                                      long long grid_cell,
	                                                      Mesh3DVertex* mesh_vertex);

	//----------------- helper functions

	// Initializes vertex properties on all grid vertices that have a value giving mesh vertex nearby to the
	// zero vector (by default Vec3d would initialize to three times DOUBLE_MIN).
	void initializeVertPropsOnGridVertsMap(const Grid3DInterface& grid);

	void saveMeshValuesForVisualization();

	//-------------------- data members

	// maps a grid cell id to a set of value giving mesh vertices inside this cell
	absl::flat_hash_map<long long, absl::flat_hash_set<Mesh3DVertex*>>
	    value_giving_mesh_verts_per_cell;

	// maps the id of a grid vertex to an interpolated value on this grid vertex
	absl::flat_hash_map<long long, VertexProperties> vert_props_on_grid_verts;

	// set of value taking mesh vertices
	absl::flat_hash_set<Mesh3DVertex*> value_taking_mesh_verts;

	//-------------------- visualization

	// flag that determines whether visualization data is to be stored
	bool save_visualization_data;

	// vector containing the initial mesh vertex positions and vertex properties
	std::vector<std::pair<Vec3d, VertexProperties>> initial_mesh_positions_and_vert_props;

	// set of grid vertices that received their values via spreading, rather than interpolation from
	// mesh vertices, used for rendering
	absl::flat_hash_set<long long> spread_grid_verts;
};