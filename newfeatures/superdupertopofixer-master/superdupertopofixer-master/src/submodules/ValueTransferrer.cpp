/* ValueTransferrer.cpp
 *
 * Peter Synak, Chris Wojtan, Huidong Yang, Aleksei Kalinov, Malina Strugaru, Arian Etemadi 2023
 *
 * Implementation of the class that manages transferring values between input and output meshes.
 */

//------------------------------------------------------------
// includes
//------------------------------------------------------------

#include "ValueTransferrer.h"

//------------------------------------------------------------
// constructors
//------------------------------------------------------------

// default constructor
ValueTransferrer::ValueTransferrer(const TopoFixerSettings& settings) : settings(&settings) {
	save_visualization_data = settings.visualize_value_transfer;
}

//------------------------------------------------------------
// coordinating functions
//------------------------------------------------------------

// function that coordinates the mesh-to-grid value transfer, always returns 0
int ValueTransferrer::meshToGridTransfer(Mesh3DInterface& mesh, Grid3DInterface& grid) {
	// if no mesh vertices are chosen to be value giving, return
	if (settings->value_giving_mesh_vertices == TopoFixerSettings::ValueGivingMeshVertices::None) {
		if (settings->verbosity >= 1) {
			std::cout << "-set of value giving mesh vertices is chosen to be empty, mesh-to-grid value "
			             "transfer trivially finished with return value 0"
			          << std::endl;
			std::cout
			    << "====================================================================================="
			    << std::endl;
		}
		return 0;
	}

	collectValueGivingMeshVertices(mesh, grid);
	calculateValuesToTransfer();
	saveMeshValuesForVisualization();
	initializeVertPropsOnGridVertsMap(grid);
	interpolateValuesOntoGridVertices(grid);
	normalizeGridValues(grid);
	spreadValuesThroughGrid(grid);

	if (settings->verbosity >= 1) {
		std::cout << "-value transferrer finished with return value 0" << std::endl;
		std::cout
		    << "====================================================================================="
		    << std::endl;
	}
	return 0;
}

// function that coordinates the grid-to-mesh value transfer before mesh upkeep, always returns 0
int ValueTransferrer::gridToMeshTransferBeforeMeshUpkeep(Mesh3DInterface& mesh,
                                                         Grid3DInterface& grid) {
	// if no mesh vertices were chosen to be value giving, then there is nothing to interpolate,
	// return
	if (settings->value_giving_mesh_vertices == TopoFixerSettings::ValueGivingMeshVertices::None) {
		if (settings->verbosity >= 1) {
			std::cout << "-set of value giving mesh vertices is chosen to be empty, grid-to-mesh value "
			             "transfer trivially finished with return value 0"
			          << std::endl;
			std::cout << "============================================================================="
			             "========"
			          << std::endl;
		}
		return 0;
	}

	// if no mesh vertices were chosen to be value taking, then there is nothing to interpolate,
	// return
	if (settings->value_taking_mesh_vertices == TopoFixerSettings::ValueTakingMeshVertices::None) {
		if (settings->verbosity >= 1) {
			std::cout << "-set of value taking mesh vertices is chosen to be empty, grid-to-mesh value "
			             "transfer trivially finished with return value 0"
			          << std::endl;
			std::cout << "============================================================================="
			             "========"
			          << std::endl;
		}
		return 0;
	}

	// --------- interpolate onto marching cubes vertices

	// for the remaining choices of `value_taking_mesh_vertices` parameter, we interpolate values onto
	// mesh vertices generated by marching cubes
	interpolateValuesOntoMarchingCubesVerticesBeforeUpkeep(grid);
	// if `value_taking_mesh_vertices` are the vertices generated by marching cubes, we are finished
	if (settings->value_taking_mesh_vertices == TopoFixerSettings::ValueTakingMeshVertices::New) {
		return 0;
	}

	// --------- interpolate onto front face vertices

	// for the remaining choices of `value_taking_mesh_vertices` parameter, we interpolate values onto
	// front face mesh vertices
	interpolateValuesOntoFrontVertices(grid);
	// if `value_taking_mesh_vertices` are the vertices generated by marching cubes and the vertices
	// in front faces, we are finished
	if (settings->value_taking_mesh_vertices ==
	    TopoFixerSettings::ValueTakingMeshVertices::NewAndFront) {
		return 0;
	}

	// --------- interpolate onto simple region vertices

	// for the only remaining choice of `value_taking_mesh_vertices` parameter, namely "all", we
	// interpolate values onto mesh vertices in the simple region
	interpolateValuesOntoSimpleRegion(mesh, grid);

	return 0;
}

// function that coordinates the grid-to-mesh value transfer after mesh upkeep, always returns 0
int ValueTransferrer::gridToMeshTransferAfterMeshUpkeep(Mesh3DInterface& mesh,
                                                        Grid3DInterface& grid) {
	// if no mesh vertices were chosen to be value giving, then there is nothing to interpolate,
	// return
	if (settings->value_giving_mesh_vertices == TopoFixerSettings::ValueGivingMeshVertices::None) {
		if (settings->verbosity >= 1) {
			std::cout << "-set of value giving mesh vertices is chosen to be empty, grid-to-mesh value "
			             "transfer trivially finished with return value 0"
			          << std::endl;
			std::cout << "============================================================================="
			             "========"
			          << std::endl;
		}
		return 0;
	}
	// if no mesh vertices were chosen to be value taking, then there is nothing to interpolate,
	// return
	if (settings->value_taking_mesh_vertices == TopoFixerSettings::ValueTakingMeshVertices::None) {
		if (settings->verbosity >= 1) {
			std::cout << "-set of value taking mesh vertices is chosen to be empty, grid-to-mesh value "
			             "transfer trivially finished with return value 0"
			          << std::endl;
			std::cout << "============================================================================="
			             "========"
			          << std::endl;
		}
		return 0;
	}

	// convert the grid-to-mesh interpolation method into a number to avoid input parameter queries
	auto interpolation_method_name = settings->grid_to_mesh_interpolation_method;
	int interpolation_method_mode = 0;
	if (interpolation_method_name == TopoFixerSettings::GridToMeshInterpolationMethod::Trilinear) {
		interpolation_method_mode = 1;
	} else if (interpolation_method_name ==
	           TopoFixerSettings::GridToMeshInterpolationMethod::AverageOnCellVertices) {
		interpolation_method_mode = 2;
	}

	// --------- interpolate onto marching cubes vertices

	// for the remaining choices of `value_taking_mesh_vertices` parameter, we interpolate values onto
	// mesh vertices that were originally generated by marching cubes, and potentially moved by mesh
	// upkeep since then

	// interpolate values onto mesh vertices originally generated by marching cubes inside grid cells
	for (const auto& [mesh_vertex, cell_id] : grid.getNewMeshVerticesInCells()) {
		interpolateValuesOntoMeshVerticesAfterUpkeep(grid, mesh_vertex, interpolation_method_mode);
	}

	// interpolate values onto mesh vertices originally generated by marching cubes on grid faces
	for (const auto& [mesh_vertex, face_id] : grid.getNewMeshVerticesOnFaces()) {
		interpolateValuesOntoMeshVerticesAfterUpkeep(grid, mesh_vertex, interpolation_method_mode);
	}

	// interpolate values onto mesh vertices originally generated by marching cubes on grid edges
	for (const auto& [mesh_vertex, edge_id] : grid.getNewMeshVerticesOnEdges()) {
		interpolateValuesOntoMeshVerticesAfterUpkeep(grid, mesh_vertex, interpolation_method_mode);
	}

	// if `value_taking_mesh_vertices` are only the vertices generated by marching cubes, we are
	// finished
	if (settings->value_taking_mesh_vertices == TopoFixerSettings::ValueTakingMeshVertices::New) {
		return 0;
	}

	// --------- interpolate onto front face vertices

	// for the remaining choices of `value_taking_mesh_vertices` parameter, we interpolate values onto
	// front face mesh vertices

	// iterate over front faces
	for (long long front_face : grid.getFrontFacesVector()) {
		// iterate over front face graph edges
		for (const auto& [graph_edge, nearby_triangle] : grid.getGraphOnFace(front_face)) {
			// both endpoints of a graph edge are mesh vertices, for each we check if it has already
			// been processed, and if not, we interpolate values onto it
			if (!value_taking_mesh_verts.count(graph_edge.first)) {
				interpolateValuesOntoMeshVerticesAfterUpkeep(grid, graph_edge.first,
				                                             interpolation_method_mode);
			}
			if (!value_taking_mesh_verts.count(graph_edge.second)) {
				interpolateValuesOntoMeshVerticesAfterUpkeep(grid, graph_edge.second,
				                                             interpolation_method_mode);
			}
		}
	}

	// if `value_taking_mesh_vertices` are the vertices generated by marching cubes and the vertices
	// in front faces, we are finished
	if (settings->value_taking_mesh_vertices ==
	    TopoFixerSettings::ValueTakingMeshVertices::NewAndFront) {
		return 0;
	}

	// --------- interpolate onto simple region vertices

	// for the only remaining choice of `value_taking_mesh_vertices` parameter, namely "all", we
	// interpolate values onto mesh vertices in the simple region

	for (Mesh3DVertex* current_mesh_vertex : mesh.ListVertices()) {
		// check if `current_mesh_vertex` hasn't had value interpolated onto it yet, and if not,
		// interpolate values onto it
		if (!value_taking_mesh_verts.count(current_mesh_vertex)) {
			interpolateValuesOntoMeshVerticesAfterUpkeep(grid, current_mesh_vertex,
			                                             interpolation_method_mode);
		}
	}

	return 0;
}

//------------------------------------------------------------
// mesh-to-grid transfer functions
//------------------------------------------------------------

// coordinates filling in of the map `value_giving_mesh_verts_per_cell` with mesh vertices
// specified by input parameter `value_giving_mesh_vertices` by calling
// `retrieveValueGivingMeshVerticesInGridCells`
void ValueTransferrer::collectValueGivingMeshVertices(Mesh3DInterface& mesh,
                                                      const Grid3DInterface& grid) {
	if (settings->value_giving_mesh_vertices == TopoFixerSettings::ValueGivingMeshVertices::All) {
		// value giving mesh vertices: all mesh vertices
		for (Mesh3DVertex* vert : mesh.ListVertices()) {
			value_giving_mesh_verts_per_cell[grid.getCellIdForPoint(vert->getCoords())].insert(vert);
		}
		return;
	} else if (settings->value_giving_mesh_vertices ==
	           TopoFixerSettings::ValueGivingMeshVertices::InComplexCells) {
		// value giving mesh vertices: mesh vertices in complex cells
		absl::flat_hash_set<long long> complex_cells =
		    grid.getComplexCellsSet(Grid3DInterface::ComplexCellType::kFixed);
		retrieveValueGivingMeshVerticesInGridCells(grid, complex_cells, true);
		return;
	} else if (settings->value_giving_mesh_vertices ==
	           TopoFixerSettings::ValueGivingMeshVertices::InSimpleFront) {
		// value giving mesh vertices: mesh vertices in simple front cells
		absl::flat_hash_set<long long> simple_region_front_cells = grid.getSimpleRegionFrontCellsSet();
		retrieveValueGivingMeshVerticesInGridCells(grid, simple_region_front_cells, true);
		return;
	} else if (settings->value_giving_mesh_vertices ==
	           TopoFixerSettings::ValueGivingMeshVertices::InComplexCellsPlusSimpleFront) {
		// value giving mesh vertices: mesh vertices in complex cells and in simple front cells
		absl::flat_hash_set<long long> combined_cells = grid.getSimpleRegionFrontCellsSet();
		combined_cells.merge(grid.getComplexCellsSet(Grid3DInterface::ComplexCellType::kFixed));
		retrieveValueGivingMeshVerticesInGridCells(grid, combined_cells, true);
		return;
	} else if (settings->value_giving_mesh_vertices ==
	           TopoFixerSettings::ValueGivingMeshVertices::OnTrisInComplexCells) {
		// value giving mesh vertices: mesh vertices on triangles that intersect complex cells
		absl::flat_hash_set<long long> complex_cells =
		    grid.getComplexCellsSet(Grid3DInterface::ComplexCellType::kFixed);
		retrieveValueGivingMeshVerticesInGridCells(grid, complex_cells, false);
		return;
	} else if (settings->value_giving_mesh_vertices ==
	           TopoFixerSettings::ValueGivingMeshVertices::OnTrisInSimpleFront) {
		// value giving mesh vertices: mesh vertices on triangles that intersect simple front cells
		absl::flat_hash_set<long long> simple_region_front_cells = grid.getSimpleRegionFrontCellsSet();
		retrieveValueGivingMeshVerticesInGridCells(grid, simple_region_front_cells, false);
		return;
	} else if (settings->value_giving_mesh_vertices ==
	           TopoFixerSettings::ValueGivingMeshVertices::OnTrisInComplexCellsPlusSimpleFront) {
		// value giving mesh vertices: mesh vertices on triangles that intersect complex cells or
		// simple front cells
		absl::flat_hash_set<long long> combined_cells = grid.getSimpleRegionFrontCellsSet();
		combined_cells.merge(grid.getComplexCellsSet(Grid3DInterface::ComplexCellType::kFixed));
		retrieveValueGivingMeshVerticesInGridCells(grid, combined_cells, false);
		return;
	}
}

// fills in the map `value_giving_mesh_verts_per_cell`
void ValueTransferrer::retrieveValueGivingMeshVerticesInGridCells(
    const Grid3DInterface& grid, const absl::flat_hash_set<long long>& grid_cells,
    bool reject_vertices_outside_cell_region) {
	// helper set that keeps already processed triangles in order to avoid recomputation
	absl::flat_hash_set<Mesh3DTriangle*> processed_triangles;
	// iterate over input `grid_cells`
	for (long long cell_id : grid_cells) {
		// iterate over triangles in `grid_cells`
		for (Mesh3DTriangle* triangle : grid.getCellTriangles(cell_id)) {
			// make sure triangles aren't processed multiple times
			if (processed_triangles.count(triangle)) {
				continue;
			}
			processed_triangles.insert(triangle);
			// iterate over `triangle` vertices
			for (int i = 0; i < 3; ++i) {
				// determine which grid cell does `triangle`'s vertex lie in
				long long vertex_cell = grid.getCellIdForPoint(triangle->getVertex(i)->getCoords());
				// if `reject_vertices_outside_cell_region` is true, check whether `vertex_cell` is in
				// `grid_cells`, if yes, add it to `value_giving_mesh_verts_per_cell`
				if (reject_vertices_outside_cell_region) {
					if (grid_cells.count(vertex_cell)) {
						value_giving_mesh_verts_per_cell[vertex_cell].insert(triangle->getVertex(i));
					}
				} else {
					// add `triangle`'s vertices to `value_giving_mesh_verts_per_cell`
					value_giving_mesh_verts_per_cell[vertex_cell].insert(triangle->getVertex(i));
				}
			}
		}
	}
}

// calculates values on value giving mesh vertices that are to be interpolated onto grid vertices
// (eg. for APIC or PolyPIC transfer); for now, this is just a placeholder for potential future
// use
void ValueTransferrer::calculateValuesToTransfer() const {}

// interpolates values from value giving mesh vertices onto grid vertices
void ValueTransferrer::interpolateValuesOntoGridVertices(const Grid3DInterface& grid) {
	if (settings->mesh_to_grid_interpolation_method ==
	    TopoFixerSettings::MeshToGridInterpolationMethod::Trilinear) {
		// retrieve the length of a grid cell side
		double cell_edge_length = grid.get_cell_dx();
		// iterate over `value_giving_mesh_verts_per_cell`
		for (const auto& [grid_cell, mesh_vertices] : value_giving_mesh_verts_per_cell) {
			// iterate over the set of value giving mesh vertices in `grid_cell`
			for (Mesh3DVertex* mesh_vertex : mesh_vertices) {
				// retrieve a vector of the 8 grid vertices of `grid_cell`
				std::vector<long long> cell_verts = grid.get_verts_neighboring_cell(grid_cell);

				// retrieve world coordinates of the two extremal vertices of `grid_cell`, i.e. vertices
				// with the smallest and largest world coordinates, i.e. vertices with relative grid
				// cordinates (i,j,k) and (i+1,j+1,k+1)
				Vec3d xyz_min = grid.getVertexPosition(cell_verts[0]);
				Vec3d xyz_max = grid.getVertexPosition(cell_verts[7]);

				// calculate the displacement vector of `mesh_vertex` from the extremal vertices;
				// normalize the vectors so that their components are proportions of the grid edge length
				// rather than absolute values; adding the two resulting vectors together should give the
				// result (1.0,1.0,1.0) modulo numerical imprecision
				Vec3d offset_min = (mesh_vertex->getCoords() - xyz_min) / cell_edge_length;
				Vec3d offset_max = (xyz_max - mesh_vertex->getCoords()) / cell_edge_length;

				// ASSERT: dispalcement should be non-negative in all components
				assert(offset_min[0] > 0.0 && offset_min[1] > 0.0 && offset_min[2] > 0.0);
				assert(offset_max[0] > 0.0 && offset_max[1] > 0.0 && offset_max[2] > 0.0);

				// for illustration, we think of the 8 grid vertices consitituting `grid_cell` as having
				// grid coordinates between (i,j,k) and (i+1,j+1,k+1)
				// interpolate vertex properties onto grid vertex with coordinates (i,j,k)
				vert_props_on_grid_verts[cell_verts[0]].iadd(
				    mesh_vertex->getProperties(), (offset_max[0] * offset_max[1] * offset_max[2]));
				// interpolate vertex properties onto grid vertex with coordinates (i+1,j,k)
				vert_props_on_grid_verts[cell_verts[1]].iadd(
				    mesh_vertex->getProperties(), (offset_min[0] * offset_max[1] * offset_max[2]));
				// interpolate vertex properties onto grid vertex with coordinates (i,j+1,k)
				vert_props_on_grid_verts[cell_verts[2]].iadd(
				    mesh_vertex->getProperties(), (offset_max[0] * offset_min[1] * offset_max[2]));
				// interpolate vertex properties onto grid vertex with coordinates (i,j,k+1)
				vert_props_on_grid_verts[cell_verts[3]].iadd(
				    mesh_vertex->getProperties(), (offset_max[0] * offset_max[1] * offset_min[2]));
				// interpolate vertex properties onto grid vertex with coordinates (i+1,j+1,k)
				vert_props_on_grid_verts[cell_verts[4]].iadd(
				    mesh_vertex->getProperties(), (offset_min[0] * offset_min[1] * offset_max[2]));
				// interpolate vertex properties onto grid vertex with coordinates (i,j+1,k+1)
				vert_props_on_grid_verts[cell_verts[5]].iadd(
				    mesh_vertex->getProperties(), (offset_max[0] * offset_min[1] * offset_min[2]));
				// interpolate vertex properties onto grid vertex with coordinates (i+1,j,k+1)
				vert_props_on_grid_verts[cell_verts[6]].iadd(
				    mesh_vertex->getProperties(), (offset_min[0] * offset_max[1] * offset_min[2]));
				// interpolate vertex properties onto grid vertex with coordinates (i+1,j+1,k+1)
				vert_props_on_grid_verts[cell_verts[7]].iadd(
				    mesh_vertex->getProperties(), (offset_min[0] * offset_min[1] * offset_min[2]));
			}
		}
	} else if (settings->mesh_to_grid_interpolation_method ==
	           TopoFixerSettings::MeshToGridInterpolationMethod::AverageInCell) {
		// iterate over `value_giving_mesh_verts_per_cell`
		for (const auto& [grid_cell, mesh_vertices] : value_giving_mesh_verts_per_cell) {
			// calculate the average of vertex properties on mesh vertices in `grid_cell`
			VertexProperties avg_of_vert_props_in_cell;
			for (Mesh3DVertex* mesh_vertex : mesh_vertices) {
				avg_of_vert_props_in_cell.iadd(mesh_vertex->getProperties());
			}
			avg_of_vert_props_in_cell.idiv(static_cast<double>(mesh_vertices.size()));

			// add the calculated average vertex properties to the 8 grid vertices of `grid_cell`
			for (long long grid_vertex : grid.get_verts_neighboring_cell(grid_cell)) {
				vert_props_on_grid_verts[grid_vertex].iadd(avg_of_vert_props_in_cell);
			}
		}
	}
}

// normalizes the values stored on grid vertices based on input parameter
// `grid_value_normalization_method`
void ValueTransferrer::normalizeGridValues(const Grid3DInterface& grid) {
	if (settings->grid_value_normalization_method ==
	    TopoFixerSettings::GridValueNormalizationMethod::None) {
		return;
	} else if (settings->grid_value_normalization_method ==
	           TopoFixerSettings::GridValueNormalizationMethod::NumContributingValues) {
		// iterate over grid vertices with interpolated values
		for (auto& [grid_vertex, vert_props] : vert_props_on_grid_verts) {
			// determine the number of contributing mesh vertices for `grid_vertex`
			int contributing_mesh_vertices = 0;
			for (long long nearby_cell : grid.get_cells_neighboring_vertex(grid_vertex)) {
				if (value_giving_mesh_verts_per_cell.count(nearby_cell)) {
					contributing_mesh_vertices += value_giving_mesh_verts_per_cell[nearby_cell].size();
				}
			}

			// ASSERT: any grid vertex saved in "vert_props_on_grid_verts" should have at least one
			// contributing value giving mesh vertex
			assert(contributing_mesh_vertices != 0);
			vert_props.idiv(static_cast<double>(contributing_mesh_vertices));
		}
	} else if (settings->grid_value_normalization_method ==
	           TopoFixerSettings::GridValueNormalizationMethod::ExpectedEightValues) {
		// iterate over grid vertices with interpolated values
		for (auto& [grid_vertex, vert_props] : vert_props_on_grid_verts) {
			// determine the number of contributing mesh vertices for `grid_vertex`
			int contributing_mesh_vertices = 0;
			for (long long nearby_cell : grid.get_cells_neighboring_vertex(grid_vertex)) {
				if (value_giving_mesh_verts_per_cell.count(nearby_cell)) {
					contributing_mesh_vertices += value_giving_mesh_verts_per_cell[nearby_cell].size();
				}
			}

			// ASSERT: any grid vertex saved in "vert_props_on_grid_verts" should have at least one
			// contributing value giving mesh vertex
			assert(contributing_mesh_vertices != 0);
			vert_props.imul(8.0 / static_cast<double>(contributing_mesh_vertices));
		}
	} else if (settings->grid_value_normalization_method ==
	           TopoFixerSettings::GridValueNormalizationMethod::NumContributingCells) {
		// iterate over grid vertices with interpolated values
		for (auto& [grid_vertex, vert_props] : vert_props_on_grid_verts) {
			// determine the number of nearby cells of `grid_vertex` with at least one contributing mesh
			// vertex
			int contributing_grid_cells = 0;
			for (long long nearby_cell : grid.get_cells_neighboring_vertex(grid_vertex)) {
				if (value_giving_mesh_verts_per_cell.count(nearby_cell)) {
					contributing_grid_cells++;
				}
			}

			// ASSERT: any grid vertex saved in "vert_props_on_grid_verts" should have at least one nearby
			// grid cell with a contributing value giving mesh vertex
			assert(contributing_grid_cells != 0);
			vert_props.idiv(static_cast<double>(contributing_grid_cells));
		}
	}
}

// spreads values to grid vertices that didn't get a value interpolated onto them based on the input
// parameter `spreading_values_on_grid_method`
void ValueTransferrer::spreadValuesThroughGrid(Grid3DInterface& grid) {
	// if the set of chosen grid spread vertices is empty, return (values on grid vertices without
	// values saved will be assumed to be zero)
	if (settings->spreading_values_on_grid_method ==
	    TopoFixerSettings::SpreadingValuesOnGridMethod::None) {
		return;
	}

	// if there is no value stored on any grid vertex, there is nothing to be spread, return (values
	// on all grid vertices will be assumed to be zero)
	if (vert_props_on_grid_verts.empty()) {
		return;
	}
	// convert the mode of spreading into a number to avoid parameter retrieval queries
	auto spread_mode_name = settings->spreading_values_on_grid_method;
	int spread_mode = 0;
	if (spread_mode_name ==
	    TopoFixerSettings::SpreadingValuesOnGridMethod::FloodFillOntoAllGridVertices) {
		spread_mode = 1;
	} else if (spread_mode_name ==
	           TopoFixerSettings::SpreadingValuesOnGridMethod::FloodFillOntoComplexRegion) {
		spread_mode = 2;
	}

	// cast those grid vertices, that had values interpolated onto them, into a vector
	std::vector<long long> value_spread_batch;
	value_spread_batch.reserve(vert_props_on_grid_verts.size());
	for (const auto& [grid_vertex, vert_props] : vert_props_on_grid_verts) {
		value_spread_batch.push_back(grid_vertex);
	}
	// flood fill based spreading
	if (spread_mode == 1) {
		do {
			// perform one step of the flood fill, it returns a vector of grid vertices, which had values
			// spread onto them during this flood fill step
			value_spread_batch = performOneSpreadStep(grid, value_spread_batch, 0);
			// check if the vector is empty, if yes, it means that no new grid vertices had values spread
			// onto them in the last flood fill step, and therefore the flood fill is finished
		} while (!value_spread_batch.empty());
	} else if (spread_mode == 2) {
		do {
			// perform one step of the flood fill, it returns a vector of grid vertices, which had values
			// spread onto them during this flood fill step
			value_spread_batch = performOneSpreadStep(grid, value_spread_batch, 1);
			// check if the vector is empty, if yes, it means that no new grid vertices had values spread
			// onto them in the last flood fill step, and therefore the flood fill is finished
		} while (!value_spread_batch.empty());

		// check that all grid vertices in the complex region have values assigned
		bool has_not_spread = false;
		for (long long complex_cell :
		     grid.getComplexCellsSet(Grid3DInterface::ComplexCellType::kBoth)) {
			for (long long cell_vertex : grid.get_verts_neighboring_cell(complex_cell)) {
				if (!vert_props_on_grid_verts.count(cell_vertex)) {
					has_not_spread = true;
					break;
				}
			}
			if (has_not_spread) {
				break;
			}
		}
		if (has_not_spread) {
			std::cout << "-WARNING: values were not spread onto all grid vertices in the complex "
			             "region\n";
		}
	}
}

// performs one step of spread flood-filling, returns a vector of grid vertices for the next
// flood-filling step
std::vector<long long> ValueTransferrer::performOneSpreadStep(
    Grid3DInterface& grid, const std::vector<long long>& value_spread_batch,
    const int spread_to_complex_region_only) {
	// return vector that contains grid vertex ids of grid vertices that get values spread onto them
	// during the current flood fill step
	std::vector<long long> next_step_value_spread_batch;

	// a map that assigns to a grid vertex, that gets a value assigned to it within this step of the
	// flood fill, the pair (value spread onto this grid vertex, number of neighbor grid vertices that
	// contributed to this value)
	absl::flat_hash_map<long long, std::pair<VertexProperties, long long>>
	    spread_vertex_value_and_counter;
	// iterate over the current batch of grid vertices that spread their values
	for (long long grid_vertex : value_spread_batch) {
		const VertexProperties& vert_props = vert_props_on_grid_verts[grid_vertex];

		// helper variable for iterating over the 6 grid neighbors of `grid_vertex` (each is offset
		// in one of 6 directions)
		int direction = 0;
		// iterate over the 6 grid neighbors of `grid_vertex`
		for (; direction < 6; ++direction) {
			// retrieve the neighbour vertex
			long long neigh_vertex = grid.get_vertex_neighboring_vertex(grid_vertex, direction);
			// if the neighbor vertex is outside of the grid, skip it
			if (neigh_vertex == -1) {
				continue;
			}
			// in case values can only be spread to grid vertices in the complex region (determined by
			// `spread_to_complex_region_only`), skip neighbors that are not in the complex region
			if (spread_to_complex_region_only && !grid.isVertexInComplexRegion(neigh_vertex)) {
				continue;
			}

			// if `neigh_vertex` has no value stored on it, assign it in `spread_vertex_value_and_counter`
			// the value on `grid_vertex`, and increase its counter of contributors; this information will
			// be used to normalize the spread value for `neigh_vertex`
			if (!vert_props_on_grid_verts.count(neigh_vertex)) {
				// we handle the case where the value is assigned to a grid vertex for the first time
				// separately, in order to make sure that it is correctly initialized
				if (!spread_vertex_value_and_counter.count(neigh_vertex)) {
					spread_vertex_value_and_counter[neigh_vertex] = {vert_props, 1};
					// if visualization of value transfer is enabled, save `neigh_vertex` as a spread vertex
					// for visualization
					if (save_visualization_data) {
						spread_grid_verts.insert(neigh_vertex);
					}
				} else {
					spread_vertex_value_and_counter[neigh_vertex].first.iadd(vert_props);
					spread_vertex_value_and_counter[neigh_vertex].second++;
				}
			}
		}
	}

	// normalize values on grid vertices that had values assigned to them in this step of the flood
	// fill by their number of contributing grid vertices, move the value to
	// `vert_props_on_grid_verts` and add the vertex to the return vector
	for (auto& [grid_vertex, value] : spread_vertex_value_and_counter) {
		vert_props_on_grid_verts[grid_vertex] = value.first.div(static_cast<double>(value.second));
		next_step_value_spread_batch.push_back(grid_vertex);
	}

	// return the vector of grid vertex ids, it will be used in the next flood fill step
	return next_step_value_spread_batch;
}

//------------------------------------------------------------
// grid-to-mesh transfer functions
//------------------------------------------------------------

// interpolates values before mesh upkeep from grid vertices onto mesh vertices that were generated
// by marching cubes
void ValueTransferrer::interpolateValuesOntoMarchingCubesVerticesBeforeUpkeep(
    Grid3DInterface& grid) {
	// interpolate values onto mesh vertices generated by marching cubes that lie inside grid cells
	// and store these mesh vertices as having had values interpolated onto them
	for (const auto& [mesh_vertex, cell_id] : grid.getNewMeshVerticesInCells()) {
		interpolateValuesOntoMeshVertexInGridCellAverage(grid, cell_id, mesh_vertex);
		value_taking_mesh_verts.insert(mesh_vertex);
	}

	// interpolate values onto mesh vertices generated by marching cubes that lie on grid faces and
	// store these mesh vertices as having had values interpolated onto them
	for (const auto& [mesh_vertex, face_id] : grid.getNewMeshVerticesOnFaces()) {
		interpolateValuesOntoMeshVertexOnGridFaceAverage(grid, face_id, mesh_vertex);
		value_taking_mesh_verts.insert(mesh_vertex);
	}

	// interpolate values onto mesh vertices generated by marching cubes that lie on grid edges and
	// store these mesh vertices as having had values interpolated onto them
	for (const auto& [mesh_vertex, edge_id] : grid.getNewMeshVerticesOnEdges()) {
		interpolateValuesOntoMeshVertexOnGridEdgeAverage(grid, edge_id, mesh_vertex);
		value_taking_mesh_verts.insert(mesh_vertex);
	}
}

// interpolates values after mesh upkeep from grid vertices onto mesh vertices
void ValueTransferrer::interpolateValuesOntoMeshVerticesAfterUpkeep(const Grid3DInterface& grid,
                                                                    Mesh3DVertex* mesh_vertex,
                                                                    int interpolation_method) {
	// if `mesh_vertex` is not inside the grid, skip the interpolation
	if (grid.isPointInsideGrid(mesh_vertex->getCoords())) {
		// retrieve the grid cell that `mesh_vertex` lies in
		long long grid_cell_id = grid.getCellIdForPoint(mesh_vertex->getCoords());
		// based on the choice of interpolation method execute either trilinear interpolation or average
		// interpolation
		if (interpolation_method == 1) {
			interpolateValuesOntoMeshVertexInGridCellTrilinear(grid, grid_cell_id, mesh_vertex);
		} else if (interpolation_method == 2) {
			interpolateValuesOntoMeshVertexInGridCellAverage(grid, grid_cell_id, mesh_vertex);
		}
		// store `mesh_vertex` as having had value interpolated onto it
		value_taking_mesh_verts.insert(mesh_vertex);
	} else {
		mesh_vertex->setPropertiesToZero();
	}
}

// interpolates values from grid vertices onto mesh vertices in front faces
void ValueTransferrer::interpolateValuesOntoFrontVertices(Grid3DInterface& grid) {
	// convert the grid-to-mesh interpolation method into a number to avoid input parameter queries
	auto interpolation_method_name = settings->grid_to_mesh_interpolation_method;
	int interpolation_method_mode = 0;
	if (interpolation_method_name == TopoFixerSettings::GridToMeshInterpolationMethod::Trilinear) {
		interpolation_method_mode = 1;
	} else if (interpolation_method_name ==
	           TopoFixerSettings::GridToMeshInterpolationMethod::AverageOnCellVertices) {
		interpolation_method_mode = 2;
	}

	// iterate over front faces
	for (long long front_face : grid.getFrontFacesVector()) {
		// we first interpolate values onto mesh vertices that lie on front edges, i.e. grid edges
		// adjacent to front faces; these vertices get values interpolated onto them from only the two
		// grid vertices that define the front edge
		for (long long front_edge : grid.get_edges_neighboring_face(front_face)) {
			// if there is a mesh vertex on `front_face`
			if (!grid.get_mesh_vertices_on_edge(front_edge).empty()) {
				// ASSERT: there should only ever be at most one mesh vertex on a front edge
				assert(grid.get_mesh_vertices_on_edge(front_edge).size() == 1);
				// collect the mesh vertex on `front_face`
				Mesh3DVertex* vertex_on_edge = grid.get_mesh_vertices_on_edge(front_edge)[0];
				// check if `vertex_on_edge` has already been processed
				if (!value_taking_mesh_verts.count(vertex_on_edge)) {
					// based on the choice of interpolation method execute either trilinear interpolation or
					// average interpolation
					if (interpolation_method_mode == 1) {
						interpolateValuesOntoMeshVertexOnGridEdgeTrilinear(grid, front_edge, vertex_on_edge);
					} else {
						interpolateValuesOntoMeshVertexOnGridEdgeAverage(grid, front_edge, vertex_on_edge);
					}
					// save `vertex_on_edge` as processed
					value_taking_mesh_verts.insert(vertex_on_edge);
				}
			}
		}
		// next we interpolate values onto mesh vertices that lie on front faces, i.e. grid faces
		// adjacent to one complex and one non-complex cell; these vertices get values interpolated onto
		// them from the four grid vertices that define the front face
		for (const auto& [graph_edge, nearby_triangle] : grid.getGraphOnFace(front_face)) {
			// both endpoints of a graph edge are mesh vertices, for each we check if it has already
			// been processed, and if not, we interpolate values onto it, and save it as processed
			if (!value_taking_mesh_verts.count(graph_edge.first)) {
				// based on the choice of interpolation method execute either trilinear interpolation or
				// average interpolation
				if (interpolation_method_mode == 1) {
					interpolateValuesOntoMeshVertexOnGridFaceTrilinear(grid, front_face, graph_edge.first);
				} else {
					interpolateValuesOntoMeshVertexOnGridFaceAverage(grid, front_face, graph_edge.first);
				}
				value_taking_mesh_verts.insert(graph_edge.first);
			}
			if (!value_taking_mesh_verts.count(graph_edge.second)) {
				// based on the choice of interpolation method execute either trilinear interpolation or
				// average interpolation
				if (interpolation_method_mode == 1) {
					interpolateValuesOntoMeshVertexOnGridFaceTrilinear(grid, front_face, graph_edge.second);
				} else {
					interpolateValuesOntoMeshVertexOnGridFaceAverage(grid, front_face, graph_edge.second);
				}
				value_taking_mesh_verts.insert(graph_edge.second);
			}
		}
	}
}

// interpolates values from grid vertices onto mesh vertices in simple cells
void ValueTransferrer::interpolateValuesOntoSimpleRegion(Mesh3DInterface& mesh,
                                                         const Grid3DInterface& grid) {
	// convert the grid-to-mesh interpolation method into a number to avoid input parameter queries
	auto interpolation_method_name =
	    settings->grid_to_mesh_interpolation_method;
	int interpolation_method_mode = 0;
	if (interpolation_method_name == TopoFixerSettings::GridToMeshInterpolationMethod::Trilinear) {
		interpolation_method_mode = 1;
	} else if (interpolation_method_name ==
	           TopoFixerSettings::GridToMeshInterpolationMethod::AverageOnCellVertices) {
		interpolation_method_mode = 2;
	}

	for (Mesh3DVertex* current_mesh_vertex : mesh.ListVertices()) {
		// check that `current_mesh_vertex` hasn't had value interpolated onto it yet
		if (!value_taking_mesh_verts.count(current_mesh_vertex)) {
			value_taking_mesh_verts.insert(current_mesh_vertex);
			// retrieve the id of the grid cell in which `current_mesh_vertex` lies
			long long grid_cell_id = grid.getCellIdForPoint(current_mesh_vertex->getCoords());
			// based on the choice of interpolation method execute either trilinear interpolation or
			// average interpolation
			if (interpolation_method_mode == 1) {
				interpolateValuesOntoMeshVertexInGridCellTrilinear(grid, grid_cell_id, current_mesh_vertex);
			} else if (interpolation_method_mode == 2) {
				interpolateValuesOntoMeshVertexInGridCellAverage(grid, grid_cell_id, current_mesh_vertex);
			}
		}
	}
}

// interpolates values on the endpoints of `grid_edge` onto `mesh_vertex` using trilinear weights
void ValueTransferrer::interpolateValuesOntoMeshVertexOnGridEdgeTrilinear(
    const Grid3DInterface& grid, long long grid_edge, Mesh3DVertex* mesh_vertex) {
	// collect the two vertices of `grid_edge`, and its orientation (an integer denoting the one
	// dimension within which `grid_edge` is varying)
	long long edge_v0, edge_v1, edge_orientation;
	grid.getEdgeVertsAndOrientation(grid_edge, edge_v0, edge_v1, edge_orientation);

	// calculate the interpolation weight for `edge_v0` as the proportion of the distance between
	// `mesh_vertex` and `edge_v0` compared to the length of a grid edge; because of the way that
	// `edge_v0` and `edge_v1` are retrieved from the mesh, the world coordinates of `edge_v0` are
	// going to be equal (up to numerical noise) to the world coordinates of `mesh_vertex` in
	// dimensions not equal to `edge_orientation`, and smaller or equal in the coordinate equal to
	// `edge_orientation`
	double edge_v0_weight = mesh_vertex->getCoords()[edge_orientation];
	edge_v0_weight -= grid.getVertexPosition(edge_v0)[edge_orientation];
	edge_v0_weight /= grid.get_cell_dx();
	// ASSERT: `edge_v0_weight` has to be between 0 and 1 (including)
	assert(edge_v0_weight >= 0 && edge_v0_weight <= 1);
	// calculate the interpolation weight of `edge_v1`
	double edge_v1_weight = 1 - edge_v0_weight;

	// initialize the vert properties on `mesh_vertex` to zero, properties will be interpolated onto
	// it from the neighboring grid vertices
	mesh_vertex->setPropertiesToZero();

	// check if `v0` and `v1` have values assigned (either from interpolation from mesh vertices, or
	// from spreading of values through the grid); if yes, interpolate the values onto `mesh_vertex`
	auto vert_props_iterator = vert_props_on_grid_verts.find(edge_v0);
	if (vert_props_iterator != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_iterator->second, edge_v0_weight);
	}
	vert_props_iterator = vert_props_on_grid_verts.find(edge_v1);
	if (vert_props_iterator != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_iterator->second, edge_v1_weight);
	}
}

// interpolates values on the endpoints of `grid_edge` onto `mesh_vertex` using equal weights
void ValueTransferrer::interpolateValuesOntoMeshVertexOnGridEdgeAverage(const Grid3DInterface& grid,
                                                                        long long grid_edge,
                                                                        Mesh3DVertex* mesh_vertex) {
	mesh_vertex->setPropertiesToZero();
	// stores the number of grid vertices with values that contribute to the interpolation onto
	// `mesh_vertex`
	int number_of_contributors = 0;
	// iterate over the two grid vertices of `grid_edge`, if a vertex has a value stored on it,
	// interpolate it onto `mesh_vertex` and increment number of contributors
	for (long long grid_vertex : grid.get_verts_neighboring_edge(grid_edge)) {
		if (vert_props_on_grid_verts.count(grid_vertex)) {
			mesh_vertex->addProperties(vert_props_on_grid_verts[grid_vertex]);
			number_of_contributors++;
		}
	}
	// if there is at least one contributor, normalize the value on `mesh_vertex` by
	// `number_of_contributors`
	if (number_of_contributors > 0) {
		mesh_vertex->divProperties(static_cast<double>(number_of_contributors));
	}
}

// interpolates values on vertices of `grid_face` onto `mesh_vertex` using trilinear weights
void ValueTransferrer::interpolateValuesOntoMeshVertexOnGridFaceTrilinear(
    const Grid3DInterface& grid, long long grid_face, Mesh3DVertex* mesh_vertex) {
	// retrieve a vector of the 4 grid vertices of `grid_face`
	std::vector<long long> face_verts = grid.get_verts_neighboring_face(grid_face);
	// retrieve the orientation of `grid_face` (an integer denoting the one dimension within which
	// `grid_face` is not varying)
	long long face_orientation = grid.getFaceOrientation(grid_face);

	// retrieve world coordinates of the two extremal vertices of `grid_face`, i.e. vertices
	// with the smallest and largest world coordinates
	Vec3d xyz_min = grid.getVertexPosition(face_verts[0]);
	Vec3d xyz_max = grid.getVertexPosition(face_verts[3]);

	// calculate the coordinates of the two extremal points of `grid_face` and the coordinates of
	// `mesh_vertex` in the plane of `grid_face`, i.e. we drop the world coordinate that is the same
	// for all these points (up to numerical noise); this coordinate is specified by
	// `face_orientation`
	Vec2d face_min, face_max, mesh_vertex_plane_position;
	if (face_orientation == 0) {
		face_min = Vec2d(xyz_min[1], xyz_min[2]);
		face_max = Vec2d(xyz_max[1], xyz_max[2]);
		mesh_vertex_plane_position = Vec2d(mesh_vertex->getCoord(1), mesh_vertex->getCoord(2));
	} else if (face_orientation == 1) {
		face_min = Vec2d(xyz_min[0], xyz_min[2]);
		face_max = Vec2d(xyz_max[0], xyz_max[2]);
		mesh_vertex_plane_position = Vec2d(mesh_vertex->getCoord(0), mesh_vertex->getCoord(2));
	} else if (face_orientation == 2) {
		face_min = Vec2d(xyz_min[0], xyz_min[1]);
		face_max = Vec2d(xyz_max[0], xyz_max[1]);
		mesh_vertex_plane_position = Vec2d(mesh_vertex->getCoord(0), mesh_vertex->getCoord(1));
	}

	// calculate the displacement vectors of `mesh_vertex` from the extremal vertices of `grid_face`;
	// normalize the vectors so that their components are proportions of the grid edge length rather
	// than absolute values; adding the two resulting vectors together should give the result
	// (1.0,1.0) modulo numerical imprecision
	Vec2d offset_min = (mesh_vertex_plane_position - face_min) / grid.get_cell_dx();
	Vec2d offset_max = (face_max - mesh_vertex_plane_position) / grid.get_cell_dx();

	// ASSERT: dispalcement should be non-negative in all components
	assert(offset_min[0] > 0.0 && offset_min[1] > 0.0);
	assert(offset_max[0] > 0.0 && offset_max[1] > 0.0);

	// initialize the vertex properties on `mesh_vertex` to zero, properties will be interpolated onto
	// it from the neighboring grid vertices
	mesh_vertex->setPropertiesToZero();

	// for each grid vertex on `grid_face`, if it has a value assigned, interpolate the value onto
	// `mesh_vertex` using trilinear weights; for `face_verts[1]` and `face_verts[2]` we have to
	// differentiate the cases when `face_orientation` is one of {0,2} or when it is 1, because the
	// order in which grid vertices of `grid_face` are stored in `face_verts` follows a different
	// rule depending on `face_orientation`
	auto vert_props_iterator = vert_props_on_grid_verts.find(face_verts[0]);
	if (vert_props_iterator != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_iterator->second, (offset_max[0] * offset_max[1]));
	}
	if (face_orientation % 2 == 1) {
		vert_props_iterator = vert_props_on_grid_verts.find(face_verts[1]);
		if (vert_props_iterator != vert_props_on_grid_verts.end()) {
			mesh_vertex->addProperties(vert_props_iterator->second, (offset_max[0] * offset_min[1]));
		}
		vert_props_iterator = vert_props_on_grid_verts.find(face_verts[2]);
		if (vert_props_iterator != vert_props_on_grid_verts.end()) {
			mesh_vertex->addProperties(vert_props_iterator->second, (offset_min[0] * offset_max[1]));
		}
	} else {
		vert_props_iterator = vert_props_on_grid_verts.find(face_verts[1]);
		if (vert_props_iterator != vert_props_on_grid_verts.end()) {
			mesh_vertex->addProperties(vert_props_iterator->second, (offset_min[0] * offset_max[1]));
		}
		vert_props_iterator = vert_props_on_grid_verts.find(face_verts[2]);
		if (vert_props_iterator != vert_props_on_grid_verts.end()) {
			mesh_vertex->addProperties(vert_props_iterator->second, (offset_max[0] * offset_min[1]));
		}
	}
	vert_props_iterator = vert_props_on_grid_verts.find(face_verts[3]);
	if (vert_props_iterator != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_iterator->second, (offset_min[0] * offset_min[1]));
	}
}

// interpolates values on the four corners of `grid_face` onto `mesh_vertex` using equal weights
void ValueTransferrer::interpolateValuesOntoMeshVertexOnGridFaceAverage(const Grid3DInterface& grid,
                                                                        long long grid_face,
                                                                        Mesh3DVertex* mesh_vertex) {
	mesh_vertex->setPropertiesToZero();
	// stores the number of grid vertices with values that contribute to the interpolation onto
	// `mesh_vertex`
	int number_of_contributors = 0;
	// iterate over the four grid vertices of `grid_face`, if a vertex has a value stored on it,
	// interpolate it onto `mesh_vertex` and increment number of contributors
	for (long long grid_vertex : grid.get_verts_neighboring_face(grid_face)) {
		auto vert_props_on_grid_vertex = vert_props_on_grid_verts.find(grid_vertex);
		if (vert_props_on_grid_vertex != vert_props_on_grid_verts.end()) {
			mesh_vertex->addProperties(vert_props_on_grid_vertex->second);
			number_of_contributors++;
		}
	}
	// if there is at least one contributor, normalize the value on `mesh_vertex` by
	// `number_of_contributors`
	if (number_of_contributors > 0) {
		mesh_vertex->divProperties(static_cast<double>(number_of_contributors));
	}
}

// interpolates values on the corners of `grid_cell` onto `mesh_vertex` using trilinear weights
void ValueTransferrer::interpolateValuesOntoMeshVertexInGridCellTrilinear(
    const Grid3DInterface& grid, long long grid_cell, Mesh3DVertex* mesh_vertex) {
	// retrieve the length of a grid cell side
	double cell_edge_length = grid.get_cell_dx();

	// retrieve a vector of the 8 grid vertices of `grid_cell`
	std::vector<long long> cell_verts = grid.get_verts_neighboring_cell(grid_cell);

	// retrieve world coordinates of the two extremal vertices of `grid_cell`, i.e. vertices
	// with the smallest and largest world coordinates, i.e. vertices with relative grid
	// cordinates (i,j,k) and (i+1,j+1,k+1)
	Vec3d xyz_min = grid.getVertexPosition(cell_verts[0]);
	Vec3d xyz_max = grid.getVertexPosition(cell_verts[7]);

	// calculate the displacement vector of `mesh_vertex` from the extremal vertices;
	// normalize the vectors so that their components are proportions of the grid edge length
	// rather than absolute values; adding the two resulting vectors together should give the
	// result (1.0,1.0,1.0) modulo numerical imprecision
	Vec3d offset_min = (mesh_vertex->getCoords() - xyz_min) / cell_edge_length;
	Vec3d offset_max = (xyz_max - mesh_vertex->getCoords()) / cell_edge_length;

	// ASSERT: dispalcement should be non-negative in all components
	assert(offset_min[0] > 0.0 && offset_min[1] > 0.0 && offset_min[2] > 0.0);
	assert(offset_max[0] > 0.0 && offset_max[1] > 0.0 && offset_max[2] > 0.0);

	// initialize the vertex properties on `mesh_vertex` to zero, properties will be interpolated onto
	// it from the neighboring grid vertices
	mesh_vertex->setPropertiesToZero();

	// for illustration, we think of the 8 grid vertices consitituting `grid_cell` as having
	// grid coordinates between (i,j,k) and (i+1,j+1,k+1)
	// interpolate vertex properties from grid vertex with coordinates (i,j,k)
	auto vert_props_on_grid_vertex = vert_props_on_grid_verts.find(cell_verts[0]);
	if (vert_props_on_grid_vertex != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_on_grid_vertex->second,
		                           (offset_max[0] * offset_max[1] * offset_max[2]));
	}
	// interpolate vertex properties from grid vertex with coordinates (i+1,j,k)
	vert_props_on_grid_vertex = vert_props_on_grid_verts.find(cell_verts[1]);
	if (vert_props_on_grid_vertex != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_on_grid_vertex->second,
		                           (offset_min[0] * offset_max[1] * offset_max[2]));
	}
	// interpolate vertex properties onto grid vertex with coordinates (i,j+1,k)
	vert_props_on_grid_vertex = vert_props_on_grid_verts.find(cell_verts[2]);
	if (vert_props_on_grid_vertex != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_on_grid_vertex->second,
		                           (offset_max[0] * offset_min[1] * offset_max[2]));
	}
	// interpolate vertex properties onto grid vertex with coordinates (i,j,k+1)
	vert_props_on_grid_vertex = vert_props_on_grid_verts.find(cell_verts[3]);
	if (vert_props_on_grid_vertex != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_on_grid_vertex->second,
		                           (offset_max[0] * offset_max[1] * offset_min[2]));
	}
	// interpolate vertex properties onto grid vertex with coordinates (i+1,j+1,k)
	vert_props_on_grid_vertex = vert_props_on_grid_verts.find(cell_verts[4]);
	if (vert_props_on_grid_vertex != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_on_grid_vertex->second,
		                           (offset_min[0] * offset_min[1] * offset_max[2]));
	}
	// interpolate vertex properties onto grid vertex with coordinates (i,j+1,k+1)
	vert_props_on_grid_vertex = vert_props_on_grid_verts.find(cell_verts[5]);
	if (vert_props_on_grid_vertex != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_on_grid_vertex->second,
		                           (offset_max[0] * offset_min[1] * offset_min[2]));
	}
	// interpolate vertex properties onto grid vertex with coordinates (i+1,j,k+1)
	vert_props_on_grid_vertex = vert_props_on_grid_verts.find(cell_verts[6]);
	if (vert_props_on_grid_vertex != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_on_grid_vertex->second,
		                           (offset_min[0] * offset_max[1] * offset_min[2]));
	}
	// interpolate vertex properties onto grid vertex with coordinates (i+1,j+1,k+1)
	vert_props_on_grid_vertex = vert_props_on_grid_verts.find(cell_verts[6]);
	if (vert_props_on_grid_vertex != vert_props_on_grid_verts.end()) {
		mesh_vertex->addProperties(vert_props_on_grid_vertex->second,
		                           (offset_min[0] * offset_min[1] * offset_min[2]));
	}
}

// interpolates values on the corners of `grid_cell` onto `mesh_vertex` using equal weights
void ValueTransferrer::interpolateValuesOntoMeshVertexInGridCellAverage(const Grid3DInterface& grid,
                                                                        long long grid_cell,
                                                                        Mesh3DVertex* mesh_vertex) {
	mesh_vertex->setPropertiesToZero();
	// stores the number of grid vertices with values that contribute to the interpolation onto
	// `mesh_vertex`
	int number_of_contributors = 0;
	// iterate over the eight grid vertices of `grid_cell`, if a vertex has a value stored on it,
	// interpolate it onto `mesh_vertex` and increment number of contributors
	for (long long grid_vertex : grid.get_verts_neighboring_cell(grid_cell)) {
		auto vert_props_on_grid_vertex = vert_props_on_grid_verts.find(grid_vertex);
		if (vert_props_on_grid_vertex != vert_props_on_grid_verts.end()) {
			mesh_vertex->addProperties(vert_props_on_grid_vertex->second);
			number_of_contributors++;
		}
	}
	// if there is at least one contributor, normalize the value on `mesh_vertex` by
	// `number_of_contributors`
	if (number_of_contributors > 0) {
		mesh_vertex->divProperties(static_cast<double>(number_of_contributors));
	}
}

//------------------------------------------------------------
// helper functions
//------------------------------------------------------------

// initializes vertex properties on all grid vertices (stored in `vert_props_on_grid_verts`) that
// have a value giving mesh vertex nearby to the zero vector
void ValueTransferrer::initializeVertPropsOnGridVertsMap(const Grid3DInterface& grid) {
	for (const auto& [grid_cell, mesh_vertices] : value_giving_mesh_verts_per_cell) {
		// retrieve a vector of the 8 grid vertices of `vertex_cell`
		std::vector<long long> cell_verts = grid.get_verts_neighboring_cell(grid_cell);
		for (long long grid_vertex : cell_verts) {
			vert_props_on_grid_verts[grid_vertex] = VertexProperties();
		}
	}
}

// if value transfer visualization is enabled, saves positions and vertex properties of value giving
// mesh vertices; used to take a snapshot of the initial configuration of value giving mesh vertices
// for visualization (therefore run before the mesh is altered)
void ValueTransferrer::saveMeshValuesForVisualization() {
	if (save_visualization_data) {
		for (const auto& [grid_vertex, mesh_vertices] : value_giving_mesh_verts_per_cell) {
			for (Mesh3DVertex* mesh_vertex : mesh_vertices) {
				initial_mesh_positions_and_vert_props.emplace_back(mesh_vertex->getCoords(),
				                                                   mesh_vertex->getProperties());
			}
		}
	}
}