/* MultiLabelMarchingCuber.h
 *
 * Peter Synak, Chris Wojtan, Huidong Yang, Aleksei Kalinov, Malina Strugaru, 2021
 *
 * This is the header for the module that executes the multi-label marching cubes algorithm.
 */

#pragma once

//------------------------------------------------------------
// includes
//------------------------------------------------------------
#include <algorithm>
#include <array>
#include <cassert>
#include <iterator>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "../datastructures/Mesh3DHalfCorner.h"
#include "../datastructures/Mesh3DTriangle.h"
#include "../utilities/intersection/ExactnessPredicates.h"
#include "ModuleInterface.h"
#include "../schemes/TopoFixerSettings.h"
//------------------------------------------------------------
// classes
//------------------------------------------------------------

// this class manages the flow of the multi-label marching cuber module
class MultiLabelMarchingCuber : public ModuleInterface {
 public:
	// constructors
	MultiLabelMarchingCuber(const TopoFixerSettings& settings) : settings(&settings){};
	virtual ~MultiLabelMarchingCuber() = default;

	// organizes the execution of individual tasks necessary for marching cubes surface reconstruction
	virtual int run(Mesh3DInterface& mesh, Grid3DInterface& grid, GridMeshIntersector& intersector,
	                int orientation) override;

	// clears all marching cubes data structures
	void clearState();

 private:
	const TopoFixerSettings* settings;
	// shortcut to simplify naming of extension maps - maps that assign to a pair of mesh vertices
	// that form a mesh edge, a vector of its extending HCs
	using ExtensionMap =
	    std::map<std::pair<Mesh3DVertex*, Mesh3DVertex*>, std::vector<Mesh3DHalfCorner*>>;

	// class to help keep track of grid faces adjacent to triangles reconstruced in an optimized way;
	// as a consequence, they don't natively connect to triangles generated by the 8-octant method,
	// so we have to generate the connecting triangles differently
	class OptimizedFace {
	 public:
		explicit OptimizedFace(long long id_) : id(id_), v0(nullptr), v1(nullptr) {}
		OptimizedFace(long long id_, Vec2i labels_, Mesh3DVertex* v0_, Mesh3DVertex* v1_)
		    : id(id_), v0(v0_), v1(v1_), labels(labels_) {}

		bool operator==(const OptimizedFace& otherFace) const { return this->id == otherFace.id; }

		struct HashFunction {
			size_t operator()(const OptimizedFace& oface) const {
				return std::hash<long long>()(oface.id);
			}
		};

		long long id;
		Mesh3DVertex* v0;
		Mesh3DVertex* v1;
		Vec2i labels;
		mutable bool has_been_reconstructed = false;
	};

	// ---------------- functions for generating unique labeling

	// Runs a BFS flood fill over grid vertices on complex cells, starting from non-complex vertices
	// on complex cells (these are guaranteed to exist, eg. all grid vertices on front faces are
	// non-complex). Grid vertices are added to the BFS queue in increasing index order, ensuring that
	// the function returns the same output on the same input. The BFS heuristic we use is that for a
	// complex grid vertex v0, we iterate over its 6 grid neighbors in a fixed order. If a neighbor v1
	// of v0 has a unique label l assigned, if l != 0, v0 inherits l. If all adjacent vertices of v0
	// that have a unique label assigned have their label == 0, v0 inherits v0. In other words, we try
	// to assign a non-zero label to v0, and only assign the zero label to v0 if it is the only
	// feasible candidate. Given the fixed order in which we traverse neighbors of v0, we prioritize
	// "earlier" directions over "later ones". The assignment of unique labels to grid ids is stored
	// in the map `unique_labeling`.
	// NOTE: we could also take the material that is most common among a vertex's neighbors, and not
	// take materials that are negative among the vertex's neighbors.
	// void generateUniqueLabelsOnGridVerticesNaiveFloodFill(Grid3DInterface& grid,
	//                                                      std::deque<int>& vertices_to_process);

	// ---------------- functions for reconstructing mesh surface

	// Mesh reconstruction coordination function. Fills in `grid_edge_mesh_vertex_map` with mesh
	// vertices on front faces, then iterates over fixed complex cells (there should be no flexible
	// complex cells at this point), and for each calls the appropriate mesh reconstruction method,
	// based on the parameter `marching_cubes_method`.
	void generateComplexCellIsosurfaces(Mesh3DInterface& mesh, Grid3DInterface& grid,
	                                    const absl::flat_hash_set<long long>& front_faces,
	                                    const absl::flat_hash_map<long long, int>& unique_labeling);

	// This function manages the generic mesh reconstruction via the 8-octant method inside the input
	// complex cell `ccell`. It iterates over the 12 edges of `ccell`, for each edge there are two
	// adjacent grid faces inside `ccell`. For each such edge-face combination, we evaluate whether
	// the face is a front face, an optimized face, or a normal face, and perform the appropriate
	// surface reconstruction routine.
	void reconstructMeshInCell8Octant(Mesh3DInterface& mesh, Grid3DInterface& grid,
	                                  const absl::flat_hash_set<long long>& front_faces_set,
	                                  const absl::flat_hash_map<long long, int>& unique_labeling,
	                                  const long long& ccell);

	// This function manages the generation of new triangles that connect the center of a complex cell
	// to a front face. Given an input `front_face`, we iterate over graph edges in its face graph.
	// For each such edge, we generate a triangle connecting center of the complex cell (`cell_vert`)
	// with the two endpoints of the edge. Each graph edge also stores its extending HC in the simple
	// region (due to our degeneracy resolution method, there can only be one). This triangle was
	// generated during cell separation in a way that ensures it respects the right hand rule. We use
	// it as an anchor for the newly generated triangles, and assign opposite pointers for the corners
	// extending the graph edge (i.e. HCs "across" the front face). We add the remaining HCs into
	// `front_extending_corners` to have their HCs assigned later.
	void generateTrianglesAdjacentToFrontFace(Mesh3DInterface& mesh, Grid3DInterface& grid,
	                                          Mesh3DVertex* cell_vert, long long front_face);

	// This function reconstructs mesh surface inside input `ccell` that was determined to be suitable
	// for optimized reconstruction, based on its vertex label configuration. Specifics of how the
	// labels on vertices of `ccell` are distributed are encoded in the input `cell_configuration`.
	// They can be:
	// -corner [1..8]
	// Labels for the newly generated triangles could be read off the grid vertices of `ccell`, but
	// are for simplicity passed to the function as `labels`. The function also stores each grid face
	// of `ccell` that touches the newly generated triangles as an optimized face, each with a pair of
	// vertices v0,v1 of the new triangles that lie in the grid face, and a pair of `labels`. The
	// combination of faces, vertices and labels that are stored together is carefully coded so that
	// the mesh generated inside a non-optimized complex cell `no_ccell` neighboring `ccell` can be
	// consistently connected to the triangles inside `ccell` by generating the triangle (center of
	// `no_ccell`, v0, v1) with the given labels (either `labels` or the flip of `labels`, depending
	// on the configuration). For each edge of each newly generated triangle t, we add its extending
	// HC within t to `internal_extending_corners` for later assignment of HC opposites.
	void reconstructMeshInCell2Material(Mesh3DInterface& mesh, Grid3DInterface& grid,
	                                    const long long ccell, const int cell_configuration,
	                                    const Vec2i labels);

	// ---------------- functions for determining cell configurations

	// Checks whether all grid cell vertices of `cell_id` have the same material label. If yes, no new
	// triangles will be generated inside this cell.
	bool allCellVerticesEqual(const Grid3DInterface& grid,
	                          const absl::flat_hash_map<long long, int>& unique_labeling,
	                          const long long cell_id) const;

	// Checks if the input grid face has an ambiguous configuration, that is, if the labels on its
	// vertices are in the ABAB configuration (each pair of two diagonal vertices shares the same
	// label within the pair, but the labels are different between the two pairs).
	bool isFaceAmbiguous(const Grid3DInterface& grid,
	                     const absl::flat_hash_map<long long, int>& unique_labeling,
	                     long long face_id);

	// Determine label configuration on vertices of `cell_id`, which will be used when deciding
	// whether (and how) to reconstruct the cell in an optimized way, or whether the generic 8-octant
	// method has to be used. In case `cell_id` is determined to be suitable for optimized
	// reconstruction, `labels` will store the two labels present on vertices of `cell_id` in the
	// order (less frequent one, i.e. minor label, more frequent one, i.e. major label). Return value
	// n can be equal to:
	// -1: the cell has to be reconstructed using 8-octant method; this could be due to the cell
	// having 3 or more labels, the labels being in an ambiguous position, or because the optimized
	// reconstruction would have to touch front faces)
	// 0: labels on all vertices of `cell_id` are the same, no triangles will be reconstructed
	// 1-8: labels on vertices of `cell_id` form the corner configuration (one label on 1 vertex, one
	// label on 7 vertices); n-1 is the relative index of the vertex in `cell_id` that has the minor
	// label
	int retrieveVertexLabelConfigurationOnCell(
	    Grid3DInterface& grid, const absl::flat_hash_map<long long, int>& unique_labeling,
	    const long long cell_id, Vec2i& labels);

	// ---------------- functions for obtaining mesh elements on the grid

	// If a mesh vertex is stored on input grid `edge`, return it. Otherwise generate a mesh vertex
	// in the center of `edge` and return it. In both cases, store a pointer to the new vertex in the
	// appropriate set on the grid.
	Mesh3DVertex* obtainGridEdgeCenterVertex(Mesh3DInterface& mesh, Grid3DInterface& grid,
	                                         long long edge);
	// If a mesh vertex is stored on input grid `face`, return it. Otherwise generate a mesh vertex
	// in the center of `face` and return it. In both cases, store a pointer to the new vertex in the
	// appropriate set on the grid.
	Mesh3DVertex* obtainGridFaceCenterVertex(Mesh3DInterface& mesh, Grid3DInterface& grid,
	                                         long long face);

	Mesh3DVertex* obtainGridFaceAverageVertex(Mesh3DInterface& mesh, Grid3DInterface& grid,
	                                          long long face);

	// ---------------- functions for assigning half-corner opposites

	// Add the half corners of an internal `triangle` to `internal_extending_corners`, which maps a
	// pair of mesh vertices that form an internal (or transition) mesh edge to a vector of HCs
	// extending this edge. We will use this map to assign opposite pointers to HCs stored in it.
	// Edges are stored in an ordered way, based on integer mesh vertex indices, from the smaller to
	// the larger index. If the orientation of the edge given by this order is compatible with the
	// orientation of `triangle`, the half-corner stored is the one associated with 0-orientation of
	// `triangle`, and if the orientation of the edge is not compatible with the orientation of
	// `triangle`, the half-corner stored is the one associated with 1-orientation of `triangle`. This
	// is equivalent to how we store extending HC during opposite assignment when loading a mesh -
	// when looking along the edge from its start vertex towards its end vertex, we store HCs that are
	// on the CW side of extending triangles. If the right hand rule is observed when generating
	// triangles (i.e. for each triangle when we take its 0-orientation plus right hand rule, we get
	// the side that has the triangle's 0th material), the HC opposite pointers will later be assigned
	// consistently.
	void addInternalExtendingCorners(Mesh3DInterface& mesh, Mesh3DTriangle* triangle);

	// Add the half corners of a front `triangle` to `front_extending_corners`, which maps a pair of
	// mesh vertices that form a front (or transition) mesh edge to a vector of HCs extending this
	// edge. We will use this map to assign opposite pointers to HCs stored in it. Because one pair of
	// mutually dual HCs of `triangle` has already had its opposites assigned during `trianlge`s
	// generation, namely the HC pair at the center vertex of the complex cell, we only add HCs at the
	// remaining two vertices of `triangle`, which are the two vertices that form an edge in the face
	// graph of the front face that `triangle` touches. Edges are stored in an ordered way, based on
	// integer mesh vertex indices, from the smaller to the larger index. If the orientation of the
	// edge given by this order is compatible with the orientation of `triangle`, the half-corner
	// stored is the one associated with 0-orientation of `triangle`, and if the orientation of the
	// edge is not compatible with the orientation of `triangle`, the half-corner stored is the one
	// associated with 1-orientation of `triangle`. This is equivalent to how we store extending HC
	// during opposite assignment when loading a mesh - when looking along the edge from its start
	// vertex towards its end vertex, we store HCs that are on the CW side of extending triangles. If
	// the right hand rule is observed when generating triangles (i.e. for each triangle when we take
	// its 0-orientation plus right hand rule, we get the side that has the triangle's 0th material),
	// the HC opposite pointers will later be assigned consistently.
	void addFrontExtendingCorners(Mesh3DInterface& mesh, Mesh3DTriangle* triangle);

	// ---------------- not yet cleaned up stuff

	void assignHalfCornerOpposites(Mesh3DInterface& mesh, Grid3DInterface& grid);

	void generateMeshVerticesOnGridEdges(Mesh3DInterface& mesh, Grid3DInterface& grid,
	                                     const absl::flat_hash_set<long long>& front_faces,
	                                     const absl::flat_hash_map<long long, int>& unique_labeling);

	// void generateUniqueLabelsOnGridVerticesTrackingFloodFill(Grid3DInterface& grid,
	//                                                          std::deque<int>& vertices_to_process);

	std::deque<long long> preprocessMaterialFloodFill(Grid3DInterface& grid);

	// ---------------- other functions

	void assignOppositesAroundNonMfldInternalEdge(Grid3DInterface& grid, Mesh3DInterface& mesh,
	                                              std::pair<Mesh3DVertex*, Mesh3DVertex*> edge,
	                                              std::vector<Mesh3DHalfCorner*> extending_hfcs);

	void consistencyCheck(Mesh3DInterface& mesh, Grid3DInterface& grid) const;

	void printLocalConfiguration(const Mesh3DInterface& mesh,
	                             std::pair<Mesh3DVertex*, Mesh3DVertex*> edge,
	                             std::vector<Mesh3DHalfCorner*> extending_hfcs,
	                             std::vector<std::set<Mesh3DHalfCorner*>>& left_neighbors,
	                             std::vector<std::set<Mesh3DHalfCorner*>>& right_neighbors,
	                             Mesh3DHalfCorner* oppos_candidate, size_t current_index);

	void printGridPrimitiveForNewMeshVertex(Mesh3DVertex* vertex);

	void moveVertsToNaiveLocations(Mesh3DInterface& mesh, Grid3DInterface& grid);
	void moveVertsToOptimizedLocations(Mesh3DInterface& mesh);

	// Functions to check and create the unique material labels. The definition of unique labeling
	// should be consistent with the complex vertex test and how inconsistent vertices are handled
	// during the grid labeling step.

	// ----------------- data members

	// map that to each grid vertex on a complex cell assignes a unique material label
	// absl::flat_hash_map<int, int> unique_labeling;
	// assigns to a grid edge in a complex cell the mesh vertex generated on this edge during surface
	// reconstruction (if there is one)
	absl::flat_hash_map<long long, Mesh3DVertex*> grid_edge_mesh_vertex_map;
	// assigns to a grid face in a complex cell the mesh vertex generated on this face during surface
	// reconstruction (if there is one)
	absl::flat_hash_map<long long, Mesh3DVertex*> grid_face_mesh_vertex_map;
	// stores for each optimized face the data necessary for reconstruction of mesh triangles in
	// adjacent non-optimized cells that touch the optimized face
	absl::flat_hash_set<OptimizedFace, OptimizedFace::HashFunction> optimized_grid_faces;

	// intersector for determining orientation tests, used when assigning opposites across a
	// non-manifold internal edge
	ExactnessPredicates intersector;

	// mesh reconstruction statistics
	int number_of_reconstructed_cells;
	int number_of_cells_with_only_1_material;
	int number_of_cells_with_exactly_2_materials;
	int number_of_cells_with_unambiguous_faces;
	int number_of_reconstructed_cells_with_corner_configuration;
	int number_of_reconstructed_cells_with_two_corners_configuration;
	int number_of_reconstructed_cells_with_edge_configuration;

	// ----------------- data saved for debug purposes

	// set of cells that were reconstructed in an optimized way
	absl::flat_hash_set<long long> optimized_cells;

	// maps a mesh vertex generated inside a complex cells to the id of the complex cell, the same
	// data is stored on the grid
	absl::flat_hash_map<Mesh3DVertex*, long long> cell_verts;
	// maps a mesh vertex generated on an edge of a complex cell to the id of the edge, the same data
	// is stored on the grid
	absl::flat_hash_map<Mesh3DVertex*, std::pair<long long, long long>> edge_verts;
	// maps a mesh vertex generated on a face of a complex cell to the id of the face, the same data
	// is stored on the grid
	absl::flat_hash_map<Mesh3DVertex*, long long> face_verts;
	// maps a mesh triangle generated inside a complex cell to the id of the cell
	absl::flat_hash_map<Mesh3DTriangle*, long long> triangle_to_cell;
	// maps id of a cell to a set of mesh triangle generated inside it
	absl::flat_hash_map<long long, absl::flat_hash_set<Mesh3DTriangle*>> cell_to_triangles;

	absl::flat_hash_set<long long> edges_with_suggested_point;

	absl::flat_hash_map<Mesh3DVertex*, Vec3d> optimized_coords_;

	// ----------------- not yet processed stuff

	// maps, where the keys are a pair of triangle vertices (x,y) in ascending order of indices, that
	// defines a triangle edge, and the value is a vector of extending HCs of this edge, one (of two
	// dual choices) per each triangle (x,y,z) containing (x,y); an extending HC of edge (x,y) is a HC
	// at z; these maps are used to assign HC opposites
	ExtensionMap internal_extending_corners;
	ExtensionMap front_extending_corners;
	ExtensionMap transition_extending_corners;

	absl::flat_hash_set<Mesh3DTriangle*> optimized_triangles;
};
