/* ValueTransferrerVisualizer.cpp
 *
 * Peter Synak, Chris Wojtan, Huidong Yang, Aleksei Kalinov, Malina Strugaru, 2022
 *
 * This is the implementation file for value transfer visualizer.
 */

//------------------------------------------------------------
// includes
//------------------------------------------------------------

#include "ValueTransferrerVisualizer.h"

// clang-format off
#include <GL/glew.h>
#include <GL/glu.h>
#include <GL/glut.h>
#include <GL/gl.h>
// clang-format on

#include <unordered_map>

#include "OpenGLRenderer.h"

//------------------------------------------------------------
// constructors
//------------------------------------------------------------

// default constructor
ValueTransferrerVisualizer::ValueTransferrerVisualizer(){};

// default destructor
ValueTransferrerVisualizer::~ValueTransferrerVisualizer(){};

//------------------------------------------------------------
// controlling functions
//------------------------------------------------------------

void ValueTransferrerVisualizer::init(SDTopoFixer* topofixer, std::vector<Vec4d> colors) {
	current_state_ = 0;
	grid_ = topofixer->getGrid3DCubical();
	mesh_ = topofixer->getMesh3DInterface();
	value_transferrer_ = topofixer->getValueTransferrer();
	velocity_colors_ = colors;
}

void ValueTransferrerVisualizer::display() {
	switch (current_state_) {
		// Render nothing.
		case 0:
			break;

		// Render initial velocity vectors on value giving mesh vertices in pink, i.e., the displayed
		// values were read from the input file.
		case 1:
			renderInitialVelocitiesOnMesh();
			break;

		// Render interpolated velocity vectors on grid vertices, pink for those that had values
		// assigned onto them directly by interpolation from mesh vertices, blue for those that had
		// values assigned onto them by spreading values through the grid.
		case 2:
			renderVelocitiesOnGrid();
			break;

		// Render new velocity vectors on value taking mesh vertices in blue, i.e., the displayed values
		// were interpolated onto mesh vertices from grid vertices.
		case 3:
			renderNewVelocitiesOnGridMesh();
			break;

		// Render velocity vectors on all mesh vertices in different colors:
		// -pink for original mesh vertices whose values didn't change;
		// -orange for original mesh vertices whose values changed;
		// -blue for mesh vertices generated by marching cubes;
		// -yellow for front face mesh vertices.
		case 4:
			renderVelocitiesOnMeshBasedOnOrigin();
			break;

		// Render value giving mesh vertices in green and the cells they lie in (i.e. all cells that had
		// values interpolated onto their vertices).
		case 5:
			renderValueGivingMeshVertices();
			renderInterpolationGridCells();
			break;

		case 6:
			renderThicknessesOnMesh();
			break;
	}
}

void ValueTransferrerVisualizer::renderInitialVelocitiesOnMesh() {
	glGetFloatv(GL_LINE_WIDTH, &stored_line_width);
	glLineWidth(6);

	glEnable(GL_DEPTH_TEST);
	glBegin(GL_LINES);

	// iterate over value giving mesh vertices, draw their velocities in pink
	glColor3d(velocity_colors_[0][0], velocity_colors_[0][1], velocity_colors_[0][2]);
	for (auto& [vertex_pos, vert_props] :
	     value_transferrer_->getInitialMeshPositionsAndVertProps()) {
		Vec3d vertex_vel = vert_props.getVelocity();
		renderVelocity(vertex_pos, vertex_vel);
		renderThickness(vertex_pos, vert_props.getThickness());
	}

	glEnd();
	glLineWidth(stored_line_width);
}

void ValueTransferrerVisualizer::renderVelocitiesOnGrid() {
	glGetFloatv(GL_LINE_WIDTH, &stored_line_width);
	glLineWidth(3);

	glEnable(GL_DEPTH_TEST);
	glBegin(GL_LINES);

	// iterate over grid vertices that had values interpolated onto them from the mesh vertices, draw
	// their velocities in pink
	glColor3d(velocity_colors_[0][0], velocity_colors_[0][1], velocity_colors_[0][2]);
	for (auto& [grid_cell, mesh_vertices] : value_transferrer_->getValueGivingMeshVerticesPerCell()) {
		for (long long grid_vertex : grid_->get_verts_neighboring_cell(grid_cell)) {
			Vec3d vertex_pos = grid_->getVertexPosition(grid_vertex);
			VertexProperties vert_props = value_transferrer_->getVertPropsOnOneGridVertex(grid_vertex);
			Vec3d vertex_vel = vert_props.getVelocity();
			renderVelocity(vertex_pos, vertex_vel);
			renderThickness(vertex_pos, vert_props.getThickness());
		}
	}

	// iterate over grid vertices that had values spread onto them, draw their velocities in blue
	glColor3d(velocity_colors_[2][0], velocity_colors_[2][1], velocity_colors_[2][2]);
	for (long long grid_vertex : value_transferrer_->getSpreadGridVertices()) {
		Vec3d vertex_pos = grid_->getVertexPosition(grid_vertex);
		VertexProperties vert_props = value_transferrer_->getVertPropsOnOneGridVertex(grid_vertex);
		Vec3d vertex_vel = vert_props.getVelocity();
		renderVelocity(vertex_pos, vertex_vel);
		renderThickness(vertex_pos, vert_props.getThickness());
	}

	glEnd();
	glLineWidth(stored_line_width);
}

void ValueTransferrerVisualizer::renderNewVelocitiesOnGridMesh() {
	glGetFloatv(GL_LINE_WIDTH, &stored_line_width);
	glLineWidth(6);

	glEnable(GL_DEPTH_TEST);
	glBegin(GL_LINES);

	// iterate over value taking mesh vertices, draw their velocities in blue
	glColor3d(velocity_colors_[2][0], velocity_colors_[2][1], velocity_colors_[2][2]);
	for (Mesh3DVertex* mesh_vertex : value_transferrer_->getValueTakingMeshVertices()) {
		Vec3d vertex_pos = mesh_vertex->getCoords();
		Vec3d vertex_vel = mesh_vertex->getVelocity();
		renderVelocity(vertex_pos, vertex_vel);
		renderThickness(vertex_pos, mesh_vertex->getThickness());
	}

	glEnd();
	glLineWidth(stored_line_width);
}

void ValueTransferrerVisualizer::renderVelocitiesOnMeshBasedOnOrigin() {
	glGetFloatv(GL_LINE_WIDTH, &stored_line_width);
	glLineWidth(6);

	glEnable(GL_DEPTH_TEST);
	glBegin(GL_LINES);

	// stores mesh vertices that were already rendered to differentiate marching cubes vertices and
	// front face vertices from original vertices that still exist after the bulk of the algorithm is
	// executed
	absl::flat_hash_set<Mesh3DVertex*> rendered_vertices;

	// draw velocities of mesh vertices generated by marching cubes in blue
	glColor3d(velocity_colors_[2][0], velocity_colors_[2][1], velocity_colors_[2][2]);
	for (auto& [mesh_vertex, grid_cell] : grid_->getNewMeshVerticesInCells()) {
		Vec3d vertex_pos = mesh_vertex->getCoords();
		Vec3d vertex_vel = mesh_vertex->getVelocity();
		renderVelocity(vertex_pos, vertex_vel);
		rendered_vertices.insert(mesh_vertex);
	}
	for (auto& [mesh_vertex, grid_cell] : grid_->getNewMeshVerticesOnFaces()) {
		Vec3d vertex_pos = mesh_vertex->getCoords();
		Vec3d vertex_vel = mesh_vertex->getVelocity();
		renderVelocity(vertex_pos, vertex_vel);
		rendered_vertices.insert(mesh_vertex);
	}
	for (auto& [mesh_vertex, grid_cell] : grid_->getNewMeshVerticesOnEdges()) {
		Vec3d vertex_pos = mesh_vertex->getCoords();
		Vec3d vertex_vel = mesh_vertex->getVelocity();
		renderVelocity(vertex_pos, vertex_vel);
		rendered_vertices.insert(mesh_vertex);
	}

	// draw velocities of mesh vertices on front faces in yellow
	glColor3d(velocity_colors_[3][0], velocity_colors_[3][1], velocity_colors_[3][2]);
	for (long long face_id : grid_->getFrontFacesVector()) {
		for (auto& [graph_edge, adjacent_triangle] : grid_->getGraphOnFace(face_id)) {
			Vec3d vertex_pos = graph_edge.first->getCoords();
			Vec3d vertex_vel = graph_edge.first->getVelocity();
			renderVelocity(vertex_pos, vertex_vel);
			rendered_vertices.insert(graph_edge.first);
			vertex_pos = graph_edge.second->getCoords();
			vertex_vel = graph_edge.second->getVelocity();
			renderVelocity(vertex_pos, vertex_vel);
			rendered_vertices.insert(graph_edge.second);
		}
	}

	// draw velocities of original mesh vertices that are not value taking in pink and of original
	// vertices that are value taking in orange
	for (Mesh3DVertex* current_mesh_vertex : mesh_->ListVertices()) {
		// check that `current_mesh_vertex` has not been rendered yet
		if (!rendered_vertices.count(current_mesh_vertex)) {
			// if `current_mesh_vertex` is not value taking, set the color to pink, otherwise set it to
			// orange
			if (!value_transferrer_->isMeshVertexValueTaking(current_mesh_vertex)) {
				glColor3d(velocity_colors_[0][0], velocity_colors_[0][1], velocity_colors_[0][2]);

			} else {
				glColor3d(1.0, 0.75, 0.0);
			}
			Vec3d vertex_pos = current_mesh_vertex->getCoords();
			Vec3d vertex_vel = current_mesh_vertex->getVelocity();
			renderVelocity(vertex_pos, vertex_vel);
		}
	}

	glEnd();
	glLineWidth(stored_line_width);
}

void ValueTransferrerVisualizer::renderValueGivingMeshVertices() {
	glGetFloatv(GL_POINT_SIZE, &stored_point_size);
	glPointSize(10.0);

	glEnable(GL_DEPTH_TEST);
	glEnable(GL_PROGRAM_POINT_SIZE);
	glEnable(GL_POINT_SMOOTH);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	glBegin(GL_POINTS);

	// draw value giving mesh vertices in green
	glColor3d(velocity_colors_[1][0], velocity_colors_[1][1], velocity_colors_[1][2]);
	for (auto& [vertex_pos, vert_props] :
	     value_transferrer_->getInitialMeshPositionsAndVertProps()) {
		glVertex3d(vertex_pos[0], vertex_pos[1], vertex_pos[2]);
	}

	glEnd();
	glPointSize(stored_point_size);
}

void ValueTransferrerVisualizer::renderInterpolationGridCells() {
	glGetFloatv(GL_LINE_WIDTH, &stored_line_width);
	glLineWidth(1);

	glBegin(GL_LINES);
	glColor3f(0.0, 0.0, 0.0);

	// iterate over cells that initially contained value giving mesh vertices
	for (auto& [grid_cell, mesh_vertices] : value_transferrer_->getValueGivingMeshVerticesPerCell()) {
		double x, y, z;
		for (const long long edge : grid_->get_edges_neighboring_cell(grid_cell)) {
			std::vector<long long> edge_vertices = grid_->get_verts_neighboring_edge(edge);
			grid_->getVertexPosition(edge_vertices[0], x, y, z);
			glVertex3f(x, y, z);
			grid_->getVertexPosition(edge_vertices[1], x, y, z);
			glVertex3f(x, y, z);
		}
	}

	glEnd();
	glLineWidth(stored_line_width);
}

void ValueTransferrerVisualizer::renderThicknessesOnMesh() {
	for (auto mesh_vertex : mesh_->ListVertices()) {
		renderThickness(mesh_vertex->getCoords(), mesh_vertex->getThickness());
	}
}

void ValueTransferrerVisualizer::nextState() {
	current_state_ = (current_state_ + 1) % kMaxStates;
	printDescription();
}

void ValueTransferrerVisualizer::printDescription() {
	switch (current_state_) {
		case 0:
			std::cout << "-render no value transfer elements" << std::endl;
			break;

		case 1:
			std::cout << "-render initial velocities on value giving mesh vertices in pink" << std::endl;
			break;

		case 2:
			std::cout
			    << "-render velocities on grid vertices, pink for interpolated ones, blue for spread ones"
			    << std::endl;
			break;

		case 3:
			std::cout << "-render interpolated velocities on value taking mesh vertices in blue"
			          << std::endl;
			break;

		case 4:
			std::cout << "-render velocity vectors on mesh vertices: pink for original, blue for MC, "
			             "yellow for front"
			          << std::endl;
			break;

		case 5:
			std::cout << "-render value giving mesh vertices and the grid cells they lie in" << std::endl;
			break;

		case 6:
			std::cout << "-render thicknesses on mesh vertices, as a small ball, red and blue for min "
						 "and max thicknesses resp."
					  << std::endl;
			break;
	}
}

void ValueTransferrerVisualizer::renderVelocity(Vec3d origin, Vec3d velocity) {
	Vec3d end = origin + static_cast<double>(velocity_scale_) * velocity;
	glVertex3d(origin[0], origin[1], origin[2]);
	glVertex3d(end[0], end[1], end[2]);
}

void ValueTransferrerVisualizer::renderThickness(Vec3d coords, double thickness) {
	double cube_half_side = 0.007 * static_cast<double>(velocity_scale_);

	// TODO: implement generic value transferrer visualizer and remove these hardcoded values.
	double min_th = 200 * 1e-6;
	double max_th = 1200 * 1e-6;
	double avg_th = (min_th + max_th) / 2;

	OpenGLRenderer::setLights();

	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	glBegin(GL_TRIANGLES);

	// set the color based on thickness
	if (thickness <= avg_th) {
		double redness = (thickness - min_th) / (avg_th - min_th);
		glColor3f(1.0, redness, redness);
	} else {
		double blueness = (max_th - thickness) / (max_th - avg_th);
		glColor3f(blueness, blueness, 1.0);
	}

	// construct the cube
	OpenGLRenderer::constructCube(coords[0], coords[1], coords[2], cube_half_side);

	glEnd();
}
