// David Eberly, Geometric Tools, Redmond WA 98052
// Copyright (c) 1998-2023
// Distributed under the Boost Software License, Version 1.0.
// https://www.boost.org/LICENSE_1_0.txt
// https://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
// Version: 6.0.2023.08.08

// Compute the distance from a point to a hyperellipsoid in nD. The
// hyperellipsoid is considered to be a closed surface, not a solid. In 2D,
// this is a point-ellipse distance query. In 3D, this is a point-ellipsoid
// distance query. The following document describes the algorithm.
//   https://www.geometrictools.com/Documentation/DistancePointEllipseEllipsoid.pdf
// The hyperellipsoid can have arbitrary center and orientation; that is, it
// does not have to be axis-aligned with center at the origin.
//

#include <algorithm>
#include <array>
#include <cmath>
#include <cstdint>
#include <initializer_list>

namespace GTE {


template <int32_t N, typename Real>
class Vector
{
public:
    // The tuple is uninitialized.
    Vector() = default;

    // The tuple is fully initialized by the inputs.
    Vector(std::array<Real, N> const& values)
        :
        mTuple(values)
    {
    }

    // At most N elements are copied from the initializer list, setting
    // any remaining elements to zero.  Create the zero vector using the
    // syntax
    //   Vector<N,Real> zero{(Real)0};
    // WARNING:  The C++ 11 specification states that
    //   Vector<N,Real> zero{};
    // will lead to a call of the default constructor, not the initializer
    // constructor!
    Vector(std::initializer_list<Real> values)
    {
        int32_t const numValues = static_cast<int32_t>(values.size());
        if (N == numValues)
        {
            std::copy(values.begin(), values.end(), mTuple.begin());
        }
        else if (N > numValues)
        {
            std::copy(values.begin(), values.end(), mTuple.begin());
            std::fill(mTuple.begin() + numValues, mTuple.end(), (Real)0);
        }
        else // N < numValues
        {
            std::copy(values.begin(), values.begin() + N, mTuple.begin());
        }
    }

    // For 0 <= d < N, element d is 1 and all others are 0.  If d is
    // invalid, the zero vector is created.  This is a convenience for
    // creating the standard Euclidean basis vectors; see also
    // MakeUnit(int32_t) and Unit(int32_t).
    Vector(int32_t d)
    {
        MakeUnit(d);
    }

    // The copy constructor, destructor, and assignment operator are
    // generated by the compiler.

    // Member access.  The first operator[] returns a const reference
    // rather than a Real value.  This supports writing via standard file
    // operations that require a const pointer to data.
    inline int32_t GetSize() const
    {
        return N;
    }

    inline Real const& operator[](int32_t i) const
    {
        return mTuple[i];
    }

    inline Real& operator[](int32_t i)
    {
        return mTuple[i];
    }

    // Comparisons for sorted containers and geometric ordering.
    inline bool operator==(Vector const& vec) const
    {
        return mTuple == vec.mTuple;
    }

    inline bool operator!=(Vector const& vec) const
    {
        return mTuple != vec.mTuple;
    }

    inline bool operator< (Vector const& vec) const
    {
        return mTuple < vec.mTuple;
    }

    inline bool operator<=(Vector const& vec) const
    {
        return mTuple <= vec.mTuple;
    }

    inline bool operator> (Vector const& vec) const
    {
        return mTuple > vec.mTuple;
    }

    inline bool operator>=(Vector const& vec) const
    {
        return mTuple >= vec.mTuple;
    }

    // Special vectors.

    // All components are 0.
    void MakeZero()
    {
        std::fill(mTuple.begin(), mTuple.end(), (Real)0);
    }

    // All components are 1.
    void MakeOnes()
    {
        std::fill(mTuple.begin(), mTuple.end(), (Real)1);
    }

    // Component d is 1, all others are zero.
    void MakeUnit(int32_t d)
    {
        std::fill(mTuple.begin(), mTuple.end(), (Real)0);
        if (0 <= d && d < N)
        {
            mTuple[d] = (Real)1;
        }
    }

    static Vector Zero()
    {
        Vector<N, Real> v;
        v.MakeZero();
        return v;
    }

    static Vector Ones()
    {
        Vector<N, Real> v;
        v.MakeOnes();
        return v;
    }

    static Vector Unit(int32_t d)
    {
        Vector<N, Real> v;
        v.MakeUnit(d);
        return v;
    }

protected:
    // This data structure takes advantage of the built-in operator[],
    // range checking, and visualizers in MSVS.
    std::array<Real, N> mTuple;
};

// Unary operations.
template <int32_t N, typename Real>
Vector<N, Real> operator+(Vector<N, Real> const& v)
{
    return v;
}

template <int32_t N, typename Real>
Vector<N, Real> operator-(Vector<N, Real> const& v)
{
    Vector<N, Real> result;
    for (int32_t i = 0; i < N; ++i)
    {
        result[i] = -v[i];
    }
    return result;
}

// Linear-algebraic operations.
template <int32_t N, typename Real>
Vector<N, Real> operator+(Vector<N, Real> const& v0, Vector<N, Real> const& v1)
{
    Vector<N, Real> result = v0;
    return result += v1;
}

template <int32_t N, typename Real>
Vector<N, Real> operator-(Vector<N, Real> const& v0, Vector<N, Real> const& v1)
{
    Vector<N, Real> result = v0;
    return result -= v1;
}

template <int32_t N, typename Real>
Vector<N, Real> operator*(Vector<N, Real> const& v, Real scalar)
{
    Vector<N, Real> result = v;
    return result *= scalar;
}

template <int32_t N, typename Real>
Vector<N, Real> operator*(Real scalar, Vector<N, Real> const& v)
{
    Vector<N, Real> result = v;
    return result *= scalar;
}

template <int32_t N, typename Real>
Vector<N, Real> operator/(Vector<N, Real> const& v, Real scalar)
{
    Vector<N, Real> result = v;
    return result /= scalar;
}

template <int32_t N, typename Real>
Vector<N, Real>& operator+=(Vector<N, Real>& v0, Vector<N, Real> const& v1)
{
    for (int32_t i = 0; i < N; ++i)
    {
        v0[i] += v1[i];
    }
    return v0;
}

template <int32_t N, typename Real>
Vector<N, Real>& operator-=(Vector<N, Real>& v0, Vector<N, Real> const& v1)
{
    for (int32_t i = 0; i < N; ++i)
    {
        v0[i] -= v1[i];
    }
    return v0;
}

template <int32_t N, typename Real>
Vector<N, Real>& operator*=(Vector<N, Real>& v, Real scalar)
{
    for (int32_t i = 0; i < N; ++i)
    {
        v[i] *= scalar;
    }
    return v;
}

template <int32_t N, typename Real>
Vector<N, Real>& operator/=(Vector<N, Real>& v, Real scalar)
{
    if (scalar != (Real)0)
    {
        Real invScalar = (Real)1 / scalar;
        for (int32_t i = 0; i < N; ++i)
        {
            v[i] *= invScalar;
        }
    }
    else
    {
        for (int32_t i = 0; i < N; ++i)
        {
            v[i] = (Real)0;
        }
    }
    return v;
}

// Componentwise algebraic operations.
template <int32_t N, typename Real>
Vector<N, Real> operator*(Vector<N, Real> const& v0, Vector<N, Real> const& v1)
{
    Vector<N, Real> result = v0;
    return result *= v1;
}

template <int32_t N, typename Real>
Vector<N, Real> operator/(Vector<N, Real> const& v0, Vector<N, Real> const& v1)
{
    Vector<N, Real> result = v0;
    return result /= v1;
}

template <int32_t N, typename Real>
Vector<N, Real>& operator*=(Vector<N, Real>& v0, Vector<N, Real> const& v1)
{
    for (int32_t i = 0; i < N; ++i)
    {
        v0[i] *= v1[i];
    }
    return v0;
}

template <int32_t N, typename Real>
Vector<N, Real>& operator/=(Vector<N, Real>& v0, Vector<N, Real> const& v1)
{
    for (int32_t i = 0; i < N; ++i)
    {
        v0[i] /= v1[i];
    }
    return v0;
}

// Geometric operations.  The functions with 'robust' set to 'false' use
// the standard algorithm for normalizing a vector by computing the length
// as a square root of the squared length and dividing by it.  The results
// can be infinite (or NaN) if the length is zero.  When 'robust' is set
// to 'true', the algorithm is designed to avoid floating-point overflow
// and sets the normalized vector to zero when the length is zero.
template <int32_t N, typename Real>
Real Dot(Vector<N, Real> const& v0, Vector<N, Real> const& v1)
{
    Real dot = v0[0] * v1[0];
    for (int32_t i = 1; i < N; ++i)
    {
        dot += v0[i] * v1[i];
    }
    return dot;
}

template <int32_t N, typename Real>
Real Length(Vector<N, Real> const& v, bool robust = false)
{
    if (robust)
    {
        Real maxAbsComp = std::fabs(v[0]);
        for (int32_t i = 1; i < N; ++i)
        {
            Real absComp = std::fabs(v[i]);
            if (absComp > maxAbsComp)
            {
                maxAbsComp = absComp;
            }
        }

        Real length;
        if (maxAbsComp > (Real)0)
        {
            Vector<N, Real> scaled = v / maxAbsComp;
            length = maxAbsComp * std::sqrt(Dot(scaled, scaled));
        }
        else
        {
            length = (Real)0;
        }
        return length;
    }
    else
    {
        return std::sqrt(Dot(v, v));
    }
}

template <int32_t N, typename Real>
Real Normalize(Vector<N, Real>& v, bool robust = false)
{
    if (robust)
    {
        Real maxAbsComp = std::fabs(v[0]);
        for (int32_t i = 1; i < N; ++i)
        {
            Real absComp = std::fabs(v[i]);
            if (absComp > maxAbsComp)
            {
                maxAbsComp = absComp;
            }
        }

        Real length;
        if (maxAbsComp > (Real)0)
        {
            v /= maxAbsComp;
            length = std::sqrt(Dot(v, v));
            v /= length;
            length *= maxAbsComp;
        }
        else
        {
            length = (Real)0;
            for (int32_t i = 0; i < N; ++i)
            {
                v[i] = (Real)0;
            }
        }
        return length;
    }
    else
    {
        Real length = std::sqrt(Dot(v, v));
        if (length > (Real)0)
        {
            v /= length;
        }
        else
        {
            for (int32_t i = 0; i < N; ++i)
            {
                v[i] = (Real)0;
            }
        }
        return length;
    }
}

// Gram-Schmidt orthonormalization to generate orthonormal vectors from
// the linearly independent inputs.  The function returns the smallest
// length of the unnormalized vectors computed during the process.  If
// this value is nearly zero, it is possible that the inputs are linearly
// dependent (within numerical round-off errors).  On input,
// 1 <= numElements <= N and v[0] through v[numElements-1] must be
// initialized.  On output, the vectors v[0] through v[numElements-1]
// form an orthonormal set.
template <int32_t N, typename Real>
Real Orthonormalize(int32_t numInputs, Vector<N, Real>* v, bool robust = false)
{
    if (v && 1 <= numInputs && numInputs <= N)
    {
        Real minLength = Normalize(v[0], robust);
        for (int32_t i = 1; i < numInputs; ++i)
        {
            for (int32_t j = 0; j < i; ++j)
            {
                Real dot = Dot(v[i], v[j]);
                v[i] -= v[j] * dot;
            }
            Real length = Normalize(v[i], robust);
            if (length < minLength)
            {
                minLength = length;
            }
        }
        return minLength;
    }

    return (Real)0;
}

// Construct a single vector orthogonal to the nonzero input vector.  If
// the maximum absolute component occurs at index i, then the orthogonal
// vector U has u[i] = v[i+1], u[i+1] = -v[i], and all other components
// zero.  The index addition i+1 is computed modulo N.
template <int32_t N, typename Real>
Vector<N, Real> GetOrthogonal(Vector<N, Real> const& v, bool unitLength)
{
    Real cmax = std::fabs(v[0]);
    int32_t imax = 0;
    for (int32_t i = 1; i < N; ++i)
    {
        Real c = std::fabs(v[i]);
        if (c > cmax)
        {
            cmax = c;
            imax = i;
        }
    }

    Vector<N, Real> result;
    result.MakeZero();
    int32_t inext = imax + 1;
    if (inext == N)
    {
        inext = 0;
    }
    result[imax] = v[inext];
    result[inext] = -v[imax];
    if (unitLength)
    {
        Real sqrDistance = result[imax] * result[imax] + result[inext] * result[inext];
        Real invLength = ((Real)1) / std::sqrt(sqrDistance);
        result[imax] *= invLength;
        result[inext] *= invLength;
    }
    return result;
}

// Compute the axis-aligned bounding box of the vectors.  The return value
// is 'true' iff the inputs are valid, in which case vmin and vmax have
// valid values.
template <int32_t N, typename Real>
bool ComputeExtremes(int32_t numVectors, Vector<N, Real> const* v,
                     Vector<N, Real>& vmin, Vector<N, Real>& vmax)
{
    if (v && numVectors > 0)
    {
        vmin = v[0];
        vmax = vmin;
        for (int32_t j = 1; j < numVectors; ++j)
        {
            Vector<N, Real> const& vec = v[j];
            for (int32_t i = 0; i < N; ++i)
            {
                if (vec[i] < vmin[i])
                {
                    vmin[i] = vec[i];
                }
                else if (vec[i] > vmax[i])
                {
                    vmax[i] = vec[i];
                }
            }
        }
        return true;
    }

    return false;
}

// Lift n-tuple v to homogeneous (n+1)-tuple (v,last).
template <int32_t N, typename Real>
Vector<N + 1, Real> HLift(Vector<N, Real> const& v, Real last)
{
    Vector<N + 1, Real> result;
    for (int32_t i = 0; i < N; ++i)
    {
        result[i] = v[i];
    }
    result[N] = last;
    return result;
}

// Project homogeneous n-tuple v = (u,v[n-1]) to (n-1)-tuple u.
template <int32_t N, typename Real>
Vector<N - 1, Real> HProject(Vector<N, Real> const& v)
{
    static_assert(N >= 2, "Invalid dimension.");
    Vector<N - 1, Real> result;
    for (int32_t i = 0; i < N - 1; ++i)
    {
        result[i] = v[i];
    }
    return result;
}

// Lift n-tuple v = (w0,w1) to (n+1)-tuple u = (w0,u[inject],w1).  By
// inference, w0 is a (inject)-tuple [nonexistent when inject=0] and w1 is
// a (n-inject)-tuple [nonexistent when inject=n].
template <int32_t N, typename Real>
Vector<N + 1, Real> Lift(Vector<N, Real> const& v, int32_t inject, Real value)
{
    Vector<N + 1, Real> result;
    int32_t i;
    for (i = 0; i < inject; ++i)
    {
        result[i] = v[i];
    }
    result[i] = value;
    int32_t j = i;
    for (++j; i < N; ++i, ++j)
    {
        result[j] = v[i];
    }
    return result;
}

// Project n-tuple v = (w0,v[reject],w1) to (n-1)-tuple u = (w0,w1).  By
// inference, w0 is a (reject)-tuple [nonexistent when reject=0] and w1 is
// a (n-1-reject)-tuple [nonexistent when reject=n-1].
template <int32_t N, typename Real>
Vector<N - 1, Real> Project(Vector<N, Real> const& v, int32_t reject)
{
    static_assert(N >= 2, "Invalid dimension.");
    Vector<N - 1, Real> result;
    for (int32_t i = 0, j = 0; i < N - 1; ++i, ++j)
    {
        if (j == reject)
        {
            ++j;
        }
        result[i] = v[j];
    }
    return result;
}


template <int32_t N, typename Real>
class Hyperellipsoid
{
public:
    // Construction and destruction.  The default constructor sets the
    // center to Vector<N,Real>::Zero(), the axes to
    // Vector<N,Real>::Unit(d), and all extents to 1.
    Hyperellipsoid()
    {
        center.MakeZero();
        for (int32_t d = 0; d < N; ++d)
        {
            axis[d].MakeUnit(d);
            extent[d] = (Real)1;
        }
    }

    Hyperellipsoid(Vector<N, Real> const& inCenter,
                   std::array<Vector<N, Real>, N> const inAxis,
                   Vector<N, Real> const& inExtent)
        :
        center(inCenter),
        axis(inAxis),
        extent(inExtent)
    {
    }
    // Public member access.
    Vector<N, Real> center;
    std::array<Vector<N, Real>, N> axis;
    Vector<N, Real> extent;
public:
    // Comparisons to support sorted containers.
    bool operator==(Hyperellipsoid const& hyperellipsoid) const
    {
        return center == hyperellipsoid.center && axis == hyperellipsoid.axis
            && extent == hyperellipsoid.extent;
    }

    bool operator!=(Hyperellipsoid const& hyperellipsoid) const
    {
        return !operator==(hyperellipsoid);
    }

    bool operator< (Hyperellipsoid const& hyperellipsoid) const
    {
        if (center < hyperellipsoid.center)
        {
            return true;
        }

        if (center > hyperellipsoid.center)
        {
            return false;
        }

        if (axis < hyperellipsoid.axis)
        {
            return true;
        }

        if (axis > hyperellipsoid.axis)
        {
            return false;
        }

        return extent < hyperellipsoid.extent;
    }

    bool operator<=(Hyperellipsoid const& hyperellipsoid) const
    {
        return !hyperellipsoid.operator<(*this);
    }

    bool operator> (Hyperellipsoid const& hyperellipsoid) const
    {
        return hyperellipsoid.operator<(*this);
    }

    bool operator>=(Hyperellipsoid const& hyperellipsoid) const
    {
        return !operator<(hyperellipsoid);
    }
};


template <int32_t N, typename T>
class DCPQuery
{
public:
    struct Result
    {
        Result()
            :
            distance(static_cast<T>(0)),
            sqrDistance(static_cast<T>(0)),
            closest{ Vector<N, T>::Zero(), Vector<N, T>::Zero() }
        {
        }

        T distance, sqrDistance;
        std::array<Vector<N, T>, 2> closest;
    };

    // The query for any hyperellipsoid.
    Result operator()(Vector<N, T> const& point,
                      Hyperellipsoid<N, T> const& hyperellipsoid)
    {
        Result result{};

        // Compute the coordinates of Y in the hyperellipsoid coordinate
        // system.
        Vector<N, T> diff = point - hyperellipsoid.center;
        Vector<N, T> y{};
        for (int32_t i = 0; i < N; ++i)
        {
            y[i] = Dot(diff, hyperellipsoid.axis[i]);
        }

        // Compute the closest hyperellipsoid point in the axis-aligned
        // coordinate system.
        Vector<N, T> x{};
        result.sqrDistance = SqrDistance(hyperellipsoid.extent, y, x);
        result.distance = std::sqrt(result.sqrDistance);

        // Convert back to the original coordinate system.
        result.closest[0] = point;
        result.closest[1] = hyperellipsoid.center;
        for (int32_t i = 0; i < N; ++i)
        {
            result.closest[1] += x[i] * hyperellipsoid.axis[i];
        }

        return result;
    }

    // The 'hyperellipsoid' is assumed to be axis-aligned and centered at
    // the origin , so only the extent[] values are used.
    Result operator()(Vector<N, T> const& point, Vector<N, T> const& extent)
    {
        Result result{};
        result.closest[0] = point;
        result.sqrDistance = SqrDistance(extent, point, result.closest[1]);
        result.distance = std::sqrt(result.sqrDistance);
        return result;
    }

private:
    // The hyperellipsoid is sum_{d=0}^{N-1} (x[d]/e[d])^2 = 1 with no
    // constraints on the orderind of the e[d]. The query point is
    // (y[0],...,y[N-1]) with no constraints on the signs of the
    // components. The function returns the squared distance from the
    // query point to the hyperellipsoid. It also computes the
    // hyperellipsoid point (x[0],...,x[N-1]) that is closest to
    // (y[0],...,y[N-1]).
    T SqrDistance(Vector<N, T> const& e, Vector<N, T> const& y, Vector<N, T>& x)
    {
        // Determine negations for y to the first octant.
        T const zero = static_cast<T>(0);
        std::array<bool, N> negate{};
        for (int32_t i = 0; i < N; ++i)
        {
            negate[i] = (y[i] < zero);
        }

        // Determine the axis order for decreasing extents.
        std::array<std::pair<T, int32_t>, N> permute{};
        for (int32_t i = 0; i < N; ++i)
        {
            permute[i].first = -e[i];
            permute[i].second = i;
        }
        std::sort(permute.begin(), permute.end());

        std::array<int32_t, N> invPermute{};
        for (int32_t i = 0; i < N; ++i)
        {
            invPermute[permute[i].second] = i;
        }

        Vector<N, T> locE{}, locY{};
        for (int32_t i = 0; i < N; ++i)
        {
            int32_t j = permute[i].second;
            locE[i] = e[j];
            locY[i] = std::fabs(y[j]);
        }

        Vector<N, T> locX{};
        T sqrDistance = SqrDistanceSpecial(locE, locY, locX);

        // Restore the axis order and reflections.
        for (int32_t i = 0; i < N; ++i)
        {
            int32_t j = invPermute[i];
            if (negate[i])
            {
                locX[j] = -locX[j];
            }
            x[i] = locX[j];
        }

        return sqrDistance;
    }

    // The hyperellipsoid is sum_{d=0}^{N-1} (x[d]/e[d])^2 = 1 with the
    // e[d] positive and nonincreasing:  e[d] >= e[d + 1] for all d. The
    // query point is (y[0],...,y[N-1]) with y[d] >= 0 for all d. The
    // function returns the squared distance from the query point to the
    // hyperellipsoid. It also computes the hyperellipsoid point
    // (x[0],...,x[N-1]) that is closest to (y[0],...,y[N-1]), where
    // x[d] >= 0 for all d.
    T SqrDistanceSpecial(Vector<N, T> const& e, Vector<N, T> const& y, Vector<N, T>& x)
    {
        T const zero = static_cast<T>(0);
        T sqrDistance = zero;

        Vector<N, T> ePos{}, yPos{}, xPos{};
        int32_t numPos = 0;
        for (int32_t i = 0; i < N; ++i)
        {
            if (y[i] > zero)
            {
                ePos[numPos] = e[i];
                yPos[numPos] = y[i];
                ++numPos;
            }
            else
            {
                x[i] = zero;
            }
        }

        if (y[N - 1] > zero)
        {
            sqrDistance = Bisector(numPos, ePos, yPos, xPos);
        }
        else  // y[N-1] = 0
        {
            Vector<N - 1, T> numer{}, denom{};
            T eNm1Sqr = e[N - 1] * e[N - 1];
            for (int32_t i = 0; i < numPos; ++i)
            {
                numer[i] = ePos[i] * yPos[i];
                denom[i] = ePos[i] * ePos[i] - eNm1Sqr;
            }

            bool inSubHyperbox = true;
            for (int32_t i = 0; i < numPos; ++i)
            {
                if (numer[i] >= denom[i])
                {
                    inSubHyperbox = false;
                    break;
                }
            }

            bool inSubHyperellipsoid = false;
            if (inSubHyperbox)
            {
                // yPos[] is inside the axis-aligned bounding box of the
                // subhyperellipsoid. This intermediate test is designed
                // to guard against the division by zero when
                // ePos[i] == e[N-1] for some i.
                Vector<N - 1, T> xde{};
                T discr = static_cast<T>(1);
                for (int32_t i = 0; i < numPos; ++i)
                {
                    xde[i] = numer[i] / denom[i];
                    discr -= xde[i] * xde[i];
                }
                if (discr > zero)
                {
                    // yPos[] is inside the subhyperellipsoid. The
                    // closest hyperellipsoid point has x[N-1] > 0.
                    sqrDistance = zero;
                    for (int32_t i = 0; i < numPos; ++i)
                    {
                        xPos[i] = ePos[i] * xde[i];
                        T diff = xPos[i] - yPos[i];
                        sqrDistance += diff * diff;
                    }
                    x[N - 1] = e[N - 1] * std::sqrt(discr);
                    sqrDistance += x[N - 1] * x[N - 1];
                    inSubHyperellipsoid = true;
                }
            }

            if (!inSubHyperellipsoid)
            {
                // yPos[] is outside the subhyperellipsoid. The closest
                // hyperellipsoid point has x[N-1] == 0 and is on the
                // domain-boundary hyperellipsoid.
                x[N - 1] = zero;
                sqrDistance = Bisector(numPos, ePos, yPos, xPos);
            }
        }

        // Fill in those x[] values that were not zeroed out initially.
        numPos = 0;
        for (int32_t i = 0; i < N; ++i)
        {
            if (y[i] > zero)
            {
                x[i] = xPos[numPos];
                ++numPos;
            }
        }

        return sqrDistance;
    }

    // The bisection algorithm to find the unique root of F(t).
    T Bisector(int32_t numComponents, Vector<N, T> const& e,
               Vector<N, T> const& y, Vector<N, T>& x)
    {
        T const zero = static_cast<T>(0);
        T const one = static_cast<T>(1);
        T const half = static_cast<T>(0.5);

        T sumZSqr = zero;
        Vector<N, T> z{};
        for (int32_t i = 0; i < numComponents; ++i)
        {
            z[i] = y[i] / e[i];
            sumZSqr += z[i] * z[i];
        }

        if (sumZSqr == one)
        {
            // The point is on the hyperellipsoid.
            for (int32_t i = 0; i < numComponents; ++i)
            {
                x[i] = y[i];
            }
            return zero;
        }

        T emin = e[numComponents - 1];
        Vector<N, T> pSqr{}, numerator{};
        pSqr.MakeZero();
        numerator.MakeZero();
        for (int32_t i = 0; i < numComponents; ++i)
        {
            T p = e[i] / emin;
            pSqr[i] = p * p;
            numerator[i] = pSqr[i] * z[i];
        }

        T s = zero, smin = z[numComponents - 1] - one, smax{};
        if (sumZSqr < one)
        {
            // The point is strictly inside the hyperellipsoid.
            smax = zero;
        }
        else
        {
            // The point is strictly outside the hyperellipsoid.
            smax = Length(numerator, true) - one;
        }

        // The use of 'double' is intentional in case T is a BSNumber
        // or BSRational type. We want the bisections to terminate in a
        // reasonable amount of time.
        uint32_t const jmax = 2048u;
        for (uint32_t j = 0; j < jmax; ++j)
        {
            s = half * (smin + smax);
            if (s == smin || s == smax)
            {
                break;
            }

            T g = -one;
            for (int32_t i = 0; i < numComponents; ++i)
            {
                T ratio = numerator[i] / (s + pSqr[i]);
                g += ratio * ratio;
            }

            if (g > zero)
            {
                smin = s;
            }
            else if (g < zero)
            {
                smax = s;
            }
            else
            {
                break;
            }
        }

        T sqrDistance = zero;
        for (int32_t i = 0; i < numComponents; ++i)
        {
            x[i] = pSqr[i] * y[i] / (s + pSqr[i]);
            T diff = x[i] - y[i];
            sqrDistance += diff * diff;
        }
        return sqrDistance;
    }
};



// Template aliases for convenience.
template <int32_t N, typename T>
using DCPPointHyperellipsoid = DCPQuery<N, T>;

template <typename T>
using DCPPoint2Ellipse2 = DCPPointHyperellipsoid<2, T>;

template <typename T>
using DCPPoint3Ellipsoid3 = DCPPointHyperellipsoid<3, T>;
} // namespace GTE
